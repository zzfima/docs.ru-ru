---
title: Функции первого класса
description: Узнайте о функциях первого класса и о том, как они важны для функционального программирования в F#.
ms.date: 10/29/2018
ms.openlocfilehash: 4681d32abd59cc4aade6f4cb2d062e7888bcfbbc
ms.sourcegitcommit: f20dd18dbcf2275513281f5d9ad7ece6a62644b4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/30/2019
ms.locfileid: "68629716"
---
# <a name="first-class-functions"></a>Функции первого класса

Определение характеристик языков функционального программирования — это повышение уровня функций до состояния первого класса. Вы должны иметь возможность выполнять функции, которые можно использовать со значениями других встроенных типов, и иметь возможность сделать это с сравнимой степенью усилий.

К типичным мерам состояния первого класса относятся следующие:

- Можно ли привязать функции к идентификаторам? То есть можно ли присвоить им имена?

- Можно ли хранить функции в структурах данных, например в списке?

- Можно ли передать функцию в качестве аргумента в вызове функции?

- Можно ли вернуть функцию из вызова функции?

Последние две меры определяют, что называются *операциями высшего порядка* или *функциями высшего порядка*. Функции высшего порядка принимают функции в качестве аргументов и возвращают функции в качестве значений вызовов функций. Эти операции поддерживают такие основ функционального программирования, как функции сопоставления и компоновка функций.

## <a name="give-the-value-a-name"></a>Присвоить значение имени

Если функция является значением первого класса, необходимо иметь возможность присвоить ей имя, точно так же, как целые числа, строки и другие встроенные типы. В литературе по функциональному программированию это называется привязкой идентификатора к значению. F#`let <identifier> = <value>` [ использует`let` привязки](../language-reference/functions/let-bindings.md) для привязки имен к значениям:. В следующем коде показаны два примера.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet20.fs)]

Вы можете легко присвоить имя функции. В следующем примере определяется функция с именем `squareIt` путем привязки идентификатора `squareIt` к [лямбда-выражению](../language-reference/functions/lambda-expressions-the-fun-keyword.md) `fun n -> n * n`. Функция `squareIt` имеет один параметр, `n`и возвращает квадрат этого параметра.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet21.fs)]

F#предоставляет следующий более краткий синтаксис для достижения того же результата с меньшей типизацией.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet22.fs)]

В приведенных ниже примерах используется первый стиль, `let <function-name> = <lambda-expression>`чтобы подчеркнуть сходство между объявлением функций и объявлением других типов значений. Однако все именованные функции также можно записать с помощью краткого синтаксиса. Некоторые примеры написаны обоими способами.

## <a name="store-the-value-in-a-data-structure"></a>Сохранение значения в структуре данных

Значение первого класса может храниться в структуре данных. В следующем коде показаны примеры хранения значений в списках и кортежах.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet23.fs)]

Чтобы убедиться, что имя функции, сохраненное в кортеже, фактически выполняет вычисление функции, в следующем примере используются `fst` операторы `snd` и для извлечения первого и второго элементов из кортежа `funAndArgTuple`. Первый элемент в кортеже имеет `squareIt` значение, а второй элемент —. `num` Идентификатор `num` привязывается в предыдущем примере к целому 10, допустимому аргументу `squareIt` для функции. Второе выражение применяет первый элемент кортежа ко второму элементу в кортеже: `squareIt num`.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet24.fs)]

Точно так же, как `num` идентификатор и целое число 10, можно использовать взаимозаменяемость, `squareIt` поэтому может быть `fun n -> n * n`идентификатором и лямбда-выражением.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet25.fs)]

## <a name="pass-the-value-as-an-argument"></a>Передать значение в качестве аргумента

Если значение имеет состояние первого класса в языке, можно передать его в качестве аргумента функции. Например, в качестве аргументов часто передаются целые числа и строки. В следующем коде показаны целые числа и строки, передаваемые в F#качестве аргументов в.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet26.fs)]

Если функции имеют состояние первого класса, необходимо иметь возможность передавать их как аргументы аналогичным образом. Помните, что это первая характеристика функций высшего порядка.

В следующем примере функция `applyIt` имеет два параметра: `op` и `arg`. Если вы отправляете в функцию, имеющую один параметр `op` для `arg`, и соответствующий аргумент функции, функция возвращает результат применения `op` функции к `arg`. В следующем примере аргументы функции и целочисленный аргумент отправляются одинаковым образом с использованием их имен.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet27.fs)]

Возможность отправки функции в качестве аргумента в другую функцию зависит от общих абстракций в языках функционального программирования, таких как операции Map или Filter. Операция Map, например, — это функция более высокого порядка, которая захватывает вычисления, совместно используемые функциями, которые пошагово проходят по списку, выполняют какие-либо действия с каждым элементом, а затем возвращают список результатов. Может потребоваться увеличить каждый элемент в списке целых чисел или квадратный каждый элемент или изменить каждый элемент в списке строк на верхний. Подверженная ошибкам часть вычислений является рекурсивным процессом, который проходит по списку и создает список возвращаемых результатов. Эта часть захватывается функцией сопоставления. Все, что необходимо написать для конкретного приложения, — это функция, которую необходимо применить к каждому элементу списка по отдельности (Добавление, возведение в изменяемый регистр). Эта функция отправляется в качестве аргумента функции сопоставления, так же как `squareIt` `applyIt` и в предыдущем примере.

F#предоставляет методы Map для большинства типов коллекций, включая [списки](../language-reference/lists.md), [массивы](../language-reference/arrays.md)и [последовательности](../language-reference/sequences.md). В следующих примерах используются списки. Синтаксис: `List.map <the function> <the list>`.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet28.fs)]

Дополнительные сведения см. в разделе [списки](../language-reference/lists.md).

## <a name="return-the-value-from-a-function-call"></a>Возврат значения из вызова функции

Наконец, если функция имеет состояние первого класса в языке, необходимо иметь возможность возвращать его как значение вызова функции, как и другие типы, такие как целые числа и строки.

Следующие вызовы функции возвращают целые числа и отображают их.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet29.fs)]

Следующий вызов функции возвращает строку.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet30.fs)]

Следующий вызов функции, объявленный встроенным, возвращает логическое значение. Отображаемое значение — `True`.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet31.fs)]

Возможность возвращать функцию в качестве значения вызова функции — это вторая характеристика функций более высокого порядка. В следующем примере `checkFor` определяется как функция, принимающая один аргумент, `item`и возвращающая в качестве значения новую функцию. Возвращаемая функция принимает список `lst` `item` в качестве аргумента, и выполняет поиск в `lst`. Если `item` имеется, функция возвращает `true`. Если `item` параметр не указан, функция возвращает `false`значение. Как и в предыдущем разделе, следующий код использует предоставленную функцию списка [List. Exists](https://msdn.microsoft.com/library/15a3ebd5-98f0-44c0-8220-7dedec3e68a8)для поиска в списке.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet32.fs)]

Следующий код использует `checkFor` для создания новой функции, которая принимает один аргумент, список и выполняет поиск 7 в списке.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet33.fs)]

В следующем примере используется состояние первого класса функций в F# для объявления функции `compose`, которая возвращает композицию двух аргументов функции.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet34.fs)]

> [!NOTE]
> Более короткая версия см. в следующем разделе "каррированных функции".

Следующий код отправляет две функции в качестве аргументов в `compose`, оба из которых принимают один аргумент того же типа. Возвращаемое значение — это новая функция, которая представляет собой композицию двух аргументов функции.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet35.fs)]

> [!NOTE]
> F#предоставляет два оператора, `<<` и `>>`, которые состоят из функций. Например, `let squareAndDouble2 = doubleIt << squareIt` `let squareAndDouble = compose doubleIt squareIt` эквивалентен в предыдущем примере.

Следующий пример возврата функции в качестве значения вызова функции создает простую игру подбора. Чтобы создать игру, вызовите `makeGame` метод с тем значением, `target`в котором вы хотите угадать. Возвращаемое значение функции `makeGame` — это функция, которая принимает один аргумент (Guess) и сообщает, верно ли предположение.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet36.fs)]

Следующий код вызывает метод `makeGame`, отправляя значение `7` для `target`. Идентификатор `playGame` привязан к возвращенному лямбда-выражению. Таким образом `playGame` , представляет собой функцию, принимающую в качестве одного аргумента `guess`значение для.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet37.fs)]

## <a name="curried-functions"></a>Каррированных функции

Многие примеры в предыдущем разделе можно написать более кратко, используя преимущества неявного *карринг* в F# объявлениях функций. Карринг — это процесс, преобразуя функцию, имеющую несколько параметров, в ряд встроенных функций, каждый из которых имеет один параметр. В F#функции, имеющие более одного параметра, по сути являются каррированных. Например, `compose` из предыдущего раздела можно написать, как показано в следующем кратком стиле с тремя параметрами.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet38.fs)]

Однако результатом является функция одного параметра, возвращающая функцию одного параметра, которая, в свою очередь, возвращает другую функцию одного параметра, как показано в `compose4curried`.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet39.fs)]

Доступ к этой функции можно получить несколькими способами. Каждый из следующих примеров возвращает и отображает 18. В любом из `compose4` примеров `compose4curried` можно заменить на.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet40.fs)]

Чтобы убедиться, что функция все еще работает, как и раньше, попробуйте повторить исходные тестовые случаи.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet41.fs)]

> [!NOTE]
> Можно ограничить карринг, заключив параметры в кортежи. Дополнительные сведения см. в разделе "Шаблоны параметров" раздела [Параметры и аргументы](../language-reference/parameters-and-arguments.md).

В следующем примере используется неявное карринг для записи более короткой версии `makeGame`. Сведения о том, `makeGame` как конструкции и `game` возвращают функцию, менее явны в этом формате, но можно проверить с помощью исходных тестовых случаев, в которых результат совпадает.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet42.fs)]

Дополнительные сведения о карринг см. в разделе "частичное применение аргументов" в [функциях](../language-reference/functions/index.md).

## <a name="identifier-and-function-definition-are-interchangeable"></a>Идентификатор и определение функции взаимозаменяемы

Имя `num` переменной в предыдущих примерах вычисляется как целое число 10, и это не удивительно, `num` что допустимо, 10 также является допустимым. То же самое касается идентификаторов функций и их значений: где можно использовать имя функции, можно использовать лямбда-выражение, к которому она привязана.

В следующем примере определяется `Boolean` функция с именем `isNegative`, а затем используется имя функции и определение взаимозаменяемой функции. В следующих трех примерах возвращаются и отображаются `False`.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet43.fs)]

Чтобы сделать это на один шаг дальше, замените значение, `applyIt` привязанное к для `applyIt`.

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet44.fs)]

## <a name="functions-are-first-class-values-in-f"></a>Функции являются значениями первого класса в F\#

В примерах, приведенных в предыдущих разделах, F# показано, что функции в удовлетворяют критериям для использования F#значений первого класса в:

- Идентификатор можно привязать к определению функции.
[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet21.fs)]

- Функцию можно сохранить в структуре данных.
[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet45.fs)]

- Функцию можно передать в качестве аргумента.
[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet46.fs)]

- Функцию можно вернуть в качестве значения вызова функции.
[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet32.fs)]

Дополнительные сведения о F#см. в справочнике по [ F# языку](../language-reference/index.md).

## <a name="example"></a>Пример

### <a name="description"></a>Описание

Следующий код содержит все примеры, приведенные в этом разделе.

### <a name="code"></a>Код

[!code-fsharp[Main](~/samples/snippets/fsharp/contour/snippet47.fs)]

## <a name="see-also"></a>См. также

- [Списки](../language-reference/lists.md)
- [Кортежи](../language-reference/tuples.md)
- [Функции](../language-reference/functions/index.md)
- [`let`Привязки](../language-reference/functions/let-bindings.md)
- [Лямбда-выражения: Ключевое слово `fun`](../language-reference/functions/lambda-expressions-the-fun-keyword.md)
