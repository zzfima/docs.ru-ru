---
title: Модули
description: Сведения о том F# , как модуль представляет собой F# Группирование кода, например значения, типы и значения функций, в F# программе.
ms.date: 04/24/2017
ms.openlocfilehash: fbde0c8b001d88614ba2de49c4aa7bfa098c6945
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/01/2019
ms.locfileid: "73425058"
---
# <a name="modules"></a>Модули

В контексте F# языка *модуль* — это группа F# кода, например значения, типы и значения функций, в F# программе. Код группирования в модулях объединяет связанный код и помогает избежать конфликтов имен в программе.

## <a name="syntax"></a>Синтаксис

```fsharp
// Top-level module declaration.
module [accessibility-modifier] [qualified-namespace.]module-name
declarations
// Local module declaration.
module [accessibility-modifier] module-name =
    declarations
```

## <a name="remarks"></a>Заметки

F# Модуль — это группа конструкций F# кода, таких как типы, значения, значения функций и код в привязках `do`. Он реализуется как класс среды CLR, имеющий только статические члены. Существует два типа объявлений модулей в зависимости от того, включен ли в модуль весь файл: объявление модуля верхнего уровня и объявление локального модуля. Объявление модуля верхнего уровня включает в себя весь файл в модуле. Объявление модуля верхнего уровня может использоваться только в качестве первого объявления в файле.

В синтаксисе объявления модуля верхнего уровня необязательное *полное-пространство имен* — это последовательность вложенных имен пространств имен, содержащих модуль. Полное имя пространства имен не обязательно должно быть объявлено ранее.

Добавлять отступы в модуль верхнего уровня не требуется. Необходимо задать отступ для всех объявлений в локальных модулях. В объявлении локального модуля только объявления, имеющие отступ под этим объявлением модуля, являются частью модуля.

Если файл кода не начинается с объявления модуля верхнего уровня или объявления пространства имен, все содержимое файла, включая все локальные модули, станет частью неявно созданного модуля верхнего уровня, который имеет то же имя, что и файл, без расширения. с первой буквы, преобразованной в верхний регистр. Например, рассмотрим следующий файл.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6601.fs)]

Этот файл будет скомпилирован так, как если бы он был написан таким образом:

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6602.fs)]

Если в файле имеется несколько модулей, необходимо использовать локальное объявление модуля для каждого модуля. Если объявлено включающее пространство имен, эти модули являются частью включающего пространства имен. Если включающее пространство имен не объявлено, модули становятся частью неявно созданного модуля верхнего уровня. В следующем примере кода показан файл кода, содержащий несколько модулей. Компилятор неявно создает модуль верхнего уровня с именем `Multiplemodules`, а `MyModule1` и `MyModule2` вложены в этот модуль верхнего уровня.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6603.fs)]

При наличии нескольких файлов в проекте или в одной компиляции или при построении библиотеки необходимо включить объявление пространства имен или объявление модуля в начало файла. F# Компилятор явно определяет имя модуля только в том случае, если в проекте или в командной строке компиляции имеется только один файл, и вы создаете приложение.

*Модификатор доступности* может быть одним из следующих: `public`, `private`, `internal`. Дополнительные сведения см. в статье [Управление доступом](access-control.md). Значение по умолчанию — "public" (открытый).

## <a name="referencing-code-in-modules"></a>Ссылка на код в модулях

При ссылке на функции, типы и значения из другого модуля необходимо либо использовать полное имя, либо открыть модуль. При использовании полного имени необходимо указать пространства имен, модуль и идентификатор нужного элемента программы. Каждая часть полного пути разделяются точкой (.), как показано ниже.

`Namespace1.Namespace2.ModuleName.Identifier`

Чтобы упростить код, можно открыть модуль или одно или несколько пространств имен. Дополнительные сведения об открытии пространств имен и модулей см. [в разделе Объявления импорта: ключевое слово `open`](import-declarations-the-open-keyword.md).

В следующем примере кода показан модуль верхнего уровня, содержащий весь код до конца файла.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6604.fs)]

Чтобы использовать этот код из другого файла в том же проекте, необходимо либо использовать полные имена, либо открыть модуль перед использованием функций, как показано в следующих примерах.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6605.fs)]

## <a name="nested-modules"></a>Вложенные модули

Модули могут быть вложенными. Внутренние модули должны быть с отступом до объявлений внешних модулей, чтобы указать, что они являются внутренними модулями, а не новыми модулями. Например, Сравните следующие два примера. Модуль `Z` является внутренним модулем в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6607.fs)]

Но `Z` модуля — это одноуровневый `Y` модуля в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6608.fs)]
Модуль `Z` также является родственным модулем в следующем коде, так как он не имеет отступов, пока другие объявления в модуле `Y`.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6609.fs)]
Наконец, если внешний модуль не имеет объявлений и за ним сразу же поступает объявление другого модуля, объявление нового модуля считается внутренним модулем, но компилятор выдаст предупреждение, если второе определение модуля не имеет отступа дальше, чем началь.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6610.fs)]
Чтобы устранить это предупреждение, помещает внутренний модуль в отступ.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6611.fs)]
Если требуется, чтобы весь код в файле настроился в одном внешнем модуле и вы хотели использовать внутренние модули, внешний модуль не требует знака равенства, а объявления, включая любые внутренние объявления модулей, которые будут находиться во внешнем модуле, не должны иметь отступов. Объявления внутри внутренних объявлений модуля должны иметь отступы. Этот случай показан в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/modules/snippet6612.fs)]

## <a name="recursive-modules"></a>Рекурсивные модули

F#в 4,1 введено понятие модулей, которые позволяют взаимно рекурсивно выполнять весь автономный код.  Это выполняется с помощью `module rec`.  Использование `module rec` может сократить некоторые трудности, не позволяя писать взаимно ссылочный код между типами и модулями.  Ниже приведен пример.

```fsharp
module rec RecursiveModule =
    type Orientation = Up | Down
    type PeelState = Peeled | Unpeeled

    // This exception depends on the type below.
    exception DontSqueezeTheBananaException of Banana

    type BananaPeel() = class end

    type Banana(orientation : Orientation) =
        member val IsPeeled = false with get, set
        member val Orientation = orientation with get, set
        member val Sides: PeelState list = [ Unpeeled; Unpeeled; Unpeeled; Unpeeled] with get, set

        member self.Peel() = BananaHelpers.peel self // Note the dependency on the BananaHelpers module.
        member self.SqueezeJuiceOut() = raise (DontSqueezeTheBananaException self) // This member depends on the exception above.

    module BananaHelpers =
        let peel (b: Banana) =
            let flip (banana: Banana) =
                match banana.Orientation with
                | Up ->
                    banana.Orientation <- Down
                    banana
                | Down -> banana

            let peelSides (banana: Banana) =
                banana.Sides
                |> List.map (function
                             | Unpeeled -> Peeled
                             | Peeled -> Peeled)

            match b.Orientation with
            | Up ->   b |> flip |> peelSides
            | Down -> b |> peelSides
```

Обратите внимание, что исключение `DontSqueezeTheBananaException` и класс `Banana` оба ссылаются друг на друга.  Кроме того, модуль `BananaHelpers` и класс `Banana` также ссылаются друг на друга.  Это невозможно, F# если вы удалили ключевое слово `rec` из модуля `RecursiveModule`.

Эта возможность также возможна в [пространствах имен](namespaces.md) с F# 4,1.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Пространства имен](namespaces.md)
- [F#RFC FS-1009 — разрешить взаимно ссылочные типы и модули в более крупных областях внутри файлов](https://github.com/fsharp/fslang-design/blob/master/FSharp-4.1/FS-1009-mutually-referential-types-and-modules-single-scope.md)
