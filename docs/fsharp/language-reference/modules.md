---
title: Модули
description: Узнайте, как F# модуль — это группа F# кодов, таких как значения, типы и значения функции, в F# программы.
ms.date: 04/24/2017
ms.openlocfilehash: 9e5bef4ffe3301a69bbe32483625652d988f8a35
ms.sourcegitcommit: fa38fe76abdc8972e37138fcb4dfdb3502ac5394
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/19/2018
ms.locfileid: "53611117"
---
# <a name="modules"></a>Модули

В контексте F# языка, *модуль* — это группа F# кодов, таких как значения, типы и значения функции, в F# программы. Код группирования в модулях объединяет связанный код и помогает избежать конфликтов имен в программе.

## <a name="syntax"></a>Синтаксис

```fsharp
// Top-level module declaration.
module [accessibility-modifier] [qualified-namespace.]module-name
declarations
// Local module declaration.
module [accessibility-modifier] module-name =
    declarations
```

## <a name="remarks"></a>Примечания

F# Модуль — это группа F# код конструкций, таких как типы, значений, значений функций и кода в `do` привязки. Он реализуется как общий класс языковой среды выполнения (CLR), содержит только статические члены. Существует два типа объявлений модулей, в зависимости от того, включены ли весь файл целиком в модуле: объявление модуля верхнего уровня и объявление локального модуля. Объявление модуля верхнего уровня содержит весь файл целиком в модуле. Объявление модуля верхнего уровня может отображаться только в качестве первого объявления в файле.

В синтаксисе объявления верхнего уровня модуля, необязательный *доменное пространство имен* последовательность вложенных имен пространств имен, содержащего модуль. Имя пространства имен не нужно предварительно объявлять.

У вас нет отступа объявления в модуль верхнего уровня. У вас отступ для всех объявлений локальных модулей. В объявлении локального модуля только объявления, которые отображаются с отступом внутри объявления являются частью этого модуля.

Если файл с кодом не начинается с объявления модуля верхнего уровня или объявление пространства имен, все содержимое файла, включая все локальные модули, становится частью неявно созданного модуля верхнего уровня, который имеет то же имя файла, без расширения с первой буквой, переведенную в верхний регистр. Например рассмотрим следующий файл.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6601.fs)]

Этот файл компилируется так, как если бы он был оформлен таким образом:

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6602.fs)]

Если у вас есть несколько модулей в файле, необходимо использовать объявление локального модуля для каждого модуля. Если объявляется пространство имен, эти модули являются частью вложенное пространство имен. Если пространство имен не объявлен, модули становятся частью неявно созданного модуля верхнего уровня. В следующем примере кода показан файл кода, содержащий несколько модулей. Компилятор неявно создает модуль верхнего уровня с именем `Multiplemodules`, и `MyModule1` и `MyModule2` вложены в этого модуля.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6603.fs)]

Если у вас есть несколько файлов в проекте или в рамках одной процедуры компиляции, или если вы создаете библиотеку, необходимо включить объявление пространства имен или модуля в верхней части файла. F# Компилятора только определяет имя модуля неявно при имеется только один файл в командной строке, проекта или компиляции, и при создании приложения.

*Модификатор доступа* может принимать одно из следующих: `public`, `private`, `internal`. Дополнительные сведения см. в статье [Управление доступом](access-control.md). Значение по умолчанию — "public" (открытый).

## <a name="referencing-code-in-modules"></a>Ссылки на код в модулях

При создании ссылки функции, типы и значения из другого модуля, необходимо использовать полное имя или открыть модуль. Если вы используете полное имя, необходимо указать пространства имен, модуля и идентификатор нужный элемент программы. Разделите каждую часть полный путь с точкой (.), следующим образом.

`Namespace1.Namespace2.ModuleName.Identifier`

Можно открыть модуль или одно или несколько пространств имен для упрощения кода. Дополнительные сведения об открытии пространств имен и модулей см. в разделе [объявления импорта: `open` Ключевое слово](import-declarations-the-open-keyword.md).

В следующем примере кода показан модуль верхнего уровня, который содержит весь код в конец файла.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6604.fs)]

Чтобы использовать этот код из другого файла, в том же проекте, можно использовать полные имена или открыть модуль перед использованием функции, как показано в следующих примерах.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6605.fs)]

## <a name="nested-modules"></a>Вложенные модули

Модули могут быть вложенными. Внутренние модули должны иметь отступ относительно внешних модулей для указания, что они внутренних модулей, а не новые модули. Например Сравните следующие два примера. Модуль `Z` представляет собой внутренний модуль, в следующем коде.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6607.fs)]

Но модуль `Z` является родственным модуль `Y` в следующем коде.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6608.fs)]
Модуль `Z` находится также на одном уровне в следующем коде, так как для него нет отступа по сравнению с другими объявлениями в модуле `Y`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6609.fs)]
Наконец, если внешний модуль не содержит объявлений и сразу же следует объявление другой модуль, предполагается, что новые объявления модуля является внутренним, но, компилятор выдает предупреждение, если второе определение модуля отобразится без отступа farther чем первый.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6610.fs)]
Чтобы устранить предупреждение, добавьте отступ внутренний модуль.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6611.fs)]
Если требуется, чтобы весь код в файл, который требуется в один внешний модуль, и вы хотите внутренних модулей, внешний модуль не требуется знак равенства и объявления, включая объявления внутренних модулей, которые помещаются во внешний модуль не требуется иметь отступ. Объявления внутри внутренних модулей должны иметь отступы. В следующем коде показано в данном случае.

[!code-fsharp[Main](../../../samples/snippets/fsharp/modules/snippet6612.fs)]

## <a name="recursive-modules"></a>Рекурсивные модулей

F#4.1, вводится понятие модулей, позволяющих все автономной кода взаимно рекурсивные.  Это делается с помощью `module rec`.  Использование `module rec` могут помочь в решении некоторые трудности в не возможность написания кода в взаимно ссылочные типы и модули.  Ниже приведен пример этого:

```fsharp
module rec RecursiveModule =
    type Orientation = Up | Down
    type PeelState = Peeled | Unpeeled

    // This exception depends on the type below.
    exception DontSqueezeTheBananaException of Banana

    type BananaPeel() = class end

    type Banana(orientation : Orientation) =
        member val IsPeeled = false with get, set
        member val Orientation = orientation with get, set
        member val Sides: PeelState list = [ Unpeeled; Unpeeled; Unpeeled; Unpeeled] with get, set

        member self.Peel() = BananaHelpers.peel self // Note the dependency on the BananaHelpers module.
        member self.SqueezeJuiceOut() = raise (DontSqueezeTheBananaException self) // This member depends on the exception above.

    module BananaHelpers =
        let peel (b: Banana) =
            let flip (banana: Banana) =
                match banana.Orientation with
                | Up -> 
                    banana.Orientation <- Down
                    banana
                | Down -> banana

            let peelSides (banana: Banana) =
                banana.Sides
                |> List.map (function
                             | Unpeeled -> Peeled
                             | Peeled -> Peeled)

            match b.Orientation with
            | Up ->   b |> flip |> peelSides
            | Down -> b |> peelSides
```

Обратите внимание, что исключение `DontSqueezeTheBananaException` и класс `Banana` оба обращаются друг к другу.  Кроме того, модуль `BananaHelpers` и класс `Banana` также обращаются друг к другу.  Это не позволяет выражать в F# Если вы удалили `rec` ключевое слово from `RecursiveModule` модуля.

Эта возможность также возможен в [пространства имен](namespaces.md) с F# 4.1.

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Пространства имен](namespaces.md)
- [F#RFC-FS-1009 - разрешить взаимно ссылочные типы и модули через большего пространства в файлах](https://github.com/fsharp/fslang-design/blob/master/FSharp-4.1/FS-1009-mutually-referential-types-and-modules-single-scope.md)