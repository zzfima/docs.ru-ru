---
title: Встраиваемые функции (F#)
description: 'Узнайте, как использовать встраиваемые функции на F #, интегрированные непосредственно в вызывающем коде.'
ms.date: 05/16/2016
ms.openlocfilehash: 47fca0fe34630792aeb0908b0cee02a927e2567d
ms.sourcegitcommit: 8c2ece71e54f46aef9a2153540d0bda7e74b19a9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/11/2018
ms.locfileid: "44368052"
---
# <a name="inline-functions"></a>Встраиваемые функции

*Встроенные функции* — это функции, интегрированные непосредственно в вызывающем коде.

## <a name="using-inline-functions"></a>С помощью встроенных функций

При использовании статических типов параметров, любые функции, которые параметризуются языком параметров типа должны быть встроенными. Это гарантирует, что компилятор может разрешить эти параметры типа. При использовании обычных параметров универсального типа, не существует такого ограничения.

Кроме применение ограничений членов, встроенные функции могут быть полезны при оптимизации кода. Тем не менее избыточное использование встроенных функций может привести к ваш код будет менее устойчивы к изменениям в оптимизации компилятора и реализации функций библиотек. По этой причине следует избегать использования встроенных функций для оптимизации, если вы попытались использовать другие методы оптимизации. Создание встроенной функции или метода может иногда повысить производительность, но это не всегда так. Таким образом чтобы убедиться, что сделать все встроенные заданная функция на самом деле оказывает положительное влияние также следует использовать измерения производительности.

`inline` Модификатор может применяться к функциям на верхнем уровне, на уровне модуля или на уровне метода в классе.

В следующем примере кода показана встроенная функция на верхнем уровне, встроенный метод экземпляра и встроенный статический метод.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet201.fs)]

## <a name="inline-functions-and-type-inference"></a>Встроенные функции и вывод типов

Наличие `inline` влияет на определение типа. Это так, как встроенные функции могут иметь статически разрешаемые параметры типа, а не встроенные функции нельзя. В следующем примере кода показан случай где `inline` полезно потому, что при использовании функции, которая имеет статически разрешаемым параметром типа, `float` оператор преобразования.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet202.fs)]

Без `inline` модификатор, вывод типа заставляет функции определенного типа, в данном случае `int`. Но с `inline` модификатор, функция также логически распознается статически разрешаемым параметром типа. С помощью `inline` модификатор, тип определяется следующим:

```fsharp
^a -> unit when ^a : (static member op_Explicit : ^a -> float)
```

Это означает, что функция принимает любой тип, поддерживающий преобразование в **float**.

## <a name="see-also"></a>См. также

- [Функции](index.md)
- [Ограничения](../generics/constraints.md)
- [Статически разрешаемые параметры типов](../generics/statically-resolved-type-parameters.md)
