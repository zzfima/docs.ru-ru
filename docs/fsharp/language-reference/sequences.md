---
title: Последовательности
description: Узнайте, как использовать F# последовательности, если имеется большой упорядоченный набор данных, но не обязательно использовать все элементы.
ms.date: 02/19/2019
ms.openlocfilehash: 76aeeb8b89ed8146ee1b7f909af6bf0764fcc55d
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/01/2019
ms.locfileid: "73424983"
---
# <a name="sequences"></a>Последовательности

> [!NOTE]
> Ссылки на справочник по API в этой статье ведут на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

*Последовательность* — это логический ряд элементов одного типа. Последовательности особенно полезны при наличии большой упорядоченной коллекции данных, но не обязательно должны использовать все элементы. Отдельные элементы последовательности вычисляются только по мере необходимости, поэтому последовательность может обеспечить лучшую производительность, чем список в ситуациях, когда не все элементы используются. Последовательности представлены типом `seq<'T>`, который является псевдонимом для `System.Collections.Generic.IEnumerable`. Таким образом, в качестве последовательности можно использовать любой тип .NET Framework, реализующий `System.IEnumerable`. [Модуль Seq](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) обеспечивает поддержку манипуляций с последовательностями.

## <a name="sequence-expressions"></a>Выражения последовательности

*Выражение последовательности* — это выражение, результатом которого является последовательность. Выражения последовательности могут принимать несколько форм. В самой простой форме указывается диапазон. Например, `seq { 1 .. 5 }` создает последовательность, содержащую пять элементов, включая конечные точки 1 и 5. Можно также указать шаг приращения (или уменьшение) между двумя двойными точками. Например, следующий код создает последовательность кратных 10.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1502.fs)]

Выражения последовательности состоят из F# выражений, создающих значения последовательности. Они могут использовать ключевое слово `yield` для получения значений, которые становятся частью последовательности.

Ниже приведен пример.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1503.fs)]

Вместо `yield`можно использовать оператор `->`. в этом случае можно опустить ключевое слово `do`, как показано в следующем примере.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1504.fs)]

Следующий код создает список пар координат и индексов в массиве, представляющем сетку.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1505.fs)]

Выражение `if`, используемое в последовательности, является фильтром. Например, чтобы создать последовательность только простых чисел, при условии, что имеется функция, `isprime` типа `int -> bool`, создайте последовательность следующим образом.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1506.fs)]

При использовании `yield` или `->` в итерации ожидается, что каждая итерация создает один элемент последовательности. Если каждая итерация создает последовательность элементов, используйте `yield!`. В этом случае элементы, формируемые в каждой итерации, объединяются для создания конечной последовательности.

В выражении последовательности можно объединить несколько выражений вместе. Элементы, создаваемые каждым выражением, объединяются вместе. Пример см. в подразделе "примеры" этого раздела.

## <a name="examples"></a>Примеры

В первом примере используется выражение последовательности, содержащее итерацию, фильтр и оператор yield для создания массива. Этот код выводит на консоль последовательность простых чисел от 1 до 100.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1507.fs)]

В следующем коде `yield` используется для создания таблицы умножения, состоящей из кортежей из трех элементов, каждый из которых состоит из двух факторов и продукта.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1508.fs)]

В следующем примере показано использование `yield!` для объединения отдельных последовательностей в одну последнюю последовательность. В этом случае последовательности для каждого поддерева в двоичном дереве объединяются в рекурсивную функцию для создания конечной последовательности.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet1509.fs)]

## <a name="using-sequences"></a>Использование последовательностей

Последовательности поддерживают многие из тех же функций, что и [списки](lists.md). Последовательности также поддерживают операции, такие как группирование и подсчет, с помощью функций создания ключа. Последовательности также поддерживают более разнообразные функции для извлечения подпоследовательностей.

Многие типы данных, такие как списки, массивы, наборы и карты, являются неявными последовательностями, так как они являются перечислимыми коллекциями. Функция, которая принимает последовательность в качестве аргумента, работает с любыми распространенными F# типами данных в дополнение к любому .NET Framework типу данных, реализующему `System.Collections.Generic.IEnumerable<'T>`. Сравните это с функцией, которая принимает список в качестве аргумента, который может принимать только списки. Тип `seq<'T>` — это аббревиатура типа для `IEnumerable<'T>`. Это означает, что любой тип, реализующий универсальный `System.Collections.Generic.IEnumerable<'T>`, включающий массивы, списки, наборы и карты F#в, а также большинство .NET Framework типов коллекций, совместим с типом `seq` и может использоваться везде, где ожидается последовательность.

## <a name="module-functions"></a>Функции модуля

[Модуль Seq](https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684) в [пространстве имен Microsoft. FSharp. Collections](https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f) содержит функции для работы с последовательностями. Эти функции также работают с списками, массивами, картами и наборами, так как все эти типы являются перечислимыми и поэтому могут рассматриваться как последовательности.

## <a name="creating-sequences"></a>Создание последовательностей

Последовательности можно создавать с помощью выражений последовательности, как описано выше, или с помощью определенных функций.

Можно создать пустую последовательность с помощью [Seq. Empty](https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59)или создать последовательность только одного указанного элемента с помощью [Seq. Singleton](https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7).

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet9.fs)]

Для создания последовательности, для которой создаются элементы с помощью предоставляемой функции, можно использовать [Seq. init](https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576) . Вы также предоставляете размер последовательности. Эта функция аналогична [List. init](https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83), за исключением того, что элементы не создаются до выполнения итерации по последовательности. В следующем коде показано использование `Seq.init`.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet10.fs)]

Выходные данные:

```console
0 10 20 30 40
```

С помощью функции [Seq. офаррай](https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99) и [Seq.&#60;офлист&#62; t](https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d)можно создавать последовательности из массивов и списков. Однако массивы и списки можно также преобразовать в последовательности с помощью оператора приведения. В следующем коде показаны оба метода.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet11.fs)]

С помощью [Seq. Cast](https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334)можно создать последовательность из слабо типизированной коллекции, например, определенных в `System.Collections`. Такие слабо типизированные коллекции имеют тип элемента `System.Object` и перечисляются с помощью неуниверсального `System.Collections.Generic.IEnumerable&#96;1` типа. Следующий код иллюстрирует использование `Seq.cast` для преобразования `System.Collections.ArrayList` в последовательность.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet12.fs)]

Можно определить бесконечные последовательности с помощью функции [Seq. инитинфините](https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef) . Для такой последовательности необходимо предоставить функцию, которая создает каждый элемент из индекса элемента. Бесконечные последовательности возможны из-за отложенного вычисления. элементы создаются по мере необходимости путем вызова указанной функции. В следующем примере кода создается неограниченная последовательность чисел с плавающей запятой, в данном случае чередующийся ряд квадратов последовательных целых чисел.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet13.fs)]

[Seq. unfold](https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21) создает последовательность из вычислительной функции, которая принимает состояние и преобразует его для создания каждого последующего элемента последовательности. Состояние — это просто значение, используемое для расчета каждого элемента, и может изменяться при вычислении каждого элемента. Вторым аргументом для `Seq.unfold` является начальное значение, используемое для запуска последовательности. `Seq.unfold` использует тип параметра для состояния, что позволяет завершить последовательность, возвращая значение `None`. В следующем коде показаны два примера последовательностей: `seq1` и `fib`, которые создаются операцией `unfold`. Первая, `seq1`, — это просто последовательность с числами до 20. Во втором `fib`используется `unfold` для вычислить последовательность Фибоначчи. Поскольку каждый элемент последовательности Фибоначчи является суммой двух предыдущих чисел Фибоначчи, значение состояния является кортежем, состоящим из двух предыдущих чисел в последовательности. Начальное значение — `(1,1)`, первые два числа в последовательности.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet14.fs)]

Выходные данные выглядят следующим образом:

```console
The sequence seq1 contains numbers from 0 to 20.

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

The sequence fib contains Fibonacci numbers.

2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

Ниже приведен пример кода, в котором используются многие из описанных здесь функций модуля последовательности для создания и расчета значений бесконечных последовательностей. Выполнение кода может занять несколько минут.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet15.fs)]

## <a name="searching-and-finding-elements"></a>Поиск и поиск элементов

Функции поддержки последовательностей доступны в списках: [Seq. Exists](https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1), [Seq. exists2-](https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565), [Seq. Find](https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8), [Seq. findIndex](https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3), [Seq. Pick](https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d), [Seq. tryFind](https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47)и [Seq. tryFindIndex](https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a). Версии этих функций, доступные для последовательностей, оценивают последовательность только до элемента, для которого выполняется поиск. Примеры см. в разделе [списки](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d).

## <a name="obtaining-subsequences"></a>Получение подпоследовательностей

[Seq. Filter](https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770) и [Seq. Choose](https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395) подобны соответствующим функциям, доступным для списков, за исключением того, что фильтрация и выбор не выполняются до оценки элементов последовательности.

[Seq. truncate](https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244) создает последовательность из другой последовательности, но ограничивает ее заданным числом элементов. [Seq. take](https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596) создает новую последовательность, содержащую только заданное число элементов из начала последовательности. Если число элементов в последовательности меньше, чем указано, `Seq.take` выдает `System.InvalidOperationException`. Различие между `Seq.take` и `Seq.truncate` заключается в том, что `Seq.truncate` не создает ошибку, если число элементов меньше указанного числа.

В следующем коде показано поведение и различия между `Seq.truncate` и `Seq.take`.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet16.fs)]

Выходные данные до возникновения ошибки выглядят следующим образом.

```console
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
1 4 9 16 25
1 4 9 16 25 36 49 64 81 100
```

С помощью [Seq. TakeWhile](https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92)можно указать функцию предиката (логическую функцию) и создать последовательность из другой последовательности, состоящие из элементов исходной последовательности, для которых предикат `true`, но останавливаться перед первым элементом для , который предикат возвращает `false`. [Seq. Skip](https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1) возвращает последовательность, которая пропускает заданное число первых элементов другой последовательности и возвращает остальные элементы. [Seq. SkipWhile](https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16) возвращает последовательность, которая пропускает первые элементы другой последовательности, если предикат возвращает `true`, а затем возвращает оставшиеся элементы, начиная с первого элемента, для которого предикат возвращает `false`.

В следующем примере кода показано поведение и различия между `Seq.takeWhile`, `Seq.skip`и `Seq.skipWhile`.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet17.fs)]

Выходные данные выглядят следующим образом.

```console
1 4 9
36 49 64 81 100
16 25 36 49 64 81 100
```

## <a name="transforming-sequences"></a>Преобразование последовательностей

Функция [Seq. парная](https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1) создает новую последовательность, в которой последовательные элементы входной последовательности группируются по кортежам.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet18.fs)]

[Seq. windowd](https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744) выглядит так `Seq.pairwise`, за исключением того, что вместо создания последовательности кортежей он создает последовательность массивов, содержащую копии смежных элементов ( *окно*) из последовательности. Вы указываете число соседних элементов в каждом массиве.

В следующем коде показано использование функции `Seq.windowed`. В этом случае число элементов в окне равно 3. В примере используется `printSeq`, который определен в предыдущем примере кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet180.fs)]

Выходные данные выглядят следующим образом.

Начальная последовательность:

```console
1.0 1.5 2.0 1.5 1.0 1.5

Windows of length 3:
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|]

Moving average:
1.5 1.666666667 1.5 1.333333333
```

## <a name="operations-with-multiple-sequences"></a>Операции с несколькими последовательностями

[Seq. zip](https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4) и [Seq. zip3](https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16) принимают две или три последовательности и создают последовательность кортежей. Эти функции подобны соответствующим функциям, доступным для [списков](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d). Нет соответствующей функциональности для разделения одной последовательности на две или более последовательностей. Если эта функция необходима для последовательности, преобразуйте последовательность в список и используйте [List. unzip](https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21).

## <a name="sorting-comparing-and-grouping"></a>Сортировка, сравнение и группирование

Функции сортировки, поддерживаемые для списков, также работают с последовательностями. Сюда входят [Seq. Sort](https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e) и [Seq. sortBy](https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f). Эти функции выполняют итерацию всей последовательности.

Для сравнения двух последовательностей используется функция [Seq. компаревис](https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f) . Функция сравнивает последовательные элементы в свою очередь и останавливается при обнаружении первой неравной пары. Все дополнительные элементы не участвуют в сравнении.

В следующем коде показано использование `Seq.compareWith`.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet19.fs)]

В предыдущем коде вычисляются и анализируются только первый элемент, а результат равен-1.

[Seq. каунтби](https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f) принимает функцию, которая создает значение, именуемое *ключом* для каждого элемента. Ключ создается для каждого элемента путем вызова этой функции для каждого элемента. `Seq.countBy` возвращает последовательность, содержащую значения ключа, и количество элементов, которые создали каждое значение ключа.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet201.fs)]

Выходные данные выглядят следующим образом.

```console
(1, 34) (2, 33) (0, 33)
```

В предыдущих выходных данных показано, что имелось 34 элементов исходной последовательности, которые производили значение ключа 1, 33, которое вызвало ключ 2, и значение 33, полученное с помощью ключа 0.

Элементы последовательности можно сгруппировать, вызвав [Seq. GroupBy](https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd). `Seq.groupBy` принимает последовательность и функцию, которая создает ключ из элемента. Функция выполняется для каждого элемента последовательности. `Seq.groupBy` возвращает последовательность кортежей, где первый элемент каждого кортежа является ключом, а второй — последовательностью элементов, которые создают этот ключ.

В следующем примере кода показано использование `Seq.groupBy` для разделения последовательности чисел от 1 до 100 на три группы, имеющие уникальные значения ключа 0, 1 и 2.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet202.fs)]

Выходные данные выглядят следующим образом.

```console
(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])
```

Можно создать последовательность, которая устраняет повторяющиеся элементы, вызывая [Seq. DISTINCT](https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401). Или можно использовать [Seq. дистинктби](https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75), который принимает функцию создания ключа для каждого элемента. Результирующая последовательность содержит элементы исходной последовательности, имеющие уникальные ключи. последующие элементы, которые создают дубликат ключа для более раннего элемента, отбрасываются.

В следующем примере кода показано использование `Seq.distinct`. `Seq.distinct` демонстрируется путем создания последовательностей, представляющих двоичные числа, а затем показывается, что единственными отдельными элементами являются 0 и 1.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet22.fs)]

Следующий код демонстрирует `Seq.distinctBy`, начиная с последовательности, содержащей отрицательные и положительные числа, и используя функцию абсолютного значения в качестве функции создания ключа. В результирующей последовательности отсутствуют все положительные числа, соответствующие отрицательным числам в последовательности, так как отрицательные числа отображаются ранее в последовательности и, следовательно, выбираются вместо положительных чисел, имеющих одинаковые абсолютные значения значение или ключ.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet23.fs)]

## <a name="readonly-and-cached-sequences"></a>Последовательностей только для чтения и кэширование

[Seq. ReadOnly](https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7) создает копию последовательности, доступную только для чтения. `Seq.readonly` удобно использовать, если имеется коллекция для чтения и записи, например массив, и вы не хотите изменять исходную коллекцию. Эта функция может использоваться для сохранения инкапсуляции данных. В следующем примере кода создается тип, содержащий массив. Свойство предоставляет массив, но вместо возвращения массива он возвращает последовательность, созданную из массива с помощью `Seq.readonly`.

[!code-fsharp[Main](~/samples/snippets/fsharp/fssequences/snippet24.fs)]

[Seq. Cache](https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0) создает сохраненную версию последовательности. Используйте `Seq.cache`, чтобы избежать повторного вычисления последовательности или при наличии нескольких потоков, использующих последовательность, но необходимо убедиться, что каждый элемент действует только один раз. При наличии последовательности, используемой несколькими потоками, у вас может быть один поток, который перечисляет и выполняет вычисление значений для исходной последовательности, а оставшиеся потоки могут использовать кэшированную последовательность.

## <a name="performing-computations-on-sequences"></a>Выполнение вычислений в последовательностях

Простые арифметические операции аналогичны спискам, например [Seq. Average](https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8), [Seq. Sum](https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a), [Seq. averageBy](https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8), [Seq. sumBy](https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1)и т. д.

Функции [Seq. fold](https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3), [Seq. reduce](https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9)и [Seq. Scan](https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e) подобны соответствующим функциям, доступным для списков. Последовательности поддерживают подмножество всех вариантов этих функций, которые поддерживаются в списках. Дополнительные сведения и примеры см. в разделе [списки](lists.md).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Типы языка F#](fsharp-types.md)
