---
title: Записи (F#)
description: 'Узнайте, как записи на F # представляют собой простые агрегаты именованных значений, при необходимости с участниками.'
ms.date: 05/16/2016
ms.openlocfilehash: 6103d96b6b80a9e2ed168755958dbe800f7fa862
ms.sourcegitcommit: 8c2ece71e54f46aef9a2153540d0bda7e74b19a9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/11/2018
ms.locfileid: "44368220"
---
# <a name="records"></a>Записи

Записи представляют собой простые агрегаты именованных значений, которые могут иметь элементы.  Начиная с F # 4.1, они может быть структуры или ссылочный тип.  Они являются ссылочными типами, по умолчанию.

## <a name="syntax"></a>Синтаксис

```fsharp
[ attributes ]
type [accessibility-modifier] typename =
    { [ mutable ] label1 : type1;
      [ mutable ] label2 : type2;
      ... }
    [ member-list ]
```

## <a name="remarks"></a>Примечания

В приведенном выше синтаксисе *typename* имя типа записи, *label1* и *label2* — это имена значений, называется *метки*, и *тип1* и *тип2* типы из следующих значений. *Список членов* — необязательный список элементов для типа.  Можно использовать `[<Struct>]` атрибут для создания записи структуры, а не записи, которая является ссылочным типом.

Ниже приведены некоторые примеры.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1901.fs)]

При каждой метки находится на отдельной строке, точка с запятой является необязательным.

Можно задать значения в выражениях, известный как *записи выражения*. Компилятор выводит тип на основе подписи (если метки в достаточной степени отличаются от других типов записей). Фигурные скобки ({}) заключите выражение записи. В следующем коде показано выражение записи, инициализирующее запись с тремя элементами число с плавающей запятой с метками `x`, `y` и `z`.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1907.fs)]

Не используйте сокращенную форму, если может быть другой тип, который также имеет одинаковые заголовки.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1903.fs)]

Метки последнего объявленного типа имеют приоритет над метками ранее объявленного типа, поэтому в приведенном выше примере `mypoint3D` выводится как `Point3D`. Можно явно указать тип записи, как показано в следующем коде.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1908.fs)]

Методы могут определяться для типов записей, так же как и типы классов.

## <a name="creating-records-by-using-record-expressions"></a>Создание записей с помощью выражений записей

Записи можно инициализировать с помощью метки, которые определены в записи. Выражение, которое делает это называется *записать выражение*. Используйте фигурные скобки для заключите выражение записи и используют в качестве разделителя точку с запятой.

В следующем примере показано, как создать запись.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1904.fs)]

Точка с запятой после последнего поля в выражении записи и в определении типа являются необязательными, независимо от того, являются ли поля все в одну строку.

При создании записи необходимо указать значения для каждого поля. Нельзя ссылаться на значения других полей в выражении инициализации для любого поля.

В следующем коде, тип `myRecord2` выводится из имена полей. При необходимости можно явно указать имя типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1905.fs)]

Можно использовать другую форму конструкции записи, при необходимо будет скопировать существующую запись, возможно, изменить некоторые значения полей. Это показано в следующей строке кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1906.fs)]

Эта форма выражения записи называется *копирование и обновление выражений записей*.

Записи являются неизменяемыми по умолчанию; Тем не менее можно легко создать измененные записи с помощью копирования и обновить выражение. Можно также явно указать изменяемого поля.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1909.fs)]

Не используйте атрибут DefaultValue с полями записей. Лучшим подходом является определение экземпляров по умолчанию записей с полями, которые были инициализированы значениями по умолчанию, а затем использовать копию и обновить записи выражение, чтобы задать все поля, которые отличаются от значений по умолчанию.

```fsharp
// Rather than use [<DefaultValue>], define a default record.
type MyRecord =
    { Field1 : int
      Field2 : int }

let defaultRecord1 = { Field1 = 0; Field2 = 0 }
let defaultRecord2 = { Field1 = 1; Field2 = 25 }

// Use the with keyword to populate only a few chosen fields
// and leave the rest with default values.
let rr3 = { defaultRecord1 with Field2 = 42 }
```

## <a name="pattern-matching-with-records"></a>Сопоставление шаблонов с записями

Записи могут использоваться с сопоставлением шаблонов. Можно явным образом задать некоторые поля и указать переменные для других полей, которые будут назначаться при совпадении. Это показано в следующем примере кода.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1910.fs)]

Результат выполнения этого кода выглядит следующим образом.

```
Point is at the origin.
Point is on the x-axis. Value is 100.000000.
Point is at (10.000000, 0.000000, -1.000000).
```

## <a name="differences-between-records-and-classes"></a>Различия между записями и классы

Поля записей отличаются от классов, в том, что они автоматически представляются как свойства, и они используются при создании и копировании записей. Построение записей также отличается от построения класса. В типе записи не может определить конструктор. Вместо этого применяется синтаксис конструкции, описанный в этом разделе. Классы не имеют прямых связей между параметров конструктора, поля и свойства.

Как и типы объединения и структуру записи имеют семантику структурного равенства. Классы имеют ссылки семантику равенства. Это действие представлено в следующем примере кода:

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet1911.fs)]

Результат выполнения этого кода выглядит следующим образом:

```
The records are equal.
```

При написании один и тот же код с классами, два объекта класса будут неравными, так как эти два значения будут представлять два объекта в куче и будут сравниваться только адреса (если тип класса не переопределяет `System.Object.Equals` метод).

Если требуется ссылка на равенство для записей, добавьте атрибут `[<ReferenceEquality>]` выше запись.

## <a name="see-also"></a>См. также

- [Типы языка F#](fsharp-types.md)
- [Классы](classes.md)
- [Справочник по языку F#](index.md)
- [Равенство ссылок](https://msdn.microsoft.com/visualfsharpdocs/conceptual/core.referenceequalityattribute-class-%5bfsharp%5d)
- [Соответствие шаблону](pattern-matching.md)
