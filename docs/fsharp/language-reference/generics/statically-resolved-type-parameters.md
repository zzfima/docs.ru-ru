---
title: Статически разрешаемые параметры типа (F#)
description: 'Сведения об использовании F # статически разрешаемым параметром типа, который заменяется фактическим типом во время компиляции, а не во время выполнения.'
ms.date: 05/16/2016
ms.openlocfilehash: 747917fef2746dcbf363ef4b717ace5e47229800
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2018
ms.locfileid: "48032781"
---
# <a name="statically-resolved-type-parameters"></a>Статически разрешаемые параметры типов

Объект *статически разрешаемым параметром типа* является параметром типа, который заменяется фактическим типом во время компиляции, а не во время выполнения. Перед ними присутствует символ крышки (^).

## <a name="syntax"></a>Синтаксис

```
ˆtype-parameter
```

## <a name="remarks"></a>Примечания

В языке F # существует два вида параметров типа. Первый тип — стандартным параметром универсального типа. Они обозначаются с помощью апострофа ('), как показано на `'T` и `'U`. Они эквивалентны параметров универсального типа в других языках .NET Framework. Другой вид является статически разрешаемым и обозначается символом крышки, как показано на `^T` и `^U`.

Статически разрешаемые параметры типа, в основном используются в связи с ограничениями членов, которые являются ограничения, которые позволяют пользователю указать, что аргумент типа должен иметь определенный элемент или элементы для использования. Нет способа для создания такого рода ограничение с помощью параметра регулярных универсального типа.

В следующей таблице перечислены сходства и различия между двумя типами параметров типа.

|Функция|Универсальный|Статически разрешаемые|
|-------|-------|-------------------|
|Синтаксис|`'T`, `'U`|`^T`, `^U`|
|Время разрешения|Выполнение|Время компиляции|
|Ограничения члена|Не может использоваться с ограничениями членов.|Может использоваться с ограничениями членов.|
|Создание кода|Тип (или метод) со стандартными параметрами универсального типа приводит к формированию, одного универсального типа или метода.|Создаются несколько экземпляров типов и методов, он будет необходим для каждого типа.|
|Использовать с типами|Можно применять к типам.|Нельзя применять к типам.|
|Использование со встроенными функциями|Нет. Встроенная функция не могут быть параметризованы с параметром standard универсального типа.|Да. Статически разрешаемые параметры типа нельзя применять к функции или методы, не являющиеся встроенными.|

Многие функции F # core библиотеки, особенно операторы, статически разрешаемые параметры типов. Эти функции и операторы в строке и привести к созданию эффективного кода для численных вычислений.

Встроенные методы и функции, которые используют операторы или использовать другие функции, которые статически разрешаемые параметры типов, также могут использовать статически разрешаемые параметры типа самостоятельно. Часто такие встроенные функции, имеющие статически разрешаемые параметры типа определяются вывод типа. В следующем примере показано определение оператора, логически распознается статически разрешаемым параметром типа.

[!code-fsharp[Main](../../../../samples/snippets/fsharp/lang-ref-3/snippet401.fs)]

Разрешенный тип `(+@)` основан на использование обоих `(+)` и `(*)`, обе из чему вывод типа ограничениям членов на статически разрешаемые параметры типа. Разрешенный тип, как показано в интерпретаторе F #, выглядит следующим образом.

```fsharp
^a -> ^c -> ^d
when (^a or ^b) : (static member ( + ) : ^a * ^b -> ^d) and
(^a or ^c) : (static member ( * ) : ^a * ^c -> ^b)
```

Выходные данные выглядят следующим образом.

```
2
1.500000
```

Начиная с F # 4.1, можно также указать имена конкретный тип в статически разрешенный тип параметра сигнатуры.  В предыдущих версиях языка имя типа могут быть выведены фактически компилятором, но фактически не удается задать в сигнатуре.  По состоянию на F # 4.1 можно также указать имена конкретный тип в статически разрешенный тип параметра сигнатуры. Ниже приведен пример:

```fsharp
let inline konst x _ = x

type CFunctor() = 
    static member inline fmap (f: ^a -> ^b, a: ^a list) = List.map f a
    static member inline fmap (f: ^a -> ^b, a: ^a option) =
        match a with
        | None -> None
        | Some x -> Some (f x)

    // default implementation of replace
    static member inline replace< ^a, ^b, ^c, ^d, ^e when ^a :> CFunctor and (^a or ^d): (static member fmap: (^b -> ^c) * ^d -> ^e) > (a, f) =
        ((^a or ^d) : (static member fmap : (^b -> ^c) * ^d -> ^e) (konst a, f))

    // call overridden replace if present
    static member inline replace< ^a, ^b, ^c when ^b: (static member replace: ^a * ^b -> ^c)>(a: ^a, f: ^b) =
        (^b : (static member replace: ^a * ^b -> ^c) (a, f))

let inline replace_instance< ^a, ^b, ^c, ^d when (^a or ^c): (static member replace: ^b * ^c -> ^d)> (a: ^b, f: ^c) =
        ((^a or ^c): (static member replace: ^b * ^c -> ^d) (a, f))

// Note the concrete type 'CFunctor' specified in the signature
let inline replace (a: ^a) (f: ^b): ^a0 when (CFunctor or  ^b): (static member replace: ^a *  ^b ->  ^a0) =
    replace_instance<CFunctor, _, _, _> (a, f)
```

## <a name="see-also"></a>См. также

- [Универсальные шаблоны](index.md)
- [Вывод типа](../type-inference.md)
- [Автоматическое обобщение](automatic-generalization.md)
- [Ограничения](constraints.md)
- [Встраиваемые функции](../functions/inline-functions.md)
