---
title: Асинхронные рабочие потоки (F#)
description: 'Сведения о поддержке в языке F # язык программирования для выполнения асинхронных вычислений, которые выполняются без блокировки других операций.'
ms.date: 05/16/2016
ms.openlocfilehash: 2a6d5f8b61d63a722744f8f71a037e8bc460c64f
ms.sourcegitcommit: 3c1c3ba79895335ff3737934e39372555ca7d6d0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/06/2018
ms.locfileid: "43861566"
---
# <a name="asynchronous-workflows"></a>Асинхронные рабочие потоки

> [!NOTE]
Ссылка на справочник по API ведет на сайт MSDN.  Работа над справочником по API docs.microsoft.com не завершена.

В этом разделе описывается поддержка в F # для выполнения асинхронных вычислений, то есть без блокировки других операций. Например асинхронные вычисления можно использовать для написания приложений с интерфейсами пользователя, продолжает отвечать на запросы для пользователей, так как приложение выполняет другую работу.

## <a name="syntax"></a>Синтаксис

```fsharp
async { expression }
```

## <a name="remarks"></a>Примечания

В приведенном выше синтаксисе представлены вычисления `expression` предназначена для запускаются асинхронно, то есть без блокировки текущего потока вычислений при выполнении операции асинхронной спящего режима, ввода-вывода и других асинхронных операций. Асинхронные вычисления часто запускаются в фоновом потоке, пока выполнение продолжается в текущем потоке. Тип выражения — `Async<'T>`, где `'T` является типом, возвращаемое выражением при `return` используется ключевое слово. Код в такое выражение называется *асинхронным блоком*, или *блоком async*.

Существует множество способов программирования асинхронно и [ `Async` ](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7) класс предоставляет методы, которые поддерживают несколько сценариев. Общий подход заключается в создании `Async` объекты, представляющие вычисления или вычисления, которые будут выполняться асинхронно и затем запустите эти вычисления с помощью одного из запускающих функций. Различные запускающие функции обеспечивают различные способы выполнения асинхронных вычислений, и который из них использовать зависит от того, требуется ли использовать текущий поток, фоновый поток или объект задачи .NET Framework и определения наличия продолжения функции, которые должны выполняться после завершения вычисления. Например, чтобы начать асинхронное вычисление в текущем потоке, можно использовать [ `Async.StartImmediate` ](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3). При запуске асинхронное вычисление в потоке пользовательского интерфейса, вы не заблокировали событие основной цикл, который обрабатывает действия пользователя, например нажатия клавиш и действия мыши, таким образом, приложение продолжает реагировать.

## <a name="asynchronous-binding-by-using-let"></a>Асинхронная привязка с помощью предложения let!

В асинхронном рабочем процессе некоторые выражения и операции являются синхронными, а некоторые — больше вычислений, которые предназначены для возврата результирующего асинхронно. При асинхронном вызове метода вместо обычной `let` привязки, использовании `let!`. Последствия `let!` позволяет продолжать выполнение других вычислений или потоков во время вычисления. После правой части `let!` возвращает привязки, остальная часть асинхронный рабочий процесс возобновляет выполнение.

В следующем коде показано различие между `let` и `let!`. В строке кода, использующего `let` просто создает асинхронное вычисление в виде объекта, который можно запустить позднее с помощью, например, `Async.StartImmediate` или [ `Async.RunSynchronously` ](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b). В строке кода, использующего `let!` запускает вычисление, а затем выполнение потока приостанавливается до получения результата, после чего выполнение продолжается.

```fsharp
// let just stores the result as an asynchronous operation.
let (result1 : Async<byte[]>) = stream.AsyncRead(bufferSize)
// let! completes the asynchronous operation and returns the data.
let! (result2 : byte[])  = stream.AsyncRead(bufferSize)
```

В дополнение к `let!`, можно использовать `use!` для выполнения асинхронной привязки. Разница между `let!` и `use!` совпадает со значением разницу между `let` и `use`. Для `use!`, объект удаляется при закрытии текущей области. Обратите внимание, что в текущем выпуске языка F #, `use!` разрешается использовать значение инициализировать значение null, даже если `use` does.

## <a name="asynchronous-primitives"></a>Асинхронные примитивы

Вызывается метод, который выполняет одну асинхронную задачу и возвращает результат *асинхронного примитива*, и они предназначены специально для использования с `let!`. Несколько асинхронные примитивы определяются в основной библиотеки F #. Два таких метода для веб-приложений определяются в модуле [ `Microsoft.FSharp.Control.WebExtensions` ](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003): [ `WebRequest.AsyncGetResponse` ](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c) и [ `WebClient.AsyncDownloadString` ](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a). Оба примитивы скачать данные из веб-страницы, URL-адреса. `AsyncGetResponse` Создает `System.Net.WebResponse` объекта, и `AsyncDownloadString` создает строку, которая представляет HTML-код для веб-страницы.

Несколько примитивов для асинхронных операций ввода-вывода, включаются в [ `Microsoft.FSharp.Control.CommonExtensions` ](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396) модуля. Эти методы расширения `System.IO.Stream` класса [ `Stream.AsyncRead` ](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e) и [ `Stream.AsyncWrite` ](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618).

Можно также написать собственные асинхронные примитивы, определив функцию, все тело заключен в блок async.

Чтобы использовать асинхронные методы в платформе .NET Framework, предназначенных для других асинхронных моделей с моделью асинхронного программирования F #, создайте функцию, возвращающую F # `Async` объекта. Библиотека F # содержит функции, позволяющие это легко сделать.

Одним из примеров применения асинхронные рабочие потоки включено Существуют и многие другие в документации по методы [Async-класс](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7).

В этом примере показано, как использовать асинхронные рабочие потоки для выполнения вычислений в параллельном режиме.

В следующем примере кода функция `fetchAsync` Получает HTML-текст, возвращаемый из веб-запроса. `fetchAsync` Функция содержит асинхронный блок кода. Если выполнена привязка к результату асинхронного примитива, в данном случае [ `AsyncDownloadString` ](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a), let! используется вместо let.

При использовании функции [ `Async.RunSynchronously` ](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b) для выполнения асинхронной операции и ожидать ее результата. Например, можно выполнять несколько асинхронных операций в параллельном режиме с помощью [ `Async.Parallel` ](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4) работать вместе с `Async.RunSynchronously` функции. `Async.Parallel` Функция принимает список `Async` объекты, настраивает код для каждого `Async` объект задачи для запуска в параллельном режиме и возвращает `Async` , представляющий параллельных вычислений. Так же как и в одной операции, вызовите `Async.RunSynchronously` для начала выполнения.

`runAll` Функция запускает три асинхронные рабочие потоки в параллельном режиме и ожидает, пока все они будут завершены.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet8003.fs)]

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Выражения вычисления](computation-expressions.md)
- [Класс Control.Async](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d)
