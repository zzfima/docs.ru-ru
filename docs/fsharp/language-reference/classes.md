---
title: Классы (F#)
description: 'Узнайте, как F # классы являются типы, представляющие объекты, которые могут иметь свойства, методы и события.'
ms.date: 05/16/2016
ms.openlocfilehash: 71cd713d192d28565e879b79b2fc9e0530e5f841
ms.sourcegitcommit: 5bbfe34a9a14e4ccb22367e57b57585c208cf757
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/17/2018
ms.locfileid: "45742523"
---
# <a name="classes"></a>Классы

*Классы* представляют объекты, которые могут иметь свойства, методы и события.

## <a name="syntax"></a>Синтаксис

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a>Примечания

Классы представляют фундаментальное Описание типов объектов .NET. класс представляет концепцию основной тип, поддерживающий объектно ориентированное программирование в F #.

Приведенный выше синтаксис `type-name` — любой допустимый идентификатор. `type-params` Описывает необязательные параметры универсального типа. Он состоит из имен параметров типа и ограничения, заключенные в угловые скобки (`<` и `>`). Дополнительные сведения см. в разделе [универсальные шаблоны](generics/index.md) и [ограничения](generics/constraints.md). `parameter-list` Описание параметров конструктора. Первый модификатор доступа относится к типу; Второй относится к первичного конструктора. В обоих случаях значение по умолчанию — `public`.

Укажите базовый класс для класса с помощью `inherit` ключевое слово. Необходимо указать аргументы для конструктора базового класса, в скобках.

Объявление полей или значений, которые являются локальными для класса с помощью функций `let` привязки и вы должны следовать основным правилам для `let` привязки. `do-bindings` Разделе содержится код, выполняемый при создании объекта.

`member-list` Состоит из дополнительных конструкторов, экземпляр и объявления статических методов, объявления интерфейса, абстрактные привязки и объявления свойств и событий. Они описаны в [члены](members/index.md).

`identifier` , Используемый с необязательным `as` ключевого слова, указывает имя переменной экземпляра, или собственный идентификатор, который может использоваться для ссылки на экземпляр типа в определении типа. Дополнительные сведения см. в разделе разделе идентификаторы Self далее в этом разделе.

Ключевые слова `class` и `end` , отмечающие начало и конец определения являются необязательными.

Взаимно рекурсивные типы, которые являются типами, которые ссылаются друг на друга, объединяются с `and` ключевое слово точно так же, как и взаимно рекурсивные функции. Пример см. в разделе взаимно рекурсивные типы.

## <a name="constructors"></a>Конструкторы

Конструктор является код, который создает экземпляр типа класса. Конструкторы классов работают немного по-разному в F # на других языках .NET. В классе F #, всегда есть первичный конструктор, аргументы которого описаны в `parameter-list` , который следует за имя типа, и тело которого состоит из `let` (и `let rec`) привязки в начале объявления класса и `do`за ними привязок. Аргументы главного конструктора, имеют область действия объявления класса.

Можно добавить дополнительные конструкторы с помощью `new` ключевое слово для добавления члена, как показано ниже:

`new`(`argument-list`) = `constructor-body`

Тело новый конструктор должен вызвать первичный конструктор, который указан в верхней части объявления класса.

Следующий пример иллюстрирует эту концепцию. В следующем коде `MyClass` имеет два конструктора, первичный конструктор, принимающий два аргумента и другой конструктор без аргументов.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a>Let и привязки do

`let` И `do` привязки в определении класса образуют основную часть главного конструктора, и поэтому они выполняются каждый раз, когда создается экземпляр класса. Если `let` привязки — это функция, а затем она компилируется в член. Если `let` привязки — это значение, не используется в любой функции или члена, а затем она компилируется в переменную, которая является локальной в конструктор. В противном случае она компилируется в поле класса. `do` Выражения компилируются в главный конструктор и выполняют код инициализации для каждого экземпляра. Поскольку все дополнительные конструкторы всегда вызывают главный конструктор, `let` привязок и `do` всегда выполняются независимо от того, что вызывается конструктор.

Поля, которые создаются с `let` привязки может осуществляться через методы и свойства класса; Однако они не доступны из статических методов, даже если статический метод принимает переменную экземпляра в качестве параметра. Они не доступны, используя собственный идентификатор, если он существует.

## <a name="self-identifiers"></a>Собственные идентификаторы

Объект *собственный идентификатор* — это имя, которое представляет текущий экземпляр. Собственные идентификаторы подобны `this` ключевого слова в C# или C++ или `Me` в Visual Basic. Можно определить собственный идентификатор двумя различными способами, в зависимости от того, нужно собственный идентификатор в области для всего определения класса или просто для отдельного метода.

Чтобы определить собственный идентификатор для всего класса, используйте `as` ключевое слово после закрывающей скобки из параметра конструктора списка и укажите имя идентификатора.

Чтобы определить собственный идентификатор для всего один метод, укажите собственный идентификатор в объявлении члена, непосредственно перед именем метода и точку (.) в качестве разделителя.

В следующем примере кода показано два способа создания собственного идентификатора. В первой строке `as` ключевое слово используется для определения собственный идентификатор. В пятой строке идентификатор `this` позволяет определить собственный идентификатор, область действия которого ограничивается метод `PrintMessage`.

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

В отличие от других языков .NET, можно назвать идентификатор самого любым способом; Вы не ограничены имена таких как `self`, `Me`, или `this`.

Собственный идентификатор, объявленный с помощью `as` ключевое слово не инициализируется, пока после `let` выполнения привязок. Таким образом, он не может использоваться в `let` привязки. Можно использовать собственный идентификатор в `do` раздел привязок.

## <a name="generic-type-parameters"></a>Параметры универсального типа

Указанные параметры универсального типа в угловых скобках (`<` и `>`), в виде одинарной кавычки, а затем по идентификатору. Параметры универсального типа разделяются запятыми. Область действия объявления является параметром универсального типа. В следующем примере кода показано задание параметров универсального типа.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

Аргументы типа выводятся в том случае, если используется тип. В следующем коде выведенный тип — это последовательность кортежей.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a>Указание наследования

`inherit` Предложение определяет прямой базовый класс, если таковой имеется. В языке F # допускается только один прямой базовый класс. Интерфейсы, реализуемые классом, не считаются базовыми классами. Интерфейсы рассматриваются в [интерфейсы](Interfaces.md) раздела.

Доступны методы и свойства базового класса из производного класса с помощью ключевого слова языка `base` как идентификатор, за которым следует точка (.) и имя члена.

Дополнительные сведения см. в разделе [Наследование](inheritance.md).

## <a name="members-section"></a>Раздел членов

В этом разделе, можно определить статический или методов экземпляра, свойства, реализации интерфейса, абстрактные члены, объявления событий и дополнительных конструкторов. Let и у привязок, не может находиться в этом разделе. Так как элементы могут добавляться к различным типов F # в дополнение к классам, они обсуждаются в отдельном разделе [члены](members/index.md).

## <a name="mutually-recursive-types"></a>Взаимно рекурсивные типы

При определении типов, на которые ссылаются друг на друга циклически, вы строку вместе определения типов с помощью `and` ключевое слово. `and` Заменяет ключевое слово `type` во всех определениях, кроме первого, как показано ниже.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

Выводится список всех файлов в текущем каталоге.

## <a name="when-to-use-classes-unions-records-and-structures"></a>Когда следует использовать классы, объединения, записи и структуры

Учитывая множество различных типов на выбор, необходимо иметь хорошее понимание того, что каждый тип предназначен для для выбора соответствующего типа для конкретной ситуации. Классы предназначены для использования в объектно ориентированного программирования контекстах. Объектно ориентированное программирование является главным парадигмой, применяемой в приложения, написанные для .NET Framework. Если приходится работать в тесном сотрудничестве с .NET Framework или другой библиотеке, объектно ориентированного кода F #, и особенно в том случае, если необходимо выполнить расширение из объектно ориентированного тип системы, такие как библиотека пользовательского интерфейса, классы, скорее всего, подходят.

При отсутствии тесного взаимодействия с объектно ориентированного кода, или если вы пишете код, который является самодостаточной и поэтому защищенного от частого взаимодействия с объектно ориентированного кода, следует рассмотреть возможность использования записи и размеченные объединения. Один, хорошо проработанное размеченного объединения, а также соответствующие шаблоны кода, можно часто использовать в качестве более простой альтернативой иерархии объектов. Дополнительные сведения о размеченные объединения, см. в разделе [размеченные объединения](discriminated-unions.md).

Записи имеют преимущество проще, чем классы, но записи не подходят, если требования к типу превышают накладываемые их простотой. Записи являются по сути простые агрегаты значений, без отдельных конструкторов, которые могут выполнять пользовательские действия, без скрытых полей и без реализации наследования и интерфейсов. Несмотря на то, что такие члены, как свойства и методы могут добавляться к записям сопоставляет свое поведение более сложных, поля записей по-прежнему являются простым агрегатом значения. Дополнительные сведения о записях см. в разделе [записей](records.md).

Структуры также полезны для небольших объемов данных, но они отличаются от классов и записей, в том, что они представляют собой типы значений .NET. Классы и записи являются ссылочными типами .NET. Семантика типов значений и ссылочных типов отличаются тем, что типы значений передаются по значению. Это означает, что они копируются бит для бита, при их переданный в качестве параметра или возвращаемого функцией. Они также хранятся в стеке или, если они используются как поле, внедренные в родительский объект, а не хранится в отдельном расположении в куче. Таким образом структур подходят для часто используемых данных, тогда, когда затраты на доступ к куче является проблемой. Дополнительные сведения о структурах см. в разделе [структуры](structures.md).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
- [Члены](members/index.md)
- [Наследование](inheritance.md)
- [Интерфейсы](interfaces.md)
