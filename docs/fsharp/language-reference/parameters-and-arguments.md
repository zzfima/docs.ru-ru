---
title: Параметры и аргументы
description: Сведения о F# языковой поддержке для определения параметров и передачи аргументов в функции, методы и свойства.
ms.date: 12/04/2019
ms.openlocfilehash: b234ef939128e7cf09d35f9580d4d5010d7dc639
ms.sourcegitcommit: a4f9b754059f0210e29ae0578363a27b9ba84b64
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "74837133"
---
# <a name="parameters-and-arguments"></a>Параметры и аргументы

В этом разделе описывается языковая поддержка для определения параметров и передачи аргументов в функции, методы и свойства. Он содержит сведения о том, как передавать данные по ссылке, а также определять и использовать методы, которые могут принимать переменное число аргументов.

## <a name="parameters-and-arguments"></a>Параметры и аргументы

*Параметр* term используется для описания имен для значений, которые должны быть указаны. *Аргумент* term используется для значений, предоставленных для каждого параметра.

Параметры могут быть указаны в кортеже или в каррированных форме или в некоторой комбинации этих двух значений. Аргументы можно передать с помощью явного имени параметра. Параметры методов можно указать как необязательные и задавая значение по умолчанию.

## <a name="parameter-patterns"></a>Шаблоны параметров

Параметры, предоставляемые функциям и методам, обычно являются шаблонами, разделенными пробелами. Это означает, что в принципе любой из шаблонов, описанных в [выражениях Match](match-expressions.md) , можно использовать в списке параметров для функции или элемента.

Обычно методы используют форму кортежа передаваемых аргументов. Это дает более четкий результат с точки зрения других языков .NET, поскольку форма кортежа соответствует способу передачи аргументов в методах .NET.

Каррированных формы чаще всего используются с функциями, созданными с помощью привязок `let`.

В следующем псевдокоде показаны примеры кортежа и каррированных аргумента.

```fsharp
// Tuple form.
member this.SomeMethod(param1, param2) = ...
// Curried form.
let function1 param1 param2 = ...
```

Объединенные формы возможны, когда некоторые аргументы находятся в кортежах, а некоторые — нет.

```fsharp
let function2 param1 (param2a, param2b) param3 = ...
```

Другие шаблоны также можно использовать в списках параметров, но если шаблон параметра не соответствует всем возможным входным данным, то во время выполнения может быть неполным совпадением. Исключение `MatchFailureException` создается, если значение аргумента не соответствует шаблонам, указанным в списке параметров. Компилятор выдает предупреждение, если шаблон параметра допускает неполные соответствия. По крайней мере один другой шаблон обычно полезен для списков параметров, и это шаблон с подстановочными знаками. Шаблон подстановочного знака используется в списке параметров, если нужно просто игнорировать любые аргументы. Следующий код иллюстрирует использование шаблона с подстановочными знаками в списке аргументов.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3801.fs)]

Шаблон подстановочного знака может быть полезен, если не нужны передаваемые аргументы, например, в главной точке входа в программу, если вы не заинтересованы в аргументах командной строки, которые обычно предоставляются в виде массива строк, как показано в следующем коде.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3802.fs)]

Другие шаблоны, которые иногда используются в аргументах, — это шаблон `as`, а также шаблоны идентификаторов, связанные с размеченные объединениями и активными шаблонами. Шаблон размеченного объединения с одним вариантом можно использовать следующим образом.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3803.fs)]

Выходные данные выглядят следующим образом.

```console
Data begins at 0 and ends at 4 in string Et tu, Brute?
Et tu
```

Активные шаблоны могут быть полезны в качестве параметров, например при преобразовании аргумента в нужный формат, как показано в следующем примере:

```fsharp
type Point = { x : float; y : float }

let (| Polar |) { x = x; y = y} =
    ( sqrt (x*x + y*y), System.Math.Atan (y/ x) )

let radius (Polar(r, _)) = r
let angle (Polar(_, theta)) = theta
```

Можно использовать шаблон `as` для сохранения совпадающего значения в качестве локального значения, как показано в следующей строке кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3805.fs)]

Другой шаблон, который используется иногда, — это функция, которая оставляет последний аргумент без имени, предоставляя в качестве тела функции лямбда-выражение, которое сразу же выполняет сопоставление шаблона с неявным аргументом. Ниже приведен пример кода.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3804.fs)]

Этот код определяет функцию, которая принимает универсальный список и возвращает `true`, если список пуст, и `false` в противном случае. Использование таких методов может сделать код более трудным для чтения.

Иногда шаблоны, использующие Неполные совпадения, полезны, например, если известно, что списки в программе содержат только три элемента, в списке параметров можно использовать такой шаблон, как показано ниже.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3806.fs)]

Использование шаблонов с неполными соответствиями лучше всего зарезервировано для быстрого создания прототипов и других временных применений. Компилятор выдаст предупреждение для такого кода. Такие шаблоны не могут охватывать все возможные входные данные и поэтому не подходят для API-интерфейсов компонентов.

## <a name="named-arguments"></a>Именованные аргументы

Аргументы для методов могут быть заданы по положению в списке аргументов с разделителями-запятыми или могут быть переданы в метод явным образом путем указания имени, за которым следует знак равенства и значение, которое необходимо передать. Если указано имя, оно может находиться в другом порядке, отличном от того, который используется в объявлении.

Именованные аргументы могут сделать код более удобочитаемым и более адаптируемым к определенным типам изменений в API, например изменить порядок параметров метода.

Именованные аргументы допускаются только для методов, а не для функций, связанных с `let`, значений функций или лямбда-выражений.

В следующем примере кода показано использование именованных аргументов.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3807.fs)]

При вызове конструктора класса можно задать значения свойств класса, используя синтаксис, аналогичный именованным аргументам. Этот синтаксис показан в следующем примере.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet3506.fs)]

Дополнительные сведения см. в разделе [конструкторыF#()](https://msdn.microsoft.com/library/2cd0ed07-d214-4125-8317-4f288af99f05).

## <a name="optional-parameters"></a>Необязательные параметры

Для метода можно указать необязательный параметр, используя вопросительный знак перед именем параметра. Необязательные параметры интерпретируется как F# тип параметра, поэтому их можно запросить обычным способом запроса типов параметров с помощью `match` выражения с `Some` и `None`. Необязательные параметры разрешены только для членов, но не для функций, созданных с помощью привязок `let`.

Можно передать существующие необязательные значения в метод по имени параметра, например `?arg=None` или `?arg=Some(3)` или `?arg=arg`. Это может быть полезно при создании метода, который передает необязательные аргументы другому методу.

Можно также использовать функцию `defaultArg`, которая задает значение по умолчанию для необязательного аргумента. Функция `defaultArg` принимает необязательный параметр в качестве первого аргумента и значение по умолчанию в качестве второго.

В следующем примере показано использование необязательных параметров.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3808.fs)]

Выходные данные выглядят следующим образом.

```console
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
Baud Rate: 300 Duplex: Half Parity: true
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 9600 Duplex: Full Parity: false
Baud Rate: 4800 Duplex: Half Parity: false
```

В целях C# и Visual Basic Interop можно использовать атрибуты `[<Optional; DefaultParameterValue<(...)>]` в F#, чтобы вызывающие объекты могли видеть аргумент как необязательный. Это эквивалентно определению аргумента в качестве необязательного в C# , как в `MyMethod(int i = 3)`.

```fsharp
open System
open System.Runtime.InteropServices
type C =
    static member Foo([<Optional; DefaultParameterValue("Hello world")>] message) =
        printfn "%s" message
```

Можно также указать новый объект в качестве значения параметра по умолчанию. Например, элемент `Foo` может иметь необязательный `CancellationToken` в качестве входных данных:

```fsharp
open System.Threading
open System.Runtime.InteropServices
type C =
    static member Foo([<Optional; DefaultParameterValue(CancellationToken())>] ct: CancellationToken) =
        printfn "%A" ct
```

Значение, заданное в качестве аргумента для `DefaultParameterValue`, должно соответствовать типу параметра. Например, следующее не разрешено:

```fsharp
type C =
    static member Wrong([<Optional; DefaultParameterValue("string")>] i:int) = ()
```

В этом случае компилятор выдает предупреждение и будет полностью игнорировать оба атрибута. Обратите внимание, что значение по умолчанию `null` должно быть снабжено заметками типа, так как в противном случае компилятор выводит неверный тип, т. е. `[<Optional; DefaultParameterValue(null:obj)>] o:obj`.

## <a name="passing-by-reference"></a>Передача по ссылке

Передача F# значения по ссылке включает в себя [ByRef](byrefs.md), которые являются типами управляемых указателей. Ниже приведены рекомендации по использованию типа.

- Используйте `inref<'T>`, если требуется только чтение указателя.
- Используйте `outref<'T>`, если требуется только запись в указатель.
- Используйте `byref<'T>`, если требуется как чтение, так и запись в указатель.

```fsharp
let example1 (x: inref<int>) = printfn "It's %d" x

let example2 (x: outref<int>) = x <- x + 1

let example3 (x: byref<int>) =
    printfn "It'd %d" x
    x <- x + 1

let test () =
    // No need to make it mutable, since it's read-only
    let x = 1
    example1 &x

    // Needs to be mutable, since we write to it
    let mutable y = 2
    example2 &y
    example3 &y // Now 'y' is 3
```

Поскольку параметр является указателем и значение является изменяемым, любые изменения значения сохраняются после выполнения функции.

Можно использовать кортеж в качестве возвращаемого значения для хранения любых `out` параметров в методах библиотеки .NET. Кроме того, параметр `out` можно рассматривать как параметр `byref`. В следующем примере кода показаны оба способа.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-1/snippet3810.fs)]

## <a name="parameter-arrays"></a>Массивы параметров

Иногда необходимо определить функцию, которая принимает произвольное число параметров разнородного типа. Было бы нецелесообразным создавать все возможные перегруженные методы для учета всех типов, которые можно использовать. Реализации .NET обеспечивают поддержку таких методов с помощью функции массива параметров. Метод, принимающий в сигнатуру массив параметров, может предоставляться с произвольным числом параметров. Параметры помещаются в массив. Тип элементов массива определяет типы параметров, которые могут быть переданы в функцию. Если вы определили массив параметров с `System.Object` в качестве типа элемента, клиентский код может передавать значения любого типа.

В F#массивы параметров можно определять только в методах. Их нельзя использовать в отдельных функциях или функциях, определенных в модулях.

Массив параметров определяется с помощью атрибута `ParamArray`. Атрибут `ParamArray` можно применить только к последнему параметру.

В следующем коде показано, как вызвать метод .NET, который принимает массив параметров, и определение типа в F# , имеющее метод, принимающий массив параметров.

[!code-fsharp[Main](~/samples/snippets/fsharp/parameters-and-arguments-2/snippet3811.fs)]

При запуске в проекте выходные данные предыдущего кода выглядят следующим образом:

```console
a 1 10 Hello world 1 True
"a"
1
10.0
"Hello world"
1u
true
```

## <a name="see-also"></a>См. также:

- [Члены](./members/index.md)
