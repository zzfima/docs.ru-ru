---
title: Приведение и преобразование (F#)
description: 'Узнайте, как на языке программирования F # предоставляет операторы преобразования для преобразования между различными типами-примитивами.'
ms.date: 05/16/2016
ms.openlocfilehash: aca1a2523130ee485a7e7c9a6a45a410904cb246
ms.sourcegitcommit: 67de6cb5dd66a19f2180ba7e4d7aecc697f8a963
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2018
ms.locfileid: "44338237"
---
# <a name="casting-and-conversions-f"></a>Приведение и преобразование (F#)

В этом разделе описывается поддержка преобразований типов в F #.

## <a name="arithmetic-types"></a>Арифметические типы

F # предоставляет операторы преобразования для преобразования между различными типами-примитивами, например между целое число и типы с плавающей запятой. Операторы преобразования целочисленных типов и char проверили и непроверяемые формы; с плавающей запятой операторы и `enum` оператор преобразования — нет. Unchecked формы определяются в `Microsoft.FSharp.Core.Operators` и проверяемые определяются в `Microsoft.FSharp.Core.Operators.Checked`. Проверяемые наличие переполнения и создает исключение времени выполнения, если полученное значение превышает ограничения типа целевого объекта.

Каждый из этих операторов имеет имя, совпадающее имя конечного типа. Например, в следующем коде, явно указанными типами слово `byte` имеет два значения. Первое — это тип, а второй — оператор преобразования.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4401.fs)]

В следующей таблице показаны операторы преобразования, определенные в F #.

|Оператор|Описание|
|--------|-----------|
|`byte`|Преобразуйте в тип byte, 8-разрядное тип без знака.|
|`sbyte`|Преобразуйте байт со знаком.|
|`int16`|Преобразуйте в 16-разрядное целое число со знаком.|
|`uint16`|Преобразуйте в 16-разрядное целое число без знака.|
|`int32, int`|Преобразуйте в 32-разрядное целое число со знаком.|
|`uint32`|Преобразуйте в 32-разрядное целое число без знака.|
|`int64`|Преобразуйте в 64-разрядное целое число со знаком.|
|`uint64`|Преобразуйте в 64-разрядное целое число без знака.|
|`nativeint`|Преобразуйте в собственном целое число.|
|`unativeint`|Преобразуйте в целое число без знака собственного.|
|`float, double`|Преобразование в стандарт IEEE двойной точности 64-разрядное число с плавающей запятой.|
|`float32, single`|Преобразование в стандарт IEEE одинарной точности 32-разрядное число с плавающей запятой.|
|`decimal`|Преобразовать в `System.Decimal`.|
|`char`|Преобразовать в `System.Char`, символ Юникода.|
|`enum`|Преобразуйте в перечисляемый тип.|
Помимо встроенных примитивных типов, эти операторы можно использовать с типами, реализующими `op_Explicit` или `op_Implicit` методы с подходящими сигнатурами. Например `int` оператор преобразования работает с любым типом, который предоставляет статический метод `op_Explicit` , принимает тип в качестве параметра и возвращает `int`. Как специальные исключение из правила, что методы не могут быть перегружены типом возвращаемого значения, это можно сделать `op_Explicit` и `op_Implicit`.

## <a name="enumerated-types"></a>Перечисляемые типы

`enum` Оператор представляет собой универсальный оператор, принимающий один параметр типа, представляющий тип `enum` для преобразования. При преобразовании в перечисляемый тип, алгоритм определения типа пытается определить тип `enum` , требуется преобразовать. В следующем примере переменная `col1` не указан явно, но его тип выводится из более поздней версии тест на равенство. Таким образом, компилятор может определить, что при преобразовании к `Color` перечисления. Кроме того, можно указывать аннотации типа, как и в `col2` в следующем примере.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4402.fs)]

Можно также явным образом указать целевой тип перечисления как параметр типа, как показано в следующем коде:

```fsharp
let col3 = enum<Color> 3
```

Обратите внимание на то, что перечисление приводит работы только в том случае, если базовый тип перечисления совместима с преобразуемого типа. В следующем коде, преобразование завершается неудачей, для компиляции из-за несоответствия между `int32` и `uint32`.

```fsharp
// Error: types are incompatible
let col4 : Color = enum 2u
```

Дополнительные сведения см. в разделе [перечисления](enumerations.md).

## <a name="casting-object-types"></a>Приведение типов объектов

Преобразование типов в иерархии объектов — это основа для объектно ориентированного программирования. Существует два основных типа преобразований: приведение повышением и понижением приведение. Приведение вверх по иерархии означает приведение из производного объекта ссылки на ссылку на базовый объект. Такое приведение будет гарантированно работать до тех пор, пока базовый класс находится в иерархии наследования производного класса. Приведение с понижением по иерархии из базового объекта ссылки на ссылку производного объекта, завершается успешно только в том случае, если объект фактически является экземпляром типа целевого (производного) или типа, производного от целевого типа.

F # предоставляет операторы для этих типов преобразований. `:>` Оператор приводит вверх по иерархии и `:?>` оператор приводит вниз по иерархии.

### <a name="upcasting"></a>Приведение

Во многих языках объектно ориентированного приведение является неявным; в F # правила несколько отличаются. Приведение применяется автоматически при передаче аргументов к методам на основе типа объекта. Тем не менее для функций привязки let в модуле, приведение не выполняется автоматически, если тип параметра не объявлена как гибкий тип. Дополнительные сведения см. в разделе [гибкие типы](flexible-Types.md).

`:>` Оператор выполняет статическое приведение, что означает, что успешность приведения определяется во время компиляции. Если приведение с помощью `:>` компилируется успешно, он является допустимым приведения к типу и не существует возможности сбоя во время выполнения.

Можно также использовать `upcast` оператор для выполнения такого преобразования. Следующее выражение задает преобразование вверх по иерархии:

```fsharp
upcast expression
```

При использовании оператор приведения с повышением, компилятор пытается определить тип, который преобразуется из контекста. Если компилятору не удалось определить тип объекта, компилятор сообщает об ошибке.

### <a name="downcasting"></a>Приведение

`:?>` Оператор выполняет динамическое приведение, что означает, что успешность приведения определяется во время выполнения. Приведение с помощью `:?>` оператор не проверяется во время компиляции; но во время выполнения попытки для приведения к указанному типу. Если объект совместим с целевым типом, приведение выполнено успешно. Если объект не совместим с типом целевого объекта, то среда выполнения вызывает `InvalidCastException`.

Можно также использовать `downcast` оператор для выполнения преобразования динамического типа. Следующее выражение задает преобразование к типу, который выводится из контекста программы вниз по иерархии:

```fsharp
downcast expression
```

Как и для `upcast` оператора, если компилятор не может определить целевой тип из контекста, он сообщает об ошибке.

Следующий код иллюстрирует использование `:>` и `:?>` операторы. В коде показано, что `:?>` оператор используется наилучшим образом в том случае, если вы знаете успешное преобразование, так как он создает `InvalidCastException` при сбое преобразования. Если вы не знаете, что преобразование будет успешным, тип теста, который использует `match` выражение лучше, так как позволяет избежать затрат на генерации исключения.

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet4403.fs)]

Поскольку универсальные операторы `downcast` и `upcast` полагаться на определение типа для определения аргументов и возвращаемых типов, в приведенном выше коде, можно заменить

```fsharp
let base1 = d1 :> Base1
```

на

```fsharp
let base1 = upcast d1
```

В предыдущем коде, тип аргумента и возвращаемые типы являются `Derived1` и `Base1`, соответственно.

Дополнительные сведения о тестировании типов см. в разделе [выражения сопоставления](match-Expressions.md).

## <a name="see-also"></a>См. также

- [Справочник по языку F#](index.md)
