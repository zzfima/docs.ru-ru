---
title: Рекомендации по проектированию компонентов F#
description: Дополнительные рекомендации по написанию компонентов F#, предназначенный для использования другими вызывающими объектами.
ms.date: 05/14/2018
ms.openlocfilehash: 446cba0f810af9517b655ef5741ddf7a919676d5
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/02/2018
ms.locfileid: "43488291"
---
# <a name="f-component-design-guidelines"></a>Рекомендации по проектированию компонентов F#

Этот документ представляет собой набор рекомендации по проектированию компонентов F# программирования, исходя из F# рекомендации по проектированию компонентов, v14, Microsoft Research и [другая версия](https://fsharp.org/specs/component-design-guidelines/) изначально проверенный и обслуживается F# Software Foundation.

В этом документе предполагается, что вы знакомы с программирование на F#. Выражаем благодарность сообщества F# за их вклад и полезные отзывы на различные версии данного руководства.

## <a name="overview"></a>Обзор

В этом документе рассматриваются некоторые вопросы, относящиеся к разработке для компонента F# и написанию кода. Компонент может означать одно из следующих:

* Слой в проекте F#, которая имеет внешних потребителей в рамках проекта.
* Библиотека, предназначенными для использования в коде F# за пределами сборки.
* Библиотека, предназначенный для использования с любым языком программирования .NET за пределами сборки.
* Библиотеки, предназначенные для распространения с помощью репозитория пакетов, таких как [NuGet](https://nuget.org).

Методы, описанные в этой статье выполните [пять принципов хорошей кода F#](index.md#five-principles-of-good-f-code)и таким образом использовать функций и объектов, программирование соответствующим образом.

Независимо от того, методику конструктор компонента и библиотека сталкивается ряд практических и прозаическом проблем при попытке создать API, который проще всего использовать разработчиками. Conscientious применения [рекомендации по разработке библиотек .NET](../../standard/design-guidelines/index.md) будет управлять процессом к созданию согласованный набор API, которые являются приятной для использования.

## <a name="general-guidelines"></a>Общие рекомендации

Существует несколько универсальных рекомендаций, которые применяются к библиотек F#, независимо от того, целевая аудитория для библиотеки.

### <a name="learn-the-net-library-design-guidelines"></a>Дополнительные рекомендации по разработке библиотек .NET

Независимо от типа F# кодирования, вы выполняете, важно иметь опыт работы с [рекомендации по разработке библиотек .NET](../../standard/design-guidelines/index.md). Большинство других F# программистов .NET будет ознакомьтесь с рекомендациями и ожидать, что код .NET в соответствии с их.

Рекомендации по разработке библиотек .NET предоставляют общие рекомендации по именованию, конструирование классов и интерфейсов, член конструктора (свойства, методы, события, и т.д.) и сведения и полезные первый точку ссылки для разнообразных руководство по проектированию.

### <a name="add-xml-documentation-comments-to-your-code"></a>Добавьте в код комментарии XML-документации

XML-документации в открытых API убедитесь, что пользователи могут получить великолепное Intellisense и кратких сведений, с помощью этих типов и членов и включить создание документации файлов для библиотеки. См. в разделе [XML-документации](../language-reference/xml-documentation.md) о различных XML-теги, которые могут использоваться для дополнительной разметки внутри комментариев xmldoc.

```fsharp
/// A class for representing (x,y) coordinates
type Point =

    /// Computes the distance between this point and another
    member DistanceTo : otherPoint:Point -> float
```

С помощью комментариев XML краткая форма (`/// comment`), или стандартные XML-комментариев (`///<summary>comment</summary>`).

### <a name="consider-using-explicit-signature-files-fsi-for-stable-library-and-component-apis"></a>Рассмотрите возможность использования файлов явные сигнатур (расширение FSI) для стабильной библиотеки и API-интерфейсы компонента

С помощью явных подписей файлов в библиотеку F# предоставляет краткий сводку открытый API, они также располагаются позволяет гарантировать, что вы знаете полного открытого области библиотеки, а также предоставляет четкого разделения между общедоступной документации по и внутренние сведения о реализации. Обратите внимание на то, что файлы сигнатур добавить трения изменение открытого API-интерфейса, при необходимости вносить изменения в файлах и реализации и подпись. Таким образом файлы подписей должны обычно только быть предоставлены при API становятся упрочило и больше не может быть значительно изменить.

### <a name="always-follow-best-practices-for-using-strings-in-net"></a>Всегда следуйте рекомендациям по использованию строк в .NET

Выполните [советы и рекомендации по использованию строк в .NET](../../standard/base-types/best-practices-strings.md) рекомендации. В частности, всегда явно указывать *региональные намерение* в преобразование и сравнение строк (если применимо).

## <a name="guidelines-for-f-facing-libraries"></a>Рекомендации по F#-с выходом библиотеки

В этом разделе представлены рекомендации по разработке общедоступных F#-с выходом библиотеки; то есть библиотеки, предоставляя открытый API-интерфейсы, которые должны использоваться разработчиков F#. Существует множество рекомендаций по разработке библиотеки применимо специально для F#. В случае отсутствия определенные рекомендации, выполните рекомендации по разработке библиотек .NET являются резервной рекомендации.

### <a name="naming-conventions"></a>Соглашения об именах

#### <a name="use-net-naming-and-capitalization-conventions"></a>Используйте соглашения об именовании и регистр букв .NET

Соглашения об именовании и регистр букв .NET учтена в следующей таблице. Существует небольшой дополнения для включения конструкций F#.

| Конструкция | Case | Отделение | Примеры | Примечания |
|-----------|------|------|----------|-------|
| Конкретные типы | PascalCase | Существительное / прилагательными | Список, Double, сложный | Конкретные типы структур, классов, перечислений, делегаты, записей и объединений. То, что имена типов традиционно нижний регистр в OCaml, F# введена новая схема именования .NET для типов.
| библиотеки DLL           | PascalCase |                 | Fabrikam.Core.dll |  |
| Объединения тегов     | PascalCase | Существительное | Некоторые из них, добавить, успех | Не используйте префикс общедоступных интерфейсов API. При необходимости использовать префикс при внутренней, такие как ' "введите команды = TAlpha | TBeta | TDelta.'' " |
| событие          | PascalCase | Команда | ValueChanged / ValueChanging |  |
| Исключения     | PascalCase |      | WebException | Имя должно заканчиваться на «Exception». |
| Поле          | PascalCase | Существительное | CurrentName  | |
| Типы интерфейса |  PascalCase | Существительное / прилагательными | IDisposable | Имя должно начинаться с «I». |
| Метод |  PascalCase |  Команда | ToString | |
| Пространство имен | PascalCase | | Microsoft.FSharp.Core | Обычно используется `<Organization>.<Technology>[.<Subnamespace>]`, но удалить организации, если эта технология не зависит от организации. |
| Параметры | camelCase | Существительное |  Имя типа, преобразование, диапазон | |
| Разрешить значения (внутренний) | camelCase или PascalCase | Существительное-глагол |  getValue myTable |
| Разрешить значения (внешний) | camelCase или PascalCase | Существительное глагол  | List.map Dates.Today | привязки let значения часто являются открытыми, при использовании традиционных функциональные шаблоны разработки. Тем не менее обычно используется PascalCase, когда идентификатор может использоваться в других языках .NET. |
| Свойство.  | PascalCase  | Существительное / прилагательными  | IsEndOfFile, BackColor  | Логические свойства обычно использование является и могут и должны быть выразил, как и в IsEndOfFile, не IsNotEndOfFile.

#### <a name="avoid-abbreviations"></a>Избегать сокращений

Рекомендации по .NET не рекомендует использовать сокращения (например, «использовать `OnButtonClick` вместо `OnBtnClick`«). Сокращений, таких как `Async` для «Асинхронной», которая допустима. Иногда это правило игнорируется для функционального программирования; например `List.iter` использует сокращение для «итерация». По этой причине, использующие сокращения стремится скорректировать в большей степени в F#-к-программирование на F#, но по-прежнему обычно следует избегать в открытого компонента конструктора.

#### <a name="avoid-casing-name-collisions"></a>Избежать конфликтов имен регистр

Рекомендации по .NET сказать, что регистр отдельно не может использоваться для однозначного определения конфликтов имен, так как некоторые языки клиента (например, Visual Basic), без учета регистра.

#### <a name="use-acronyms-where-appropriate"></a>Используйте акронимов, если это уместно

Акронимы, таких как XML, не являются сокращения и широко используются в библиотеках .NET в параметр формы (Xml). Только хорошо известного, широко признанный акронимов.

#### <a name="use-pascalcase-for-generic-parameter-names"></a>Использующие PascalCase для имен универсальных параметров

Использующие PascalCase для универсального параметра имен общедоступных интерфейсов API, в том числе для языка F#-с выходом библиотеки. В частности, используйте имена, такие как `T`, `U`, `T1`, `T2` для произвольных универсальных параметров, а также при определенными именами имеет смысл, затем F#-имена, как использовать библиотеки с выходом `Key`, `Value`, `Arg`(но не к примеру, `TKey`).

#### <a name="use-either-pascalcase-or-camelcase-for-public-functions-and-values-in-f-modules"></a>Использовать для открытых функций и значений в F# модули PascalCase или camelCase

camelCase используется для открытых функций, которые предназначены для использования неполное (например, `invalidArg`) и для «функции стандартной коллекции» (например, List.map). В обоих случаях имена функций действуют во многом аналогично ключевых слов на языке.

### <a name="object-type-and-module-design"></a>Объект, тип и модуль разработки

#### <a name="use-namespaces-or-modules-to-contain-your-types-and-modules"></a>Используйте пространства имен или модули для размещения типов и модули

Каждый файл F# в компоненте должно начинаться с объявлением пространства имен или объявлению модуля.

```fsharp
namespace Fabrikam.BasicOperationsAndTypes

type ObjectType1() =
    ...

type ObjectType2() =
     ...

module CommonOperations =
    ...
```

или

```fsharp
module Fabrikam.BasicOperationsAndTypes

type ObjectType1() =
    ...

type ObjectType2() =
    ...

module CommonOperations =
    ...
```

Далее приведены различия между использованием модулей и пространств имен для организации кода верхнего уровня.

* Пространства имен могут охватывать несколько файлов
* Пространства имен не может содержать функции F#, если они находятся в внутренним
* Код для любого заданного модуля должны содержаться в одном файле
* Модули верхнего уровня может содержать функции F# без необходимости внутренним

Выбор между пространством имен верхнего уровня или модуль влияет на форме скомпилированного кода и таким образом повлияет на представлении из других языков .NET следует API со временем использовать за пределами кода F#.

#### <a name="use-methods-and-properties-for-operations-intrinsic-to-object-types"></a>Использовать методы и свойства для операций, характерными для типов объектов

При работе с объектами, нужно убедиться, что готовых к использованию функциональность реализуется как методы и свойства этого типа.

```fsharp
type HardwareDevice() =

    member this.ID = ...

    member this.SupportedProtocols = ...

type HashTable<'Key,'Value>(comparer: IEqualityComparer<'Key>) =

    member this.Add(key, value) = ...

    member this.ContainsKey(key) = ...

    member this.ContainsValue(value) = ...
```

Не, основная часть функций для данного элемента должны обязательно будут реализованы в этот элемент, но должно быть готовых к использованию части эту функциональность.

#### <a name="use-classes-to-encapsulate-mutable-state"></a>Использование классов, инкапсулирующих изменяемое состояние

В языке F# это достаточно сделать где что состояние не уже инкапсулируется другой языковой конструкции, такие как замыкание, выражения последовательности или асинхронное вычисление.

```fsharp
type Counter() =
    // let-bound values are private in classes.
    let mutable count = 0

    member this.Next() =
        count <- count + 1
        count
```

#### <a name="use-interfaces-to-group-related-operations"></a>Используйте интерфейсы для группирования операций, связанных с

Используйте типы интерфейсов для представления набора операций. Это предпочтительнее другие параметры, например кортежей, функций или записей функций.

```fsharp
type Serializer =
    abstract Serialize<'T> : preserveRefEq: bool -> value: 'T -> string
    abstract Deserialize<'T> : preserveRefEq: bool -> pickle: string -> 'T
```

В ссылке к:

```fsharp
type Serializer<'T> = {
    Serialize : bool -> 'T -> string
    Deserialize : bool -> string -> 'T
}
```

Интерфейсы являются понятиями первостепенными в .NET, который можно использовать для достижения, что Функторы обычно отображаются. Кроме того они могут использоваться для кодирования типов уже существует в вашу программу, которой нет записей функций.

#### <a name="use-a-module-to-group-functions-which-act-on-collections"></a>Использование модуля группы функций, которые действуют в коллекциях

При определении типа коллекции, подберите стандартный набор операций, например `CollectionType.map` и `CollectionType.iter`) для новых типов коллекций.

```fsharp
module CollectionType =
    let map f c =
        ...
    let iter f c =
        ...
```

При включении таких модулей, следуйте стандартным соглашениям об именовании для функций, содержащихся в FSharp.Core.

#### <a name="use-a-module-to-group-functions-for-common-canonical-functions-especially-in-math-and-dsl-libraries"></a>Использование модуля группы функций для общих канонических функций, особенно в math и библиотеки DSL

Например `Microsoft.FSharp.Core.Operators` — автоматического открытия коллекция функции верхнего уровня (например `abs` и `sin`), предоставляемые FSharp.Core.dll.

Аналогичным образом, библиотека статистики может включать модуль с функциями `erf` и `erfc`, где этот модуль предназначен должны быть открыты автоматически.

#### <a name="consider-using-requirequalifiedaccess-and-carefully-apply-autoopen-attributes"></a>Рассмотрите возможность использования RequireQualifiedAccess и тщательно применять атрибуты AutoOpen

Добавление `[<RequireQualifiedAccess>]` атрибут к модулю указывает, что модуль не может быть открыт, и необходимость явной ссылки на элементы модуля полного доступа. Например `Microsoft.FSharp.Collections.List` модуля с этим атрибутом.

Это полезно в том случае, если функции и значения в модуле имеют имена, которые могут конфликтовать с именами в других модулях. Требуется метод доступа может значительно увеличивать долгосрочной поддержки и развиваемости библиотеки.

Добавление `[<AutoOpen>]` атрибут к модулю означает, что модуль будет открываться при открытии содержащего пространства имен. `[<AutoOpen>]` Атрибут также может быть применен к сборке, чтобы указать модуль, который автоматически открывается при ссылке на сборку.

Например, библиотеку статистики **MathsHeaven.Statistics** может содержать `module MathsHeaven.Statistics.Operators` функции `erf` и `erfc`. Следует отметить этот модуль как `[<AutoOpen>]`. Это означает, что `open MathsHeaven.Statistics` будет также открыть этот модуль и вывести имена `erf` и `erfc` в область действия. Использование другой good `[<AutoOpen>]` для модулей, содержащих методы расширения.

Излишнее применение параметров `[<AutoOpen>]` приводит к его засорения пространств имен, а атрибуту следует использовать с осторожностью. Для определенных библиотек в определенных доменах, разумно использовать `[<AutoOpen>]` может привести к более удобной.

#### <a name="consider-defining-operator-members-on-classes-where-using-well-known-operators-is-appropriate"></a>Рекомендуется определять оператор членов в классах, в которых подходит использование хорошо известного операторов

Иногда классы используются для моделирования математической конструкции, такие как векторы. Если домен моделируемой содержит хорошо известных операторов, определяя их в качестве членов, встроенные в класс полезен.

```fsharp
type Vector(x:float) =

    member v.X = x

    static member (*) (vector:Vector, scalar:float) = Vector(vector.X * scalar)

    static member (+) (vector1:Vector, vector2:Vector) = Vector(vector1.X + vector2.X)

let v = Vector(5.0)

let u = v * 10.0
```

В этом руководстве соответствует общих рекомендаций .NET для этих типов. Однако бывает, кроме того, важно в F# кодирования, так как он разрешает этих типов для использования в вместе с F#-функции и методы с ограничениями элементов, таких как List.sumBy.

#### <a name="consider-using-compiledname-to-provide-a-net-friendly-name-for-other-net-language-consumers"></a>Рассмотрите возможность использования CompiledName для предоставления. NET-понятное имя для других потребителей язык .NET

Иногда вы можете назвать в один стиль для потребителей F# (таких как статический член в нижнем регистре, чтобы он располагался как будто связанного с модулем функции), но имеют другой стиль для имени, при компиляции в сборку. Можно использовать `[<CompiledName>]` атрибут для предоставления другой стиль для использования сборки кода не F#.

```fsharp
type Vector(x:float, y:float) =

    member v.X = x
    member v.Y = y

    [<CompiledName("Create")>]
    static member create x y = Vector (x, y)

let v = Vector.create 5.0 3.0
```

С помощью `[<CompiledName>]`, вы можете использовать соглашения об именовании .NET для пользователей не F# сборки.

#### <a name="use-method-overloading-for-member-functions-if-doing-so-provides-a-simpler-api"></a>Используйте перегрузки метода для функций-членов, если такой подход обеспечивает простой API

Перегрузка метода является мощным средством для упрощения API, который может потребоваться выполнить аналогичные функциональные возможности, но разные параметры и аргументы.

```fsharp
type Logger() =

    member this.Log(message) =
        ...
    member this.Log(message, retryPolicy) =
        ...
```

В F# чаще для перегрузки на число аргументов, а не типы аргументов.

#### <a name="hide-the-representations-of-record-and-union-types-if-the-design-of-these-types-is-likely-to-evolve"></a>Скрыть представления типы объединений и записи, если разработка этих типов — вероятно эволюционирование

Избегайте раскрытия конкретные представления объектов. Например, конкретные представление <xref:System.DateTime> значения не раскрываются внешних, открытый в API для разработки библиотеки .NET. Во время выполнения среда CLR знает зафиксированных реализации, который будет использоваться на протяжении выполнения. Тем не менее скомпилированный код не сам получают зависимостей от конкретного представления.

#### <a name="avoid-the-use-of-implementation-inheritance-for-extensibility"></a>Избегайте использования реализации наследования для расширяемости

В F# наследование реализации используется редко. Кроме того часто иерархий наследования являются сложными и трудно изменить, когда поступают новые требования. Реализация наследования по-прежнему существует в F# для совместимости и редких случаях, когда он является лучшим решением проблемы альтернативных методик, необходимо обратиться в программах F#, при разработке для полиморфизма, таких как реализация интерфейса.

### <a name="function-and-member-signatures"></a>Функция и элемент подписи

#### <a name="use-tuples-for-return-values-when-returning-a-small-number-of-multiple-unrelated-values"></a>Использование кортежей для возвращаемых значений, при возврате небольшое количество несколько несвязанных значений

Вот хороший пример использования в возвращаемом типе кортежа:

```fsharp
val divrem : BigInteger -> BigInteger -> BigInteger * BigInteger
```

Для возврата типов, содержащих множество компонентов или там, где компоненты связаны с одной идентифицировать сущности, рассмотрите возможность использования именованного типа вместо кортежа.

#### <a name="use-asynct-for-async-programming-at-f-api-boundaries"></a>Используйте `Async<T>` для асинхронного программирования на границах API F#

Если имеется соответствующий синхронную операцию с именем `Operation` , возвращающий `T`, то асинхронная операция должна называться `AsyncOperation` при его использовании возвращается `Async<T>` или `OperationAsync` при его использовании возвращается `Task<T>`. Для часто используемых типов .NET, которые предоставляют методов Begin и End, рассмотрите возможность использования `Async.FromBeginEnd` для записи методы расширения в качестве оболочки для предоставления F# асинхронную модель программирования этих интерфейсов API .NET.

```fsharp
type SomeType =
    member this.Compute(x:int) : int =
        ...
    member this.AsyncCompute(x:int) : Async<int> =
        ...

type System.ServiceModel.Channels.IInputChannel with
    member this.AsyncReceive() =
        ...
```

### <a name="exceptions"></a>Исключения

См. в разделе [управление обработкой ошибок](conventions.md#error-management) Дополнительные сведения о соответствующее использование исключений, результаты и параметры.

### <a name="extension-members"></a>Члены расширений

#### <a name="carefully-apply-f-extension-members-in-f-to-f-components"></a>Тщательно применить F# члены расширений для в F#-к-компонентов F#

Члены расширений F#, обычно только используется в для операций, которые находятся в закрытии внутренних операций, связанных с типом в большинстве режимов, его использования. Один обычно используется для предоставления API, которые являются более устойчивым к F# для различных типов .NET:

```fsharp
type System.ServiceModel.Channels.IInputChannel with
    member this.AsyncReceive() =
        Async.FromBeginEnd(this.BeginReceive, this.EndReceive)

type System.Collections.Generic.IDictionary<'Key,'Value> with
    member this.TryGet key =
        let ok, v = this.TryGetValue key
        if ok then Some v else None
```

### <a name="union-types"></a>Типы объединений

#### <a name="use-discriminated-unions-instead-of-class-hierarchies-for-tree-structured-data"></a>Использование размеченных объединений вместо иерархий классов для древовидной данных

Древовидной структуры являются рекурсивного определения. Это неудобно с наследованием, но элегантного с размеченные объединения.

```fsharp
type BST<'T> =
    | Empty
    | Node of 'T * BST<'T> * BST<'T>
```

Представления данных дерева с размеченные объединения также позволяет использовать преимущества exhaustiveness при сопоставлении шаблонов.

#### <a name="use-requirequalifiedaccess-on-union-types-whose-case-names-are-not-sufficiently-unique"></a>Используйте `[<RequireQualifiedAccess>]` на типы объединения вариантов, имена которых не являются достаточно уникальными

Вы обнаружите себя в домене, где имя рекомендации для выполнения различных задач, таких как случаи размеченного объединения тем же именем. Можно использовать `[<RequireQualifiedAccess>]` для однозначного определения вариантов имена во избежание активации заблуждение ошибок из-за затенение зависит от порядка `open` инструкций

#### <a name="hide-the-representations-of-discriminated-unions-for-binary-compatible-apis-if-the-design-of-these-types-is-likely-to-evolve"></a>Скрыть представления размеченные объединения для двоичных совместимых API, если разработка этих типов — вероятно эволюционирование

Типы объединений, зависят от F# поиска совпадения с шаблоном формы для краткости модель программирования. Как упоминалось ранее, следует избегать раскрытия представления конкретных данных, если разработка этих типов — вероятно эволюционирование.

Например, представление размеченное объединение можно скрыть с помощью объявление закрытого или внутреннего или с помощью подписи файла.

```fsharp
type Union =
    private
    | CaseA of int
    | CaseB of string
```

Если вы раскрываете информацию размеченные объединения беспорядочно, может оказаться трудно версии библиотеки без нарушения кода пользователя. Вместо этого рассмотрите возможность раскрытия один или несколько активных шаблонов, позволяющая сопоставления над значениями типа шаблона.

Активные шаблоны предоставляют альтернативный способ предоставить потребителям F# сопоставления избегая предоставление типов объединения F# напрямую шаблона.

### <a name="inline-functions-and-member-constraints"></a>Встроенные функции и ограничения члена

#### <a name="define-generic-numeric-algorithms-using-inline-functions-with-implied-member-constraints-and-statically-resolved-generic-types"></a>Определите универсальный числовые алгоритмы, с помощью встроенных функций с ограничениями подразумеваемых членов и статически разрешаемым универсальные типы

Арифметические член ограничения и ограничения сравнения F# являются стандартом для программирование на F#. Рассмотрим следующий пример кода:

```fsharp
let inline highestCommonFactor a b =
    let rec loop a b =
        if a = LanguagePrimitives.GenericZero<_> then b
        elif a < b then loop a (b - a)
        else loop (a - b) b
    loop a b
```

Тип этой функции выглядит следующим образом:

```fsharp
val inline highestCommonFactor : ^T -> ^T -> ^T
                when ^T : (static member Zero : ^T)
                and ^T : (static member ( - ) : ^T * ^T -> ^T)
                and ^T : equality
                and ^T : comparison
```

Это подходящая функция для общего API в математической библиотеки.

#### <a name="avoid-using-member-constraints-to-simulate-type-classes-and-duck-typing"></a>Старайтесь не использовать член ограничения для имитации классов типа и типизации по признакам

Можно имитировать «типизации по признакам» с помощью ограничений члена F#. Однако члены, которые делают с помощью этого следует использовать не в общие в F#-к-проекты библиотеки F#. Это обусловлено тем, как правило, вызвать пользовательский код стать неудобными и привязаны к одной конкретной платформой шаблон библиотеки макетов на основе незнакомых или нестандартные неявное ограничений.

Кроме того есть шанс, что активно использовать ограничения член таким образом может привести компиляции очень много времени.

### <a name="operator-definitions"></a>Оператор определения

#### <a name="avoid-defining-custom-symbolic-operators"></a>Не рекомендуется определять пользовательские операторы, символьные

Пользовательские операторы необходимы в некоторых случаях и очень удобен в обозначениям устройства в больших частях кода реализации. Для новых пользователей библиотеки именованных функций зачастую проще в использовании. Кроме того пользовательские символьные операторы могут возникнуть трудности с документов и пользователям будет сложно более поиск справки по операторам, из-за ограничений существующих обработчиков интегрированной среды разработки и поиска.

Таким образом рекомендуется для публикации в виде именованных функций и члены и Кроме того, только в том случае, если значимых преимуществ перевешивают документация и cognitive затраты на их, предоставлять операторы для использования этой функции.

### <a name="units-of-measure"></a>Единицы измерения

#### <a name="carefully-use-units-of-measure-for-added-type-safety-in-f-code"></a>Тщательно единицы измерения используются в целях безопасности добавлен тип в коде F#

Дополнительные сведения о типизации для единицы измерения удаляется при его просмотре на других языках .NET. Имейте в виду, что компоненты .NET и средства отражения будут видеть типы sans единиц. Например, C# пользователи увидят `float` вместо `float<kg>`.

### <a name="type-abbreviations"></a>Сокращенные обозначения типов

#### <a name="carefully-use-type-abbreviations-to-simplify-f-code"></a>Внимательно используйте сокращенные формы типов для упрощения кода на F#

Компоненты .NET и средства отражения не увидит сокращенные имена для типов. Значительное использование сокращенные формы типов также можно сделать домена отображаются более сложным, чем он фактически является, которой удалось вводят в заблуждение потребителей.

#### <a name="avoid-type-abbreviations-for-public-types-whose-members-and-properties-should-be-intrinsically-different-to-those-available-on-the-type-being-abbreviated"></a>Избегайте сокращенные формы типов для открытых типов, членов и свойств должны отличаться по своей природе для тех, которые доступны для типа сокращается

В этом случае тип сокращается показывает, что слишком многое о представлении фактический тип определяемого. Вместо этого рассмотрите возможность упаковки аббревиатура в тип класса или одиночным размеченного объединения (или, если важна производительность, рассмотрите возможность использования типа структуры программы-оболочки для сокращения).

Например это подмывает вас определить карту несколькими как особый случай F# карты, например:

```fsharp
type MultiMap<'Key,'Value> = Map<'Key,'Value list>
```

Тем не менее операции логического нотацию для этого типа не так же, как операции на карте — например, разумно, оператор поиска были сопоставлены. [key] Возврат пустой список, если ключа нет в словаре, а не вызывает исключение.

## <a name="guidelines-for-libraries-for-use-from-other-net-languages"></a>Рекомендации для библиотек для использования из других языков .NET

При разработке библиотек для использования в других языках .NET, очень важно придерживаться [рекомендации по разработке библиотек .NET](../../standard/design-guidelines/index.md). В этом документе, эти библиотеки помечены как стандартный библиотеки .NET, в отличие от F#-с выходом библиотеки, использующие F# создает без ограничений. Проектирование vanilla библиотек .NET означает, предоставляя знакомые и устойчивым API согласования с остальной частью платформы .NET Framework, сводя к минимуму использование F#-конкретных конструкций в открытом API. В следующих разделах описаны правила.

### <a name="namespace-and-type-design-for-libraries-for-use-from-other-net-languages"></a>Пространство имен и тип конструктора (для библиотек для использования из других языков .NET)

#### <a name="apply-the-net-naming-conventions-to-the-public-api-of-your-components"></a>Применить соглашения об именовании .NET для открытого API-интерфейса компонентов

Обратите внимание на использование сокращенные имена и регистр букв рекомендациям .NET.

```fsharp
type pCoord = ...
    member this.theta = ...

type PolarCoordinate = ...
    member this.Theta = ...
```

#### <a name="use-namespaces-types-and-members-as-the-primary-organizational-structure-for-your-components"></a>Используйте пространства имен, типы и члены как основной организационной структурой для компонентов

Все файлы, содержащие открытые методы должны начинаться с `namespace` объявления и только общедоступные сущности в пространствах имен, которые должны быть типы. Не используйте модули F#.

Используйте модули не являющиеся открытыми для размещения код реализации, служебные типы и служебных функций.

Статические типы лучше использовать модули, так как позволяют использовать перегрузки и другие принципы проектирования .NET API, которые не могут использоваться в модулях, F# для будущего развития API.

Например, вместо следующих открытого API-интерфейса:

```fsharp
module Fabrikam

module Utilities =
    let Name = "Bob"
    let Add2 x y = x + y
    let Add3 x y z = x + y + z
```

Попробуйте вместо этого:

```fsharp
namespace Fabrikam

[<AbstractClass; Sealed>]
type Utilities =
    static member Name = "Bob"
    static member Add(x,y) = x + y
    static member Add(x,y,z) = x + y + z
```

#### <a name="use-f-record-types-in-vanilla-net-apis-if-the-design-of-the-types-wont-evolve"></a>Используйте типов записи на F# в ваниль API-интерфейсы .NET, если не будет развиваться разработки типов

Типы записей F# компилируются в простой класс .NET. Они подходят для некоторых типов простых и стабильных в API-интерфейсы. Следует рассмотреть возможность использования `[<NoEquality>]` и `[<NoComparison>]` атрибуты, чтобы отключить автоматическое создание интерфейсов. Также Избегайте поля изменяемых записей в обычный API-интерфейсы .NET как эти предоставляет открытое поле. Всегда учитывайте, будет ли класс предоставляет более гибкий вариант для будущего развития API-интерфейса.

Например следующий код на F# предоставляет открытый API для потребителя C#:

F#:

```fsharp
[<NoEquality; NoComparison>]
type MyRecord =
    { FirstThing : int
        SecondThing : string }
```

C#:

```csharp
public sealed class MyRecord
{
    public MyRecord(int firstThing, string secondThing);
    public int FirstThing { get; }
    public string SecondThing { get; }
}
```

#### <a name="hide-the-representation-of-f-union-types-in-vanilla-net-apis"></a>Скрыть представление типов F# объединения в обычный API-интерфейсы .NET

Типы объединений F# не распространены через границы компонентов, даже для F#-к-F# кодирования. Это устройство отличную реализации при для внутреннего использования в компоненты и библиотеки.

При разработке обычный .NET API, можно скрыть представление типа объединения, используя объявление закрытого или файл сигнатур.

```fsharp
type PropLogic =
    private
    | And of PropLogic * PropLogic
    | Not of PropLogic
    | True
```

Кроме того, может быть расширено типов, которые внутренне используют представление union с членами для обеспечения требуемой. NET API-интерфейсы.

```fsharp
type PropLogic =
    private
    | And of PropLogic * PropLogic
    | Not of PropLogic
    | True

    /// A public member for use from C#
    member x.Evaluate =
        match x with
        | And(a,b) -> a.Evaluate && b.Evaluate
        | Not a -> not a.Evaluate
        | True -> true

    /// A public member for use from C#
    static member CreateAnd(a,b) = And(a,b)
```

#### <a name="design-gui-and-other-components-using-the-design-patterns-of-the-framework"></a>Проектирование графического пользовательского интерфейса и другими компонентами с помощью шаблонов разработки платформы

Существует множество различных платформ в .NET, например WinForms, WPF и ASP.NET. Соглашения об именовании и проектирования для каждого можно использовать при разработке компонентов, используемых в этих платформ. Например для программирования WPF, внедряйте WPF шаблоны разработки для классов, которые вы разрабатываете. Для моделей в программировании пользовательского интерфейса, используйте шаблоны проектирования, таких как события и коллекций на основе уведомлений, например из статьи <xref:System.Collections.ObjectModel>.

### <a name="object-and-member-design-for-libraries-for-use-from-other-net-languages"></a>Объекты и элементы проектирования (для библиотек для использования из других языков .NET)

#### <a name="use-the-clievent-attribute-to-expose-net-events"></a>Используется для предоставления событий .NET CLIEvent-атрибут

Создать `DelegateEvent` с определенной .NET делегат типа, который принимает объект и `EventArgs` (вместо `Event`, которой пользуется только `FSharpHandler` тип по умолчанию) таким образом, чтобы события, публикуются в знакомый способ других языков .NET.

```fsharp
type MyBadType() =
    let myEv = new Event<int>()

    [<CLIEvent>]
    member this.MyEvent = myEv.Publish

type MyEventArgs(x:int) =
    inherit System.EventArgs()
    member this.X = x

    /// A type in a component designed for use from other .NET languages
type MyGoodType() =
    let myEv = new DelegateEvent<EventHandler<MyEventArgs>>()

    [<CLIEvent>]
    member this.MyEvent = myEv.Publish
```

#### <a name="expose-asynchronous-operations-as-methods-which-return-net-tasks"></a>Предоставлять асинхронные операции, как методы, которые возвращают задачи .NET

Задачи используются в .NET для представления active асинхронных вычислений. Задачи, в целом, менее композиционной, чем F# `Async<T>` объектов, так как они представляют задачи «уже выполняется» и не может содержать вместе одним из способов, которые выполняют параллельные композиции или который скрыть распространение сигналы отмены и других контекстные параметры.

Однако несмотря на это, методы, которые возвращают задачи, стандартное представление асинхронного программирования на платформе .NET.

```fsharp
/// A type in a component designed for use from other .NET languages
type MyType() =

    let compute (x: int) : Async<int> = async { ... }

    member this.ComputeAsync(x) = compute x |> Async.StartAsTask
```

Вы будете часто Обраб явного токена отмены:

```fsharp
/// A type in a component designed for use from other .NET languages
type MyType() =
    let compute(x:int) : Async<int> = async { ... }
    member this.ComputeAsTask(x, cancellationToken) = Async.StartAsTask(compute x, cancellationToken)
```

#### <a name="use-net-delegate-types-instead-of-f-function-types"></a>Использование типов делегатов .NET вместо типов функция F#

Здесь «типы функция F#» означает «стрелка» типов, таких как `int -> int`.

Вместо этого:

```fsharp
member this.Transform(f:int->int) =
    ...
```

Выполните следующее.

```fsharp
member this.Transform(f:Func<int,int>) =
    ...
```

Тип функции F# отображается как `class FSharpFunc<T,U>` на других языках .NET и этот процесс менее подходит для функций языка и инструменты, которые понимают типы делегатов. При создании метода более высокого порядка, предназначенных для .NET Framework 3.5 или более поздней версии, `System.Func` и `System.Action` делегаты являются правой API-интерфейсы для публикации позволяет разработчикам .NET использовать эти API-интерфейсы в виде низким коэффициентом трения. (При нацеливании на .NET Framework 2.0, типы делегатов, определяемые системой более ограничены; рассмотрите возможность использования делегата предопределенные типы, такие как `System.Converter<T,U>` или определение определенному типу делегата.)

С другой стороны, делегаты .NET не являются естественным для языка F#-с выходом библиотек (в следующем разделе на F#-с выходом библиотек). Таким образом распространенные стратегия реализации при разработке методы более высокого порядка для соответствующего ванили библиотек .NET — создание всех реализации, с помощью функции типов F#, а затем создать открытый интерфейс API с использованием делегатов в качестве тонкой оболочки поверх фактическое F# Реализация.

#### <a name="use-the-trygetvalue-pattern-instead-of-returning-f-option-values-and-prefer-method-overloading-to-taking-f-option-values-as-arguments"></a>Использование шаблона TryGetValue вместо возвращения значения параметров F# и предпочитаете перегрузка методов с созданием параметр значения F# в качестве аргументов

Общие шаблоны использования для типа параметра F# в API-интерфейсы работают лучше реализации в ваниль методы разработки API-интерфейсы .NET, с помощью standard .NET. Вместо возвращения значения параметра F#, рассмотрите возможность использования возвращаемый тип bool, а также как в шаблоне «TryGetValue» выходной параметр. И вместо значения параметров F# в качестве параметров, рассмотрите возможность использования перегрузки метода или необязательные аргументы.

```fsharp
member this.ReturnOption() = Some 3

member this.ReturnBoolAndOut(outVal : byref<int>) =
    outVal <- 3
    true

member this.ParamOption(x : int, y : int option) =
    match y with
    | Some y2 -> x + y2
    | None -> x

member this.ParamOverload(x : int) = x

member this.ParamOverload(x : int, y : int) = x + y
```

#### <a name="use-the-net-collection-interface-types-ienumerablet-and-idictionarykeyvalue-for-parameters-and-return-values"></a>Использовать интерфейс коллекции .NET типы IEnumerable\<T\> и IDictionary\<ключ, значение\> для параметров и возвращаемых значений

Не рекомендуется использовать конкретный набор типов, таких как массивы .NET `T[]`, типы F# `list<T>`, `Map<Key,Value>` и `Set<T>`, и .NET конкретные типы коллекций, такие как `Dictionary<Key,Value>`. Рекомендации по разработке библиотек .NET имеют хороший совет, касающийся необходимости использования различных типов коллекций, такие как `IEnumerable<T>`. Некоторые использование массивов (`T[]`) допустима в некоторых случаях на территории производительности. Обратите внимание, особенно что `seq<T>` является просто F# псевдоним для `IEnumerable<T>`, и поэтому seq часто соответствующих типов для обычный .NET API.

Вместо списков F#:

```fsharp
member this.PrintNames(names : string list) =
    ...
```

Использование последовательностей F#:

```fsharp
member this.PrintNames(names : seq<string>) =
    ...
```

#### <a name="use-the-unit-type-as-the-only-input-type-of-a-method-to-define-a-zero-argument-method-or-as-the-only-return-type-to-define-a-void-returning-method"></a>Используйте тип единицы измерения как единственный входной тип метода для определения метода нулевой аргумент, или как единственный возвращаемый тип для определения метода, возвращающего значение void

Избегайте других вариантов использования тип единицы измерения. Это хороший:

```fsharp
✔ member this.NoArguments() = 3

✔ member this.ReturnVoid(x : int) = ()
```

Это неправильный:

```fsharp
member this.WrongUnit( x:unit, z:int) = ((), ())
```

#### <a name="check-for-null-values-on-vanilla-net-api-boundaries"></a>Проверять наличие значений null по границам стандартный API для .NET

Реализация кода F# обычно имеют меньшее количество значений null, из-за неизменяемый конструктивные шаблоны и ограничения использования литералы null для типов F#. Другими языками .NET часто используют значение null гораздо чаще. По этой причине код F#, которая предоставляет обычный .NET API следует проверять параметры со значением NULL на границе API и предотвратить эти значения поступают глубже в код реализации F#. `isNull` Функции или шаблоны на `null` шаблон может использоваться.

```fsharp
let checkNonNull argName (arg: obj) =
    match arg with
    | null -> nullArg argName
    | _ -> ()

let checkNonNull` argName (arg: obj) =
    if isNull arg then nullArg argName
    else ()
```

#### <a name="avoid-using-tuples-as-return-values"></a>Старайтесь не использовать кортежи как возвращаемые значения

Вместо этого предпочитают, возвращая именованный тип, содержащий статистические данные, или использование выходных параметров для возврата нескольких значений. Несмотря на то, что кортежи и кортежи, структура существует в .NET (в том числе поддержка языка C# для структурных кортежей), они чаще всего не будет предоставлять идеальная и ожидаемый интерфейс API для разработчиков .NET.

#### <a name="avoid-the-use-of-currying-of-parameters"></a>Избегайте использования каррирование параметров

Вместо этого использовать соглашения о вызовах .NET ``Method(arg1,arg2,…,argN)``.

```fsharp
member this.TupledArguments(str, num) = String.replicate num str
```

Совет: При создании библиотек для использования в любом языке .NET, то нет никакой альтернативы делать некоторые экспериментальные C# и Visual Basic программирования, чтобы убедиться, что библиотеки «вид справа» из этих языков. Средства, такие как .NET Reflector и обозревателя объектов Visual Studio также можно гарантией библиотек и связанную документацию для разработчиков должным образом.

## <a name="appendix"></a>Приложение

### <a name="end-to-end-example-of-designing-f-code-for-use-by-other-net-languages"></a>End-to-end пример создания кода F# для использования с другими языками .NET

Рассмотрим следующий класс:

```fsharp
open System

type Point1(angle,radius) =
    new() = Point1(angle=0.0, radius=0.0)
    member x.Angle = angle
    member x.Radius = radius
    member x.Stretch(l) = Point1(angle=x.Angle, radius=x.Radius * l)
    member x.Warp(f) = Point1(angle=f(x.Angle), radius=x.Radius)
    static member Circle(n) =
        [ for i in 1..n -> Point1(angle=2.0*Math.PI/float(n), radius=1.0) ]
```

Выведенный тип F# этот класс выглядит следующим образом:

```fsharp
type Point1 =
    new : unit -> Point1
    new : angle:double * radius:double -> Point1
    static member Circle : n:int -> Point1 list
    member Stretch : l:double -> Point1
    member Warp : f:(double -> double) -> Point1
    member Angle : double
    member Radius : double
```

Давайте рассмотрим, как выглядит этот тип F# программисту, используя другой язык .NET. Например приблизительное C# «подпись» выглядит следующим образом:

```csharp
// C# signature for the unadjusted Point1 class
public class Point1
{
    public Point1();

    public Point1(double angle, double radius);

    public static Microsoft.FSharp.Collections.List<Point1> Circle(int count);

    public Point1 Stretch(double factor);

    public Point1 Warp(Microsoft.FSharp.Core.FastFunc<double,double> transform);

    public double Angle { get; }

    public double Radius { get; }
}
```

Существуют некоторые важные особенности о том, как F# представляет конструкции здесь. Пример:

* Метаданные, такие как имена аргументов был сохранен.

* F# методы, которые принимают два аргумента становятся методы C#, которые принимают два аргумента.

* Функции и списки становятся ссылки на соответствующие типы в библиотеке F#.

Ниже показано, как настроить этот код необходимо учитывать следующее.

```fsharp
namespace SuperDuperFSharpLibrary.Types

type RadialPoint(angle:double, radius:double) =

    /// Return a point at the origin
    new() = RadialPoint(angle=0.0, radius=0.0)

    /// The angle to the point, from the x-axis
    member x.Angle = angle

    /// The distance to the point, from the origin
    member x.Radius = radius

    /// Return a new point, with radius multiplied by the given factor
    member x.Stretch(factor) =
        RadialPoint(angle=angle, radius=radius * factor)

    /// Return a new point, with angle transformed by the function
    member x.Warp(transform:Func<_,_>) =
        RadialPoint(angle=transform.Invoke angle, radius=radius)

    /// Return a sequence of points describing an approximate circle using
    /// the given count of points
    static member Circle(count) =
        seq { for i in 1..count ->
                RadialPoint(angle=2.0*Math.PI/float(count), radius=1.0) }
```

Выведенный тип F# код выглядит следующим образом:

```fsharp
type RadialPoint =
    new : unit -> RadialPoint
    new : angle:double * radius:double -> RadialPoint
    static member Circle : count:int -> seq<RadialPoint>
    member Stretch : factor:double -> RadialPoint
    member Warp : transform:System.Func<double,double> -> RadialPoint
    member Angle : double
    member Radius : double
```

Сигнатура C# — теперь следующим образом:

```csharp
public class RadialPoint
{
    public RadialPoint();

    public RadialPoint(double angle, double radius);

    public static System.Collections.Generic.IEnumerable<RadialPoint> Circle(int count);

    public RadialPoint Stretch(double factor);

    public RadialPoint Warp(System.Func<double,double> transform);

    public double Angle { get; }

    public double Radius { get; }
}
```

Внесены исправления для подготовки к использованию этого типа, как часть стандартного библиотеки .NET являются следующим образом:

* Изменить несколько имен: `Point1`, `n`, `l`, и `f` стали `RadialPoint`, `count`, `factor`, и `transform`, соответственно.

* Используемый тип возвращаемого значения `seq<RadialPoint>` вместо `RadialPoint list` путем изменения конструкции списка с помощью `[ ... ]` для создания последовательности с помощью `IEnumerable<RadialPoint>`.

* Используемый тип делегата .NET `System.Func` вместо типа функции F#.

Это делает гораздо лучше, для использования в коде C#.
