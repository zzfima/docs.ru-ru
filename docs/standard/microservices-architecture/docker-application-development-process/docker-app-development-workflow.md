---
title: Рабочий процесс разработки для приложений Docker
description: Архитектура микрослужб .NET для упакованных в контейнеры приложений .NET | Рабочий процесс разработки для приложений Docker
keywords: Docker, микрослужбы, ASP.NET, контейнер
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 73d4ad82ef8c48f57aa4cceceedba862a2c9ffa4
ms.sourcegitcommit: b750a8e3979749b214e7e10c82efb0a0524dfcb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2018
---
# <a name="development-workflow-for-docker-apps"></a>Рабочий процесс разработки для приложений Docker

Жизненный цикл разработки приложений начинается на компьютере каждого разработчика, где разработчик локально программирует приложение на предпочитаемом языке и тестирует его. Независимо от выбранного языка, инфраструктуры и платформы, в рамках этого рабочего процесса разработчик всегда разрабатывает и тестирует контейнеры Docker, но делает это локально.

В каждый контейнер (экземпляр образа Docker) входят следующие компоненты:

-   Выбранная операционная система (например, дистрибутив Linux, Windows Nano Server или Windows Server Core).

-   Файлы, добавленные разработчиком (двоичные файлы приложения и т. п.).

-   Сведения о конфигурации (параметры среды и зависимости).

## <a name="workflow-for-developing-docker-container-based-applications"></a>Рабочий процесс разработки приложений Docker на основе контейнера

В этом разделе описывается рабочий процесс *внутреннего цикла* разработки приложений на основе контейнера Docker. Рабочий процесс внутреннего цикла означает, что речь идет только о разработке, которая выполняется на компьютере разработчика, не касаясь более широкого рабочего процесса DevOps. Начальные этапы настройки среды здесь не рассматриваются, так как они выполняются только один раз.

Приложение состоит из ваших собственных служб и дополнительных библиотек (зависимостей). Ниже приведены основные шаги, которые обычно выполняются при сборке приложения Docker, как показано на рисунке 5-1.

![](./media/image1.png)

**Рис. 5-1**. Пошаговый рабочий процесс разработки приложения на основе контейнера Docker

В этом руководстве подробно описывается весь процесс, и каждый важный шаг объясняется с акцентом на среду Visual Studio.

Если разработка выполняется с помощью редактора и CLI (например, Visual Studio Code и Docker CLI на macOS или Windows), то необходимо знать каждый шаг и обычно более детально, чем при использовании Visual Studio. Дополнительные сведения о работе в среде CLI см. в электронной книге [Containerized Docker Application lifecycle with Microsoft Platforms and Tools](http://aka.ms/dockerlifecycleebook/).

При использовании Visual Studio 2015 или Visual Studio 2017 многие из этих шагов выполняются автоматически, что значительно повышает производительность. Это особенно справедливо в тех случаях, когда используется Visual Studio 2017 и планируется создание многоконтейнерных приложений. Например, всего лишь одним щелчком мыши Visual Studio добавляет в проект Dockerfile и файл docker-compose.yml с конфигурацией для вашего приложения. При запуске приложения в Visual Studio он создает образ Docker и запускает многоконтейнерное приложение непосредственно в Docker; вы даже можете отлаживать несколько контейнеров одновременно. Эти возможности значительно повышают скорость разработки.

Однако то, что Visual Studio автоматизирует эти действия, не означает, что вам не нужно знать, что происходит внутри Docker. Поэтому далее в руководстве подробно описывается каждый шаг.

![](./media/image2.png)

## <a name="step-1-start-coding-and-create-your-initial-application-or-service-baseline"></a>Шаг 1. Начало программирования и создание первого приложения или базовой службы

Разработка приложения Docker аналогична разработке приложения без Docker. Разница заключается в том, что при разработке для Docker развертывание и тестирование приложения или служб, работающих в контейнерах Docker, выполняется в локальной среде. Этот контейнер может быть контейнером Linux или контейнером Windows.

### <a name="set-up-your-local-environment-with-visual-studio"></a>Настройка локальной среды с помощью Visual Studio

Перед началом работы убедитесь, что [Docker Community Edition (CE)](https://www.docker.com/community-edition) для Windows установлен, как описано в следующих инструкциях:

[Начало работы с Docker CE для Windows](https://docs.docker.com/docker-for-windows/)

Кроме того, потребуется установленный Visual Studio 2017. Вместо Visual Studio 2015 с надстройкой "Средства Visual Studio для Docker" рекомендуется использовать именно Visual Studio 2017, поскольку в нем реализована расширенная поддержка Docker, например, поддерживается отладка контейнеров. Visual Studio 2017 включает инструментарий для Docker, если при установке вы выбрали рабочую нагрузку **.NET Core и Docker**, как показано на рисунке 5-2.

![](./media/image3.png)

**Рис. 5-2**. Выбор рабочей нагрузки **.NET Core и Docker** при установке Visual Studio 2017

Можно приступать к программированию приложения в обычной среде .NET (как правило, в .NET Core, если вы планируете использовать контейнеры) даже до включения Docker в вашем приложении и развертывания и тестирования в Docker. Тем не менее рекомендуется начать работу в Docker как можно быстрее, поскольку это будет реальная среда, и любые проблемы можно будет обнаружить гораздо раньше. Это также рекомендуется потому, что Visual Studio настолько упрощает работу с Docker, что практически все действия очевидны; лучший пример — отладка многоконтейнерного приложения в Visual Studio.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Начало работы с Docker CE для Windows**
    [*https://docs.docker.com/docker-for-windows/*](https://docs.docker.com/docker-for-windows/)

-   **Visual Studio 2017**
    [*https://www.visualstudio.com/downloads/*](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)

![](./media/image4.png)

## <a name="step-2-create-a-dockerfile-related-to-an-existing-net-base-image"></a>Шаг 2. Создание файла Dockerfile, связанного с существующим базовым образом .NET

Dockerfile необходим для каждого пользовательского образа, который вы хотите создать; кроме того, Dockerfile потребуется для каждого контейнера, который будет развертываться автоматически из Visual Studio или вручную с помощью Docker CLI (с помощью команд docker run и docker-compose). Если в приложении имеется единственный экземпляр пользовательской службы, необходим один Dockerfile. Если в приложении имеется несколько служб (как в архитектуре на основе микрослужб), потребуется по одному Dockerfile для каждой службы.

Dockerfile размещается в корневой папке приложения или службы. Он содержит команды, которые указывают Docker, как настраивать и запускать приложение или службу в контейнере. Можно вручную создать Dockerfile в коде и добавить его в проект вместе с зависимостями .NET.

В Visual Studio со средствами для Docker эта задача выполняется лишь несколькими щелчками мыши. При создании нового проекта в Visual Studio 2017 можно выбрать параметр с именем **Enable Container (Docker) Support** (Включить поддержку контейнеров (Docker)), как показано на рисунке 5-3.

![](./media/image5.png)

**Рис. 5-3**. Включение поддержки Docker при создании нового проекта в Visual Studio 2017

Можно также включить поддержку Docker в новом или существующем проекте, щелкнув правой кнопкой мыши файл проекта в Visual Studio и выбрав в меню пункты **Add-Docker Project Support** (Добавить-Поддержка проекта Docker), как показано на рисунке 5-4.

![](./media/image6.png)

**Рис. 5-4**. Включение поддержки Docker в существующем проекте Visual Studio 2017

Если выполнить это действие в проекте (например, в веб-приложении ASP.NET или в службе веб-API), то в проект будет добавлен Dockerfile с необходимой конфигурацией. Кроме того, будет добавлен файл docker-compose.yml для всего решения. В следующих разделах описывается информация, которая находится в каждом из этих файлов. Visual Studio может сделать это вместо вас, однако полезно разобраться, что входит в Dockerfile.

### <a name="option-a-creating-a-project-using-an-existing-official-net-docker-image"></a>Вариант А. Создание проекта с помощью существующего официального образа .NET Docker

Обычно вы создаете пользовательский образ для своего контейнера на основе базового образа, который можно получить из официального репозитория в реестре [Центра Docker](https://hub.docker.com/). Именно это происходит на внутреннем уровне при включении поддержки Docker в Visual Studio. Ваш Dockerfile будет использовать существующий образ aspnetcore.

Ранее было показано, какие образы и репозитории Docker можно использовать в зависимости от выбранной платформы и операционной системы. Например, если вы выбрали ASP.NET Core (Windows или Linux), следует использовать образ microsoft/aspnetcore:2.0. Таким образом, достаточно просто указать, какой базовый образ Docker будет использоваться для контейнера. Для этого добавьте в Dockerfile строку FROM microsoft/aspnetcore:2.0. Visual Studio выполнит это автоматически, но в случае обновления версии вы обновляете это значение.

Использование официального репозитория образов .NET из Центра Docker с номером версии гарантирует, что на всех компьютерах (включая компьютеры для разработки, тестирования и работы) будут доступны одни и те же функции языка.

Ниже приведен пример Dockerfile для контейнера ASP.NET Core.

```Dockerfile
FROM microsoft/aspnetcore:2.0
  
ARG source
  
WORKDIR /app
  
EXPOSE 80
  
COPY ${source:-obj/Docker/publish} .
  
ENTRYPOINT ["dotnet", " MySingleContainerWebApp.dll "]
```

В этом случае контейнер основан на версии 2.0 официального образа Docker ASP.NET Core (мультиархитектурного для Linux и Windows). Это параметр `FROM microsoft/aspnetcore:2.0`. (Дополнительные сведения об этом базовом образе см. на страницах [Образ Docker ASP.NET Core](https://hub.docker.com/r/microsoft/aspnetcore/) и [Образ Docker .NET Core](https://hub.docker.com/r/microsoft/dotnet/).) Кроме того, в Dockerfile необходимо указать Docker прослушивать порт TCP, который будет использоваться во время выполнения (в данном случае это порт 80, как задано в параметре EXPOSE).

В Dockerfile можно задать дополнительные параметры конфигурации, в зависимости от используемого языка и платформы. Например, параметр ENTRYPOINT со значением \["dotnet", "MySingleContainerWebApp.dll"\] указывает Docker запускать приложение .NET Core. Если для создания и запуска приложения .NET используется пакет SDK и .NET Core CLI (dotnet CLI), этот параметр будет другим. Параметр ENTRYPOINT, который находится в нижней строке, и другие параметры будут отличаться в зависимости от языка и платформы, выбранных для приложения.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Создание образов Docker для приложений .NET Core**
    [*https://docs.microsoft.com/dotnet/core/docker/building-net-docker-images*](../../../core/docker/building-net-docker-images.md)

-   **Создание собственного образа**. В официальной документации Docker.
    [*https://docs.docker.com/engine/tutorials/dockerimages/*](https://docs.docker.com/engine/tutorials/dockerimages/)

### <a name="using-multi-arch-image-repositories"></a>Использование мультиархитектурных репозиториев

Один репозиторий может содержать варианты платформ, например образ Linux и образ Windows. Эта функция позволяет поставщикам, таким как Майкрософт, которые создают базовые образы, создать один репозиторий для охвата нескольких платформ (т. е. Windows и Linux). Например, репозиторий [microsoft/dotnet](https://hub.docker.com/r/microsoft/aspnetcore/) в реестре Центра Docker обеспечивает поддержку Linux и Windows Nano Server при использовании одного и того же имени репозитория.

Можно указать тег, явно задающий платформу, как в следующих случаях:

-   **microsoft/aspnetcore:2.0.0-jessie**

        .NET Core 2.0 runtime-only on Linux 

-   **microsoft/aspnetcore:2.0.0-nanoserver**

        .NET Core 2.0 runtime-only on Windows Nano Server

Однако в середине 2017 г. появилась возможность указывать одно и то же имя образа, даже с одинаковым тегом, и новые мультиархитектурные образы (например, образ aspnetcore, поддерживающий мультиархитектурность) будут использовать версию Windows или Linux в зависимости от развернутой базовой ОС Docker, как показано в следующем примере:

-   **microsoft/aspnetcore:2.0**

        Multi-arch: .NET Core 2.0 runtime-only on Linux or Windows Nano Server depending on the Docker host OS

Таким образом, при запросе образа с узла Windows будет получен вариант для Windows, а при запросе образа с тем же именем с узла Linux будет получен вариант для Linux.

### <a name="option-b-creating-your-base-image-from-scratch"></a>Вариант Б. Создание базового образа с нуля

Вы можете создать собственный базовый образ Docker с нуля. Этот сценарий не рекомендуется для тех, кто только начинает работать с Docker, но если вы хотите задать определенные биты базового образа, это можно сделать.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Мультиархитектурные образы .NET Core**.
https://github.com/dotnet/announcements/issues/14 
-   **Создание базового образа**. Официальная документация Docker.
    [*https://docs.docker.com/engine/userguide/eng-image/baseimages/*](https://docs.docker.com/engine/userguide/eng-image/baseimages/)

![](./media/image7.png)

## <a name="step-3-create-your-custom-docker-images-and-embed-your-application-or-service-in-them"></a>Шаг 3. Создание пользовательских образов Docker и внедрение в них собственных приложений или служб

Для каждой службы в приложении необходимо создать связанный образ. Если приложение состоит из одной службы или веб-приложения, достаточно одного образа.

Обратите внимание, что образы Docker в Visual Studio создаются автоматически. Следующие действия потребуются только в рабочем процессе с использованием редактора/CLI и подробно описываются, чтобы показать, что происходит внутри.

Разработчик должен выполнять разработку и тестирование локально до тех пор, пока не завершит и отправит компонент или пока не перейдет в систему управления версиями (например, в GitHub). Это означает, что необходимо создавать образы Docker и разворачивать контейнеры на локальном узле Docker (на виртуальной машине Windows или Linux), а затем выполнять запуск, тестирование и отладку этих локальных контейнеров.

Чтобы создать пользовательский образ в локальной среде с помощью Docker CLI и Dockerfile, можно использовать команду docker build, как показано на рисунке 5-5.

![](./media/image8.png)

**Рис. 5-5**. Создание пользовательского образа Docker

При необходимости вместо непосредственного выполнения команды docker build из папки проекта можно сначала создать развертываемую папку с нужными библиотеками .NET и двоичными файлами, выполнив команду dotnet publish, а затем использовать команду docker build.

Так будет создан образ Docker с именем cesardl/netcore-webapi-microservice-docker:first. В данном случае :first — это тег, представляющий конкретную версию. Этот шаг можно повторить для каждого пользовательского образа, который вам требуется создать для своего составного приложения Docker.

Если приложение состоит из нескольких контейнеров (т. е. это многоконтейнерное приложение), можно также использовать команду docker-compose up --build, чтобы собрать все связанные образы одной командой с помощью метаданных, представленных в связанном файле docker-compose.yml.

Вы можете найти существующие в локальном репозитории образы с помощью команды docker images, как показано на рисунке 5-6.

![](./media/image9.png)

**Рис. 5-6**. Просмотр существующих образов с помощью команды docker images

### <a name="creating-docker-images-with-visual-studio"></a>Создание образов Docker с помощью Visual Studio

При использовании Visual Studio для создания проекта с поддержкой Docker не требуется создавать образ явно. Этот образ создается автоматически, когда вы нажимаете клавишу F5 и запускаете приложение или службу, добавленную в Docker. Этот шаг выполняется в Visual Studio автоматически, и вы не увидите, как это происходит, но важно знать, что происходит внутри.

![](./media/image10.png)

## <a name="step-4-define-your-services-in-docker-composeyml-when-building-a-multi-container-docker-application"></a>Шаг 4. Определение служб в файле docker-compose.yml при сборке многоконтейнерного приложения Docker

В файле [docker-compose.yml](https://docs.docker.com/compose/compose-file/) можно задать ряд связанных служб для развертывания в качестве составного приложения с помощью команд развертывания.

Чтобы использовать файл docker-compose.yml, его необходимо создать в основной или корневой папке решения, и его содержимое должно быть аналогично приведенному в следующем примере.

```yml
version: '3'
  
services:

  webmvc:
    image: eshop/web
    environment:
      - CatalogUrl=http://catalog.api
      - OrderingUrl=http://ordering.api
    ports:
      - "80:80"
    depends_on:
      - catalog.api
      - ordering.api

  catalog.api:
    image: eshop/catalog.api
    environment: 
      - ConnectionString=Server=sql.data;Database=CatalogDB;…
    ports:
      - "81:80"
    depends_on:
      - sql.data

  ordering.api:
    image: eshop/ordering.api
    environment:
      - ConnectionString=Server=sql.data;Database=OrderingDb;…
    ports:
      - "82:80"
    extra_hosts:
      - "CESARDLBOOKVHD:10.0.75.1"
    depends_on:
      - sql.data

  sql.data:
    image: mssql-server-linux:latest
    environment:
      - SA_PASSWORD=Pass@word
      - ACCEPT_EULA=Y
    ports:
      - "5433:1433"

```

Обратите внимание, что данный файл docker-compose.yml представляет собой упрощенную и объединенную версию. Он содержит статические данные конфигурации для каждого контейнера (такие как имя пользовательского образа), которые применяются всегда, а также сведения о конфигурации, которые могут зависеть от среды развертывания, такие как строка подключения. В следующих разделах вы узнаете, как можно разбить конфигурацию в файле docker-compose.yml на несколько файлов docker-compose и переопределить значения в зависимости от среды и типа выполнения (отладка или выпуск).

В примере файла docker-compose.yml определяются четыре службы: служба webmvc (веб-приложение), две микрослужбы (catalog.api и ordering.api) и один контейнер источника данных, sql.data, на основе SQL Server для Linux, работающий как контейнер. Каждая служба развертывается как контейнер, поэтому образ Docker требуется для каждой службы.

Файл docker-compose.yml задает не только используемые контейнеры, но и их индивидуальные конфигурации. Например, в определении контейнера webmvc в файле .yml задается следующее.

-   Используется предварительно созданный образ eshop/web:latest. Однако вы также можете настроить сборку этого образа при выполнении команды docker-compose с дополнительной конфигурацией на основе раздела build: в файле docker-compose.

-   Инициализируются две переменные среды (CatalogUrl и OrderingUrl).

-   Предоставленный порт 80 в контейнере переадресуется на внешний порт 80 на хост-компьютере.

-   Веб-приложение связывается со службами catalog и ordering с помощью параметра depends\_on. В результате данная служба будет ожидать запуска этих служб.

Мы вернемся к файлу docker-compose.yml в следующем разделе, когда будем рассматривать реализацию микрослужб и многоконтейнерных приложений.

### <a name="working-with-docker-composeyml-in-visual-studio-2017"></a>Работа с файлом docker-compose.yml в Visual Studio 2017

Когда вы добавляете поддержку решения Docker в проект службы в решении Visual Studio, как показано на рисунке 5-7, Visual Studio добавляет в ваш проект Dockerfile, а также добавляет в ваше решение раздел служб (проект) с помощью файла docker-compose.yml. Это простой способ начать создание многоконтейнерного решения. Затем можно открыть файлы docker-compose.yml и добавить в них дополнительные возможности.

![](./media/image6.png)

**Рис. 5-7**. Добавление поддержки Docker в Visual Studio 2017 щелчком правой кнопкой мыши на проекте ASP.NET Core

При добавлении поддержки Docker в Visual Studio помимо добавления в проект Dockerfile также добавляются сведения о конфигурации в несколько глобальных файлов docker-compose.yml, заданных на уровне решения.

После добавления поддержки Docker в решение в Visual Studio вы также увидите новый узел в обозревателе решений (в файле проекта docker-compose.dcproj), содержащий добавленные файлы docker-compose.yml, как показано на рисунке 5-8.

![](./media/image11.PNG)

**Рис. 5-8**. Узел дерева **docker-compose**, добавленный в обозреватель решений Visual Studio 2017

Можно было бы развернуть многоконтейнерное приложение с единственным файлом docker-compose.yml с помощью команды docker-compose up. Однако Visual Studio добавляет группу этих файлов, чтобы вы могли переопределять значения в зависимости от среды (разработки или рабочей) и типа выполнения (выпуска или отладки). Эта возможность разъясняется в следующих разделах.

![](./media/image12.png)

## <a name="step-5-build-and-run-your-docker-application"></a>Шаг 5. Сборка и запуск приложения Docker

Если в приложении имеется только один контейнер, его можно запустить путем развертывания на узле Docker (на виртуальной машине или физическом сервере). Но если приложение содержит несколько служб, его можно развернуть как составное приложение с помощью одной команды CLI (docker-compose up) или в Visual Studio, в котором внутри будет выполняться эта же команда. Давайте рассмотрим разные варианты.

### <a name="option-a-running-a-single-container-with-docker-cli"></a>Вариант А. Запуск единственного контейнера с помощью Docker CLI

Контейнер Docker можно запустить с помощью команды docker run, как показано на рисунке 5-9.

```console
  docker run -t -d -p 80:5000 cesardl/netcore-webapi-microservice-docker:first
```

![](./media/image13.png)

**Рис. 5-9**. Запуск контейнера Docker с помощью команды docker run

В этом случае команда привязывает внутренний порт 5000 контейнера к порту 80 хост-компьютера. Это означает, что узел выполняет прослушивание порта 80 и переадресацию в порт 5000 в контейнере.

### <a name="option-b-running-a-multi-container-application"></a>Вариант Б. Запуск многоконтейнерного приложения

В большинстве корпоративных сценариев приложение Docker будет состоять из нескольких служб; это означает, что необходимо запускать многоконтейнерное приложение, как показано на рисунке 5-10.

![](./media/image14.png)

**Рис. 5-10**. Виртуальная машина с развернутыми контейнерами Docker

#### <a name="running-a-multi-container-application-with-the-docker-cli"></a>Запуск многоконтейнерного приложения с помощью Docker CLI

Чтобы запустить многоконтейнерное приложение с помощью Docker CLI, можно выполнить команду docker-compose up. Эта команда разворачивает многоконтейнерное приложение с помощью файла docker-compose.yml, существующего на уровне решения. На рисунке 5-11 показаны результаты выполнения этой команды из главного каталога проекта, в котором находится файл docker-compose.yml.

![](./media/image15.png)

**Рис. 5-11**. Пример результата выполнения команды docker-compose up

После выполнения команды docker-compose up приложение и связанные с ним контейнеры развертываются в узле Docker, как показано в представлении виртуальной машины на рисунке 5-10.

#### <a name="running-and-debugging-a-multi-container-application-with-visual-studio"></a>Запуск и отладка многоконтейнерного приложения с помощью Visual Studio 

Запуск многоконтейнерного приложения с помощью Visual Studio 2017 не может быть проще. Вы можете не только запускать многоконтейнерное приложение, но также и отлаживать все его контейнеры непосредственно в Visual Studio, установив обычные точки останова.

Как упоминалось ранее, каждый раз при добавлении поддержки решения Docker в проект в решении этот проект настраивается в глобальном (на уровне решения) файле docker-compose.yml, что позволяет запускать или отлаживать все решение сразу. Visual Studio будет запускать по одному контейнеру для каждого проекта с включенной поддержкой решения Docker и выполнять все внутренние шаги автоматически (dotnet publish, docker build и т. д.).

Здесь важно то, что, как показано на рисунке 5-12, в Visual Studio 2017 имеется дополнительная команда **Docker** для действия клавиши F5. Эта возможность позволяет запускать или отлаживать многоконтейнерное приложение путем запуска всех контейнеров, определенных в файлах docker-compose.yml на уровне решения. Возможность отладки многоконтейнерных решений означает, что можно установить несколько точек останова, чтобы все они были в разных проектах (контейнерах), и во время отладки из Visual Studio вы будете останавливаться в точках останова, заданных в разных проектах, и работать в разных контейнерах.

![](./media/image16.png)

**Рис. 5-12**. Запуск многоконтейнерных приложений в Visual Studio 2017

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Развертывание контейнера ASP.NET на удаленном узле Docker**
    [*https://docs.microsoft.com/azure/vs-azure-tools-docker-hosting-web-apps-in-docker*](https://docs.microsoft.com/azure/vs-azure-tools-docker-hosting-web-apps-in-docker)

### <a name="a-note-about-testing-and-deploying-with-orchestrators"></a>Примечание о тестировании и развертывании с использованием оркестраторов

Команды docker-compose up и docker run (или запуск и отладка контейнеров в Visual Studio) подходят для тестирования контейнеров в вашей среде разработки. Однако этот способ не подходит, если вы планируете использовать оркестраторы и кластеры Docker, такие как Docker Swarm, Mesosphere DC/OS и Kubernetes. Если вы используете кластер, например [режим Docker Swarm](https://docs.docker.com/engine/swarm/) (доступный в Docker CE для Windows и Mac, начиная с версии 1.12), необходимо выполнять развертывание и тестирование единственных служб с помощью дополнительных команд, таких как [docker service create](https://docs.docker.com/engine/reference/commandline/service_create/). При развертывании приложения, состоящего из нескольких контейнеров, следует использовать команды [docker compose bundle](https://docs.docker.com/compose/reference/bundle/) и [docker deploy myBundleFile](https://docs.docker.com/engine/reference/commandline/deploy/), чтобы развернуть составное приложение как *стек*. Дополнительные сведения см. в записи блога [Introducing Experimental Distributed Application Bundles](https://blog.docker.com/2016/06/docker-app-bundle/) (Общие сведения об экспериментальных пакетах распределенных приложений) в документации Docker на сайте Docker.

Для [DC/OS](https://mesosphere.com/blog/2015/09/02/dcos-cli-command-line-tool-datacenter/) и [Kubernetes](http://kubernetes.io/docs/user-guide/deployments/) вы также должны использовать другие скрипты и команды развертывания.

![](./media/image17.png)

## <a name="step-6-test-your-docker-application-using-your-local-docker-host"></a>Шаг 6. Тестирование приложения Docker с помощью локального узла Docker

Этот шаг будет зависеть от того, что делает ваше приложение. В случае простого веб-приложения .NET Core, развернутого в виде единственного контейнера или службы, можно получить доступ к этой службе, открыв на узле Docker браузер и перейдя в нем на этот сайт, как показано на рисунке 5-13. (Если конфигурация в Dockerfile сопоставляет контейнер с портом узла, отличным от 80, укажите этот порт узла в URL-адресе.)

![](./media/image18.png)

**Рис. 5-13**. Пример локального тестирования приложения Docker с помощью localhost

Если localhost не указывает на IP-адрес узла Docker (при использовании Docker CE это должно происходить по умолчанию), то для перехода к службе используйте IP-адрес сетевой карты вашего компьютера.

Обратите внимание, что этот URL-адрес в браузере использует порт 80 для рассматриваемого примера конкретного контейнера. Однако внутренние запросы перенаправляются на порт 5000, поскольку именно так было выполнено развертывание с помощью команды docker run, как описано в предыдущем шаге.

Вы также можете тестировать приложение с помощью команды curl с терминала, как показано на рисунке 5-14. В случае установки Docker в Windows по умолчанию всегда будет использоваться IP-адрес узла Docker 10.0.75.1 помимо фактического IP-адреса вашего компьютера.

![](./media/image19.png)

**Рис. 5-14**. Пример локального тестирования приложения Docker с помощью curl

### <a name="testing-and-debugging-containers-with-visual-studio-2017"></a>Тестирование и отладка контейнеров в Visual Studio 2017

При запуске и отладке контейнеров в Visual Studio 2017 вы можете отлаживать приложения .NET в основном так же, как при запуске без контейнеров.

### <a name="testing-and-debugging-without-visual-studio"></a>Тестирование и отладка без Visual Studio

Если при разработке используется редактор или CLI, отлаживать контейнеры будет значительно труднее, и вы захотите выполнять отладку путем создания трассировок.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Отладка приложений в локальном контейнере Docker**
    [*https://docs.microsoft.com/azure/vs-azure-tools-docker-edit-and-refresh*](https://docs.microsoft.com/azure/vs-azure-tools-docker-edit-and-refresh)

-   **Стив Ласкер (Steve Lasker). Сборка, отладка, развертывание приложений ASP.NET Core с помощью Docker.** Видео.
    [*https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T115*](https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T115)

## <a name="simplified-workflow-when-developing-containers-with-visual-studio"></a>Упрощенный рабочий процесс при разработке контейнеров в Visual Studio

В сущности, при использовании Visual Studio рабочий процесс гораздо проще, чем при использовании редактора или CLI. Большинство шагов, необходимых для Docker и связанных с Dockerfile и docker-compose.yml, выполняются скрыто от пользователя или значительно упрощаются благодаря Visual Studio, как показано на рисунке 5-15.

![](./media/image20.png)

**Рис. 5-15**. Упрощенный рабочий процесс при разработке в Visual Studio

Кроме того, вам достаточно будет выполнить шаг 2 (добавление поддержки Docker в проекты) только один раз. Таким образом, рабочий процесс аналогичен другим обычным задачам разработки, когда для разработки используется .NET. Вам нужно знать, что происходит на самом деле (процесс создания образа, какие базовые образы используются, развертывание контейнеров и т. п.), и в некоторых случаях также может потребоваться изменить файл Dockerfile или docker-compose.yml, чтобы настроить функциональность. Но благодаря Visual Studio большую часть работы можно выполнить гораздо проще, что существенно повышает эффективность работы.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **Стив Ласкер (Steve Lasker). Разработка .NET Docker в Visual Studio 2017**
    [*https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T111*](https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T111)

-   **Джеффри Т. Фриц (Jeffrey T. Fritz). Помещение приложения .NET Core в контейнер с помощью новых инструментов Docker для Visual Studio**
    [*https://blogs.msdn.microsoft.com/webdev/2016/11/16/new-docker-tools-for-visual-studio/*](https://blogs.msdn.microsoft.com/webdev/2016/11/16/new-docker-tools-for-visual-studio/)

## <a name="using-powershell-commands-in-a-dockerfile-to-set-up-windows-containers"></a>Использование команд PowerShell в DockerFile для настройки контейнеров Windows 

[Контейнеры Windows](https://msdn.microsoft.com/en-us/virtualization/windowscontainers/about/about_overview) позволяют преобразовывать существующие приложения Windows в образы Docker и развертывать их с помощью тех же средств, что и остальную часть экосистемы Docker. Чтобы использовать контейнеры Windows, выполните команды PowerShell в Dockerfile, как показано в следующем примере:

```Dockerfile
FROM microsoft/windowsservercore
  
LABEL Description="IIS" Vendor="Microsoft" Version="10"
  
RUN powershell -Command Add-WindowsFeature Web-Server
  
CMD [ "ping", "localhost", "-t" ]
```

В этом случае мы используем базовый образ Windows Server Core (параметр FROM) и устанавливаем службы IIS с помощью команды PowerShell (параметр RUN). Аналогичным образом можно также использовать команды PowerShell для настройки дополнительных компонентов, таких как ASP.NET 4.x, .NET 4.6 и другого программного обеспечения Windows. Например, следующая команда в Dockerfile настраивает ASP.NET 4.5:

```Dockerfile
RUN powershell add-windowsfeature web-asp-net45
```

### <a name="additional-resources"></a>Дополнительные ресурсы

-   **aspnet-docker/Dockerfile.** Примеры команд Powershell, которые можно выполнять в файлах Dockerfile для включения компонентов Windows.
    [*https://github.com/Microsoft/aspnet-docker/blob/master/4.6.2/Dockerfile*](https://github.com/Microsoft/aspnet-docker/blob/master/4.6.2/Dockerfile)

>[!div class="step-by-step"]
[Назад] (index.md) [Далее] (../net-core-single-containers-linux-windows-server-hosts/index.md)
