---
title: Потенциальные ошибки, связанные с параллелизмом данных и задач
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallel programming, pitfalls
ms.assetid: 1e357177-e699-4b8f-9e49-56d3513ed128
ms.openlocfilehash: ff6ac9e8c41ee203ae72e1b28c088f462ddf6a54
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "73140031"
---
# <a name="potential-pitfalls-in-data-and-task-parallelism"></a>Потенциальные ошибки, связанные с параллелизмом данных и задач
Во многих случаях <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> могут значительно повысить производительность по сравнению с обычным выполнением последовательных циклов. В то же время сложность процесса параллелизации может вызывать проблемы, которые в последовательном коде не встречаются или для него не типичны. В этом разделе перечислены некоторые рекомендации по написанию параллельных циклов.  
  
## <a name="do-not-assume-that-parallel-is-always-faster"></a>Не считайте, что параллельные процессы всегда быстрее.  
 В некоторых случаях параллельный цикл может выполняться медленнее, чем аналогичный последовательный. Первое правило состоит в том, что параллельные циклы с небольшим числом итераций и быстрыми пользовательскими делегатами, скорее всего, большого ускорения не дадут. Но в связи с тем, что на производительность влияет множество факторов, рекомендуем всегда оценивать фактические результаты.  
  
## <a name="avoid-writing-to-shared-memory-locations"></a>Избегайте размещения в общей памяти.  
 В последовательном коде для чтения и записи часто используются статические переменные и поля классов. Но всякий раз, когда к таким переменным обращаются сразу несколько потоков, может возникать состояние гонки. Несмотря на то что для синхронизации доступа к переменной можно использовать блокировки, связанные с нею затраты ресурсов могут снизить производительность. В связи с этим рекомендуем не использовать или хотя бы максимально ограничить обращение к общему состоянию в параллельном цикле. Для этого лучше всего использовать перегрузки <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> и <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>, которые используют переменную <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> для хранения локального состояния потока во время выполнения цикла. Дополнительные сведения см. в разделе [Практическое руководство. Написание цикла Parallel.For с локальными переменными потока](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) и [Практическое руководство. Написание цикла Parallel.ForEach c локальными переменными раздела](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).  
  
## <a name="avoid-over-parallelization"></a>Избегайте излишней параллелизации.  
 Использование параллельных циклов связано с чрезмерными затратами ресурсов на секционирование исходной коллекции и синхронизацию рабочих потоков. Преимущества параллелизации также ограничивает число процессоров на компьютере. Выполнение сразу нескольких потоков с большим количеством вычислений на одном и том же процессоре не повысит производительность. В связи с этим излишней параллелизации цикла следует избегать.  
  
 Чаще всего излишняя параллелизация возникает во вложенных циклах. Если не выполняется хотя бы одно из следующих условий, в большинстве случаев выгоднее параллелизовать только внешний цикл:  
  
- Внутренний цикл очень длинный.  
  
- С каждым заказом вы выполняете дорогостоящие вычисления. (Операция, показанная в примере, не является дорогостоящей.)  
  
- Целевая система имеет достаточно процессоров для обработки того количества потоков, которое будет создано при параллелизации запроса в `cust.Orders`.  
  
 В любом случае лучший способ определения оптимальной формы запроса — это проверка и измерение.  
  
## <a name="avoid-calls-to-non-thread-safe-methods"></a>Избегайте вызова методов, небезопасных для потоков.  
 Запись в методы экземпляров, не безопасные для потоков, из параллельного цикла способна привести к повреждению данных, которое может остаться или не остаться незамеченным в программе. Кроме того, она может вызывать исключения. В следующем примере несколько потоков одновременно пытаются вызвать метод <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType>, но этот класс не поддерживает такое поведение.  
  
 [!code-csharp[TPL_Pitfalls#04](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#04)]
 [!code-vb[TPL_Pitfalls#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#04)]  
  
## <a name="limit-calls-to-thread-safe-methods"></a>Ограничение вызовов потокобезопасных методов  
 Большинство статических методов на платформе .NET Framework безопасны для потоков и могут вызываться из нескольких потоков одновременно. Но даже в этих случаях соответствующая синхронизация может значительно замедлить запрос.  
  
> [!NOTE]
> Вы можете проверить это самостоятельно, добавив в запросы несколько вызовов <xref:System.Console.WriteLine%2A>. Несмотря на то что в примерах документации этот метод часто приводится для демонстрации, не используйте его в параллельных циклах без необходимости.  
  
## <a name="be-aware-of-thread-affinity-issues"></a>Помните о проблемах сходства потоков.  
 Некоторые технологии, например COM-взаимодействие для компонентов однопотокового подразделения (STA), Windows Forms и Windows Presentation Foundation (WPF), накладывают ограничения на сходство потоков, требующие, чтобы код выполнялся в определенном потоке. Например, и в Windows Forms, и в WPF элемент управления может быть доступен только в том потоке, в котором он был создан. В этом случае вы, например, не сможете обновить элемент управления "список" из параллельного цикла, не настроив планировщик потоков на выполнение задач только в потоке пользовательского интерфейса. Дополнительные сведения см. в статье [Указание контекста синхронизации](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).  
  
## <a name="use-caution-when-waiting-in-delegates-that-are-called-by-parallelinvoke"></a>Будьте внимательны при ожидании в делегатах, вызываемых методом Parallel.Invoke.  
 В некоторых случаях библиотека параллельных задач встраивает задачу — это означает, что данная задача выполняется в текущем потоке. (Дополнительные сведения см. в разделе [Планировщики задач](xref:System.Threading.Tasks.TaskScheduler).) В некоторых случаях подобная оптимизация производительности может привести к взаимоблокировке. Например, две задачи могут выполнять один и тот же код делегата, который подает сигнал, если возникает событие, а затем ожидает сигнала от другой задачи. Если вторая задача встроена в тот же поток, что и первая, а первая переходит в состояние ожидания, вторая задача не сможет подать сигнал о своем событии никогда. Чтобы этого избежать, можно указать время ожидания для операции ожидания или использовать явные конструкторы потоков, позволяющие убедиться, что одна задача не будет блокировать другую.  
  
## <a name="do-not-assume-that-iterations-of-foreach-for-and-forall-always-execute-in-parallel"></a>Не считайте, что итерации операторов ForEach, For и ForAll всегда выполняются параллельно.  
 Важно помнить, что отдельные итерации цикла <xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> или <xref:System.Linq.ParallelEnumerable.ForAll%2A> иногда могут выполняться параллельно, но это не гарантируется. В связи с этим старайтесь не писать код, который будет зависеть от правильности параллельного выполнения итераций или от выполнения итераций в определенном порядке. Например, этот код может вызвать взаимоблокировку:  
  
 [!code-csharp[TPL_Pitfalls#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#01)]
 [!code-vb[TPL_Pitfalls#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#01)]  
  
 В этом примере одна итерация задает событие, а все остальные его ожидают. Ни одна из ожидающих итераций не может быть завершена, пока не завершится итерация, задающая событие. При этом ожидающие итерации способны заблокировать все потоки, которые используются для выполнения параллельного цикла, прежде чем будет выполнена итерация, задающая событие. Это приведет к взаимоблокировке — итерация, задающая событие, никогда не будет выполнена, а ожидающие итерации никогда не активизируются.  
  
 Таким образом, для выполнения работы необходимо, чтобы ни одна итерация параллельного цикла не ожидала другой итерации цикла. Если параллельный цикл решит запланировать итерации последовательно, но в обратном порядке, может возникнуть взаимоблокировка.  
  
## <a name="avoid-executing-parallel-loops-on-the-ui-thread"></a>Избегайте выполнения параллельных циклов в потоке пользовательского интерфейса.  
 Пользовательский интерфейс всегда должен реагировать на действия пользователя. Если операция содержит достаточный объем работы для параллелизации, то, скорее всего, выполнять ее в потоке пользовательского интерфейса не следует.  Вместо этого такую операцию следует разгрузить, обеспечив ее выполнение в фоновом потоке. Например, если вы хотите использовать параллельный цикл для вычисления некоторых данных, которые будут затем предоставлены в элемент управления пользовательского интерфейса, рекомендуется выполнить цикл в экземпляре задачи, а не в самом обработчике событий пользовательского интерфейса.  Маршалировать обновление пользовательского интерфейса обратно в поток пользовательского интерфейса следует только после завершения основных вычислений.  
  
 При выполнении параллельных циклов в потоке пользовательского интерфейса следует избегать обновления элементов управления пользовательского интерфейса из цикла. Попытка обновить элементы управления пользовательского интерфейса из параллельного цикла, который выполняется в потоке пользовательского интерфейса, может привести к повреждению состояния, исключениям, отложенным обновлениям и даже взаимоблокировкам в зависимости от того, каким образом вызывается обновление пользовательского интерфейса. В следующем примере параллельный цикл блокирует поток пользовательского интерфейса, в котором он выполняется, до завершения всех итераций. Если же итерация цикла выполняется в фоновом потоке (как это может делать <xref:System.Threading.Tasks.Parallel.For%2A>), вызов метода Invoke приводит к передаче сообщения в поток пользовательского интерфейса и блокируется в ожидании обработки этого сообщения. Так как поток пользовательского интерфейса блокируется при выполнении <xref:System.Threading.Tasks.Parallel.For%2A>, сообщение никогда не будет обработано. Такая ситуация с потоком пользовательского интерфейса называется взаимоблокировкой.  
  
 [!code-csharp[TPL_Pitfalls#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#02)]
 [!code-vb[TPL_Pitfalls#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#02)]  
  
 В следующем примере показано, как избежать взаимоблокировки, выполнив цикл в экземпляре задачи. Цикл не блокирует поток пользовательского интерфейса целиком и не препятствует обработке сообщения.  
  
 [!code-csharp[TPL_Pitfalls#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#03)]
 [!code-vb[TPL_Pitfalls#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#03)]  
  
## <a name="see-also"></a>См. также

- [Параллельное программирование](../../../docs/standard/parallel-programming/index.md)
- [Возможные ошибки, связанные с PLINQ](../../../docs/standard/parallel-programming/potential-pitfalls-with-plinq.md)
- [Шаблоны параллельного программирования. Описание и применение в .NET Framework 4](https://www.microsoft.com/download/details.aspx?id=19222)
