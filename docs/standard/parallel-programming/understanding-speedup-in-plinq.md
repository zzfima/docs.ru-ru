---
title: Общее представление об ускорении выполнения в PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
ms.openlocfilehash: 07b5027d560a4caccc6c0a516c3f70c11df6be83
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73139905"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="59e0a-102">Общее представление об ускорении выполнения в PLINQ</span><span class="sxs-lookup"><span data-stu-id="59e0a-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="59e0a-103">Основное назначение PLINQ — ускорять обработку запросов LINQ to Objects на компьютерах с многоядерными процессорами, выполняя делегаты запроса в параллельном режиме.</span><span class="sxs-lookup"><span data-stu-id="59e0a-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="59e0a-104">Преимущества PLINQ проявляются лучше всего, когда обработка каждого элемента в исходной коллекции не зависит от других элементов и отдельные делегаты не используют общее состояние.</span><span class="sxs-lookup"><span data-stu-id="59e0a-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="59e0a-105">Такие операции достаточно часто встречаются в LINQ to Objects и PLINQ. Они являются *параллельными*, так как легко поддаются разделению на несколько потоков.</span><span class="sxs-lookup"><span data-stu-id="59e0a-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="59e0a-106">Но не все запросы состоят из таких параллельных операций. Очень часто запросы содержат некоторые операторы, которые не могут выполняться параллельно или существенно замедляют параллельное выполнение.</span><span class="sxs-lookup"><span data-stu-id="59e0a-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="59e0a-107">И даже для параллельных запросов PLINQ приходится выполнять дополнительную работу: разделять источники данных, распределять работу между потоками и (чаще всего) объединять результаты после обработки запроса.</span><span class="sxs-lookup"><span data-stu-id="59e0a-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="59e0a-108">Все эти дополнительные операции привносят *накладные расходы*, то есть повышают вычислительную стоимость параллелизации.</span><span class="sxs-lookup"><span data-stu-id="59e0a-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="59e0a-109">Чтобы добиться оптимальной производительности запросов PLINQ, нужно применять как можно больше параллельных элементов и свести к минимуму элементы, повышающих накладные расходы.</span><span class="sxs-lookup"><span data-stu-id="59e0a-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="59e0a-110">Эта статья содержит сведения, которые помогут вам создавать максимально эффективные запросы PLINQ, обеспечивая правильность результатов.</span><span class="sxs-lookup"><span data-stu-id="59e0a-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="59e0a-111">Факторы, влияющие на производительность запросов PLINQ</span><span class="sxs-lookup"><span data-stu-id="59e0a-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="59e0a-112">В следующих разделах перечисляются самые важные факторы, которые влияют на производительность параллельного выполнения запросов.</span><span class="sxs-lookup"><span data-stu-id="59e0a-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="59e0a-113">Это инструкции общего характера, которые нельзя использовать для прогнозирования производительности запросов во всех сценариях.</span><span class="sxs-lookup"><span data-stu-id="59e0a-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="59e0a-114">Для точной оценки нужно измерить фактическую производительность конкретных запросов на конкретных компьютерах в разных сочетаниях репрезентативных конфигураций и нагрузок.</span><span class="sxs-lookup"><span data-stu-id="59e0a-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1. <span data-ttu-id="59e0a-115">Вычислительная стоимость общей работы.</span><span class="sxs-lookup"><span data-stu-id="59e0a-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="59e0a-116">Чтобы ускорить обработку запросов PLINQ, нужен достаточный объем параллельных операций, позволяющий компенсировать накладные расходы.</span><span class="sxs-lookup"><span data-stu-id="59e0a-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="59e0a-117">Работу можно оценить как произведение вычислительной стоимости каждого делегата на число элементов в исходной коллекции.</span><span class="sxs-lookup"><span data-stu-id="59e0a-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="59e0a-118">Если операция допускает параллелизацию, потенциал ускорения напрямую зависит от ее вычислительной стоимости.</span><span class="sxs-lookup"><span data-stu-id="59e0a-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="59e0a-119">Например, если функция выполняется за одну миллисекунду, последовательный запрос к 1000 элементов будет выполняться около одной секунды. Параллельное выполнение этого же запроса на компьютере с четырьмя ядрами можно произвести всего за 250 миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="59e0a-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="59e0a-120">Таким образом, ускорение может составить 750 миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="59e0a-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="59e0a-121">Если же выполнение функции для каждого элемента занимает одну секунду, общее ускорение составит 750 секунд.</span><span class="sxs-lookup"><span data-stu-id="59e0a-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="59e0a-122">Если делегат является очень затратным, PLINQ может обеспечить значительное ускорение даже при небольшом размере исходной коллекции.</span><span class="sxs-lookup"><span data-stu-id="59e0a-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="59e0a-123">И наоборот, небольшие исходные коллекции в сочетании с элементарными делегатами не будут хорошими кандидатами для использования PLINQ.</span><span class="sxs-lookup"><span data-stu-id="59e0a-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="59e0a-124">Запрос queryA из следующего примера можно считать хорошим кандидатом для PLINQ, если его функция Select предусматривает много работы.</span><span class="sxs-lookup"><span data-stu-id="59e0a-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="59e0a-125">Запрос queryB вряд ли хорошо подходит для параллелизации, так как в его инструкции Select выполняется мало работы, и накладные расходы перевесят все возможное ускорение или значительную его часть.</span><span class="sxs-lookup"><span data-stu-id="59e0a-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2. <span data-ttu-id="59e0a-126">Число логических ядер в системе (степень параллелизма).</span><span class="sxs-lookup"><span data-stu-id="59e0a-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="59e0a-127">Это очевидное следствие всего, что мы обсуждали в предыдущем разделе — параллельные запросы работают быстрее на компьютерах, которые имеют больше ядер, так как работу можно разделить между большим числом параллельных потоков.</span><span class="sxs-lookup"><span data-stu-id="59e0a-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="59e0a-128">Общий эффект ускорения зависит от того, какой процент работы поддается распараллеливанию.</span><span class="sxs-lookup"><span data-stu-id="59e0a-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="59e0a-129">Но не следует полагать, что на компьютере с восемью ядрами все запросы будут выполняться в два раза быстрее,чем на компьютере с четырьмя ядрами.</span><span class="sxs-lookup"><span data-stu-id="59e0a-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="59e0a-130">При оптимизации производительности запросов важно измерить фактические результаты на компьютерах с разным количеством ядер.</span><span class="sxs-lookup"><span data-stu-id="59e0a-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="59e0a-131">Этот аспект напрямую связан с аспектом № 1: увеличение вычислительных ресурсов принесет больше пользы для крупных наборов данных.</span><span class="sxs-lookup"><span data-stu-id="59e0a-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3. <span data-ttu-id="59e0a-132">Число и типы операций.</span><span class="sxs-lookup"><span data-stu-id="59e0a-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="59e0a-133">Язык PLINQ предоставляет оператор AsOrdered для ситуаций, в которых важно поддерживать исходный порядок элементов в последовательности.</span><span class="sxs-lookup"><span data-stu-id="59e0a-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="59e0a-134">Упорядочение требует определенных затрат, но обычно они не очень велики.</span><span class="sxs-lookup"><span data-stu-id="59e0a-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="59e0a-135">Операции GroupBy и Join требуют затрат.</span><span class="sxs-lookup"><span data-stu-id="59e0a-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="59e0a-136">PLINQ работает лучше всего, если есть возможность обрабатывать элементы исходной коллекции в любом порядке и передавать результаты следующему оператору сразу по мере готовности.</span><span class="sxs-lookup"><span data-stu-id="59e0a-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="59e0a-137">Дополнительные сведения см. в разделе [Сохранение порядка в PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="59e0a-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4. <span data-ttu-id="59e0a-138">Форма выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="59e0a-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="59e0a-139">Если вы сохраняете результаты запроса вызовом ToArray или ToList, все результаты из всех параллельных потоков необходимо объединять в одну структуру данных.</span><span class="sxs-lookup"><span data-stu-id="59e0a-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="59e0a-140">С этим процессом связаны неизбежные вычислительные затраты.</span><span class="sxs-lookup"><span data-stu-id="59e0a-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="59e0a-141">Если же результаты просматриваются в цикле foreach (For Each в Visual Basic), результаты из рабочих потоков нужно сериализовать в поток-перечислитель.</span><span class="sxs-lookup"><span data-stu-id="59e0a-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="59e0a-142">Но если вам нужно лишь выполнить некоторую операцию над результатами каждого потока, вы можете использовать метод ForAll, поддерживающий многопоточное выполнение.</span><span class="sxs-lookup"><span data-stu-id="59e0a-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5. <span data-ttu-id="59e0a-143">Тип параметров слияния.</span><span class="sxs-lookup"><span data-stu-id="59e0a-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="59e0a-144">В PLINQ можно включить буферизацию, чтобы возвращать результаты блоками или целиком после завершения работы, или выводить каждый отдельный результат сразу по мере готовности.</span><span class="sxs-lookup"><span data-stu-id="59e0a-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="59e0a-145">Первый вариант уменьшает общее время выполнения, а второй снижает задержку до получения приостановленных элементов.</span><span class="sxs-lookup"><span data-stu-id="59e0a-145">The former results in decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="59e0a-146">Хотя параметры слияния не всегда значительно влияют на общую производительность запроса, они изменяют субъективное восприятие пользователя, так как от этого выбора напрямую зависит, сколько времени пользователю придется ждать до начала вывода результатов.</span><span class="sxs-lookup"><span data-stu-id="59e0a-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="59e0a-147">Дополнительные сведения см. в разделе [Параметры слияние в PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="59e0a-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6. <span data-ttu-id="59e0a-148">Тип секционирования.</span><span class="sxs-lookup"><span data-stu-id="59e0a-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="59e0a-149">В некоторых случаях запрос PLINQ по индексируемой исходной коллекции может привести к несбалансированности рабочей нагрузки.</span><span class="sxs-lookup"><span data-stu-id="59e0a-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="59e0a-150">В этом случае производительность запросов можно увеличить, добавив пользовательский модуль разделения.</span><span class="sxs-lookup"><span data-stu-id="59e0a-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="59e0a-151">Дополнительные сведения см. в разделе [Пользовательские разделители для PLINQ и TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="59e0a-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="59e0a-152">В каких случаях PLINQ выбирает последовательный режим</span><span class="sxs-lookup"><span data-stu-id="59e0a-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="59e0a-153">PLINQ всегда старается выполнять запрос по меньшей мере так же быстро, как если бы он выполнялся последовательно.</span><span class="sxs-lookup"><span data-stu-id="59e0a-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="59e0a-154">PLINQ не оценивает, сколько вычислительных ресурсов потребуется для пользовательских делегатов, и не учитывает размер источника входных данных, но проверяет некоторые характерные формы запросов.</span><span class="sxs-lookup"><span data-stu-id="59e0a-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="59e0a-155">В частности, определяется наличие в запросе некоторых операторов или их сочетаний, которые часто приводят к медленному выполнению в параллельном режиме.</span><span class="sxs-lookup"><span data-stu-id="59e0a-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="59e0a-156">Обнаружив некоторые из таких форм, PLINQ по умолчанию переходит в последовательный режим.</span><span class="sxs-lookup"><span data-stu-id="59e0a-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="59e0a-157">Но иногда, оценив производительность конкретного запроса, вы заметите, что он все таки выполняется быстрее в параллельном режиме.</span><span class="sxs-lookup"><span data-stu-id="59e0a-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="59e0a-158">В таких случаях можно использовать флаг <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> в методе <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>, чтобы принудительно указать для PLINQ параллельный режим выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="59e0a-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="59e0a-159">Дополнительные сведения см. в разделе [Практическое руководство. Задание режима выполнения в PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="59e0a-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="59e0a-160">В следующем списке описываются формы запросов, которые PLINQ по умолчанию будет выполнять в последовательном режиме.</span><span class="sxs-lookup"><span data-stu-id="59e0a-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
- <span data-ttu-id="59e0a-161">Запросы, содержащие предложение Select, а также индексированные инструкции Where, SelectMany или ElementAt после оператора упорядочивания или фильтрации, который удаляет или изменяет исходные индексы.</span><span class="sxs-lookup"><span data-stu-id="59e0a-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
- <span data-ttu-id="59e0a-162">Запросы, содержащие оператор Take, TakeWhile, Skip или SkipWhile, в которых индексы исходной последовательности не сохраняют исходный порядок.</span><span class="sxs-lookup"><span data-stu-id="59e0a-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
- <span data-ttu-id="59e0a-163">Запросы, которые содержат Zip или SequenceEquals, за исключением случаев, когда один из источников данных содержит изначально упорядоченный индекс, а другой источник данных можно проиндексировать (например, массив или IList(T)).</span><span class="sxs-lookup"><span data-stu-id="59e0a-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
- <span data-ttu-id="59e0a-164">Запросы, которые содержат оператор Concat, если он не применяется к индексируемым источникам данных.</span><span class="sxs-lookup"><span data-stu-id="59e0a-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
- <span data-ttu-id="59e0a-165">Запросы, содержащие оператор Reverse, если он не применяется к индексируемым источникам данных.</span><span class="sxs-lookup"><span data-stu-id="59e0a-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="59e0a-166">См. также</span><span class="sxs-lookup"><span data-stu-id="59e0a-166">See also</span></span>

- [<span data-ttu-id="59e0a-167">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="59e0a-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
