---
title: Введение в PLINQ
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, introduction to
ms.assetid: eaa720d8-8999-4eb7-8df5-3c19ca61cad0
ms.openlocfilehash: 938bae09eab4e95c0ec875a8681cc276325b976b
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73129045"
---
# <a name="introduction-to-plinq"></a><span data-ttu-id="bf7e4-102">Введение в PLINQ</span><span class="sxs-lookup"><span data-stu-id="bf7e4-102">Introduction to PLINQ</span></span>

## <a name="what-is-a-parallel-query"></a><span data-ttu-id="bf7e4-103">Что такое параллельный запрос?</span><span class="sxs-lookup"><span data-stu-id="bf7e4-103">What is a Parallel Query?</span></span>

<span data-ttu-id="bf7e4-104">Встроенный язык запросов (LINQ) был впервые представлен в .NET Framework 3.5.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-104">Language-Integrated Query (LINQ) was introduced in the .NET Framework 3.5.</span></span> <span data-ttu-id="bf7e4-105">Он поддерживает унифицированную модель для запросов к любому источнику данных <xref:System.Collections.IEnumerable?displayProperty=nameWithType> или <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> типобезопасным образом.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-105">It features a unified model for querying any <xref:System.Collections.IEnumerable?displayProperty=nameWithType> or <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> data source in a type-safe manner.</span></span> <span data-ttu-id="bf7e4-106">LINQ to Objects — это запросы LINQ, выполняемые с коллекциями в памяти (например, <xref:System.Collections.Generic.List%601>) или массивами.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-106">LINQ to Objects is the name for LINQ queries that are run against in-memory collections such as <xref:System.Collections.Generic.List%601> and arrays.</span></span> <span data-ttu-id="bf7e4-107">В этой статье предполагается, что у вас уже есть общие представления о LINQ.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-107">This article assumes that you have a basic understanding of LINQ.</span></span> <span data-ttu-id="bf7e4-108">Дополнительные сведения см. в разделе [LINQ — C#](../../csharp/programming-guide/concepts/linq/index.md) или [LINQ — Visual Basic](../../visual-basic/programming-guide/concepts/linq/index.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-108">For more information, see [Language-Integrated Query (LINQ) - C#](../../csharp/programming-guide/concepts/linq/index.md) or [Language-Integrated Query (LINQ) - Visual Basic](../../visual-basic/programming-guide/concepts/linq/index.md).</span></span>

<span data-ttu-id="bf7e4-109">Parallel LINQ (PLINQ) является параллельной реализацией шаблона LINQ.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-109">Parallel LINQ (PLINQ) is a parallel implementation of the LINQ pattern.</span></span> <span data-ttu-id="bf7e4-110">Запрос PLINQ во многом напоминает непараллельный запрос LINQ to Objects.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-110">A PLINQ query in many ways resembles a non-parallel LINQ to Objects query.</span></span> <span data-ttu-id="bf7e4-111">Запросы PLINQ, как и последовательные запросы [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)], работают с любым источником данных <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601> в памяти и поддерживают отложенное выполнение, т. е. выполнение только по завершении перечисления запроса.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-111">PLINQ queries, just like sequential [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)] queries, operate on any in-memory <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> data source, and have deferred execution, which means they do not begin executing until the query is enumerated.</span></span> <span data-ttu-id="bf7e4-112">Основное различие состоит в том, что PLINQ пытается задействовать сразу все процессоры в системе.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-112">The primary difference is that PLINQ attempts to make full use of all the processors on the system.</span></span> <span data-ttu-id="bf7e4-113">Для этого он разбивает источник данных на сегменты, а затем запрашивается каждый сегмент в отдельном рабочем потоке сразу, используя сразу несколько процессоров.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-113">It does this by partitioning the data source into segments, and then executing the query on each segment on separate worker threads in parallel on multiple processors.</span></span> <span data-ttu-id="bf7e4-114">Во многих случаях параллельное выполнение значительно сокращает время выполнения запроса.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-114">In many cases, parallel execution means that the query runs significantly faster.</span></span>

<span data-ttu-id="bf7e4-115">Благодаря параллельному выполнению PLINQ позволяет существенно повысить производительность некоторых видов запросов по сравнению с устаревшим кодом. Часто для этого достаточно добавить к источнику данных оператор запроса <xref:System.Linq.ParallelEnumerable.AsParallel%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-115">Through parallel execution, PLINQ can achieve significant performance improvements over legacy code for certain kinds of queries, often just by adding the <xref:System.Linq.ParallelEnumerable.AsParallel%2A> query operation to the data source.</span></span> <span data-ttu-id="bf7e4-116">Тем не менее параллелизм может представлять свои собственные сложности, и не все операции запросов в PLINQ выполняются быстрее.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-116">However, parallelism can introduce its own complexities, and not all query operations run faster in PLINQ.</span></span> <span data-ttu-id="bf7e4-117">Некоторые запросы при применении параллелизма только замедляются.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-117">In fact, parallelization actually slows down certain queries.</span></span> <span data-ttu-id="bf7e4-118">В связи с этим необходимо понимать, как влияют на параллельные запросы такие аспекты, как упорядочение.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-118">Therefore, you should understand how issues such as ordering affect parallel queries.</span></span> <span data-ttu-id="bf7e4-119">Дополнительные сведения см. в разделе [Общее представление об ускорении выполнения в PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-119">For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).</span></span>

> [!NOTE]
> <span data-ttu-id="bf7e4-120">В этой документации для определения делегатов в PLINQ используются лямбда-выражения.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-120">This documentation uses lambda expressions to define delegates in PLINQ.</span></span> <span data-ttu-id="bf7e4-121">Если вы не знакомы с лямбда-выражениями в C# или Visual Basic, см. раздел [Лямбда-выражения в PLINQ и TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-121">If you are not familiar with lambda expressions in C# or Visual Basic, see [Lambda Expressions in PLINQ and TPL](../../../docs/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl.md).</span></span>

<span data-ttu-id="bf7e4-122">Далее в этой статье приводится обзор основных классов PLINQ и обсуждаются способы создания запросов PLINQ.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-122">The remainder of this article gives an overview of the main PLINQ classes, and discusses how to create PLINQ queries.</span></span> <span data-ttu-id="bf7e4-123">Каждый раздел содержит ссылки на более подробные сведения и примеры кода.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-123">Each section contains links to more detailed information and code examples.</span></span>

## <a name="the-parallelenumerable-class"></a><span data-ttu-id="bf7e4-124">Класс ParallelEnumerable</span><span class="sxs-lookup"><span data-stu-id="bf7e4-124">The ParallelEnumerable Class</span></span>

<span data-ttu-id="bf7e4-125">Класс <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> предоставляет почти все функциональные возможности PLINQ.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-125">The <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> class exposes almost all of PLINQ's functionality.</span></span> <span data-ttu-id="bf7e4-126">Этот класс и остальные типы пространства имен <xref:System.Linq?displayProperty=nameWithType> компилируются в сборку System.Core.dll.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-126">It and the rest of the <xref:System.Linq?displayProperty=nameWithType> namespace types are compiled into the System.Core.dll assembly.</span></span> <span data-ttu-id="bf7e4-127">Проекты C# и Visual Basic по умолчанию в Visual Studio ссылаются на сборку и импортируют пространство имен.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-127">The default C# and Visual Basic projects in Visual Studio both reference the assembly and import the namespace.</span></span>

<span data-ttu-id="bf7e4-128"><xref:System.Linq.ParallelEnumerable> содержит реализации всех стандартных операторов запроса, поддерживаемых LINQ to Objects, но не все из них пытается выполнять параллельно.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-128"><xref:System.Linq.ParallelEnumerable> includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one.</span></span> <span data-ttu-id="bf7e4-129">Если вы не знакомы с [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)], см. разделы [Введение в LINQ (C#)](../../csharp/programming-guide/concepts/linq/index.md) и [Введение в LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-129">If you are not familiar with [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)], see [Introduction to LINQ (C#)](../../csharp/programming-guide/concepts/linq/index.md) and [Introduction to LINQ (Visual Basic)](../../visual-basic/programming-guide/concepts/linq/introduction-to-linq.md).</span></span>

<span data-ttu-id="bf7e4-130">Помимо стандартных операторов запроса, класс <xref:System.Linq.ParallelEnumerable> содержит набор методов для реализации функций, характерных для параллельного выполнения.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-130">In addition to the standard query operators, the <xref:System.Linq.ParallelEnumerable> class contains a set of methods that enable behaviors specific to parallel execution.</span></span> <span data-ttu-id="bf7e4-131">Методы, характерные для PLINQ, перечислены в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-131">These PLINQ-specific methods are listed in the following table.</span></span>

|<span data-ttu-id="bf7e4-132">Класс ParallelEnumerable</span><span class="sxs-lookup"><span data-stu-id="bf7e4-132">ParallelEnumerable Operator</span></span>|<span data-ttu-id="bf7e4-133">ОПИСАНИЕ</span><span class="sxs-lookup"><span data-stu-id="bf7e4-133">Description</span></span>|
|---------------------------------|-----------------|
|<xref:System.Linq.ParallelEnumerable.AsParallel%2A>|<span data-ttu-id="bf7e4-134">Точка входа для PLINQ.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-134">The entry point for PLINQ.</span></span> <span data-ttu-id="bf7e4-135">Указывает, что по возможности остальная часть запроса должна быть параллелизована.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-135">Specifies that the rest of the query should be parallelized, if it is possible.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsSequential%2A>|<span data-ttu-id="bf7e4-136">Указывает, что остальная часть запроса должна выполняться последовательно, как непараллельный запрос LINQ.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-136">Specifies that the rest of the query should be run sequentially, as a non-parallel LINQ query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsOrdered%2A>|<span data-ttu-id="bf7e4-137">Указывает, что PLINQ должен сохранить порядок исходной последовательности до конца запроса либо до тех пор, пока порядок не изменится, что может произойти, например, при использовании предложения orderby (Order By в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-137">Specifies that PLINQ should preserve the ordering of the source sequence for the rest of the query, or until the ordering is changed, for example by the use of an orderby (Order By in Visual Basic) clause.</span></span>|
|<xref:System.Linq.ParallelEnumerable.AsUnordered%2A>|<span data-ttu-id="bf7e4-138">Указывает, что PLINQ для остальной части запроса не обязан сохранять порядок исходной последовательности.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-138">Specifies that PLINQ for the rest of the query is not required to preserve the ordering of the source sequence.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithCancellation%2A>|<span data-ttu-id="bf7e4-139">Указывает, что PLINQ должен периодически отслеживать состояние предоставленного токена отмены и отменить выполнение, если он будет запрошен.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-139">Specifies that PLINQ should periodically monitor the state of the provided cancellation token and cancel execution if it is requested.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A>|<span data-ttu-id="bf7e4-140">Указывает максимальное количество процессоров, которое PLINQ должен использовать для параллелизации запроса.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-140">Specifies the maximum number of processors that PLINQ should use to parallelize the query.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A>|<span data-ttu-id="bf7e4-141">Предоставляет подсказку о том, каким образом PLINQ должен объединять параллельные результаты в одну последовательность в потоке-потребителе, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-141">Provides a hint about how PLINQ should, if it is possible, merge parallel results back into just one sequence on the consuming thread.</span></span>|
|<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>|<span data-ttu-id="bf7e4-142">Указывает, должен ли PLINQ параллелизовать запрос, даже если по умолчанию он должен выполняться последовательно.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-142">Specifies whether PLINQ should parallelize the query even when the default behavior would be to run it sequentially.</span></span>|
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="bf7e4-143">Многопоточный метод перечисления в отличие от итерации результатов запроса может обрабатываться параллельно без предварительного объединения с потоком-потребителем.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-143">A multithreaded enumeration method that, unlike iterating over the results of the query, enables results to be processed in parallel without first merging back to the consumer thread.</span></span>|
|<span data-ttu-id="bf7e4-144">Перегрузка <xref:System.Linq.ParallelEnumerable.Aggregate%2A></span><span class="sxs-lookup"><span data-stu-id="bf7e4-144"><xref:System.Linq.ParallelEnumerable.Aggregate%2A> overload</span></span>|<span data-ttu-id="bf7e4-145">Перегрузка, которая является уникальной для PLINQ и обеспечивает промежуточное агрегирование локальных разделов потока, а также функцию окончательного агрегирования, позволяющую объединять результаты всех разделов.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-145">An overload that is unique to PLINQ and enables intermediate aggregation over thread-local partitions, plus a final aggregation function to combine the results of all partitions.</span></span>|

## <a name="the-opt-in-model"></a><span data-ttu-id="bf7e4-146">Модель с явным согласием</span><span class="sxs-lookup"><span data-stu-id="bf7e4-146">The Opt-in Model</span></span>

<span data-ttu-id="bf7e4-147">Когда вы создаете запрос, подтвердите согласие на использование PLINQ вызовом метода расширения <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> для источника данных, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-147">When you write a query, opt in to PLINQ by invoking the <xref:System.Linq.ParallelEnumerable.AsParallel%2A?displayProperty=nameWithType> extension method on the data source, as shown in the following example.</span></span>

[!code-csharp[PLINQ#1](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#1)]
[!code-vb[PLINQ#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#1)]

<span data-ttu-id="bf7e4-148">Метод расширения <xref:System.Linq.ParallelEnumerable.AsParallel%2A> привязывает последующие операторы запросов (в нашем примере это `where` и `select`) к реализациям <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-148">The <xref:System.Linq.ParallelEnumerable.AsParallel%2A> extension method binds the subsequent query operators, in this case, `where` and `select`, to the <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> implementations.</span></span>

## <a name="execution-modes"></a><span data-ttu-id="bf7e4-149">Режимы выполнения</span><span class="sxs-lookup"><span data-stu-id="bf7e4-149">Execution Modes</span></span>

<span data-ttu-id="bf7e4-150">По умолчанию PLINQ является консервативным.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-150">By default, PLINQ is conservative.</span></span> <span data-ttu-id="bf7e4-151">Во время выполнения инфраструктура PLINQ анализирует общую структуру запроса.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-151">At run time, the PLINQ infrastructure analyzes the overall structure of the query.</span></span> <span data-ttu-id="bf7e4-152">Если параллелизация может ускорить выполнение запроса, PLINQ разбивает исходную последовательность на задачи, которые выполняются одновременно.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-152">If the query is likely to yield speedups by parallelization, PLINQ partitions the source sequence into tasks that can be run concurrently.</span></span> <span data-ttu-id="bf7e4-153">Если параллелизовать запрос небезопасно, PLINQ просто выполняет его последовательно.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-153">If it is not safe to parallelize a query, PLINQ just runs the query sequentially.</span></span> <span data-ttu-id="bf7e4-154">Если PLINQ может выбирать между потенциально затратным параллельным алгоритмом или нетребовательным последовательным алгоритмом, по умолчанию он выбирает алгоритм последовательной обработки.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-154">If PLINQ has a choice between a potentially expensive parallel algorithm or an inexpensive sequential algorithm, it chooses the sequential algorithm by default.</span></span> <span data-ttu-id="bf7e4-155">Метод <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> и перечисление <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> позволяют указать, что PLINQ следует выбрать параллельный алгоритм.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-155">You can use the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method and the <xref:System.Linq.ParallelExecutionMode?displayProperty=nameWithType> enumeration to instruct PLINQ to select the parallel algorithm.</span></span> <span data-ttu-id="bf7e4-156">Это пригодится в том случае, если тестирование и измерение показали, что в параллельном режиме определенный запрос будет выполнять быстрее.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-156">This is useful when you know by testing and measurement that a particular query executes faster in parallel.</span></span> <span data-ttu-id="bf7e4-157">Дополнительные сведения см. в разделе [Практическое руководство. Задание режима выполнения в PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-157">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>

## <a name="degree-of-parallelism"></a><span data-ttu-id="bf7e4-158">Степень параллелизма</span><span class="sxs-lookup"><span data-stu-id="bf7e4-158">Degree of Parallelism</span></span>

<span data-ttu-id="bf7e4-159">По умолчанию PLINQ использует все процессоры на главном компьютере.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-159">By default, PLINQ uses all of the processors on the host computer.</span></span> <span data-ttu-id="bf7e4-160">Вы можете ограничить число процессоров, используемых PLINQ, с помощью метода <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-160">You can instruct PLINQ to use no more than a specified number of processors by using the <xref:System.Linq.ParallelEnumerable.WithDegreeOfParallelism%2A> method.</span></span> <span data-ttu-id="bf7e4-161">Это пригодится в том случае, если вам нужно, чтобы другие процессы, выполняемые на том же компьютере, получали определенное количество процессорного времени.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-161">This is useful when you want to make sure that other processes running on the computer receive a certain amount of CPU time.</span></span> <span data-ttu-id="bf7e4-162">Следующий фрагмент кода позволяет запросу использовать не более двух процессоров.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-162">The following snippet limits the query to utilizing a maximum of two processors.</span></span>

[!code-csharp[PLINQ#5](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#5)]
[!code-vb[PLINQ#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#5)]

<span data-ttu-id="bf7e4-163">В случаях, когда запрос выполняет значительный объем работы, не связанной с вычислениями, такой как ввод-вывод файлов, степень параллелизма может быть больше количества ядер на соответствующем компьютере.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-163">In cases where a query is performing a significant amount of non-compute-bound work such as File I/O, it might be beneficial to specify a degree of parallelism greater than the number of cores on the machine.</span></span>

## <a name="ordered-versus-unordered-parallel-queries"></a><span data-ttu-id="bf7e4-164">Упорядоченные и неупорядоченные параллельные запросы</span><span class="sxs-lookup"><span data-stu-id="bf7e4-164">Ordered Versus Unordered Parallel Queries</span></span>

<span data-ttu-id="bf7e4-165">В некоторых случаях оператор запроса должен выдавать результаты с сохранением порядка исходной последовательности.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-165">In some queries, a query operator must produce results that preserve the ordering of the source sequence.</span></span> <span data-ttu-id="bf7e4-166">Для этого PLINQ предоставляет оператор <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-166">PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator for this purpose.</span></span> <span data-ttu-id="bf7e4-167"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> отличается от <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-167"><xref:System.Linq.ParallelEnumerable.AsOrdered%2A> is distinct from <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span></span> <span data-ttu-id="bf7e4-168">Последовательность <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> по-прежнему обрабатывается параллельно, но ее результаты помещаются в буфер и сортируются.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-168">An <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence is still processed in parallel, but its results are buffered and sorted.</span></span> <span data-ttu-id="bf7e4-169">Поскольку сохранение порядка обычно требует дополнительной работы, последовательность <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> может обрабатываться медленнее, чем стандартная последовательность <xref:System.Linq.ParallelEnumerable.AsUnordered%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-169">Because order preservation typically involves extra work, an <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> sequence might be processed more slowly than the default <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> sequence.</span></span> <span data-ttu-id="bf7e4-170">Будет ли та или иная упорядоченная параллельная операция выполняться быстрее, чем ее последовательная версия, зависит от многих факторов.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-170">Whether a particular ordered parallel operation is faster than a sequential version of the operation depends on many factors.</span></span>

<span data-ttu-id="bf7e4-171">В следующем примере кода показано, как разрешить сохранение порядка.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-171">The following code example shows how to opt in to order preservation.</span></span>

[!code-csharp[PLINQ#3](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#3)]
[!code-vb[PLINQ#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#3)]

<span data-ttu-id="bf7e4-172">Дополнительные сведения см. в разделе [Сохранение порядка в PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-172">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>

## <a name="parallel-vs-sequential-queries"></a><span data-ttu-id="bf7e4-173">Сравнение параллельных и последовательных запросов</span><span class="sxs-lookup"><span data-stu-id="bf7e4-173">Parallel vs. Sequential Queries</span></span>

<span data-ttu-id="bf7e4-174">Некоторые операции требуют, чтобы исходные данные доставлялись последовательно.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-174">Some operations require that the source data be delivered in a sequential manner.</span></span> <span data-ttu-id="bf7e4-175">При необходимости операторы запроса <xref:System.Linq.ParallelEnumerable> автоматически переходят в последовательный режим.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-175">The <xref:System.Linq.ParallelEnumerable> query operators revert to sequential mode automatically when it is required.</span></span> <span data-ttu-id="bf7e4-176">Для пользовательских операторов запроса и делегатов, которые требуют последовательного выполнения, PLINQ предоставляет метод <xref:System.Linq.ParallelEnumerable.AsSequential%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-176">For user-defined query operators and user delegates that require sequential execution, PLINQ provides the <xref:System.Linq.ParallelEnumerable.AsSequential%2A> method.</span></span> <span data-ttu-id="bf7e4-177">При использовании метода <xref:System.Linq.ParallelEnumerable.AsSequential%2A> все операторы, содержащиеся в запросе, будут выполняться последовательно вплоть до следующего вызова <xref:System.Linq.ParallelEnumerable.AsParallel%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-177">When you use <xref:System.Linq.ParallelEnumerable.AsSequential%2A>, all subsequent operators in the query are executed sequentially until <xref:System.Linq.ParallelEnumerable.AsParallel%2A> is called again.</span></span> <span data-ttu-id="bf7e4-178">Дополнительные сведения см. в разделе [Практическое руководство. Объединение параллельных и последовательных запросов LINQ](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-178">For more information, see [How to: Combine Parallel and Sequential LINQ Queries](../../../docs/standard/parallel-programming/how-to-combine-parallel-and-sequential-linq-queries.md).</span></span>

## <a name="options-for-merging-query-results"></a><span data-ttu-id="bf7e4-179">Параметры для слияния результатов запроса</span><span class="sxs-lookup"><span data-stu-id="bf7e4-179">Options for Merging Query Results</span></span>

<span data-ttu-id="bf7e4-180">При параллельном выполнении запроса PLINQ его результаты из каждого рабочего потока должны быть снова объединены с основным потоком для использования циклом `foreach` (`For Each` в Visual Basic) либо вставки в список или массив.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-180">When a PLINQ query executes in parallel, its results from each worker thread must be merged back onto the main thread for consumption by a `foreach` loop (`For Each` in Visual Basic), or insertion into a list or array.</span></span> <span data-ttu-id="bf7e4-181">В некоторых случаях может быть полезно указать конкретный вид операции слияния, например для того, чтобы получать результаты быстрее.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-181">In some cases, it might be beneficial to specify a particular kind of merge operation, for example, to begin producing results more quickly.</span></span> <span data-ttu-id="bf7e4-182">Для этого PLINQ поддерживает метод <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> и перечисление <xref:System.Linq.ParallelMergeOptions>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-182">For this purpose, PLINQ supports the <xref:System.Linq.ParallelEnumerable.WithMergeOptions%2A> method, and the <xref:System.Linq.ParallelMergeOptions> enumeration.</span></span> <span data-ttu-id="bf7e4-183">Дополнительные сведения см. в разделе [Параметры слияние в PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-183">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>

## <a name="the-forall-operator"></a><span data-ttu-id="bf7e4-184">Оператор ForAll</span><span class="sxs-lookup"><span data-stu-id="bf7e4-184">The ForAll Operator</span></span>

<span data-ttu-id="bf7e4-185">В последовательных запросах [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)] выполнение откладывается до того момента, когда завершится перечисление запроса в цикле `foreach` (`For Each` в Visual Basic) или будет вызван метод <xref:System.Linq.ParallelEnumerable.ToList%2A>, <xref:System.Linq.ParallelEnumerable.ToArray%2A> или <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-185">In sequential [!INCLUDE[vbteclinq](../../../includes/vbteclinq-md.md)] queries, execution is deferred until the query is enumerated either in a `foreach` (`For Each` in Visual Basic) loop or by invoking a method such as <xref:System.Linq.ParallelEnumerable.ToList%2A> , <xref:System.Linq.ParallelEnumerable.ToArray%2A> , or <xref:System.Linq.ParallelEnumerable.ToDictionary%2A>.</span></span> <span data-ttu-id="bf7e4-186">Кроме того, для выполнения запроса и итерации результатов в PLINQ можно использовать `foreach`.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-186">In PLINQ, you can also use `foreach` to execute the query and iterate through the results.</span></span> <span data-ttu-id="bf7e4-187">При этом сам оператор `foreach` параллельно не выполняется, а значит результаты всех параллельных задач необходимо снова объединить с тем потоком, в котором выполняется цикл.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-187">However, `foreach` itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running.</span></span> <span data-ttu-id="bf7e4-188">Оператор `foreach` можно использовать в PLINQ, если вам нужно сохранить окончательный порядок результатов запроса, а также при любой последовательной обработке результатов (например, при вызове `Console.WriteLine` для каждого элемента).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-188">In PLINQ, you can use `foreach` when you must preserve the final ordering of the query results, and also whenever you are processing the results in a serial manner, for example when you are calling `Console.WriteLine` for each element.</span></span> <span data-ttu-id="bf7e4-189">Чтобы ускорить выполнение запроса в ситуации, когда сохранение порядка не требуется и обработка результатов допускает параллелизацию, используйте для выполнения запроса PLINQ метод <xref:System.Linq.ParallelEnumerable.ForAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-189">For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method to execute a PLINQ query.</span></span> <span data-ttu-id="bf7e4-190"><xref:System.Linq.ParallelEnumerable.ForAll%2A> не выполняет этот заключительный шаг слияния.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-190"><xref:System.Linq.ParallelEnumerable.ForAll%2A> does not perform this final merge step.</span></span> <span data-ttu-id="bf7e4-191">В следующем примере кода показано применение метода <xref:System.Linq.ParallelEnumerable.ForAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-191">The following code example shows how to use the <xref:System.Linq.ParallelEnumerable.ForAll%2A> method.</span></span> <span data-ttu-id="bf7e4-192"><xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> используется здесь потому, что он оптимизирован для одновременного добавления данных из нескольких потоков и не пытается удалять элементы.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-192"><xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> is used here because it is optimized for multiple threads adding concurrently without attempting to remove any items.</span></span>

[!code-csharp[PLINQ#4](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#4)]
[!code-vb[PLINQ#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#4)]

<span data-ttu-id="bf7e4-193">Ниже демонстрируется разница между `foreach` и <xref:System.Linq.ParallelEnumerable.ForAll%2A> в выполнении запросов.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-193">The following illustration shows the difference between `foreach` and <xref:System.Linq.ParallelEnumerable.ForAll%2A> with regard to query execution.</span></span>

<span data-ttu-id="bf7e4-194">![Сравнение ForAll и ForEach](../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span><span class="sxs-lookup"><span data-stu-id="bf7e4-194">![ForAll vs. ForEach](../../../docs/standard/parallel-programming/media/vs-isvnt-allvseach.png "VS_ISVNT_ALLvsEACH")</span></span>

## <a name="cancellation"></a><span data-ttu-id="bf7e4-195">Отмена</span><span class="sxs-lookup"><span data-stu-id="bf7e4-195">Cancellation</span></span>

<span data-ttu-id="bf7e4-196">PLINQ интегрирован с типами отмены в .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-196">PLINQ is integrated with the cancellation types in .NET Framework 4.</span></span> <span data-ttu-id="bf7e4-197">(Дополнительные сведения см. в разделе [Отмена в управляемых потоках](../../../docs/standard/threading/cancellation-in-managed-threads.md).) Это значит, что в отличие от последовательных запросов LINQ to Objects запросы PLINQ можно отменять.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-197">(For more information, see [Cancellation in Managed Threads](../../../docs/standard/threading/cancellation-in-managed-threads.md).) Therefore, unlike sequential LINQ to Objects queries, PLINQ queries can be canceled.</span></span> <span data-ttu-id="bf7e4-198">Чтобы создать запрос PLINQ с возможностью отмены, примените в запросе оператор <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> и предоставьте ему экземпляр <xref:System.Threading.CancellationToken> в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-198">To create a cancelable PLINQ query, use the <xref:System.Linq.ParallelEnumerable.WithCancellation%2A> operator on the query and provide a <xref:System.Threading.CancellationToken> instance as the argument.</span></span> <span data-ttu-id="bf7e4-199">Когда свойство <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> для маркера примет значение TRUE, PLINQ заметит это и остановит обработку всех потоков, а затем создаст исключение <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-199">When the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property on the token is set to true, PLINQ will notice it, stop processing on all threads, and throw an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="bf7e4-200">Существует вероятность, что запрос PLINQ продолжит обработку некоторых элементов после того, как будет задан маркер отмены.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-200">It is possible that a PLINQ query might continue to process some elements after the cancellation token is set.</span></span>

<span data-ttu-id="bf7e4-201">Для повышения скорости реагирования можно также отвечать на запросы отмены в пользовательских делегатах, выполняемых долгое время.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-201">For greater responsiveness, you can also respond to cancellation requests in long-running user delegates.</span></span> <span data-ttu-id="bf7e4-202">Дополнительные сведения см. в разделе [Практическое руководство. Отмена запроса PLINQ](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-202">For more information, see [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>

## <a name="exceptions"></a><span data-ttu-id="bf7e4-203">Исключения</span><span class="sxs-lookup"><span data-stu-id="bf7e4-203">Exceptions</span></span>

<span data-ttu-id="bf7e4-204">При выполнении запроса PLINQ могут быть одновременно выданы сразу несколько исключений из разных потоков.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-204">When a PLINQ query executes, multiple exceptions might be thrown from different threads simultaneously.</span></span> <span data-ttu-id="bf7e4-205">Кроме того, код для обработки исключения может находиться не в том потоке, где находится код, который вызвал исключение.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-205">Also, the code to handle the exception might be on a different thread than the code that threw the exception.</span></span> <span data-ttu-id="bf7e4-206">С помощью типа <xref:System.AggregateException> PLINQ инкапсулирует все исключения, созданные запросом, и маршалирует эти исключения в вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-206">PLINQ uses the <xref:System.AggregateException> type to encapsulate all the exceptions that were thrown by a query, and marshal those exceptions back to the calling thread.</span></span> <span data-ttu-id="bf7e4-207">В вызывающем потоке должен присутствовать только один блок try-catch.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-207">On the calling thread, only one try-catch block is required.</span></span> <span data-ttu-id="bf7e4-208">Но в нем вы можете последовательно просмотреть все инкапсулированные в <xref:System.AggregateException>исключения и обработать те из них, которые допускают безопасное восстановление.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-208">However, you can iterate through all of the exceptions that are encapsulated in the <xref:System.AggregateException> and catch any that you can safely recover from.</span></span> <span data-ttu-id="bf7e4-209">В редких случаях могут создаваться исключения, не упакованные в <xref:System.AggregateException>. Также этот механизм не применяется для <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-209">In rare cases, some exceptions may be thrown that are not wrapped in an <xref:System.AggregateException>, and <xref:System.Threading.ThreadAbortException>s  are also not wrapped.</span></span>

<span data-ttu-id="bf7e4-210">Если исключения могут всплывать обратно в присоединяемый поток, запрос может продолжить обработку некоторых элементов после создания исключения.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-210">When exceptions are allowed to bubble up back to the joining thread, then it is possible that a query may continue to process some items after the exception is raised.</span></span>

<span data-ttu-id="bf7e4-211">Дополнительные сведения см. в разделе [Практическое руководство. Обработка исключений в запросе PLINQ](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-211">For more information, see [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="bf7e4-212">Пользовательские разделители</span><span class="sxs-lookup"><span data-stu-id="bf7e4-212">Custom Partitioners</span></span>

<span data-ttu-id="bf7e4-213">В некоторых случаях производительность запросов можно улучшить, написав пользовательский модуль разделения, который использует преимущества некоторых характеристик исходных данных.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-213">In some cases, you can improve query performance by writing a custom partitioner that takes advantage of some characteristic of the source data.</span></span> <span data-ttu-id="bf7e4-214">В запросе сам пользовательский модуль разделения является запрашиваемым перечислимым объектом.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-214">In the query, the custom partitioner itself is the enumerable object that is queried.</span></span>

[!code-csharp[PLINQ#2](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinq2_cs.cs#2)]
[!code-vb[PLINQ#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq3.vb#2)]

<span data-ttu-id="bf7e4-215">PLINQ поддерживает фиксированное количество разделов (хотя для балансировки нагрузки данные могут динамически переназначаться этим разделам во время выполнения).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-215">PLINQ supports a fixed number of partitions (although data may be dynamically reassigned to those partitions during run time for load balancing.).</span></span> <span data-ttu-id="bf7e4-216"><xref:System.Threading.Tasks.Parallel.For%2A> и <xref:System.Threading.Tasks.Parallel.ForEach%2A> поддерживают только динамическое секционирование, а значит количество секций может изменяться во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-216"><xref:System.Threading.Tasks.Parallel.For%2A> and <xref:System.Threading.Tasks.Parallel.ForEach%2A> support only dynamic partitioning, which means that the number of partitions changes at run time.</span></span> <span data-ttu-id="bf7e4-217">Дополнительные сведения см. в разделе [Пользовательские разделители для PLINQ и TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-217">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>

## <a name="measuring-plinq-performance"></a><span data-ttu-id="bf7e4-218">Измерение производительности PLINQ</span><span class="sxs-lookup"><span data-stu-id="bf7e4-218">Measuring PLINQ Performance</span></span>

<span data-ttu-id="bf7e4-219">Во многих случаях запрос может выполняться параллельно, но на настройку параллельного запроса уходит больше времени, чем будет выиграно в результате.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-219">In many cases, a query can be parallelized, but the overhead of setting up the parallel query outweighs the performance benefit gained.</span></span> <span data-ttu-id="bf7e4-220">Если запрос не выполняет большой объем вычислений или источник данных небольшой, запрос PLINQ может быть медленнее, чем последовательный запрос LINQ to Objects.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-220">If a query does not perform much computation or if the data source is small, a PLINQ query may be slower than a sequential LINQ to Objects query.</span></span> <span data-ttu-id="bf7e4-221">Анализатор параллельной производительности в Visual Studio Team Server позволяет сравнивать производительность различных запросов и таким образом выявлять проблемы обработки и определять, выполняется ли запрос параллельно или последовательно.</span><span class="sxs-lookup"><span data-stu-id="bf7e4-221">You can use the Parallel Performance Analyzer in Visual Studio Team Server to compare the performance of various queries, to locate processing bottlenecks, and to determine whether your query is running in parallel or sequentially.</span></span> <span data-ttu-id="bf7e4-222">Дополнительные сведения см. в статье [Визуализатор параллелизма](/visualstudio/profiling/concurrency-visualizer) и [Практическое руководство. Измерение производительности запросов PLINQ](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md).</span><span class="sxs-lookup"><span data-stu-id="bf7e4-222">For more information, see [Concurrency Visualizer](/visualstudio/profiling/concurrency-visualizer) and [How to: Measure PLINQ Query Performance](../../../docs/standard/parallel-programming/how-to-measure-plinq-query-performance.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="bf7e4-223">См. также</span><span class="sxs-lookup"><span data-stu-id="bf7e4-223">See also</span></span>

- [<span data-ttu-id="bf7e4-224">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="bf7e4-224">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
- [<span data-ttu-id="bf7e4-225">Общее представление об ускорении выполнения в PLINQ</span><span class="sxs-lookup"><span data-stu-id="bf7e4-225">Understanding Speedup in PLINQ</span></span>](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)
