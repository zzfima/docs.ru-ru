---
title: Вызов неуправляемого кода (P/Invoke)
description: Сведения о вызове собственных функций с помощью P/Invoke в .NET.
ms.date: 01/18/2019
ms.openlocfilehash: fa8b43edfba50fbc620f257c4e7caf1673f83235
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75706309"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="c1811-103">Вызов неуправляемого кода (P/Invoke)</span><span class="sxs-lookup"><span data-stu-id="c1811-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="c1811-104">P/Invoke — это технология, которая позволяет обращаться к структурам, обратным вызовам и функциям в неуправляемых библиотеках из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="c1811-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="c1811-105">Большинство API P/Invoke содержится в двух пространствах имен: `System` и `System.Runtime.InteropServices`.</span><span class="sxs-lookup"><span data-stu-id="c1811-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="c1811-106">Эти пространства имен предоставляют средства для описания способа взаимодействия с собственным компонентом.</span><span class="sxs-lookup"><span data-stu-id="c1811-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="c1811-107">Давайте начнем с наиболее общего примера — вызова неуправляемых функций в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="c1811-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="c1811-108">Приведем окно сообщения из приложения командной строки:</span><span class="sxs-lookup"><span data-stu-id="c1811-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="c1811-109">Предыдущий пример достаточно прост, но он показывает, что именно нужно для вызова неуправляемых функций из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="c1811-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="c1811-110">Рассмотрим пример подробнее:</span><span class="sxs-lookup"><span data-stu-id="c1811-110">Let’s step through the example:</span></span>

- <span data-ttu-id="c1811-111">Строка 1 показывает инструкцию using для пространства имен `System.Runtime.InteropServices`, которое содержит все нужные нам элементы.</span><span class="sxs-lookup"><span data-stu-id="c1811-111">Line #1 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="c1811-112">Строка 7 вводит атрибут `DllImport`.</span><span class="sxs-lookup"><span data-stu-id="c1811-112">Line #7 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="c1811-113">Этот атрибут является критически важным, так как он сообщает среде выполнения, что требуется загрузить неуправляемую библиотеку DLL.</span><span class="sxs-lookup"><span data-stu-id="c1811-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="c1811-114">Передаваемая строка — это библиотека DLL, в которой находится наша целевая функция.</span><span class="sxs-lookup"><span data-stu-id="c1811-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="c1811-115">Кроме того, в ней указывается, какая [кодировка](./charset.md) используется для маршалинга строк.</span><span class="sxs-lookup"><span data-stu-id="c1811-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="c1811-116">В конце строки указано, что эта функция вызывает [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) и что среда выполнения должна перехватить этот код ошибки, чтобы пользователь получил его с помощью <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c1811-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="c1811-117">Строка 8 является основополагающей для работы P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="c1811-117">Line #8 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="c1811-118">Она определяет управляемый метод, имеющий **точно такую же сигнатуру**, что и неуправляемый.</span><span class="sxs-lookup"><span data-stu-id="c1811-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="c1811-119">Объявление содержит новое ключевое слово `extern`, которое сообщает среде выполнения, что это внешний метод и что при его вызове среда выполнения должна найти его в библиотеке DLL, указанной в атрибуте `DllImport`.</span><span class="sxs-lookup"><span data-stu-id="c1811-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="c1811-120">Остальная часть примера представляет собой обычный вызов метода, аналогичный любому другому управляемому методу.</span><span class="sxs-lookup"><span data-stu-id="c1811-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="c1811-121">Для macOS используется аналогичный код.</span><span class="sxs-lookup"><span data-stu-id="c1811-121">The sample is similar for macOS.</span></span> <span data-ttu-id="c1811-122">Имя библиотеки в атрибуте `DllImport` необходимо изменить, так как macOS имеет другую схему именования динамических библиотек.</span><span class="sxs-lookup"><span data-stu-id="c1811-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="c1811-123">В следующем примере используется функция `getpid(2)`, чтобы получить идентификатор процесса приложения и вывести его на консоль.</span><span class="sxs-lookup"><span data-stu-id="c1811-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="c1811-124">В Linux это осуществляется аналогичным образом.</span><span class="sxs-lookup"><span data-stu-id="c1811-124">It is also similar on Linux.</span></span> <span data-ttu-id="c1811-125">Имя функции такое же, так как `getpid(2)` является стандартным системным вызовом [POSIX](https://en.wikipedia.org/wiki/POSIX).</span><span class="sxs-lookup"><span data-stu-id="c1811-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="c1811-126">Вызов управляемого кода из неуправляемого кода</span><span class="sxs-lookup"><span data-stu-id="c1811-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="c1811-127">Среда выполнения обеспечивает взаимодействие в обоих направлениях, что позволяет вызывать собственные функции обратно в управляемый код с помощью указателей функций.</span><span class="sxs-lookup"><span data-stu-id="c1811-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="c1811-128">В управляемом коде к указателю функции ближе всего **делегат**, так как он позволяет выполнять обратные вызовы из машинного кода в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="c1811-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="c1811-129">Этот компонент используется по аналогии с описанным ранее собственным процессом.</span><span class="sxs-lookup"><span data-stu-id="c1811-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="c1811-130">Для заданного обратного вызова определяется делегат с такой же сигнатурой, который передается во внешний метод.</span><span class="sxs-lookup"><span data-stu-id="c1811-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="c1811-131">Обо всем остальном позаботится среда выполнения.</span><span class="sxs-lookup"><span data-stu-id="c1811-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="c1811-132">Перед рассмотрением примера следует просмотреть сигнатуры неуправляемых функций, с которыми нам предстоит работать.</span><span class="sxs-lookup"><span data-stu-id="c1811-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="c1811-133">Функция, которую требуется вызвать для перечисления всех окон, имеет такую сигнатуру: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="c1811-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="c1811-134">Первый параметр — это обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="c1811-134">The first parameter is a callback.</span></span> <span data-ttu-id="c1811-135">Он имеет следующую сигнатуру: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="c1811-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="c1811-136">Рассмотрим пример подробнее.</span><span class="sxs-lookup"><span data-stu-id="c1811-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="c1811-137">Строка 9 определяет делегат, который соответствует сигнатуре обратного вызова из неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="c1811-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="c1811-138">Обратите внимание, как типы LPARAM и HWND представлены с помощью `IntPtr` в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="c1811-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="c1811-139">Строки 13 и 14 вводят функцию `EnumWindows` из библиотеки user32.dll.</span><span class="sxs-lookup"><span data-stu-id="c1811-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="c1811-140">Строки 17—20 реализуют делегат.</span><span class="sxs-lookup"><span data-stu-id="c1811-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="c1811-141">В этом простом примере мы просто выводим маркер на консоль.</span><span class="sxs-lookup"><span data-stu-id="c1811-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="c1811-142">Наконец, в строке 24 вызывается внешний метод и передается делегат.</span><span class="sxs-lookup"><span data-stu-id="c1811-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="c1811-143">Ниже приведены примеры для Linux и macOS.</span><span class="sxs-lookup"><span data-stu-id="c1811-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="c1811-144">В них мы используем функцию `ftw`, которую можно найти в библиотеке C `libc`.</span><span class="sxs-lookup"><span data-stu-id="c1811-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="c1811-145">Эта функция используется для обхода иерархий каталогов и принимает указатель функции в качестве одного из своих параметров.</span><span class="sxs-lookup"><span data-stu-id="c1811-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="c1811-146">Она имеет следующую сигнатуру: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span><span class="sxs-lookup"><span data-stu-id="c1811-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="c1811-147">В примере для macOS используется та же функция. Единственное отличие состоит в аргументе для атрибута `DllImport`, так как macOS сохраняет `libc` в другом месте.</span><span class="sxs-lookup"><span data-stu-id="c1811-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="c1811-148">Оба предыдущих примера зависят от параметров, и в обоих случаях параметры задаются в виде управляемых типов.</span><span class="sxs-lookup"><span data-stu-id="c1811-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="c1811-149">На другой стороне среда выполнения преобразует их в эквивалентные.</span><span class="sxs-lookup"><span data-stu-id="c1811-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="c1811-150">Дополнительные сведения о том, как типы маршалируются в машинный код на нашей странице, см. в разделе [Маршалинг типов](type-marshaling.md).</span><span class="sxs-lookup"><span data-stu-id="c1811-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="c1811-151">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="c1811-151">More resources</span></span>

- <span data-ttu-id="c1811-152">[Вики-сайт PInvoke.net](https://www.pinvoke.net/) — это отличный ресурс с информацией о распространенных API Windows и способах их вызова.</span><span class="sxs-lookup"><span data-stu-id="c1811-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="c1811-153">P/Invoke в C++/CLI</span><span class="sxs-lookup"><span data-stu-id="c1811-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="c1811-154">Документация Mono по P/Invoke</span><span class="sxs-lookup"><span data-stu-id="c1811-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)
