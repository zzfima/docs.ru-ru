---
title: Глобализация
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- globalization [.NET Framework], about globalization
- global applications, globalization
- international applications [.NET Framework], globalization
- world-ready applications, globalization
- application development [.NET Framework], globalization
- culture, globalization
ms.assetid: 4e919934-6b19-42f2-b770-275a4fae87c9
ms.openlocfilehash: fe03bbdd7d037a9f1fb4985b62b447c6ef9c6535
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "79174788"
---
# <a name="globalization"></a>Глобализация

Глобализация предполагает проектирование и разработку готовых к использованию во всем мире приложений, поддерживающих локализованные интерфейсы и региональные данные для пользователей разных культур. Перед началом проектирования необходимо определить, какие языки и региональные параметры будет поддерживать приложение. Хотя приложение нацелено на один язык или страну по умолчанию, его можно спроектировать и создать так, чтобы его могли использовать пользователи в других странах.

Разработчики имеют предположения о пользовательских интерфейсах и данных, которые формируются их культурами. Например, для англоговорящего разработчика в США сериализация сведений о дате и времени в виде строки в формате `MM/dd/yyyy hh:mm:ss` выглядит совершенно естественно. Однако десериализация этой строки в системе на другом языке, вероятно, создаст исключение <xref:System.FormatException> или выдаст неточные данные. Глобализация позволяет определять такие допущения, связанные с языком и региональными параметрами, и убедиться, что они не влияют на разработку или код приложения.

В этой статье рассматриваются некоторые из основных вопросов, которые следует принять во внимание, а также рекомендации, которым можно следовать при обработке строк, значений даты и времени и числовых значений в глобализованном приложении.

## <a name="strings"></a>Строки

Обработка символов и строк является центральным моментом глобализации, поскольку для каждого языка или региона могут использоваться разные символы и кодировки, и сортироваться эти символы могут по-разному. В этом разделе приведены рекомендации по использованию строк в глобализованных приложениях.

### <a name="use-unicode-internally"></a>Внутреннее использование Юникода

По умолчанию в .NET используются строки Юникода. Строка Юникода состоит из 0, одного или нескольких объектов <xref:System.Char>, каждый из которых представляет собой единицу кода UTF-16. Представление Юникода существует почти для каждого символа в каждом из наборов символов, используемых по всему миру.

Многие приложения и операционные системы, включая операционную систему Windows, могут использовать также кодовые страницы для представления кодировок. Кодовые страницы обычно содержат стандартные значения ASCII от 0x00 до 0x7F и сопоставляют другие символы с остальными значениями от 0x80 до 0xFF. Интерпретация значений от 0x80 до 0xFF зависит от конкретной кодовой страницы. По этой причине следует избегать использования кодовых страниц в глобализованном приложении, если это возможно.

В следующем примере показаны опасности, связанные с интерпретацией данных кодовой страницы, если используемая в системе по умолчанию кодовая страница отлична от кодовой страницы, на которой были сохранены данные. (Чтобы смоделировать этот сценарий, в примере явным образом задаются разные кодовые страницы.) Во-первых, в примере определяется массив, состоящий из символов верхнего регистра греческого алфавита. Он кодирует их в массив байт с помощью кодовой страницы 737 (также известной как MS-DOS греческий) и сохраняет массив байтов в файл. Если файл извлекается и его массив байтов расшифровывается с использованием кодовой страницы 737, исходные символы будут восстановлены. Однако если файл извлекается и его массив байтов расшифровывается с использованием кодовой страницы 1252 (или Windows-1252, которая представляет символы в латинском алфавите), исходные символы теряются.

[!code-csharp[Conceptual.Globalization#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/codepages1.cs#1)]
[!code-vb[Conceptual.Globalization#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/codepages1.vb#1)]

Использование Юникода гарантирует, что одни и те же единицы кода всегда сопоставляются с одними и теми же символами и что одни и те же символы всегда сопоставляются с одними и теми же байтовыми массивами.

### <a name="use-resource-files"></a>Использование файлов ресурсов

Даже если вы разрабатываете приложение, которое предназначено для одной культуры или региона, необходимо использовать файлы ресурсов для сохранения строк и других ресурсов, отображаемых в пользовательском интерфейсе. Никогда не следует добавлять их непосредственно в код. Использование файлов ресурсов имеет ряд преимуществ:

- Все строки находятся в одном месте. Нет необходимости выполнять поиск во всем исходном коде для определения строки для изменения для конкретного языка.

- Дублировать строки не нужно. Разработчики, которые не используют файлы ресурсов, часто определяют одинаковые строки в нескольких файлах исходного кода. Эта дублирование увеличивает вероятность пропуска одного или нескольких экземпляров при изменении строки.

- Нестроковые ресурсы, например изображения или двоичные данные, можно включить в файл ресурсов, вместо того чтобы сохранять их в отдельном файле, чтобы их можно было легко извлечь.

Использование файлов ресурсов имеет определенные преимущества при создании локализованного приложения. При развертывании ресурсов во вспомогательных сборках среда CLR автоматически выбирает соответствующий языку и региональным параметрам ресурс на основе текущего языка пользовательского интерфейса, как определено свойством <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>. Если требуется предоставить подходящий ресурс для конкретного языка и региональных параметров и правильно создать экземпляр объекта <xref:System.Resources.ResourceManager> или использовать строго типизированный класс ресурса, среда выполнения обрабатывает сведения о получении соответствующих ресурсов.

Дополнительные сведения о создании файлов ресурсов см. в статье [Создание файлов ресурсов для приложений для настольных систем](../../../docs/framework/resources/creating-resource-files-for-desktop-apps.md). Сведения о создании и развертывании вспомогательных сборок см. в статьях [Создание вспомогательных сборок для приложений для настольных систем](../../../docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) и [Упаковка и развертывание ресурсов в приложениях для настольных систем](../../../docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).

### <a name="search-and-compare-strings"></a>Поиск и сравнение строк

При возможности рекомендуется обрабатывать строки целиком, а не в виде последовательностей отдельных символов. Это особенно важно при сортировке или поиске подстрок для избежания проблем, связанных с обработкой несамостоятельных знаков.

> [!TIP]
> Можно использовать класс <xref:System.Globalization.StringInfo> для работы с текстовыми элементами, а не отдельными символами в строке.

В операциях поиска и сравнения строк частая ошибка заключается в том, что строка рассматривается как коллекция символов, каждый из которых представлен объектом <xref:System.Char>. Фактически, один символ может быть сформирован одним, двумя или более объектами <xref:System.Char>. Эти символы чаще всего встречаются в строках из языков, алфавиты которых состоят из символов, не входящих в базовый диапазон латинских символов Юникода (с U+0021 по U+007E). В следующем примере предпринимается попытка найти индекс символа LATIN CAPITAL LETTER A WITH GRAVE (U+00C0) в строке. Однако этот символ можно представить двумя различными способами: как один блок кода (U+00C0) или как составной знак (два блока кода: U+0041 и U+0300). В этом случае символ представлен в экземпляре строки двумя объектами <xref:System.Char> — U+0041 и U+0300. Код в примере вызывает перегрузки <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> и <xref:System.String.IndexOf%28System.String%29?displayProperty=nameWithType>, чтобы найти позицию этого символа в экземпляре строки, но они возвращают разные результаты. Первый вызов метода имеет аргумент <xref:System.Char>; он выполняет порядковое сравнение и поэтому не может найти совпадение. Второй вызов имеет аргумент <xref:System.String>; он выполняет сравнение с учетом языка и региональных параметров и поэтому находит совпадение.

[!code-csharp[Conceptual.Globalization#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/search1.cs#18)]
[!code-vb[Conceptual.Globalization#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/search1.vb#18)]

Чтобы избежать неоднозначности этого примера (вызовы двух одинаковых перегрузок метода возвращают разные результаты), можно вызвать перегрузку, которая включает параметр <xref:System.StringComparison>, например метод <xref:System.String.IndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> или <xref:System.String.LastIndexOf%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType>.

Однако поиски всегда не учитывают язык и региональные параметры. Если цель поиска — принять решение о безопасности или разрешить или запретить доступ к определенному ресурсу, сравнение должно быть порядковое, как описано в следующем разделе.

### <a name="test-strings-for-equality"></a>Проверка строк на равенство

Если требуется проверить две строки на равенство, а не определить, как они сравниваются в порядке сортировки, следует использовать метод <xref:System.String.Equals%2A?displayProperty=nameWithType> вместо метода сравнения строк, такого как <xref:System.String.Compare%2A?displayProperty=nameWithType> или <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>.

Сравнения на равенство обычно выполняются для получения некоторой условности ресурса. Например, можно выполнить сравнение на равенство для проверки пароля или чтобы убедиться, что файл существует. Такие нелингвистические сравнения всегда должны быть порядковыми, а не зависящими от языка и региональных параметров. Как правило, необходимо вызвать экземпляр метода <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29?displayProperty=nameWithType> или статический метод <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> со значением <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> для строк, например паролей, и значением <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> для строк, таких как имена файлов или URI.

Сравнения на равенство иногда включают поиск или сравнения подстрок, а не вызовы метода <xref:System.String.Equals%2A?displayProperty=nameWithType>. В некоторых случаях можно использовать поиск подстрок, чтобы определить, равняется ли эта подстрока другой строке. Если цель сравнения не лингвистическая, поиск также должен быть порядковым, а не с учетом языка и региональных параметров.

Следующий пример иллюстрирует опасность, связанную с использованием поиска с учетом языка и региональных параметров применительно к нелингвистическим данным. Метод `AccessesFileSystem` позволяет запретить файловой системе доступ к URI, которые начинается с подстроки "FILE". Для этого он выполняет сравнение с учетом языка и региональных параметров без учета регистра начала URI со строкой "FILE". Поскольку универсальный код ресурса (URI) для доступа к файловой системе может начинаться с "FILE:" или "file:", то неявно предполагается, что символ "i" (U+0069) всегда является эквивалентом символа "I" (U+0049) в нижнем регистре. Однако в турецком и азербайджанском прописная версия "i" — "İ" (U+0130). Вследствие этого несоответствия сравнение с учетом языка и региональных параметров разрешает доступ к файловой системе, когда он должен быть запрещен.

[!code-csharp[Conceptual.Globalization#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/equals1.cs#12)]
[!code-vb[Conceptual.Globalization#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/equals1.vb#12)]

Чтобы избежать этой проблемы, выполните порядковое сравнение, которое не учитывает регистр, как показано в следующем примере.

[!code-csharp[Conceptual.Globalization#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/equals2.cs#13)]
[!code-vb[Conceptual.Globalization#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/equals2.vb#13)]

### <a name="order-and-sort-strings"></a>Порядок и сортировка строк

Как правило, упорядоченные строки, которые должны отображаться в пользовательском интерфейсе, должны сортироваться с учетом языка и региональных параметров. В большинстве случаев эти сравнения строк обрабатываются неявно платформой .NET при вызове метода, сортирующего строки, например <xref:System.Array.Sort%2A?displayProperty=nameWithType> или <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. По умолчанию строки будут отсортированы с помощью соглашений сортировки текущего языка и региональных параметров. В следующем примере показана разница между сортировкой массива строк с использованием соглашений языка и региональных параметров "Английский (США)" и языка и региональных параметров "Шведский (Швеция)".

[!code-csharp[Conceptual.Globalization#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/sort1.cs#14)]
[!code-vb[Conceptual.Globalization#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/sort1.vb#14)]

Учитывающее язык и региональные параметры сравнение строк определяется объектом <xref:System.Globalization.CompareInfo>, который возвращается свойством <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> каждого языка и региональных параметров. Учитывающие язык и региональные параметры сравнения строк, которые используют перегрузки метода <xref:System.String.Compare%2A?displayProperty=nameWithType>, также используют объект <xref:System.Globalization.CompareInfo>.

В .NET используются таблицы для сортировки строковых данных с учетом языка и региональных параметров. Содержимое этих таблиц, которые содержат данные по весам сортировки и нормализации строк, определяется версией стандарта Юникода, реализуемой определенной версией .NET. В следующей таблице перечислены версии Юникода, реализуемые различными версиями .NET Framework и .NET Core. Обратите внимание, что этот список поддерживаемых версий Юникода применяется только к сравнению и сортировке символов. Он не применяется для классификации символов Юникода по категориям. Дополнительные сведения см. в разделе "Строки и стандарт Юникода" в статье <xref:System.String>.

|Версия платформы .NET Framework|Операционная система|Версия Юникода|
|----------------------------|----------------------|---------------------|
|.NET Framework 2.0|Все операционные системы|Юникод 4.1|
|.NET Framework 3.0|Все операционные системы|Юникод 4.1|
|.NET Framework 3,5|Все операционные системы|Юникод 4.1|
|.NET Framework 4|Все операционные системы|Юникод 5.0|
|.NET Framework 4.5 и более поздних версий в Windows 7|Юникод 5.0|
|.NET Framework 4.5 и более поздних версий в операционных системах не ниже Windows 8|Юникод 6.3.0|
|.NET Core (все версии)|Зависит от версии стандарта Юникода, поддерживаемой базовой операционной системой.|

Начиная с .NET Framework 4.5 и во всех версиях .NET Core сравнение строк и их сортировка зависит от операционной системы. Платформа .NET Framework 4.5 и более поздних версий, запущенная в Windows 7, извлекает данные из собственных таблиц, реализующих Юникод 5.0. Платформа .NET Framework 4.5 и более поздних версий, запущенная в Windows 8, извлекает данные из таблиц операционной системы, реализующих Юникод 6.3. В .NET Core поддерживаемая версия Юникода зависит от базовой операционной системы. Если вы сериализуете учитывающие язык и региональные параметры данные, можно использовать класс <xref:System.Globalization.SortVersion>, чтобы определить, когда сериализованные данные должны быть отсортированы, чтобы порядок был согласован с порядком сортировки платформы .NET и операционной системы. Пример см. в разделе с описанием класса <xref:System.Globalization.SortVersion>.

Если приложение выполняет множество сортировок строковых данных в связи с особенностями культуры, можно работать с классом <xref:System.Globalization.SortKey> для сравнения строк. Ключ сортировки отражает весовые коэффициенты сортировки для конкретных языков и региональных параметров, включая вес алфавитный, вес регистра и диакритический вес конкретной строки. Поскольку сравнения с помощью ключей сортировки бинарны, они быстрее, чем сравнения, использующие объект <xref:System.Globalization.CompareInfo> явно или неявно. При создании ключа сортировки для конкретных языков и региональных параметров для конкретной строки вы передаете строку в метод <xref:System.Globalization.CompareInfo.GetSortKey%2A?displayProperty=nameWithType>.

Следующий пример подобен предыдущему примеру. Однако вместо вызова метода <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>, который неявно вызывает метод <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType>, он определяет реализацию <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType>, которая сравнивает создаваемые им ключи сортировки и передает в метод <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType>.

[!code-csharp[Conceptual.Globalization#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/sortkey1.cs#15)]
[!code-vb[Conceptual.Globalization#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/sortkey1.vb#15)]

### <a name="avoid-string-concatenation"></a>Избегайте объединения строк

Если это возможно, никогда не следует использовать составные строки, полученные во время выполнения программы при помощи соединения фраз. Составные строки трудно локализовать, потому что они часто используют грамматический порядок исходного языка приложения, который не может быть применен для других языков локализации.

## <a name="handle-dates-and-times"></a>Обработка дат и времени

Способ обработки значений даты и времени зависит от того, отображаются ли они в интерфейсе пользователя или сохраняются. В данном разделе рассматриваются оба варианта использования. Здесь также рассматриваются способы обработки отличий в часовом поясе и арифметические операции при работе с датами и временем.

### <a name="display-dates-and-times"></a>Отображение дат и времени

Как правило, когда даты и время отображаются в пользовательском интерфейсе, необходимо использовать соглашения о форматировании, принятые в языке и региональных параметрах пользователя, которые определяются свойством <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> и объектом <xref:System.Globalization.DateTimeFormatInfo>, возвращаемым свойством `CultureInfo.CurrentCulture.DateTimeFormat`. Соглашения о форматировании текущего языка и региональных параметров автоматически используются при форматировании даты с помощью любого из следующих методов.

- Метод <xref:System.DateTime.ToString?displayProperty=nameWithType> без параметров

- Метод <xref:System.DateTime.ToString%28System.String%29?displayProperty=nameWithType>, который включает строку формата

- Метод <xref:System.DateTimeOffset.ToString?displayProperty=nameWithType> без параметров

- Метод <xref:System.DateTimeOffset.ToString%28System.String%29?displayProperty=nameWithType>, который включает строку формата

- Функция [составного форматирования](../../../docs/standard/base-types/composite-formatting.md), когда она используется с датами.

Следующий пример выводит данные о восходе и заходе солнца дважды для 11 октября 2012 г. Сначала он устанавливает текущий язык и региональные параметры как хорватский (Хорватия), а затем как английский язык (Соединенное Королевство). В каждом случае дата и время отображаются в формате, который подходит для этого языка и региональных параметров.

[!code-csharp[Conceptual.Globalization#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates1.cs#2)]
[!code-vb[Conceptual.Globalization#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates1.vb#2)]

### <a name="persist-dates-and-times"></a>Сохранение дат и времени

Никогда не следует сохранять данные даты и времени в формате, который может зависеть от языка и региональных параметров. Это распространенная ошибка программирования, которая приводит к повреждению данных или исключению времени выполнения. Следующий пример сериализует две даты — 9 января 2013 г. и 18 августа 2013 г. — в виде строк с использованием соглашений о форматировании для языка и региональных параметров "Английский (США)". Когда данные получены и проанализированы с помощью соглашений английского языка (американский вариант), они успешно восстанавливаются. Однако когда они извлекаются и анализируются с использованием соглашений для английского языка (Соединенное Королевство), первая дата неправильно интерпретируется как 1-е сентября, а вторая не анализируется, поскольку в григорианском календаре нет 18-го месяца.

[!code-csharp[Conceptual.Globalization#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates2.cs#3)]
[!code-vb[Conceptual.Globalization#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates2.vb#3)]

Эту проблему можно исключить любым из трех способов.

- Сериализовать дату и время в двоичный формат, а не в строку.

- Сохранить и проанализировать строковое представление даты и времени, используя строку пользовательского формата, одинаковую вне зависимости от языка и региональных параметров пользователя.

- Сохранить строку с использованием соглашений о форматировании, принятых в инвариантном языке и региональных параметрах.

Последний подход показан в приведенном ниже примере. Он использует соглашения о форматировании с учетом инвариантного языка и региональных параметров с использованием свойства <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.

[!code-csharp[Conceptual.Globalization#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates3.cs#4)]
[!code-vb[Conceptual.Globalization#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates3.vb#4)]

### <a name="serialization-and-time-zone-awareness"></a>Поддержка сериализации и часовых поясов

Значение даты и времени может иметь несколько интерпретаций, от общего времени ("Магазины открываются 2-го января 2013 г. в 9:00") до определенного момента времени ("Дата рождения: 2-е января 2013 г. 6:32:00"). Если значение времени представляет определенный момент времени и восстанавливается из сериализуемого значения, необходимо убедиться, что оно представляет тот же момент времени независимо от географического положения пользователя или часового пояса.

Приведенный ниже пример иллюстрирует данную проблему. В нем одиночное значение локальных даты и времени сохраняется в виде строки в трех [стандартных форматах](../../../docs/standard/base-types/standard-date-and-time-format-strings.md) ("G" для общего длинного формата даты и времени, "s" для сортируемого формата даты и времени и "o" для обратимого преобразования даты и времени), а также в двоичном формате.

[!code-csharp[Conceptual.Globalization#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates4.cs#10)]
[!code-vb[Conceptual.Globalization#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates4.vb#10)]

Если данные восстановлены в системе в том же часовом поясе, что и система, в которой они были сериализованы, десериализованные значения даты и времени точно отражают исходное значение, как показано в выходных данных:

```console
'3/30/2013 6:00:00 PM' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00.0000000-07:00' --> 3/30/2013 6:00:00 PM Local

3/30/2013 6:00:00 PM Local
```

Однако при восстановлении данных в системе в другом часовом поясе только значение даты и времени, которое было форматировано с строкой стандартного формата "o" (цикл обработки), сохраняет данные часового пояса и поэтому представляет тот же момент времени. Далее приведен результат, когда данные даты и времени восстанавливаются в системе в часовом поясе "Стандартное романское время":

```console
'3/30/2013 6:00:00 PM' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00' --> 3/30/2013 6:00:00 PM Unspecified
'2013-03-30T18:00:00.0000000-07:00' --> 3/31/2013 3:00:00 AM Local

3/30/2013 6:00:00 PM Local
```

Для точного отражения значения даты и времени, которое представляет один момент времени независимо от часового пояса системы, где десериализуются данные, можно выполнить любое из следующих действий.

- Сохранение значения как строки с помощью строки стандартного формата "o" (цикл обработки). Последующая десериализация в целевой системе.

- Преобразование его во время в формате UTC и сохранение его в виде строки с помощью строки стандартного формата "r" (RFC1123). Последующая десериализация в целевой системе и преобразование в местное время.

- Преобразование его во время в формате UTC и сохранение его в виде строки с помощью строки стандартного формата "u" (универсальное сортируемое). Последующая десериализация в целевой системе и преобразование в местное время.

- Преобразование его во время в формате UTC и сохранение его в двоичном формате. Последующая десериализация в целевой системе и преобразование в местное время.

Следующий пример демонстрирует каждую из технологий.

[!code-csharp[Conceptual.Globalization#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates8.cs#11)]
[!code-vb[Conceptual.Globalization#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates8.vb#11)]

Если данные сериализуются в системе в часовом поясе тихоокеанского стандартного времени и десериализуются в системе в часовом поясе римского стандартного времени, пример отображает следующий результат:

```console
'2013-03-30T18:00:00.0000000-07:00' --> 3/31/2013 3:00:00 AM Local
'Sun, 31 Mar 2013 01:00:00 GMT' --> 3/31/2013 3:00:00 AM Local
'2013-03-31 01:00:00Z' --> 3/31/2013 3:00:00 AM Local

3/31/2013 3:00:00 AM Local
```

Дополнительные сведения см. в статье [Преобразование времени из одного часового пояса в другой](../../../docs/standard/datetime/converting-between-time-zones.md).

### <a name="perform-date-and-time-arithmetic"></a>Выполнение арифметических операций с датами и временем

Типы <xref:System.DateTime> и <xref:System.DateTimeOffset> поддерживают арифметические операции. Можно вычислить разницу между двумя значениями дат или добавить или вычесть конкретные временные интервалы в или из значения даты. Однако арифметические операции над значениями даты и времени не принимают в расчет часовые пояса и правила коррекции часового пояса. Вследствие этого арифметические операции даты и времени на значениях, представляющих моменты времени, могут возвращать неточные результаты.

Например, переход со стандартного тихоокеанского времени на тихоокеанское летнее время происходит во второе воскресенье марта, то есть 10 марта 2013 г. В следующем примере показан расчет даты и времени на момент через 48 часов после 10:30 9 марта 2013 г. в системе, использующей стандартный тихоокеанский часовой пояс. Мы получаем результат 11 марта 2013 г. 10:30 без учета корректировки времени, которая происходит в этот период.

[!code-csharp[Conceptual.Globalization#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates5.cs#8)]
[!code-vb[Conceptual.Globalization#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates5.vb#8)]

Чтобы гарантировать, что арифметическая операция со значениями даты и времени даст точные результаты, выполните следующие действия.

1. Преобразуйте время в исходном часовом поясе в формат UTC.

2. Выполните арифметическую операцию.

3. Если результатом является значение даты и времени, преобразуйте его из времени в формате UTC во время в исходном часовом поясе.

Следующий пример аналогичен предыдущему за исключением того, что эти три шага выполняются для правильного добавления 48 часов к 9 марта 2013 г. в 10:30.

[!code-csharp[Conceptual.Globalization#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/dates6.cs#9)]
[!code-vb[Conceptual.Globalization#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/dates6.vb#9)]

Подробнее см. в статье [Выполнение арифметических операций с датами и временем](../../../docs/standard/datetime/performing-arithmetic-operations.md).

### <a name="use-culture-sensitive-names-for-date-elements"></a>Использование имен с учетом языка и региональных параметров для элементов дат

Возможно, приложению нужно отобразить название месяца или дня недели. Для этого обычно используют код, аналогичный следующему.

[!code-csharp[Conceptual.Globalization#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/monthname1.cs#19)]
[!code-vb[Conceptual.Globalization#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/monthname1.vb#19)]

Однако этот код всегда возвращает имена дней недели на английском языке. Код, который извлекает имя месяца, часто бывает еще более жестким. Он часто предполагает использование календаря с 12 месяцами с именами месяцев на конкретном языке.

С помощью [строк даты и времени пользовательского формата](../../../docs/standard/base-types/custom-date-and-time-format-strings.md) или свойств объекта <xref:System.Globalization.DateTimeFormatInfo> можно легко извлечь строки с названиями дней недели или месяцев с учетом языка и региональных параметров пользователя, как показано в примере ниже. Он изменяет текущий язык на французский (Франция) и отображает название дня недели и название месяца для 1-го июля 2013 г.

[!code-csharp[Conceptual.Globalization#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/monthname2.cs#20)]
[!code-vb[Conceptual.Globalization#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/monthname2.vb#20)]

## <a name="numeric-values"></a>Числовые значения

Способ обработки чисел зависит от того, отображаются ли они в интерфейсе пользователя или сохраняются. В данном разделе рассматриваются оба варианта использования.

> [!NOTE]
> В операциях форматирования и синтаксического анализа платформа .NET распознает как числовые символы только основные латинские символы от 0 до 9 (от U+0030 до U+0039).

### <a name="display-numeric-values"></a>Отображение числовых значений

Как правило, когда числа отображаются в пользовательском интерфейсе, необходимо использовать соглашения о форматировании, принятые в языке и региональных параметрах пользователя, которые определяются свойством <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> и объектом <xref:System.Globalization.NumberFormatInfo>, возвращаемым свойством `CultureInfo.CurrentCulture.NumberFormat`. Соглашения о форматировании текущего языка и региональных параметров автоматически используются при форматировании даты с помощью любого из следующих методов.

- Метод `ToString` любого числового типа без параметров

- Метод `ToString(String)` любого числового типа, включающий строку формата в качестве аргумента

- Функция [составного форматирования](../../../docs/standard/base-types/composite-formatting.md), когда она используется с числовыми значениями.

В следующем примере выводится средняя температура для каждого месяца в Париж, Франция. Перед отображением данных он устанавливает текущий язык и региональные параметры как французский (Франция), а затем задает английский язык (США). В каждом случае имена месяцев и температуры отображаются в формате, который подходит для данного языка и региональных параметров. Обратите внимание, что в двух языках и региональных параметрах используются разные десятичные разделители в значении температуры. Также обратите внимание, что в примере используется строка пользовательского формата даты и времени "MMMM" для отображения полного названия месяца и что он выделяет необходимый объем пространства для названия месяца в результирующей строке, указав длину самого длинного названия месяца в массиве <xref:System.Globalization.DateTimeFormatInfo.MonthNames%2A?displayProperty=nameWithType>.

[!code-csharp[Conceptual.Globalization#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers1.cs#5)]
[!code-vb[Conceptual.Globalization#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers1.vb#5)]

### <a name="persist-numeric-values"></a>Сохранение числовых значений

Никогда не следует сохранять числовые данные в формате языка и региональных параметров. Это распространенная ошибка программирования, которая приводит к повреждению данных или исключению времени выполнения. Следующий пример создает десять случайных чисел с плавающей запятой, а затем сериализует их в виде строк с использованием соглашений о форматировании для языка и региональных параметров "Английский (США)". Когда данные получены и проанализированы с помощью соглашений английского языка (американский вариант), они успешно восстанавливаются. Однако если они извлекаются и анализируются с помощью соглашений культуры французского языка (Франция), ни одно из чисел не может быть проанализировано, поскольку языки используют различные десятичные разделители.

[!code-csharp[Conceptual.Globalization#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers2.cs#6)]
[!code-vb[Conceptual.Globalization#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers2.vb#6)]

Чтобы избежать этой проблемы, можно использовать один из следующих приемов:

- Сохраните и проанализируйте строковое представление числа, используя строку пользовательского формата, одинаковую вне зависимости от языка и региональных параметров пользователя.

- Сохраните число в виде строки с использованием соглашений о форматировании, принятых в инвариантном языке и региональных параметрах, которые возвращаются свойством <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.

- Сериализуйте число в двоичный, а не в строковый формат.

Последний подход показан в приведенном ниже примере. Он выполняет сериализацию массива значений <xref:System.Double>, а затем десериализует и отображает их с помощью соглашений о форматировании для английского (США) и французского (Франция) языка и региональных параметров.

[!code-csharp[Conceptual.Globalization#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/numbers3.cs#7)]
[!code-vb[Conceptual.Globalization#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/numbers3.vb#7)]

Сериализация значений валюты — особый случай. Поскольку значение валюты зависит от единицы валюты, в которой оно выражено, нет смысла интерпретировать его как независимое числовое значение. Однако если сохранить значение валюты в качестве отформатированной строки, которая содержит символ валюты, его невозможно десериализовать в системе, язык по умолчанию которой использует другой символ валюты, как показано в следующем примере.

[!code-csharp[Conceptual.Globalization#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/currency1.cs#16)]
[!code-vb[Conceptual.Globalization#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/currency1.vb#16)]

Вместо этого необходимо сериализовать числовое значение вместе с некоторыми языковыми сведениями, например имя языка, чтобы значение и его символ валюты можно десериализовать независимо от текущего языка и региональных параметров. В следующем примере это делается путем определения структуры `CurrencyValue` с двумя членами: значением <xref:System.Decimal> и именем языка, которому принадлежит значение.

[!code-csharp[Conceptual.Globalization#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.globalization/cs/currency2.cs#17)]
[!code-vb[Conceptual.Globalization#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.globalization/vb/currency2.vb#17)]

## <a name="work-with-culture-specific-settings"></a>Работа с параметрами, специфичными для языков и региональных параметров

В .NET конкретный язык и региональные параметры представлены классом <xref:System.Globalization.CultureInfo>. Некоторые из его свойств возвращают объекты, которые содержат определенные сведения о каком-либо аспекте языка и региональных параметров.

- Свойство <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> возвращает объект <xref:System.Globalization.CompareInfo>, содержащий сведения о том, как в языке и региональных параметрах происходит сравнение и упорядочение строк.

- Свойство <xref:System.Globalization.CultureInfo.DateTimeFormat%2A?displayProperty=nameWithType> возвращает объект <xref:System.Globalization.DateTimeFormatInfo>, который предоставляет относящиеся к конкретному языку и региональным параметрам сведения, используемые при форматировании данных дат и времени.

- Свойство <xref:System.Globalization.CultureInfo.NumberFormat%2A?displayProperty=nameWithType> возвращает объект <xref:System.Globalization.NumberFormatInfo>, который предоставляет относящиеся к конкретному языку и региональным параметрам сведения, используемые при форматировании числовых данных.

- Свойство <xref:System.Globalization.CultureInfo.TextInfo%2A?displayProperty=nameWithType> возвращает объект <xref:System.Globalization.TextInfo>, который предоставляет сведения о системе письма, соответствующей языку и региональным параметрам.

Как правило, не следует делать предположений о конкретных значениях свойств <xref:System.Globalization.CultureInfo> и их связанных объектов. Вместо этого данные для конкретных языков и региональных параметров необходимо считать изменяемыми по следующим причинам:

- Значения отдельных свойств могут изменяться и редактироваться со временем по мере исправления данных, получения лучших данных или изменения соглашений для конкретных языков и региональных параметров.

- Значения отдельных свойств могут различаться в разных версиях платформы .NET или операционной системы.

- .NET поддерживает замещающие языки и региональные параметры. Это позволяет определить новые пользовательские язык и региональные параметры, которые либо дополняют существующие стандартные языки и региональные параметры, либо полностью заменяют существующие стандартные язык и региональные параметры.

- В системе Windows пользователь может настроить язык и региональные параметры с помощью приложения **Язык и региональные стандарты** на панели управления. При создании экземпляра объекта <xref:System.Globalization.CultureInfo> можно указать, отражает ли он эти настройки пользователя, вызвав конструктор <xref:System.Globalization.CultureInfo.%23ctor%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>. Обычно для приложений, предназначенных для конечных пользователей, необходимо учитывать предпочтения пользователя и предоставлять пользователю данные в том формате, в котором он ожидает их увидеть.

## <a name="see-also"></a>См. также

- [Глобализация и локализация](../../../docs/standard/globalization-localization/index.md)
- [Рекомендации по использованию строк](../../../docs/standard/base-types/best-practices-strings.md)
