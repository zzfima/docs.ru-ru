---
title: Подробный обзор асинхронного программирования
description: Сведения о простом написании асинхронного кода, связанного с операциями ввода-вывода и задействованием ЦП, с помощью асинхронной модели .NET на базе класса Task.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 91fd37ce329c03b43b5472e4579be7f5ef961738
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "70169105"
---
# <a name="async-in-depth"></a>Подробный обзор асинхронного программирования

Писать асинхронный код, связанный с операциями ввода-вывода и задействованием ЦП, очень просто с помощью асинхронной модели .NET на базе класса Task. Эта модель основывается на типах `Task` и `Task<T>` и ключевых словах `async` и `await` в C# и Visual Basic. (Ресурсы, связанные с определенным языком, см. в разделе [См. также](#see-also).) В этой статье описывается использование асинхронного кода в .NET и объясняется базовая асинхронная платформа.

## <a name="task-and-taskt"></a>Task и Task\<T>

Task (задача) — это конструкции, реализующие [модель параллельной обработки на основе обещаний (Promise)](https://ru.wikipedia.org/wiki/Futures_and_promises).  Если в двух словах, она "обещает", что работа будет выполнена позже, позволяя взаимодействовать с помощью обещания с чистым API.

- `Task` представляет одну операцию, которая не возвращает значение.
- `Task<T>` представляет одну операцию, которая возвращает значение типа `T`.

Важно рассматривать задачи как абстракции асинхронных операций, но *не* как абстракции поверх потоков. По умолчанию задачи выполняются в текущем потоке и при необходимости делегируют работу операционной системе. Для задач может также явно запрашиваться запуск в отдельном потоке через API `Task.Run`.

Задачи предоставляют протокол API для мониторинга, ожидания и доступа к результирующему значению (в случае `Task<T>`) задачи. Интеграция с языком через ключевое слово `await` обеспечивает абстракцию более высокого уровня для использования задач.

Использование `await` позволяет приложению или службе выполнять полезную работу во время выполнения задачи за счет передачи управления вызывающему объекту задачи до ее завершения. В коде не нужно использовать обратные вызовы или события для продолжения выполнения после завершения задачи. Это берут на себя язык и интеграцию API-интерфейса задач. Если вы используете `Task<T>`, ключевое слово `await` будет дополнительно "разворачивать" значение, возвращаемое после завершения задачи.  Ниже приводится подробное описание того, как это работает.

Дополнительные сведения о задачах и разных способах взаимодействия с ними см. в статье [Асинхронный шаблон, основанный на задачах (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a>Подробный обзор задач, связанных с операциями ввода-вывода

В следующем разделе приводится общее описание того, что происходит с обычным асинхронным вызовом ввода-вывода. Начнем с нескольких примеров.

В первом примере вызывается асинхронный метод и возвращается активная задача, которая, вероятно, еще не завершилась.

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();

    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

Во втором примере для работы с задачей добавляются ключевые слова `async` и `await`.

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();

    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");

    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.

    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

Вызов `GetStringAsync()` обращается к библиотекам .NET более низкого уровня (возможно, с вызовом других асинхронных методов), пока не дойдет до вызова взаимодействия P/Invoke для внутренней сетевой библиотеки. Внутренняя библиотека может впоследствии воспользоваться вызовом системного API-интерфейса (например, выполнить запись `write()` в сокет Linux). Объект задачи будет создан на границе внутренней/управляемой областей, возможно, с использованием [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)). Объект задачи будет передаваться вверх через уровни, возможно, с некоторой обработкой или прямым возвратом, и в итоге вернется к исходному вызывающему объекту.

Во втором примере выше объект `Task<T>` будет возвращен из `GetStringAsync`. Использование ключевого слова `await` предписывает методу возвратить только что созданный объект задачи. Управление возвращается вызывающему объекту из этого места в методе `GetFirstCharactersCountAsync`. Методы и свойства объекта [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) позволяют вызывающим объектам отслеживать ход выполнения задачи, которая завершится после выполнения оставшегося кода в GetFirstCharactersCountAsync.

После вызова API System запрос оказывается в пространстве ядра и доходит до сетевой подсистемы операционной системы (например, до `/net` в Linux).  На этом этапе ОС обрабатывает сетевой запрос *асинхронно*.  Детали могут отличаться в зависимости от используемой операционной системы (вызов драйвера устройства может быть запланирован как сигнал, возвращаемый в среду выполнения, либо сначала выполняется вызов драйвера устройства, а *затем* возвращается сигнал), но в конечном счете среда выполнения будет проинформирована о том, что идет выполнение сетевого запроса.  В это время драйвер устройства может находиться в одном из трех состояний: работа запланирована, работа выполняется, работа завершена (запрос уже отправлен обратно), но так как все это происходит асинхронно, драйвер устройства может сразу же приступать к выполнению других задач.

Например, в Windows поток операционной системы направляет вызов к драйверу сетевого устройства и запрашивает у него выполнение сетевой операции через пакет запроса прерывания (IRP), который представляет собой операцию.  Драйвер устройства получает IRP, делает вызов к сети, помечает IRP как "ожидающий" и возвращает управление операционной системе.  Так как поток ОС теперь знает, что запрос является "ожидающим", ему больше нечего делать в рамках этого задания и он "возвращается" обратно, где его можно использовать в других целях.

Когда запрос выполнен и данные возвращаются через драйвер устройства, поток с помощью прерывания уведомляет ЦП о получении новых данных.  Обработка этого прерывания зависит от операционной системы, но в конечном счете данные будут передаваться в ОС, пока не достигнут вызова системного взаимодействия (например, в Linux обработчик прерываний зарезервирует нижнюю половину IRQ для асинхронной передачи данных через ОС).  Обратите внимание, что это *также* происходит асинхронно.  Результат помещается в очередь, пока следующий доступный поток не сможет выполнить асинхронный метод и развернуть результат завершенной задачи.

На протяжении всего процесса ключевым моментом является то, что **ни один поток не выделяется для выполнения задачи**.  Несмотря на то, что работа выполняется в некотором контексте (т. е. ОС нужно передать данные в драйвер устройства и ответить на прерывание), никакой поток специально не выделяется для *ожидания* возвращения данных из запроса.  Это позволяет системе выполнять гораздо больший объем работы, а не ждать завершения какого-либо вызова операции ввода-вывода.

Несмотря на то, что вышесказанное может показаться довольно масштабным процессом, если его оценивать по общему времени исполнения, это считанные мгновения по сравнению с временем, которое тратится на фактические процедуры ввода-вывода. График выполнения такого вызова, без претензии на точность, может выглядеть следующим образом:

0-1————————————————————————————————————————————————–2-3

- Время между точками `0` и `1` — это все, что происходит до того, как асинхронный метод передает управление вызывающему его объекту.
- Время между точками `1` и `2` — это время, которое тратится на операции ввода-вывода без участия ЦП.
- Наконец, время между точками `2` и `3` — это время на передачу назад управления (и, возможно, значения) асинхронному методу, когда он начинает выполняться снова.

### <a name="what-does-this-mean-for-a-server-scenario"></a>Что это означает для сервера?

Эта модель хорошо подходит для типовых рабочих нагрузок на сервере.  Поскольку потоков, выделенных для блокировки незавершенных задач, нет, пул потоков на сервере может обрабатывать намного большее количество веб-запросов.

Рассмотрим два сервера: один выполняет асинхронный код, а второй нет.  В данном примере на каждом сервере есть только 5 потоков, доступных для обслуживания запросов.  Обратите внимание, что эти числа не имеют никакого отношения к реальным цифрам в жизни и используются только в качестве примера.

Предположим, что оба сервера получили 6 параллельных запросов. В каждом запросе выполняется операция ввода-вывода.  Сервер *без* асинхронного кода должен поставить в очередь 6-й запрос, пока один из 5 потоков не завершит работу, связанную с вводом-выводом, и не возвратит ответ. После поступления 20-го запроса работа сервера может начать замедляться, поскольку очередь становится слишком длинной.

Сервер *с* асинхронным кодом также помещает 6-й запрос в очередь, но так как он использует `async` и `await`, каждый из его потоков освобождается при начале работы подсистемы ввода-вывода, а не после завершения такой работы.  К моменту поступления 20-го запроса очередь входящих запросов будет гораздо меньше (если в ней вообще что-либо будет), а сервер будет работать как и прежде.

Хотя этот пример и вымышленный, в реальном мире все происходит примерно так же.  Фактически можно ожидать, что сервер сможет обрабатывать на порядок больше запросов при использовании `async` и `await`, в отличие от стратегии с выделением потока для каждого поступающего запроса.

### <a name="what-does-this-mean-for-client-scenario"></a>Что это означает для клиента?

Важнейшим преимуществом использования `async` и `await` для клиента является повышение скорости реагирования.  Несмотря на то, что приложение можно сделать более отзывчивым за счет создания потоков вручную, процедура создания потока — это дорогостоящая операция по сравнению с использованием `async` и `await`.  Это особенно актуально, например, для мобильных игр, где воздействие на поток пользовательского интерфейса минимально, а скорость ввода-вывода имеет решающее значение.

Что еще важнее, поскольку работа, связанная с вводом-выводом, практически не задействует ресурсов ЦП, выделение целого потока ЦП для выполнения мизерной нагрузки является крайне неэффективным использованием ресурсов.

Кроме того, направление работы в поток пользовательского интерфейса (например, обновление пользовательского интерфейса) с помощью методов `async` реализуется очень просто и не требует дополнительных усилий (например, вызова потокобезопасного делегата).

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a>Подробный обзор Task и Task\<T> для операций, связанных с ЦП

Код `async`, связанный с использованием ЦП, немного отличается от кода `async`, связанного с операциями ввода-вывода.  Поскольку работа выполняется на ЦП, невозможно избежать выделения потока для вычислений.  Использование `async` и `await` предоставляет чистый способ взаимодействия с фоновым потоком и позволяет объекту, вызвавшему асинхронный метод, по-прежнему реагировать на новые запросы.  Обратите внимание, что это не обеспечивает защиту общих данных.  Если вы используете общие данные, все равно потребуется применять соответствующую стратегию синхронизации.

Ниже приводится общий обзор асинхронного вызова, связанного с ЦП:

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));

    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!

    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;

    return result;
}
```

`CalculateResult()` выполняется в потоке, в котором он вызывался.  Когда он вызывает `Task.Run`, он помещает дорогостоящую операцию, связанную с ЦП, `DoExpensiveCalculation()`, в очередь пула потоков и получает дескриптор `Task<int>`.  `DoExpensiveCalculation()` в конечном счете выполняется параллельно в следующем доступном потоке, скорее всего, на другом ядре ЦП.  Пока `DoExpensiveCalculation()` выполняется в другом потоке, можно выполнять параллельные операции, так как поток, вызвавший `CalculateResult()`, по-прежнему выполняется.

При появлении `await` выполнение `CalculateResult()` передается вызвавшему объекту, что позволяет выполнить другую работу в параллельном потоке, пока `DoExpensiveCalculation()` формирует результат.  После завершения его работы результат передается в очередь для использования в основном потоке.  В конечном счете основной поток вернется к выполнению `CalculateResult()`, при этом у него будет результат `DoExpensiveCalculation()`.

### <a name="why-does-async-help-here"></a>Что здесь дает асинхронный режим?

`async` и `await` рекомендуется использовать для действий, связанных с ЦП, когда необходима быстрая скорость реагирования. Существуют разные модели использования асинхронного кода для работы, связанной с ЦП. Важно отметить, что использование асинхронного кода приводит к небольшим затратам и не рекомендуется для непрерывных циклов.  Решать, как использовать эту новую возможность в своем коде, предстоит вам.

## <a name="see-also"></a>См. также

- [Асинхронное программирование на C#](../csharp/async.md)
- [Асинхронное программирование с использованием ключевых слов Async и Await (C#)](../csharp/programming-guide/concepts/async/index.md)
- [Асинхронное программирование на F#](../fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [Асинхронное программирование с использованием ключевых слов Async и Await (Visual Basic)](../visual-basic/programming-guide/concepts/async/index.md)
