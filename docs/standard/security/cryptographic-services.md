---
title: службы шифрования
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- cryptography [.NET Framework]
- pattern of derived class inheritance
- digital signatures
- asymmetric cryptographic algorithms
- digital signatures, public-key systems
- public keys
- decryption [.NET Framework]
- private keys
- MAC algorithms
- cryptographic algorithms
- private keys, overview
- encryption [.NET Framework]
- security [.NET Framework], encryption
- cryptographic services
- symmetric cryptographic algorithms
- hash
- message authentication codes
- derived class inheritance
- cryptography [.NET Framework], about
- random number generation
ms.assetid: f96284bc-7b73-44b5-ac59-fac613ad09f8
ms.openlocfilehash: c1783a578d0b55b0b62a1ffb870802faca97623f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187011"
---
# <a name="cryptographic-services"></a>службы шифрования

Общедоступные сети, такие как Интернет, не предоставляют средств обеспечения защищенного взаимодействия между объектами. При взаимодействии через такие сети может происходить чтение или даже изменение передаваемой информации неправомочными третьими лицами. Использование криптографии обеспечивает защиту данных от просмотра, обнаружение изменения данных и безопасный обмен данными на основе незащищенных каналов. Например, данные могут быть зашифрованы с помощью некоторого криптографического алгоритма, переданы в зашифрованном виде, а затем расшифрованы лицом, которому они предназначались. Если зашифрованные данные будут перехвачены третьим лицом, расшифровать их будет трудно.

Классы в пространстве имен <xref:System.Security.Cryptography?displayProperty=nameWithType> .NET Framework управляют различными аспектами криптографии. Некоторые из них являются оболочками для неуправляемого кода Microsoft Cryptography API (CryptoAPI), в то время как другие реализованы полностью в виде управляемого кода. При использовании этих классов вам вовсе не обязательно быть экспертом в криптографии. При создании экземпляра одного из классов, реализующих алгоритмы шифрования, ключи создаются автоматически с целью удобства использования, а принятые по умолчанию значения свойств призваны обеспечить максимальную защищенность.

Этот обзор содержит краткий обзор методов и практик шифрования, поддерживаемых рамочной системой .NET, включая манифесты ClickOnce, Suite B и поддержку криптографии следующего поколения (CNG), представленную в системе .NET 3.5.

Дополнительные сведения о шифровании, а также службах, компонентах и средствах корпорации Майкрософт, позволяющих обеспечить криптографическую защиту в приложениях, см. в разделе данной документации, посвященном обеспечению безопасности при разработке приложений Win32 и COM.

## <a name="cryptographic-primitives"></a>Криптографические примитивы

В типичной ситуации, когда используется криптография, две стороны (Анна и Виктор) осуществляют связь по незащищенному каналу. Анна и Виктор хотят быть уверены в том, что передаваемые ими данные не могут быть прочитаны даже в случае возможного перехвата. Более того, так как Анна и Виктор находятся в удаленных друг от друга местах, Анна должна быть уверена, что информация, которую она получает от Виктора, не подвергается изменению во время передачи. Также она должна быть уверена в том, что получаемые ею данные действительно исходят от Виктора, а не от кого-то, выдающего себя за него.

Криптография используется для достижения следующих целей:

- конфиденциальность: защита данных или личной информации пользователя от несанкционированного просмотра;

- целостность данных: защита данных от несанкционированного изменения;

- аутентификация: проверка того, что данные исходят действительно от определенного лица;

- неотрекаемость: ни одна сторона не должна иметь возможность отрицать факт отправки сообщения.

Для достижения этих целей можно использовать алгоритмы и правила, известные как криптографические примитивы, для создания криптографической схемы. В таблице ниже приведены криптографические примитивы и описано их использование.

|Криптографический примитив|Использование|
|-----------------------------|---------|
|Шифрование с закрытым ключом (симметричное шифрование)|Осуществляет преобразование данных с целью предотвращения их просмотра третьей стороной. При таком способе шифрования для шифрования и расшифровки данных используется один общий закрытый ключ.|
|Шифрование с открытым ключом (асимметричное шифрование)|Осуществляет преобразование данных с целью предотвращения их просмотра третьей стороной. При таком способе шифрования для шифрования и расшифровки данных используется набор, состоящий из открытого и закрытого ключей.|
|Создание криптографической подписи|Позволяет проверить, действительно ли данные исходят от конкретного лица, с помощью уникальной цифровой подписи этого лица. Этот процесс также использует хэш-функции.|
|Криптографическое хэширование|Отображает данные любого размера в байтовую последовательность фиксированной длины. Результаты хэширования статистически уникальны; отличающаяся хотя бы одним байтом последовательность не будет преобразована в то же самое значение.|

## <a name="secret-key-encryption"></a>Шифрование с закрытым ключом

При шифровании с закрытым ключом для шифрования и расшифровки данных используется один закрытый ключ. Необходимо обезопасить этот ключ от несанкционированного доступа, потому что любое обладающее им лицо может использовать его для расшифровки данных или шифрования собственных данных с подменой источника.

Шифрование с закрытым ключом называют также симметричным шифрованием, так как для шифрования и расшифровки используется один и тот же ключ. Алгоритмы шифрования с закрытым ключом являются очень быстрыми (по сравнению с алгоритмами шифрования с открытым ключом) и хорошо подходят для осуществления криптографических преобразований больших массивов данных. Асимметричные алгоритмы шифрования, такие как RSA, имеют математические ограничения на объем шифруемых данных. Для симметричных алгоритмов шифрования подобные проблемы обычно не возникают.

Разновидность алгоритмов шифрования с закрытым ключом, называемая блочным шифром, используется для шифрования целого блока данных за один раз. Блочные шифры (такие как DES, TrippleDES и AES) преобразуют входной блок данных длиной в *n* байтов в выходной блок зашифрованных данных. Если необходимо зашифровать или расшифровать последовательность байтов, следует делать это блок за блоком. Так как значение *n* достаточно мало (8 байт для DES и TripleDES; 16 байт (по умолчанию), 24 или 32 байта для AES), данные большей длины, чем *n* , должны шифроваться блоками, по одному за раз. Блоки данных размером менее *n* байт должны быть увеличены до *n* байт перед обработкой.

Одна из простейших форм блочного шифра называется режимом электронной кодовой книги (ECB). Режим ECB не считается безопасным, так как в нем не используется вектор инициализации для инициализации первого текстового блока. Для заданного закрытого ключа *k*простой блочный шифр, не использующий вектор инициализации, зашифрует одинаковые входные блоки текста в одинаковые выходные блоки зашифрованного текста. Поэтому, если во входном текстовом потоке есть одинаковые блоки, в зашифрованном потоке также будут одинаковые блоки. Такие повторяющиеся выходные блоки сообщают неправомочным пользователям о ненадежных алгоритмах шифрования, которыми можно воспользоваться, и о возможных типах атак. Шифр ECB поэтому очень уязвим для анализа и, в конечном итоге, для взлома ключа.

Классы блочных шифров, предоставляемые библиотекой базовых классов, используют режим сцепления, называемый сцеплением шифровальных блоков (CBC), хотя эту настройку по умолчанию можно изменить.

Шифры CBC решают проблемы, связанные с использованием шифров ECB, благодаря использованию вектора инициализации (IV) для шифрования первого текстового блока. Перед шифрованием каждого блока открытого текста он объединяется с зашифрованным текстом предыдущего блока с помощью поразрядной исключающей операции OR (`XOR`). Поэтому каждый блок зашифрованного текста зависит от всех предыдущих блоков. При использовании этой системы шифрования стандартные заголовки сообщений, которые могут быть известны неправомочному пользователю, не могут быть использованы им для восстановления закрытого ключа.

Одним из способов раскрытия данных, зашифрованных с помощью шифра CBC, является подбор ключа методом полного перебора возможных ключей. В зависимости от длины использованного для шифрования ключа такой подбор занимает очень много времени даже на самых быстрых компьютерах, поэтому он является практически неосуществимым. Шифры с большей длиной ключа труднее взломать. Несмотря на то что использование шифрования не гарантирует теоретическую невозможность раскрытия зашифрованных данных неправомочным лицом, стоимость такого взлома становится чрезвычайно высокой. Если процесс подбора ключа и раскрытия зашифрованных данных занимает три месяца, в то время как сами данные актуальны в течение всего нескольких дней, подбор ключа методом полного перебора не представляет практической ценности.

Недостатком шифрования с закрытым ключом является необходимость того, чтобы две стороны согласовали ключ и вектор инициализации, для чего может потребоваться их передача через систему связи. Вектор инициализации не считается секретным и может передаваться вместе с сообщением в текстовом формате. Однако ключ не должен стать известен неправомочным пользователям. Из-за этих проблем шифрование с закрытым ключом часто используется в сочетании с шифрованием с открытым ключом для безопасной передачи ключа и вектора инициализации.

Предположим, что Анна и Виктор являются двумя сторонами, которые хотят осуществлять связь по незащищенному каналу. Они могли бы воспользоваться шифрованием с закрытым ключом следующим образом. Анна и Виктор соглашаются использовать некоторый определенный алгоритм (например, AES) с определенным ключом и вектором инициализации. Алиса составляет сообщение и создает сетевой поток (возможно, названную трубу или сетевую электронную почту), на котором можно отправить сообщение. Затем она шифрует текст с помощью ключа и вектора инициализации и по интрасети пересылает зашифрованное сообщение и вектор инициализации Виктору. Виктор принимает зашифрованный текст и осуществляет расшифровку, используя ранее согласованные ключ и вектор инициализации. Если передача перехвачена, перехватчик не может восстановить исходное сообщение, потому что они не знают ключа. В этой ситуации в секрете должен сохраняться только ключ. В более реалистичном случае либо Анна, либо Виктор создает закрытый ключ и использует шифрование с открытым ключом (асимметричное) для передачи другой стороне закрытого (симметричного) ключа. Подробнее о шифровании с открытым ключом читайте в следующем разделе.

В рамочном принципе .NET предусмотрены следующие классы, внедряющие алгоритмы шифрования секретных ключей:

- <xref:System.Security.Cryptography.AesManaged>(введено в рамочном общении .NET 3.5).

- <xref:System.Security.Cryptography.DESCryptoServiceProvider>.

- <xref:System.Security.Cryptography.HMACSHA1> (Технически это алгоритм с закрытым ключом, так как он представляет собой код проверки подлинности сообщений, вычисляемый на основе хэш-функции шифрования и закрытого ключа. См. подраздел [Хэш-значения](#hash-values)ниже.)

- <xref:System.Security.Cryptography.RC2CryptoServiceProvider>.

- <xref:System.Security.Cryptography.RijndaelManaged>.

- <xref:System.Security.Cryptography.TripleDESCryptoServiceProvider>.

## <a name="public-key-encryption"></a>Шифрование с открытым ключом

При шифровании с открытым ключом используются закрытый ключ, который должен храниться в секрете от неправомочных пользователей, а также открытый ключ, который может предоставляться кому угодно. Открытый и закрытый ключи математически взаимосвязаны. Данные, зашифрованные с помощью открытого ключа, можно расшифровать исключительно с помощью соответствующего закрытого ключа, а цифровая подпись данных, подписанных с помощью закрытого ключа, может быть проверена только с помощью соответствующего открытого ключа. Открытый ключ можно предоставить любому лицу; он используется для шифрования данных, которые должны быть отправлены хранителю закрытого ключа. Алгоритмы шифрования с открытым ключом также известны как асимметричные алгоритмы, потому что для шифрования данных требуется один ключ, а для расшифровки — другой. Основное правило шифрования запрещает повторное использование ключа; оба ключа в каждом сеансе шифрования должны быть уникальными. Однако на практике асимметричные ключи обычно используются подолгу.

Две стороны (Анна и Виктор) могут использовать шифрование с открытым ключом следующим образом. Сначала Анна создает набор, состоящий из открытого и закрытого ключей. Если Виктор хочет послать Анне зашифрованное сообщение, он запрашивает у нее ее открытый ключ. Анна высылает Виктору свой открытый ключ через незащищенную сеть, и Виктор использует полученный ключ для шифрования своего сообщения. Виктор пересылает зашифрованное сообщение Анне, а она расшифровывает его с помощью своего закрытого ключа. Если Виктор получил ключ Анны по незащищенному каналу, например через открытую сеть, он оказывается уязвимым для атак типа «злоумышленник в середине». Поэтому Виктору необходимо убедиться в том, что Анна имеет правильную копию открытого ключа.

Во время передачи Виктору открытого ключа Анны может произойти несанкционированный перехват ключа третьим лицом. Более того, возможна ситуация, что то же самое лицо перехватит зашифрованное сообщение Виктора. Тем не менее неправомочная сторона не может расшифровать сообщение с помощью открытого ключа. Сообщение можно расшифровать только с помощью закрытого ключа Анны, который не передавался через какие-либо системы связи. Анна не использует свой закрытый ключ для шифрования ответного сообщения Виктору, потому что любое лицо может расшифровать это сообщение с помощью открытого ключа. Если Анна желает послать Виктору ответное сообщение, она запрашивает у Виктора его открытый ключ и шифрует свое сообщение, используя его. Затем Виктор расшифровывает сообщение с помощью своего соответствующего закрытого ключа.

В этом случае Анна и Виктор используют шифрование с открытым ключом (асимметричное) для передачи закрытого (симметричного) ключа, а затем пользуются шифрованием с этим закрытым ключом в течение сеанса связи.

В списке ниже сравниваются алгоритмы шифрования с открытым и закрытым ключом.

- Алгоритмы шифрования с открытым ключом используют буфер фиксированного размера, в то время как алгоритмы шифрования с закрытым ключом могут использовать буфер переменного размера.

- Алгоритмы шифрования с открытым ключом нельзя использовать для сцепления блоков данных в потоки тем же образом, как в алгоритмах шифрования с закрытым ключом, потому что можно шифровать только маленькие порции данных. Поэтому асимметричные операции не используют такую же потоковую модель, как симметричные операции.

- Шифрование с открытым ключом имеет намного большее пространство ключей (диапазон возможных значений ключа), чем шифрование с закрытым ключом. Поэтому такое шифрование менее уязвимо к атакам полного перебора, когда проверяются все возможные значения ключа.

- Открытые ключи можно легко распространять, так как они не требуют особой защиты при условии, что существует некий способ установления подлинности источника.

- Некоторые алгоритмы шифрования с открытым ключом (такие как RSA и DSA, но не Диффи-Хелмана) можно использовать для создания цифровых подписей, служащих для подтверждения подлинности лица, от которого исходят данные.

- Алгоритмы шифрования с открытым ключом являются весьма медленными по сравнению с алгоритмами шифрования с закрытым ключом и не предназначены для шифрования больших объемов данных. Использование шифрования с открытым ключом имеет смысл только при передаче очень малых массивов данных. Обычно шифрование с открытым ключом применяется для того, чтобы зашифровать ключ и вектор инициализации, которые будут использоваться при шифровании с закрытым ключом. После передачи ключа и вектора инициализации используется уже шифрование с закрытым ключом.

Рамочное значение .NET содержит следующие классы, внедряющие алгоритмы шифрования с открытым и ключами:

- <xref:System.Security.Cryptography.DSACryptoServiceProvider>

- <xref:System.Security.Cryptography.RSACryptoServiceProvider>

- <xref:System.Security.Cryptography.ECDiffieHellman> (базовый класс)

- <xref:System.Security.Cryptography.ECDiffieHellmanCng>

- <xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey> (базовый класс)

- <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction> (базовый класс)

- <xref:System.Security.Cryptography.ECDsaCng>

RSA допускает как шифрование, так и подписывание, в то время как DSA может использоваться только для подписывания, а алгоритм Диффи-Хелмана — только для создания ключей. В целом, алгоритмы с открытым ключом имеют более ограниченную сферу применения, чем алгоритмы с закрытым ключом.

## <a name="digital-signatures"></a>цифровые подписи

Алгоритмы шифрования с открытым ключом также можно использовать для создания цифровых подписей. Цифровые подписи удостоверяют подлинность источника данных (если вы доверяете открытому ключу источника) и защищают целостность данных. С помощью открытого ключа, созданного Анной, получатель отправленных ею данных может проверить, что их источником действительно является Анна, сравнив цифровую подпись полученных данных с открытым ключом Анны.

Чтобы использовать шифрование с открытым ключом для создания цифровой подписи сообщения, Анна сначала применяет к этому сообщению хэш-алгоритм, который создает хэш сообщения. Хэш сообщения является компактным и уникальным представлением данных. Для создания своей личной цифровой подписи Анна шифрует хэш сообщения с помощью своего закрытого ключа. При получении сообщения и цифровой подписи Виктор расшифровывает подпись с помощью открытого ключа Анны, восстанавливая хэш сообщения, а затем хэширует сообщение с помощью того же алгоритма, который использовала Анна. Если вычисленный Виктором хэш в точности совпадает с хэшем, полученным от Анны, Виктор может быть уверен в том, что сообщение пришло действительно от владельца закрытого ключа и что данные в нем не были изменены. Если Виктор уверен, что именно Анна владеет закрытым ключом, он удостоверяется в том, что сообщение пришло от нее.

> [!NOTE]
> Цифровая подпись может быть проверена любым лицом, потому что открытый ключ отправителя является общедоступным и обычно включается в формат цифровой подписи. Рассматриваемый метод не обеспечивает секретности сообщения; для обеспечения секретности его следует еще и зашифровать.

Рамочка .NET предоставляет следующие классы, которые реализуют алгоритмы цифровой подписи:

- <xref:System.Security.Cryptography.DSACryptoServiceProvider>

- <xref:System.Security.Cryptography.RSACryptoServiceProvider>

- <xref:System.Security.Cryptography.ECDsa> (базовый класс)

- <xref:System.Security.Cryptography.ECDsaCng>

## <a name="hash-values"></a>Хэш-значения

Хэш-алгоритмы преобразуют двоичные последовательности произвольной длины в двоичные последовательности фиксированного меньшего размера, известные как хэш-значения. Хэш-значение является числовым представлением порции данных. Если в хэшированном абзаце текста изменяется хотя бы одна буква, результат хэширования также меняется. Если хэш является криптостойким, его значение значительно изменится. Например, если изменяется один бит сообщения, результат выполнения криптостойкой хэш-функции может отличаться на 50 %. Несколько входных значений могут преобразовываться в один хэш-код. Однако в вычислительном плане немыслимо найти два разных входных набора данных, результаты хэширования которых полностью совпадают.

Две стороны (Анна и Виктор) могут использовать хэш-функцию для проверки целостности сообщений. Им нужно выбрать хэш-алгоритм для подписывания сообщений. Анна будет писать сообщение, а затем создавать его хэш с помощью выбранного алгоритма. Затем стороны могут применять один из указанных ниже вариантов дальнейших действий.

- Анна отправляет Виктору сообщение с открытым текстом и хэш сообщения (цифровую подпись). Виктор получает сообщение, применяет к нему хэш-алгоритм и сравнивает свое значение хэша со значением, полученным от Анны. Если хэш-значения совпадают, значит, данные не изменялись. Если хэш-значения не совпадают, значит, данные изменялись после создания.

  К сожалению, этот способ не позволяет установить подлинность отправителя. Любой человек может выдавать себя за Анну и отправлять сообщения Виктору. Для этого достаточно подписывать сообщения с помощью такого же хэш-алгоритма, и Виктор сможет лишь проверить, соответствует ли сообщение подписи. Это одна из форм атаки «злоумышленник в середине». Для получения дополнительной информации, см [Cryptography Следующее поколение (CNG) Безопасный пример связи](https://docs.microsoft.com/previous-versions/cc488018(v=vs.100)).

- Анна отправляет Виктору сообщение с открытым текстом по незащищенному открытому каналу. По защищенному закрытому каналу она оправляет Виктору хэш сообщения. Виктор получает сообщение с открытым текстом, хэширует его и сравнивает хэш со значением, полученным по закрытому каналу. Если хэши совпадают, Виктор может сделать два вывода:

  - сообщение не было изменено;

  - отправитель сообщения подлинный (Анна).

  Для того чтобы такая система работала, Анна должна скрывать оригинальное хэш-значение от всех, кроме Виктора.

- Анна по незащищенному открытому каналу отправляет Виктору сообщение в виде открытого текста, а хэш сообщения помещает на свой общедоступный веб-сайт.

  Такой подход позволяет защититься от изменения хэша третьей стороной. Хотя сообщение и его хэш могут видеть все, изменить хэш может только Анна. Злоумышленнику, который хочет выдать себя за Анну, потребуется доступ к её веб-сайту.

Ни один из описанных выше способов не защищает Анну от чтения ее сообщений третьими лицами, так как сообщения передаются в виде открытого текста. Для обеспечения полной защиты обычно требуется использовать цифровые подписи и шифрование.

В рамочном принципе .NET предусмотрены следующие классы, внедряющие алгоритмы хэширования:

- <xref:System.Security.Cryptography.HMACSHA1>.

- <xref:System.Security.Cryptography.MACTripleDES>.

- <xref:System.Security.Cryptography.MD5CryptoServiceProvider>.

- <xref:System.Security.Cryptography.RIPEMD160>.

- <xref:System.Security.Cryptography.SHA1Managed>.

- <xref:System.Security.Cryptography.SHA256Managed>.

- <xref:System.Security.Cryptography.SHA384Managed>.

- <xref:System.Security.Cryptography.SHA512Managed>.

- Разновидности HMAC всех алгоритмов SHA, MD5 и RIPEMD-160

- Реализации CryptoServiceProvider (оболочки управляемого кода) всех алгоритмов SHA

- Реализации криптографии следующего поколения (CNG) всех алгоритмов MD5 и SHA

> [!NOTE]
> Недостатки алгоритма MD5 были выявлены еще в 1996 году, и вместо него был рекомендован алгоритм SHA-1. В 2004 году были обнаружены дополнительные уязвимости, и в настоящее время алгоритм MD5 уже не считается безопасным. Алгоритм SHA-1 также был признан ненадежным, и вместо него рекомендуется использовать SHA-2.

## <a name="random-number-generation"></a>генерация случайных чисел

Генерация случайных чисел является неотъемлемой частью многих криптографических операций. Например, криптографические ключи должны выбираться настолько случайно, насколько это возможно, чтобы было фактически невозможно воспроизвести их значения. Криптографические генераторы случайных чисел должны генерировать результат, который нельзя предсказать вычислительными методами с вероятностью хотя бы 50 %. Поэтому все методы предсказания очередного случайного бита не должны быть точнее, чем простое угадывание. Классы в рамках .NET используют генераторы случайных чисел для генерации криптографических ключей.

Класс <xref:System.Security.Cryptography.RNGCryptoServiceProvider> является реализацией алгоритма генерации случайных чисел.

## <a name="clickonce-manifests"></a>Манифесты ClickOnce

В рамках .NET 3.5 следующие классы криптографии позволяют получать и проверять информацию о явно йогу для приложений, развернутых с использованием [технологии ClickOnce:](/visualstudio/deployment/clickonce-security-and-deployment)

- Класс <xref:System.Security.Cryptography.ManifestSignatureInformation> получает сведения о подписи манифеста при использовании перегрузок его метода <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> .

- С помощью перечисления <xref:System.Security.ManifestKinds> можно указать манифесты, которые нужно проверить. Результатом проверки является одно из значений перечисления <xref:System.Security.Cryptography.SignatureVerificationResult> .

- Класс <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> предоставляет коллекцию объектов проверенных подписей <xref:System.Security.Cryptography.ManifestSignatureInformation> только для чтения.

 Кроме того, перечисленные ниже классы предоставляют сведения о конкретных подписях.

- <xref:System.Security.Cryptography.StrongNameSignatureInformation> содержит сведения о строгом имени подписи для манифеста.

- <xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> представляет сведения о подписи Authenticode для манифеста.

- <xref:System.Security.Cryptography.X509Certificates.TimestampInformation> содержит сведения о метке времени в подписи Authenticode.

- <xref:System.Security.Cryptography.X509Certificates.TrustStatus> предоставляет простой способ проверить, является ли подпись Authenticode достоверной.

## <a name="suite-b-support"></a>Поддержка пакета Suite B

Рамочный номер .NET 3.5 поддерживает набор криптографических алгоритмов Suite B, опубликованный Агентством национальной безопасности (АНБ). Дополнительные сведения о шифровании по стандарту Suite B см. в документе [NSA Suite B Cryptography Fact Sheet](https://www.nsa.gov/what-we-do/information-assurance/).

В набор входят перечисленные ниже алгоритмы.

- Алгоритм AES с размером ключа для шифрования 128, 192 и 256 битов.

- Алгоритмы SHA-1, SHA-256, SHA-384 и SHA-512 для хеширования. (Последние три обычно объединяются и известны как SHA-2.)

- Алгоритм цифровой подписи ECDSA, использующий кривые в 256, 384 и 521 бит для подписи. В документации NSA приводится определение этих кривых, которые называются в ней P-256, P-384 и P-521. Этот алгоритм предоставляется в классе <xref:System.Security.Cryptography.ECDsaCng> . Он позволяет подписывать данные закрытым ключом и проверять подпись открытым ключом.

- Алгоритм ECDH, использующий кривые в 256, 384 и 521 бит для обмена ключами и секретного соглашения. Этот алгоритм предоставляется в классе <xref:System.Security.Cryptography.ECDiffieHellmanCng> .

Оболочки управляемого кода для сертифицированных Федеральным стандартом обработки информации (FIPS) реализаций AES, SHA-256, SHA-384 и SHA-512 доступны в новых классах <xref:System.Security.Cryptography.AesCryptoServiceProvider>, <xref:System.Security.Cryptography.SHA256CryptoServiceProvider>, <xref:System.Security.Cryptography.SHA384CryptoServiceProvider>и <xref:System.Security.Cryptography.SHA512CryptoServiceProvider> .

## <a name="cryptography-next-generation-cng-classes"></a>Классы криптографии следующего поколения (CNG)

Классы криптографии следующего поколения (CNG) предоставляют управляемую оболочку для собственных функций CNG. (CNG является заменой CryptoAPI.) Эти классы имеют "Cng" как часть их имен. Центральным в группе классов оболочек CNG является класс контейнера ключей <xref:System.Security.Cryptography.CngKey> , который абстрагирует хранение и использование ключей CNG. Этот класс позволяет безопасно хранить пару ключей или открытый ключ и ссылаться на него, используя простое строковое имя. Класс цифровых подписей <xref:System.Security.Cryptography.ECDsaCng> и класс шифрования <xref:System.Security.Cryptography.ECDiffieHellmanCng> на основе эллиптических кривых используют объекты <xref:System.Security.Cryptography.CngKey> .

Класс <xref:System.Security.Cryptography.CngKey> используется для множества дополнительных операций, включая открытие, создание, удаление и экспорт ключей. Он также предоставляет доступ к базовому дескриптору ключа, используемому при непосредственном вызове собственных функций.

Рамочный 3.5 .NET также включает в себя различные поддерживающие классы CNG, такие как:

- <xref:System.Security.Cryptography.CngProvider> поддерживает поставщика хранилища ключей.

- <xref:System.Security.Cryptography.CngAlgorithm> поддерживает алгоритм CNG.

- <xref:System.Security.Cryptography.CngProperty> поддерживает часто используемые свойства ключей.

## <a name="related-topics"></a>См. также

|Title|Описание|
|-----------|-----------------|
|[Модель криптографии](../../../docs/standard/security/cryptography-model.md)|Описывается реализация криптографических функций в библиотеке базовых классов.|
|[Пошаговое руководство. Создание криптографического приложения](../../../docs/standard/security/walkthrough-creating-a-cryptographic-application.md)|Демонстрируется решение основных задач шифрования и расшифровки.|
|[Настройка криптографических классов](../../../docs/framework/configure-apps/configure-cryptography-classes.md)|Описываются способы сопоставления названий алгоритмов с криптографическими классами и сопоставления идентификаторов объектов с криптографическим алгоритмом.|
