---
title: Базовые сборки
description: Сведения о базовых сборках как о специальном типе сборок в .NET, которые содержат только общедоступный API-интерфейс библиотеки
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 7d2cc01861e8a3fdc260a2990ca0652878c386b0
ms.sourcegitcommit: 7f8eeef060ddeb2cabfa52843776faf652c5a1f5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/14/2019
ms.locfileid: "74089268"
---
# <a name="reference-assemblies"></a><span data-ttu-id="46430-103">Базовые сборки</span><span class="sxs-lookup"><span data-stu-id="46430-103">Reference assemblies</span></span>

<span data-ttu-id="46430-104">*Базовые сборки* являются особым типом сборки, которая содержит только минимальный объем метаданных, необходимый для представления общедоступного API-интерфейса библиотеки.</span><span class="sxs-lookup"><span data-stu-id="46430-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="46430-105">Такие сборки включают в себя объявления для всех элементов, которые важны при указании ссылки на сборку в средствах сборки, но исключают все реализации элементов, а также объявления закрытых элементов, не имеющих наблюдаемого влияния на их контракт API.</span><span class="sxs-lookup"><span data-stu-id="46430-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="46430-106">Обычные сборки, напротив, называются *сборками реализации*.</span><span class="sxs-lookup"><span data-stu-id="46430-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="46430-107">Базовые сборки не могут быть загружены для выполнения, но они могут передаваться как входные данные компилятора так же, как сборки реализации.</span><span class="sxs-lookup"><span data-stu-id="46430-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="46430-108">Базовые сборки обычно распределяются с помощью пакета средств разработки программного обеспечения (SDK) определенной платформы или библиотеки.</span><span class="sxs-lookup"><span data-stu-id="46430-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="46430-109">Использование базовой сборки позволяет разработчикам создавать программы, предназначенные для конкретной версии библиотеки, без наличия полной сборки реализации для этой версии.</span><span class="sxs-lookup"><span data-stu-id="46430-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="46430-110">Допустим, на компьютере установлена только последняя версия определенной библиотеки, но требуется создать программу, предназначенную для более ранней версии этой библиотеки.</span><span class="sxs-lookup"><span data-stu-id="46430-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="46430-111">При компиляции непосредственно из сборки реализации вы можете случайно использовать элементы API, которые недоступны в более ранней версии,</span><span class="sxs-lookup"><span data-stu-id="46430-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="46430-112">и обнаружите эту ошибку только при проверке программы на целевом компьютере.</span><span class="sxs-lookup"><span data-stu-id="46430-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="46430-113">При компиляции из базовой сборки для более ранней версии сразу же возникает ошибка времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="46430-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="46430-114">Базовая сборка также может представлять контракт, то есть набор API-интерфейсов, который не соответствует конкретной сборке реализации.</span><span class="sxs-lookup"><span data-stu-id="46430-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="46430-115">Такие базовые сборки, называемые *сборками контракта*, можно использовать для нескольких платформ, поддерживающих один и тот же набор API-интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="46430-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="46430-116">Например, .NET Standard предоставляет сборку контракта, *netstandard.dll*, которая представляет набор общих API-интерфейсов, совместно используемых различными платформами .NET.</span><span class="sxs-lookup"><span data-stu-id="46430-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="46430-117">Реализации этих API-интерфейсов содержатся в разных сборках на разных платформах, например *mscorlib.dll* в .NET Framework или *System.Private.CoreLib.dll* в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="46430-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="46430-118">Библиотека, нацеленная на .NET Standard, может выполняться на всех платформах, поддерживающих .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="46430-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="46430-119">Использование базовых сборок</span><span class="sxs-lookup"><span data-stu-id="46430-119">Using reference assemblies</span></span>

<span data-ttu-id="46430-120">Чтобы использовать определенные API-интерфейсы из проекта, необходимо добавить ссылки на их сборки.</span><span class="sxs-lookup"><span data-stu-id="46430-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="46430-121">Ссылки можно добавлять либо в сборки реализации, либо в базовые сборки.</span><span class="sxs-lookup"><span data-stu-id="46430-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="46430-122">По возможности рекомендуется использовать базовые сборки если они доступны.</span><span class="sxs-lookup"><span data-stu-id="46430-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="46430-123">Таким образом, вы будете гарантированно использовать в целевой версии только поддерживаемые члены API, которые были предназначены для этого разработчиками API.</span><span class="sxs-lookup"><span data-stu-id="46430-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="46430-124">Применяя базовую сборку, вы гарантированно не будете зависеть от деталей реализации.</span><span class="sxs-lookup"><span data-stu-id="46430-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="46430-125">Базовые сборки для библиотек .NET Framework распределяются с помощью пакетов нацеливания.</span><span class="sxs-lookup"><span data-stu-id="46430-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="46430-126">Их можно получить, скачав автономный установщик или выбрав компонент в Visual Studio Installer.</span><span class="sxs-lookup"><span data-stu-id="46430-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="46430-127">См. дополнительные сведения об [установке .NET Framework для разработчиков](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="46430-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="46430-128">Для .NET Core и .NET Standard базовые сборки автоматически скачиваются при необходимости (через NuGet) и на них указываются ссылки.</span><span class="sxs-lookup"><span data-stu-id="46430-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="46430-129">Для .NET Core 3.0 и более поздних версий базовые сборки для основной платформы находятся в пакете [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (до версии 3.0 используется пакет [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App)).</span><span class="sxs-lookup"><span data-stu-id="46430-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="46430-130">Дополнительные сведения см. в статье [Пакеты, метапакеты и платформы](../../core/packages.md) в руководстве по .NET Core.</span><span class="sxs-lookup"><span data-stu-id="46430-130">For more information, see [Packages, metapackages, and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="46430-131">При добавлении ссылок на сборки .NET Framework в Visual Studio с помощью диалогового окна **Добавление ссылки** вы выбираете сборку из списка, и Visual Studio автоматически находит базовые сборки, соответствующие требуемой версии .NET Framework, выбранной в проекте.</span><span class="sxs-lookup"><span data-stu-id="46430-131">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="46430-132">То же самое применимо для добавления ссылок непосредственно в проект MSBuild с помощью элемента проекта [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference). Вам необходимо указать только имя сборки, а не полный путь к файлу.</span><span class="sxs-lookup"><span data-stu-id="46430-132">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="46430-133">При добавлении ссылок на эти сборки в командной строке с помощью параметра компилятора `-reference` ([в C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) и в [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) или с помощью метода <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> в API Roslyn необходимо вручную указать файлы базовой сборки для правильной версии целевой платформы.</span><span class="sxs-lookup"><span data-stu-id="46430-133">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="46430-134">Файлы базовой сборки .NET Framework находятся в каталоге *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework*.</span><span class="sxs-lookup"><span data-stu-id="46430-134">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="46430-135">Для .NET Core можно принудительно выполнить операцию публикации, чтобы скопировать базовые сборки для целевой платформы в подкаталог *publish/refs* выходного каталога, установив для свойства проекта `PreserveCompilationContext` значение `true`.</span><span class="sxs-lookup"><span data-stu-id="46430-135">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="46430-136">Затем можно передать эти файлы базовой сборки компилятору.</span><span class="sxs-lookup"><span data-stu-id="46430-136">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="46430-137">Для поиска их путей можно использовать `DependencyContext` из пакета [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/).</span><span class="sxs-lookup"><span data-stu-id="46430-137">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="46430-138">Так как базовые сборки не содержат реализации, они не могут быть загружены для выполнения. Любые попытки сделать это приведут к возникновению исключения <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="46430-138">Because they contain no implementation, reference assemblies can't be loaded for execution; trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="46430-139">Однако если необходимо просмотреть их содержимое, они могут быть загружены в контекст, предназначенный только для отражения (с помощью метода <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="46430-139">However, they still can be loaded into the reflection-only context (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method), if you need to examine their contents.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="46430-140">Создание базовых сборок</span><span class="sxs-lookup"><span data-stu-id="46430-140">Generating reference assemblies</span></span>

<span data-ttu-id="46430-141">Рекомендуется создавать базовые сборки для библиотек в тех случаях, когда их пользователям требуется создавать программы на основе множества разных версий отдельной библиотеки.</span><span class="sxs-lookup"><span data-stu-id="46430-141">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="46430-142">Распространение сборок реализации для всех этих версий может оказаться нецелесообразным из-за их большого размера.</span><span class="sxs-lookup"><span data-stu-id="46430-142">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="46430-143">Базовые сборки имеют меньший размер, поэтому их распространение в составе пакета SDK для библиотеки уменьшает объем скачиваемых данных и экономит место на диске.</span><span class="sxs-lookup"><span data-stu-id="46430-143">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="46430-144">Интегрированные среды разработки и средства сборки также могут использовать базовые сборки, чтобы сократить время сборки в случае больших решений, состоящих из нескольких библиотек классов.</span><span class="sxs-lookup"><span data-stu-id="46430-144">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="46430-145">Как правило, в сценариях инкрементной сборки проект перестраивается при изменении любого из его входных файлов, включая сборки, от которых он зависит.</span><span class="sxs-lookup"><span data-stu-id="46430-145">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="46430-146">Сборка реализации изменяется каждый раз, когда программист изменяет реализацию любого элемента.</span><span class="sxs-lookup"><span data-stu-id="46430-146">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="46430-147">Базовая сборка изменяется только при ее влиянии на общедоступный API.</span><span class="sxs-lookup"><span data-stu-id="46430-147">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="46430-148">Таким образом, использование базовой сборки в качестве входного файла вместо сборки реализации позволяет в некоторых случаях пропустить сборку зависимого проекта.</span><span class="sxs-lookup"><span data-stu-id="46430-148">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="46430-149">Вы можете создавать базовые сборки:</span><span class="sxs-lookup"><span data-stu-id="46430-149">You can generate reference assemblies:</span></span>

- <span data-ttu-id="46430-150">В проекте MSBuild с помощью [свойства проекта `ProduceReferenceAssembly`](/visualstudio/msbuild/common-msbuild-project-properties).</span><span class="sxs-lookup"><span data-stu-id="46430-150">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="46430-151">При компиляции программы из командной строки, указывая параметры компилятора `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) или `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)).</span><span class="sxs-lookup"><span data-stu-id="46430-151">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="46430-152">При использовании API Roslyn путем установки для параметра <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> значения `true`, а для параметра <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> значения `false` в объекте, переданном в метод <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="46430-152">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="46430-153">Если хотите распределить базовые сборки с помощью пакетов NuGet, их необходимо включить в подкаталог *ref\\* каталога пакета, а не в подкаталог *lib\\* , используемый для сборок реализации.</span><span class="sxs-lookup"><span data-stu-id="46430-153">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="46430-154">Структура базовых сборок</span><span class="sxs-lookup"><span data-stu-id="46430-154">Reference assemblies structure</span></span>

<span data-ttu-id="46430-155">Базовые сборки являются расширением связанной концепции — *сборок, содержащих только метаданные*.</span><span class="sxs-lookup"><span data-stu-id="46430-155">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="46430-156">Тела методов в сборках, состоящих только из метаданных, заменяются одним телом `throw null`, но такие сборки включают все члены, кроме анонимных типов.</span><span class="sxs-lookup"><span data-stu-id="46430-156">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="46430-157">Тело `throw null` используется для того, чтобы могло выполняться средство **PEVerify** для проверки полноты метаданных, что было бы невозможно при отсутствии тела.</span><span class="sxs-lookup"><span data-stu-id="46430-157">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="46430-158">Базовые сборки удаляют метаданные (закрытые члены) из сборок, содержащих только метаданные.</span><span class="sxs-lookup"><span data-stu-id="46430-158">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="46430-159">Базовая сборка содержит ссылки только на необходимые компоненты в слое доступа API.</span><span class="sxs-lookup"><span data-stu-id="46430-159">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="46430-160">Реальная сборка может иметь дополнительные ссылки, связанные с конкретной реализацией.</span><span class="sxs-lookup"><span data-stu-id="46430-160">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="46430-161">Например, базовая сборка для `class C { private void M() { dynamic d = 1; ... } }` не ссылается на типы, требуемые для `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="46430-161">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="46430-162">Закрытые функции-члены (методы, свойства и события) удаляются в случае, если их удаление не скажется заметно на компиляции.</span><span class="sxs-lookup"><span data-stu-id="46430-162">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="46430-163">Если нет атрибутов [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute), внутренние элементы функции также удаляются.</span><span class="sxs-lookup"><span data-stu-id="46430-163">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="46430-164">Метаданные в базовых сборках продолжают хранить следующие сведения:</span><span class="sxs-lookup"><span data-stu-id="46430-164">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="46430-165">все типы, включая закрытые и вложенные;</span><span class="sxs-lookup"><span data-stu-id="46430-165">All types, including private and nested types.</span></span>
- <span data-ttu-id="46430-166">все атрибуты, даже внутренние;</span><span class="sxs-lookup"><span data-stu-id="46430-166">All attributes, even internal ones.</span></span>
- <span data-ttu-id="46430-167">все виртуальные методы;</span><span class="sxs-lookup"><span data-stu-id="46430-167">All virtual methods.</span></span>
- <span data-ttu-id="46430-168">явные реализации интерфейса;</span><span class="sxs-lookup"><span data-stu-id="46430-168">Explicit interface implementations.</span></span>
- <span data-ttu-id="46430-169">явно реализованные свойства и события, так как их методы доступа являются виртуальными;</span><span class="sxs-lookup"><span data-stu-id="46430-169">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="46430-170">все поля структур.</span><span class="sxs-lookup"><span data-stu-id="46430-170">All fields of structures.</span></span>

<span data-ttu-id="46430-171">Базовые сборки содержат атрибут [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) уровня сборки.</span><span class="sxs-lookup"><span data-stu-id="46430-171">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="46430-172">Этот атрибут может быть задан в исходном коде, в таком случае компилятору не требуется его синтезировать.</span><span class="sxs-lookup"><span data-stu-id="46430-172">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="46430-173">Из-за этого атрибута среды выполнения не будут загружать базовые сборки для выполнения (однако они могут загружаться в режиме только для отражения).</span><span class="sxs-lookup"><span data-stu-id="46430-173">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="46430-174">Точные сведения о структуре базовой сборки зависят от версии компилятора.</span><span class="sxs-lookup"><span data-stu-id="46430-174">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="46430-175">Более новые версии могут исключить дополнительные метаданные, если они не влияют на общедоступный API-интерфейса.</span><span class="sxs-lookup"><span data-stu-id="46430-175">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="46430-176">Сведения в этом разделе применимы только к базовым сборкам, которые созданы компиляторами Roslyn, начиная с C# версии 7.1 или Visual Basic версии 15.3.</span><span class="sxs-lookup"><span data-stu-id="46430-176">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="46430-177">Структура базовых сборок для библиотек .NET Framework и .NET Core может отличаться некоторыми деталями, так как они используют собственный механизм создания базовых сборок.</span><span class="sxs-lookup"><span data-stu-id="46430-177">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="46430-178">Например, они могут иметь совершенно пустые тела методов вместо тела `throw null`.</span><span class="sxs-lookup"><span data-stu-id="46430-178">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="46430-179">Но общие принципы по-прежнему применяются: у них нет пригодных для использования реализаций методов и они содержат метаданные только для элементов, которые имеют наблюдаемый эффект с точки зрения общедоступного API-интерфейса.</span><span class="sxs-lookup"><span data-stu-id="46430-179">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="46430-180">См. также</span><span class="sxs-lookup"><span data-stu-id="46430-180">See also</span></span>

- [<span data-ttu-id="46430-181">Сборки в .NET</span><span class="sxs-lookup"><span data-stu-id="46430-181">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="46430-182">Общие сведения о настройке для платформы</span><span class="sxs-lookup"><span data-stu-id="46430-182">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="46430-183">Практическое руководство. Добавление и удаление ссылок с помощью диспетчера ссылок</span><span class="sxs-lookup"><span data-stu-id="46430-183">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
