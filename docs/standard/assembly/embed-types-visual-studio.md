---
title: Пошаговое руководство. Внедрение типов из управляемых сборок в Visual Studio
ms.date: 08/19/2019
ms.assetid: 55ed13c9-c5bb-4bc2-bcd8-0587eb568864
dev_langs:
- csharp
- vb
ms.openlocfilehash: f11fbedad766753ee462c5f597b823493cdaf7cf
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "75338557"
---
# <a name="walkthrough-embed-types-from-managed-assemblies-in-visual-studio"></a>Пошаговое руководство. Внедрение типов из управляемых сборок в Visual Studio

Внедряя сведения о типе из управляемой сборки со строгим именем, можно свободно объединять типы в приложении, делая версию независимой. Это означает, что в программе можно использовать типы из любой версии управляемой библиотеки, т. е. необходимость компиляции для каждой новой версии отпадает.

Внедрение типов часто используется с COM-взаимодействием, например в приложениях, использующих объекты автоматизации из Microsoft Office. Сведения о типе внедрения позволяют одной и той же сборке программы работать с различными версиями Microsoft Office на разных компьютерах. Тем не менее внедрение типа можно также использовать с полностью управляемыми решениями.

После указания открытых интерфейсов, доступных для внедрения, создайте реализующие их классы среды выполнения. Во время разработки клиентская программа встраивает сведения о типе для интерфейсов, ссылаясь на сборку, содержащую открытые интерфейсы, и присваивая свойству `Embed Interop Types` ссылки значение `True`. После этого клиентская программа может загружать экземпляры объектов среды выполнения, типизированные как указанные интерфейсы. Это эквивалентно использованию компилятора командной строки и ссылки на сборку с помощью [параметра компилятора -link](../../csharp/language-reference/compiler-options/link-compiler-option.md).

При создании новой версии сборки среды выполнения со строгим именем повторная компиляция клиентской программы не требуется. Клиентская программа продолжает работать с той версией сборки среды выполнения, которая ей доступна, используя сведения о внедренном типе для открытых интерфейсов.

С помощью этого пошагового руководства:

1. Создайте сборку со строгим именем и открытым интерфейсом, содержащим сведения о типе, который может быть внедрен.
1. Создайте сборку среды выполнения со строгим именем, реализующую открытый интерфейс.
1. Создайте клиентскую программу, внедряющую сведения о типе из открытого интерфейса и создающую экземпляр класса из сборки среды выполнения.
1. Внесите изменения и создайте сборку среды выполнения заново.
1. Запустите клиентскую программу, чтобы увидеть, что новая версия сборки среды выполнения используется без повторной компиляции.

[!INCLUDE[note_settings_general](../../../includes/note-settings-general-md.md)]

## <a name="conditions-and-limitations"></a>Условия и ограничения

Вы можете внедрить информацию о типах из сборки при следующих условиях:

- Сборка предоставляет по крайней мере один открытый интерфейс.
- Внедренные интерфейсы снабжаются аннотацией с указанием атрибутов `ComImport` и `Guid` с уникальными GUID.
- Сборка снабжается аннотацией с указанием атрибута `ImportedFromTypeLib` или атрибута `PrimaryInteropAssembly`, а также атрибута сборки `Guid`. По умолчанию шаблоны проектов Visual C# и Visual Basic включают атрибут сборки `Guid`.

Так как основной функцией внедрения типа является поддержка внедрения сборок COM-взаимодействия, при внедрении сведений о типе в полностью управляемое решение применяются следующие ограничения:

- Внедряются только атрибуты, характерные для COM-взаимодействия. Другие атрибуты игнорируются.
- Если тип включает универсальные параметры внедренного типа, использовать этот тип за границей сборки невозможно. Граница сборки пересекается, например, при вызове метода из другой сборки или выведении типа из типа, определенного в другой сборке.
- Константы не внедряются.
- Класс <xref:System.Collections.Generic.Dictionary%602?displayProperty=nameWithType> не поддерживает использование внедренного типа в качестве ключа. Для поддержки внедренного типа в качестве ключа можно реализовать свой собственный тип словаря.

## <a name="create-an-interface"></a>Создание интерфейса

Первый шаг заключается в создании сборки интерфейса для эквивалентности типов.

1. В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**.

1. В диалоговом окне **Создание проекта** введите *библиотека классов* в поле **Поиск шаблонов**. Выберите шаблон **Библиотека классов (.NET Framework)** для C# или Visual Basic в списке и щелкните **Далее**.

1. В диалоговом окне **Настроить новый проект** в поле **Имя проекта** введите *TypeEquivalenceInterface* и нажмите кнопку **Создать**. Проект создан.

1. В **обозревателе решений** щелкните правой кнопкой мыши файл *Class1.cs* или *Class1.vb*, выберите пункт **Переименовать** и переименуйте файл с *Class1* на *ISampleInterface*. Ответьте **Да** на запрос, чтобы также переименовать класс на `ISampleInterface`. Этот класс представляет открытый интерфейс для класса.

1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Свойства**.

1. Выберите элемент **Сборка** в левой области экрана **Свойства** и задайте в поле **Путь вывода** расположение на компьютере, например *C:\TypeEquivalenceSample*. Данное расположение используется в рамках всего этого пошагового руководства.

1. Выберите **Подписывание** в левой области экрана **Свойства** и установите флажок **Подписать сборку**. В раскрывающемся списке **Выберите файл ключа строгого имени** выберите **Создать**.

1. В диалоговом окне **Создание ключа строгого имени** в разделе **Имя файла ключа** введите *key.snk*. Снимите флажок **Защитить мой файл ключей паролем** и нажмите кнопку **ОК**.

1. Откройте файл класса *ISampleInterface* в редакторе кода и замените его содержимое следующим кодом, чтобы создать интерфейс `ISampleInterface`:

   ```csharp
   using System;
   using System.Runtime.InteropServices;

   namespace TypeEquivalenceInterface
   {
       [ComImport]
       [Guid("8DA56996-A151-4136-B474-32784559F6DF")]
       public interface ISampleInterface
       {
           void GetUserInput();
           string UserInput { get; }
       }
   }
   ```

   ```vb
   Imports System.Runtime.InteropServices

   <ComImport()>
   <Guid("8DA56996-A151-4136-B474-32784559F6DF")>
   Public Interface ISampleInterface
       Sub GetUserInput()
       ReadOnly Property UserInput As String
   End Interface
   ```

1. В меню **Сервис** выберите пункт **Создать GUID** и в диалоговом окне **Создание GUID** выберите **Формат реестра**. Выберите **Копировать**, а затем **Выход**.

1. В атрибуте `Guid` кода замените пример GUID на скопированный GUID и удалите фигурные скобки ( **{ }** ).

1. В **обозревателе решений** разверните папку **Свойства** и выберите файл *AssemblyInfo.cs* или *AssemblyInfo.vb* file. В редакторе кода добавьте в файл следующий атрибут:

   ```csharp
   [assembly: ImportedFromTypeLib("")]
   ```

   ```vb
   <Assembly: ImportedFromTypeLib("")>
   ```

1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.

1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Сборка**. DLL-файл библиотеки классов компилируется и сохраняется по указанному пути вывода сборки, например *C:\TypeEquivalenceSample*.

## <a name="create-a-runtime-class"></a>Создание класса среды выполнения

Далее создайте класс среды выполнения для эквивалентности типов.

1. В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**.

1. В диалоговом окне **Создание проекта** введите *библиотека классов* в поле **Поиск шаблонов**. Выберите шаблон **Библиотека классов (.NET Framework)** для C# или Visual Basic в списке и щелкните **Далее**.

1. В диалоговом окне **Настроить новый проект** в поле **Имя проекта** введите *TypeEquivalenceRuntime* и нажмите кнопку **Создать**. Проект создан.

1. В **обозревателе решений** щелкните правой кнопкой мыши файл *Class1.cs* или *Class1.vb*, выберите пункт **Переименовать** и переименуйте файл с *Class1* на *SampleClass*. Ответьте **Да** на запрос, чтобы также переименовать класс на `SampleClass`. Этот класс реализует интерфейс `ISampleInterface` .

1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Свойства**.

1. Выберите элемент **Сборка** в левой области экрана **Свойства** и задайте в поле **Путь вывода** то же расположение, которое использовали для проекта TypeEquivalenceInterface, например, *C:\TypeEquivalenceSample*.

1. Выберите **Подписывание** в левой области экрана **Свойства** и установите флажок **Подписать сборку**. В раскрывающемся списке **Выберите файл ключа строгого имени** выберите **Создать**.

1. В диалоговом окне **Создание ключа строгого имени** в разделе **Имя файла ключа** введите *key.snk*. Снимите флажок **Защитить мой файл ключей паролем** и нажмите кнопку **ОК**.

1. В **обозревателе решений** щелкните проект **TypeEquivalenceRuntime** правой кнопкой мыши и выберите **Добавить** > **Ссылка**.

1. В диалоговом окне **Диспетчер ссылок** выберите **Обзор** и перейдите к папке пути вывода. Выберите файл *TypeEquivalenceInterface.dll*, нажмите кнопку **Добавить** и затем кнопку **ОК**.

1. В **обозревателе решений** разверните папку **Ссылки** и выберите ссылку **TypeEquivalenceInterface**. В области **Свойства** задайте для параметра **Определенная версия** значение **False**, если оно еще не установлено.

1. Откройте файл класса *SampleClass* в редакторе кода и замените его содержимое следующим кодом, чтобы создать класс `SampleClass`:

   ```csharp
   using System;
   using TypeEquivalenceInterface;

   namespace TypeEquivalenceRuntime
   {
       public class SampleClass : ISampleInterface
       {
           private string p_UserInput;
           public string UserInput { get { return p_UserInput; } }

           public void GetUserInput()
           {
               Console.WriteLine("Please enter a value:");
               p_UserInput = Console.ReadLine();
           }
       }
   }
   ```

   ```vb
   Imports TypeEquivalenceInterface

   Public Class SampleClass
       Implements ISampleInterface

       Private p_UserInput As String
       Public ReadOnly Property UserInput() As String Implements ISampleInterface.UserInput
           Get
               Return p_UserInput
           End Get
       End Property

       Public Sub GetUserInput() Implements ISampleInterface.GetUserInput
           Console.WriteLine("Please enter a value:")
           p_UserInput = Console.ReadLine()
       End Sub
   End Class
   ```

1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.

1. В **обозревателе решений** щелкните проект **TypeEquivalenceRuntime** правой кнопкой мыши и выберите **Сборка**. DLL-файл библиотеки классов компилируется и сохраняется по указанному пути вывода сборки.

## <a name="create-a-client-project"></a>Создание клиентского проекта

Наконец, создайте клиентскую программу эквивалентности типов, которая ссылается на сборку интерфейса.

1. В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**.

1. В диалоговом окне **Создание проекта** введите *консоль* в поле **Поиск шаблонов**. Выберите шаблон **Консольное приложение (.NET Framework)** для C# или Visual Basic в списке и щелкните **Далее**.

1. В диалоговом окне **Настроить новый проект** в поле **Имя проекта** введите *TypeEquivalenceClient* и нажмите кнопку **Создать**. Проект создан.

1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceClient** и выберите пункт **Свойства**.

1. Выберите элемент **Сборка** в левой области экрана **Свойства** и задайте в поле **Путь вывода** то же расположение, которое использовали для проекта TypeEquivalenceInterface, например, *C:\TypeEquivalenceSample*.

1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceClient** и выберите **Добавить** > **Ссылка**.

1. В диалоговом окне **Диспетчер ссылок** выберите файл **TypeEquivalenceInterface.dll**, если он уже присутствует в списке. В противном случае выберите **Обзор**, перейдите к папке пути вывода, выберите файл *TypeEquivalenceInterface.dll* (а не *TypeEquivalenceRuntime.dll*) и нажмите кнопку **Добавить**. Нажмите кнопку **ОК**.

1. В **обозревателе решений** разверните папку **Ссылки** и выберите ссылку **TypeEquivalenceInterface**. В области **Свойства** установите для параметра **Внедрить типы взаимодействия** значение **True**.

1. Откройте файл *Program.cs* или *Module1.vb* в редакторе кода и замените его содержимое следующим кодом, чтобы создать клиентскую программу:

   ```csharp
   using System;
   using System.Reflection;
   using TypeEquivalenceInterface;

   namespace TypeEquivalenceClient
   {
       class Program
       {
           static void Main(string[] args)
           {
               Assembly sampleAssembly = Assembly.Load("TypeEquivalenceRuntime");
               ISampleInterface sampleClass =
                   (ISampleInterface)sampleAssembly.CreateInstance("TypeEquivalenceRuntime.SampleClass");
               sampleClass.GetUserInput();
               Console.WriteLine(sampleClass.UserInput);
               Console.WriteLine(sampleAssembly.GetName().Version.ToString());
               Console.ReadLine();
           }
       }
   }
   ```

   ```vb
   Imports System.Reflection
   Imports TypeEquivalenceInterface

   Module Module1

       Sub Main()
           Dim sampleAssembly = Assembly.Load("TypeEquivalenceRuntime")
           Dim sampleClass As ISampleInterface = CType( _
               sampleAssembly.CreateInstance("TypeEquivalenceRuntime.SampleClass"), ISampleInterface)
           sampleClass.GetUserInput()
           Console.WriteLine(sampleClass.UserInput)
           Console.WriteLine(sampleAssembly.GetName().Version)
           Console.ReadLine()
       End Sub

   End Module
   ```

1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.

1. Нажмите клавиши **CTRL**+**F5**, чтобы собрать и запустить программу. Обратите внимание, что выходные данные консоли возвращают версию сборки **1.0.0.0**.

## <a name="modify-the-interface"></a>Изменение интерфейса

Теперь измените сборку интерфейса и смените ее версию.

1. В Visual Studio выберите **Файл** > **Открыть** > **Проект/решение** и откройте проект **TypeEquivalenceInterface**.

1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Свойства**.

1. Выберите **Приложение** в левой области экрана **Свойства** и элемент **Сведения о сборке**.

1. В диалоговом окне **Сведения о сборке** измените значения **Версия сборки** и **Версия файла** на *2.0.0.0* и нажмите кнопку **ОК**.

1. Откройте файл *SampleInterface.cs* или *SampleInterface.vb* и добавьте в интерфейс `ISampleInterface` следующую строку кода:

   ```csharp
   DateTime GetDate();
   ```

   ```vb
   Function GetDate() As Date
   ```

1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.

1. В **обозревателе решений** щелкните правой кнопкой мыши проект **TypeEquivalenceInterface** и выберите пункт **Сборка**. Новая версия DLL-файла библиотеки классов компилируется и сохраняется по пути вывода сборки.

## <a name="modify-the-runtime-class"></a>Изменение класса среды выполнения

Также измените класс среды выполнения и обновите его версию.

1. В Visual Studio выберите **Файл** > **Открыть** > **Проект/решение** и откройте проект **TypeEquivalenceRuntime**.

1. В **обозревателе решений** щелкните проект **TypeEquivalenceRuntime** правой кнопкой мыши и выберите **Свойства**.

1. Выберите **Приложение** в левой области экрана **Свойства** и элемент **Сведения о сборке**.

1. В диалоговом окне **Сведения о сборке** измените значения **Версия сборки** и **Версия файла** на *2.0.0.0* и нажмите кнопку **ОК**.

1. Откройте файл *SampleClass.cs* или *SampleClass.vb* и добавьте в класс `SampleClass` следующий код:

   ```csharp
    public DateTime GetDate()
    {
        return DateTime.Now;
    }
   ```

   ```vb
   Public Function GetDate() As DateTime Implements ISampleInterface.GetDate
       Return Now
   End Function
   ```

1. Выберите **Файл** > **Сохранить все** или нажмите клавиши **CTRL**+**SHIFT**+**S** для сохранения файлов и проекта.

1. В **обозревателе решений** щелкните проект **TypeEquivalenceRuntime** правой кнопкой мыши и выберите **Сборка**. Новая версия DLL-файла библиотеки классов компилируется и сохраняется по пути вывода сборки.

## <a name="run-the-updated-client-program"></a>Запуск обновленной клиентской программы

Перейдите в папку вывода сборки и запустите *TypeEquivalenceClient.exe*. Обратите внимание, что выходные данные консоли теперь отражают новую версию сборки `TypeEquivalenceRuntime` — *2.0.0.0* — без повторной компиляции программы.

## <a name="see-also"></a>См. также

- [-link (параметры компилятора C#)](../../csharp/language-reference/compiler-options/link-compiler-option.md)
- [-link (Visual Basic)](../../visual-basic/reference/command-line-compiler/link.md)
- [Руководство по программированию на C#](../../csharp/programming-guide/index.md)
- [Основные понятия программирования (Visual Basic)](../../visual-basic/programming-guide/concepts/index.md)
- [Сборки в .NET](index.md)
