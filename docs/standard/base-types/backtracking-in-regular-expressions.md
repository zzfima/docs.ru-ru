---
title: Поиск с возвратом в регулярных выражениях .NET
description: Сведения об управлении поиском с возвратом в сопоставлении шаблонов регулярных выражений.
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
ms.custom: seodec18
ms.openlocfilehash: 06f1094d872c84f2f277c7695a8858edc285449f
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73140517"
---
# <a name="backtracking-in-regular-expressions"></a>Поиск с возвратом в регулярных выражениях
<a name="top"></a> Поиск с возвратом происходит, если шаблон регулярного выражения содержит переменные [квантификаторы](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) или [конструкции изменения](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), и обработчик регулярных выражений возвращается в предыдущее сохраненное состояние, чтобы продолжить поиск совпадения. В поиске с возвратом заключена сила регулярных выражений. Благодаря ему выражения могут быть мощными и гибкими, а также совпадать со сложными шаблонами. С другой стороны, эти возможности дорого обходятся. Часто именно поиск с возвратом существенно снижает производительность обработчика регулярных выражений. К счастью, разработчик может управлять работой обработчика регулярных выражений и тем, как он использует поиск с возвратом. В этом разделе описано, как функционирует поиск с возвратом, и как им можно управлять.  
  
> [!NOTE]
> В целом при использовании NFA-машины (недетерминированного конечного автомата), такой как обработчик регулярных выражений .NET, ответственность за создание эффективных и быстро выполняемых регулярных выражений лежит на разработчике.  
  
 В этом разделе содержатся следующие подразделы.  
  
- [Линейное сравнение без поиска с возвратом](#linear_comparison_without_backtracking)  
  
- [Поиск с возвратом с переменными квантификаторами и конструкциями изменения](#backtracking_with_optional_quantifiers_or_alternation_constructs)  
  
- [Поиск с возвратом со вложенными переменными квантификаторами](#backtracking_with_nested_optional_quantifiers)  
  
- [Управление поиском с возвратом](#controlling_backtracking)  
  
<a name="linear_comparison_without_backtracking"></a>   
## <a name="linear-comparison-without-backtracking"></a>Линейное сравнение без поиска с возвратом  
 Если шаблон регулярного выражения не содержит переменных квантификаторов или конструкций изменения, обработчик регулярных выражений работает за линейное время. Это значит, что когда обработчик регулярных выражений находит совпадение с первым языковым элементом шаблона в тексте входной строки, он сопоставляет следующий языковой элемент шаблона со следующим символом или группой символов входной строки. Так продолжается, пока поиск совпадения не заканчивается успешно или неуспешно. В обоих случаях обработчик регулярных выражений продвигается вперед, обрабатывая по одному символу входной строки.  
  
 Ниже приведен пример. Регулярное выражение `e{2}\w\b` ищет следующую строку: два вхождения буквы «e», затем символ слова, затем граница слова.  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 Несмотря на то что это регулярное выражение содержит квантификатор `{2}`, оно обрабатывается линейным образом. Обработчик регулярных выражений не выполняет поиск с возвратом, поскольку квантификатор `{2}` не является переменным квантификатором; он указывает конкретное, а не переменное число вхождений предшествующей части выражения. В результате обработчик регулярных выражений ищет совпадение с шаблоном во входной строке, как показано в следующей таблице.  
  
|Операция|Положение в шаблоне|Положение в строке|Результат|  
|---------------|-------------------------|------------------------|------------|  
|1|й|"needing a reed" (позиция 0)|Нет совпадения.|  
|2|й|"eeding a reed" (позиция 1)|Возможное совпадение.|  
|3|e{2}|"eding a reed" (позиция 2)|Возможное совпадение.|  
|4|\\w|"ding a reed" (позиция 3)|Возможное совпадение.|  
|5|\b|"ing a reed" (позиция 4)|Совпадение не подтвердилось.|  
|6|й|"eding a reed" (позиция 2)|Возможное совпадение.|  
|7|e{2}|"ding a reed" (позиция 3)|Совпадение не подтвердилось.|  
|8|й|"ding a reed" (позиция 3)|Совпадение отсутствует.|  
|9|й|"ing a reed" (позиция 4)|Нет совпадения.|  
|10|й|"ng a reed" (позиция 5)|Нет совпадения.|  
|11|й|"g a reed" (позиция 6)|Нет совпадения.|  
|12|й|" a reed" (позиция 7)|Нет совпадения.|  
|13|й|a reed (позиция 8)|Нет совпадения.|  
|14|й|" reed" (позиция 9)|Нет совпадения.|  
|15|й|reed (позиция 10)|Нет совпадения.|  
|16|й|"eed" (позиция 11)|Возможное совпадение.|  
|17|e{2}|"ed" (позиция 12)|Возможное совпадение.|  
|18|\\w|"d" (позиция 13)|Возможное совпадение.|  
|19|\b|"" (позиция 14)|Совпадение.|  
  
 Если в шаблоне регулярного выражения нет переменных квантификаторов или конструкций изменения, максимальное число сравнений, необходимое для поиска во входной строке совпадения с шаблоном регулярного выражения, примерно равно числу символов во входной строке. В этом случае обработчик регулярных выражений использует 19 сравнений, чтобы определить возможные совпадения в этой 13-значной строке.  Другими словами, обработчик регулярных выражений работает почти за линейное время, если отсутствуют переменные квантификаторы или конструкции изменения.  
  
 [К началу](#top)  
  
<a name="backtracking_with_optional_quantifiers_or_alternation_constructs"></a>   
## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a>Поиск с возвратом с переменными квантификаторами и конструкциями изменения  
 Если регулярное выражение содержит переменные квантификаторы или конструкции изменения, оценка входной строки уже не может быть линейной. При использовании NFA-машины сопоставление шаблонов определяется языковыми элементами регулярного выражения, а не символами входной строки. Поэтому обработчик регулярных выражений пытается найти полное совпадение для переменных подвыражений или подвыражений выбора. При переходе к следующему языковому элементу подвыражения и нарушении совпадения обработчик регулярных выражений отбрасывает совпавшую часть и возвращается к ранее сохраненному состоянию; ему снова требуется найти во входной строке совпадение с регулярным выражением целиком. Процесс возвращения к ранее сохраненному состоянию для поиска совпадения называется "поиск с возвратом".  
  
 Например, рассмотрим шаблон регулярного выражения `.*(es)`, совпадающий с символами "es" и любыми предшествующими символам. Как показано в следующем примере, если взять входную строку "Essential services are provided by regular expressions.", совпадать с шаблоном будет вся строка до букв "es" в слове "expressions" включительно.  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 В этом случае обработчик регулярных выражений использует поиск с возвратом следующим образом.  
  
- Обработчик обнаруживает совпадение части выражения `.*` (что соответствует любому числу любых символов) со всей входной строкой.  
  
- Затем обработчик ищет совпадение для символа "e" шаблона регулярного выражения. Однако во входной строке нет больше символов для поиска совпадения.  
  
- Обработчик возвращается к месту последнего успешного совпадения, "Essential services are provided by regular expressions", и сравнивает символ "e" с точкой в конце предложения. Совпадение отсутствует.  
  
- Обработчик продолжает возвращаться к предыдущим успешным совпадениям, отступая по одному символу, пока предположительно подходящей подстрокой не становится подстрока "Essential services are provided by regular expr". Затем обработчик сравнивает символ "e" шаблона со второй буквой "e" в слове "expressions" и обнаруживает совпадение.  
  
- Затем он сравнивает символ "s" шаблона с символом "s" после символа "e" в строке (первая буква "s" в слове "expressions"). Совпадение успешно.  
  
 При использовании поиска с возвратом поиск совпадения шаблона регулярного выражения со входной строкой длиной 55 символов требует 67 операций сравнения. Как правило, если в шаблоне регулярного выражения есть один переменный квантификатор или одна конструкция изменения, число сравнений, необходимых для поиска во входной строке совпадения с шаблоном регулярного выражения, более чем вдвое превышает число символов во входной строке.  
  
 [К началу](#top)  
  
<a name="backtracking_with_nested_optional_quantifiers"></a>   
## <a name="backtracking-with-nested-optional-quantifiers"></a>Поиск с возвратом со вложенными переменными квантификаторами  
 Количество сравнений, необходимое для поиска во входной строке совпадения с шаблоном регулярного выражения, может увеличиваться экспоненциально, если шаблон включает большое количество конструкций изменения или вложенные конструкции изменения, или, что случается чаще, вложенные переменные квантификаторы. Например, шаблон регулярного выражения `^(a+)+$` должен совпадать со строкой, состоящей из одного и более символов "a". В примере показаны две входные строки одинаковой длины, только одна из которых совпадает с шаблоном. Класс <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> используется для определения времени выполнения операции поиска совпадения.  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 Как показывают выходные данные примера, у обработчика регулярных выражений установление отсутствия совпадения с шаблоном занимает в два раза больше времени, чем нахождение совпадения. Неуспешное совпадение — худший сценарий. Обработчик регулярных выражений должен использовать регулярное выражение для проверки всех возможных путей в данных, чтобы заключить, что совпадения нет, а вложенные скобки сильно увеличивают количество таких путей. Чтобы установить, что вторая строка не совпадает с шаблоном, обработчику регулярных выражений нужно выполнить следующие действия:  
  
- Он проверяет, что находится в начале строки, после чего проверяет первые пять символов строки на совпадение с шаблоном `a+`. Затем проверяет, что в строке нет других групп символов "a". Затем выполняется проверка до конца строки. Поскольку в строке содержится один дополнительный символ, проверка оказывается неудачной. Этот отрицательный результат требует 9 сравнений. Обработчик регулярных выражений также сохраняет информацию о состоянии при совпадениях "a" (совпадение 1), "aa" (совпадение 2), "aaa" (совпадение 3) и "aaaa" (совпадение 4).  
  
- Затем он возвращается к предварительно сохраненному совпадению 4. Далее устанавливается наличие дополнительного символа "a", который назначается дополнительной захваченной группе. Затем выполняется проверка до конца строки. Поскольку в строке содержится один дополнительный символ, проверка оказывается неудачной. Этот отрицательный результат требует 4 сравнений. Таким образом, всего выполнено 13 сравнений.  
  
- Затем он возвращается к предварительно сохраненному совпадению 3. Он устанавливает наличие двух дополнительных символов "a", которые назначаются дополнительной захваченной группе. Однако проверка на наличие окончания строки не проходит. Обработчик возвращается к совпадению 3 и пытается сопоставить два дополнительных символа "a" с двумя дополнительными захваченными группами. Проверка на наличие окончания строки не проходит. Для получения этих неуспешных совпадений потребовалось 12 сравнений. Таким образом, всего выполнено 25 сравнений.  
  
 Сравнение входной строки с регулярным выражением продолжается таким же образом, пока обработчик регулярных выражений не переберет все возможные комбинации совпадений, заключив, что совпадений нет. Из-за наличия вложенных квантификаторов это сравнение представляет собой операцию экспоненциальной сложности O(2<sup>n</sup>), где *n* — количество символов входной строки. Это значит, что в худшем случае входная строка, состоящая из 30 символов, требует по примерным подсчетам 1 073 741 824 сравнений, а входная строка длиной 40 символов — 1 099 511 627 776 сравнений. При использовании строк такого или большего размера методы, выполняющие регулярные выражения, могут выполняться очень долго, прежде чем будет установлено, что входная строка не совпадает с шаблоном регулярного выражения.  
  
 [К началу](#top)  
  
<a name="controlling_backtracking"></a>   
## <a name="controlling-backtracking"></a>Управление поиском с возвратом  
 Поиск с возвратом позволяет создавать мощные и гибкие регулярные выражения. Однако, как было показано в предыдущем разделе, эти преимущества могут сопровождаться неприемлемо низкой производительностью. Чтобы предотвратить излишнее использование поиска с возвратом, необходимо указать интервал времени ожидания при создании экземпляра объекта <xref:System.Text.RegularExpressions.Regex> или вызвать соответствующий метод статического регулярного выражения. Этот метод будет рассмотрен в следующем разделе. Кроме того, в .NET Core поддерживаются три элемента языка регулярных выражений, ограничивающих или подавляющих поиск с возвратом, что позволяет выполнять сложные регулярные выражения, не теряя или почти не теряя в производительности: [невозвращающиеся части выражения](#Nonbacktracking), [утверждения просмотра назад](#Lookbehind) и [утверждения просмотра вперед](#Lookahead). Дополнительные сведения об этих элементах языка см. в разделе [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).  
  
<a name="Timeout"></a>   
### <a name="defining-a-time-out-interval"></a>Определение интервала времени ожидания  
 Начиная с .NET Framework 4.5 можно задавать значение времени ожидания, которое равняется значению самого длинного интервала, необходимого обработчику регулярных выражений для выполнения поиска до первого совпадения, пока он не приостановит попытки найти соответствие и не вызовет исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. Чтобы задать интервал ожидания, укажите значение <xref:System.TimeSpan> в конструкторе <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> регулярных выражений экземпляра. Кроме того, каждый статический метод сравнения с шаблоном имеет перегруженную версию с параметром <xref:System.TimeSpan> , который позволяет указать значение времени ожидания. По умолчанию интервал времени ожидания задается в <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> и время ожидания обработчика регулярных выражений не истекает.  
  
> [!IMPORTANT]
> Рекомендуется всегда устанавливать интервал времени ожидания, если регулярное выражение использует поиск с возвратом.  
  
 Выражение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> указывает на то, что обработчику регулярных выражений не удалось найти совпадение в пределах заданного интервала времени ожидания, но не указывает причину создания исключения. Причина может быть как в излишнем поиске с возвратом, так и в недостаточном значении интервала времени ожидания для текущей загруженности системы на момент создания исключения. При обработке исключения можно прервать дальнейший поиск совпадений входной строки или увеличить интервал времени ожидания и повторно выполнить операцию поиска.  
  
 Например, следующий код вызывает конструктор <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> для создания экземпляра объекта <xref:System.Text.RegularExpressions.Regex> со значением времени ожидания, равным одной секунде. Шаблон регулярного выражения `(a+)+$`, который сопоставляется с последовательностью из одного или нескольких символов "a" в конце строки, относится к шаблонам с чрезмерным использованием поиска с возвратом. Если создается исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> , то интервал времени ожидания в данном примере увеличивается до максимального значения, равного трем секундам. После этого попытки найти соответствие шаблону будут прерваны.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
<a name="Nonbacktracking"></a>   
### <a name="nonbacktracking-subexpression"></a>Невозвращающиеся подвыражения  
 Элемент языка `(?>` *subexpression*`)` подавляет поиск с возвратом в подвыражении. Это полезно для предотвращения проблем с производительностью, связанных с неуспешным совпадением.  
  
 В следующем примере показано, как подавление поиска с возвратом улучшает производительность при использовании вложенных квантификаторов. В нем измеряется время, которое требуется обработчику регулярных выражений, чтобы определить, что входная строка не совпадает с двумя регулярными выражениями. В первом регулярном выражении поиск с возвратом используется для поиска строки, содержащей последовательно одну и более шестнадцатеричных цифр, двоеточие, одну и более шестнадцатеричных цифр и два двоеточия. Второе регулярное выражение аналогично первому, но в нем отключен поиск с возвратом. Как показывают выходные данные примера, отключение поиска с возвратом приводит к существенному росту производительности.  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  
  
<a name="Lookbehind"></a>   
### <a name="lookbehind-assertions"></a>утверждения просмотра назад  
 В платформу .NET входят два элемента языка, `(?<=`*часть_выражения*`)` и `(?<!`*часть_выражения*`)`, которые сопоставляются с одним или несколькими предшествующими символами во входной строке. Оба элемента языка являются утверждениями нулевой ширины; они определяют, должны ли символы, непосредственно предшествующие текущему, соответствовать *subexpression*. Смещения или поиска с возвратом не происходит.  
  
 `(?<=` *subexpression* `)` — это утверждение положительного просмотра назад; символы, непосредственно предшествующие текущему, должны соответствовать *subexpression*. `(?<!`*subexpression*`)` — это утверждение отрицательного просмотра назад; символы, непосредственно предшествующие текущему, не должны соответствовать *subexpression*. Утверждения положительного и отрицательного просмотра назад наиболее полезны, если *subexpression* является подмножеством предыдущего подвыражения.  
  
 В следующем примере используются два равнозначных шаблона регулярных выражений, которые проверяют имя пользователя в адресе электронной почты. Первый шаблон демонстрирует низкую производительность из-за неоправданного использования поиска с возвратом. Во втором шаблоне то же самое регулярное выражение изменено. Вложенный квантификатор заменен на утверждение положительного просмотра назад. Выходные данные примера демонстрируют время выполнения метода <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 Первый шаблон регулярного выражения `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`определяется, как показано в следующей таблице.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`^`|Совпадение с началом строки.|  
|`[0-9A-Z]`|Совпадение с алфавитно-цифровым символом. Поскольку метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , сравнение не зависит от регистра символов.|  
|`[-.\w]*`|Нуль и более совпадений с дефисом, точкой или символом слова.|  
|`[0-9A-Z]`|Совпадение с алфавитно-цифровым символом.|  
|`([-.\w]*[0-9A-Z])*`|Ноль и более совпадений с комбинацией нуля и более дефисов, точек и символов слова, за которыми следует алфавитно-цифровой символ. Это первая группа записи.|  
|`@`|Совпадение со знаком "коммерческое эт" (\@).|  
  
 Второй шаблон регулярного выражения `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`использует утверждение положительного просмотра назад. Определяется, как показано в следующей таблице.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`^`|Совпадение с началом строки.|  
|`[0-9A-Z]`|Совпадение с алфавитно-цифровым символом. Поскольку метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , сравнение не зависит от регистра символов.|  
|`[-.\w]*`|Нуль и более совпадений с дефисом, точкой или символом слова.|  
|`(?<=[0-9A-Z])`|Выполняется просмотр назад последнего совпавшего символа; поиск совпадения продолжается, если этот символ является алфавитно-цифровым. Обратите внимание, что алфавитно-цифровой символ является подмножеством набора, образованного точкой, дефисом и всеми символами слова.|  
|`@`|Совпадение со знаком "коммерческое эт" (\@).|  
  
<a name="Lookahead"></a>   
### <a name="lookahead-assertions"></a>утверждения просмотра вперед  
 В платформу .NET входят два элемента языка, `(?=`*часть_выражения*`)` и `(?!`*часть_выражения*`)`, которые сопоставляются с одним или несколькими следующими символами во входной строке. Оба элемента языка являются утверждениями нулевой ширины; они определяют, должны ли символы, непосредственно следующие за текущим, соответствовать *subexpression*. Смещения или поиска с возвратом не происходит.  
  
 `(?=` *subexpression* `)` — это утверждение положительного просмотра вперед; символы, непосредственно следующие за текущим, должны соответствовать *subexpression*. `(?!`*subexpression*`)` — это утверждение отрицательного просмотра вперед; символы, непосредственно следующие за текущим, не должны соответствовать *subexpression*. Утверждения положительного и отрицательного просмотра вперед наиболее полезны, если *subexpression* является подмножеством следующего подвыражения.  
  
 В следующем примере используются два одинаковых шаблона регулярного выражения, проверяющих полное имя типа. Первый шаблон демонстрирует низкую производительность из-за неоправданного использования поиска с возвратом. Во втором шаблоне то же самое регулярное выражение изменено. Вложенный квантификатор заменен на утверждение положительного просмотра вперед. Выходные данные примера демонстрируют время выполнения метода <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> .  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 Первый шаблон регулярного выражения `^(([A-Z]\w*)+\.)*[A-Z]\w*$`определяется, как показано в следующей таблице.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`^`|Совпадение с началом строки.|  
|`([A-Z]\w*)+\.`|Совпадение с алфавитным символом (A-Z), за которым следует ноль и более символов слова, повторенных ноль и более раз, за которыми следует точка. Поскольку метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , сравнение не зависит от регистра символов.|  
|`(([A-Z]\w*)+\.)*`|Совпадение с предыдущим шаблоном ноль и более раз.|  
|`[A-Z]\w*`|Совпадение с алфавитно-цифровым символом, за которым следует ноль и более символов слова.|  
|`$`|Совпадение должно заканчиваться в конце входной строки.|  
  
 Второй шаблон регулярного выражения `^((?=[A-Z])\w+\.)*[A-Z]\w*$`использует утверждение положительного просмотра вперед. Определяется, как показано в следующей таблице.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`^`|Совпадение с началом строки.|  
|`(?=[A-Z])`|Выполняется просмотр вперед к следующему символу; если он является алфавитным (A-Z), продолжается поиск совпадения. Поскольку метод <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> , сравнение не зависит от регистра символов.|  
|`\w+\.`|Совпадение с одним или несколькими символами слова, за которыми следует точка.|  
|`((?=[A-Z])\w+\.)*`|Совпадение с одним или несколькими символами слова, за которым следует ноль и более точек. Первый символ слова должен быть алфавитным.|  
|`[A-Z]\w*`|Совпадение с алфавитно-цифровым символом, за которым следует ноль и более символов слова.|  
|`$`|Совпадение должно заканчиваться в конце входной строки.|  
  
 [К началу](#top)  
  
## <a name="see-also"></a>См. также

- [Регулярные выражения .NET](../../../docs/standard/base-types/regular-expressions.md)
- [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [Квантификаторы](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)
- [Конструкции чередования](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)
- [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)
