---
title: кванторы в регулярных выражениях
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET Framework regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: f1627248cbed0f03c6fb76ce660f9b2bf7764781
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "78160018"
---
# <a name="quantifiers-in-regular-expressions"></a>кванторы в регулярных выражениях
Квантификаторы определяют количество экземпляров символа, группы или класса символов, которое должно присутствовать во входных данных, чтобы было зафиксировано совпадение.  В приведенной ниже таблице перечислены квантификаторы, поддерживаемые платформой .NET.  
  
|Жадный квантификатор|Ленивый квантификатор|Описание|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|Совпадение ноль или несколько раз.|  
|`+`|`+?`|Совпадение один или несколько раз.|  
|`?`|`??`|Совпадение ноль или один раз.|  
|`{` *n* `}`|`{` *n* `}?`|Совпадение ровно *n* раз.|  
|`{` *n* `,}`|`{` *n* `,}?`|Совпадение как минимум *n* раз.|  
|`{` *n* `,` *m* `}`|`{` *n* `,` *m* `}?`|Совпадение от *n* до *m* раз.|  
  
 Количества `n` и `m` являются целочисленными константами. Обычно квантификаторы "жадные" — они заставляют обработчик регулярных выражений выделить максимально возможное число вхождений определенного шаблона. Добавление символа `?` в квантификатор делает его отложенным (или ленивым). Это приводит к тому, что обработчик регулярных выражений пытается сопоставить так мало вхождений, как это возможно. Полное описание различий между "жадными" и "ленивыми" квантификаторами см. в разделе [Жадные и ленивые квантификаторы](#Greedy) далее в этой статье.  
  
> [!IMPORTANT]
> Вложенные квантификаторы (например, шаблон регулярного выражения `(a*)*`) могут увеличить количество сравнений, которые должен выполнять обработчик регулярных выражений, как экспоненциальная функция количества символов во входной строке. Дополнительные сведения об этом поведении и способах его обхода см. в статье [о поиске с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
## <a name="regular-expression-quantifiers"></a>Квантификаторы регулярных выражений  
 В следующих разделах перечислены квантификаторы, поддерживаемые регулярными выражениями платформы .NET.  
  
> [!NOTE]
> Если в шаблоне регулярных выражений встречаются символы *, +, ?, { или }, обработчик регулярных выражений интерпретирует их как квантификаторы или как часть конструкций квантификаторов, если они не включены в [класс символов](../../../docs/standard/base-types/character-classes-in-regular-expressions.md). Чтобы они интерпретировались как символы-литералы за пределами класса символов, необходимо ставить перед ними escape-символ — обратную косую черту. Например, строка `\*` в шаблоне регулярного выражения интерпретируется как литеральный символ звездочки ("\*").  
  
### <a name="match-zero-or-more-times-"></a>Совпадение ноль или несколько раз: *  
 Квалификатор `*` выделяет предыдущий элемент, повторяющийся ноль или более раз. Это свойство эквивалентно квантификатору `{0,}`. `*` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `*?`.  
  
 В следующем примере показано, как использовать это регулярное выражение. Пять из девяти чисел в исходной строке соответствуют заданному шаблону, четыре числа (`95`, `929`, `9219` и `9919`) — нет.  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`91*`|Совпадение с символом "9", за которыми следует ноль или более символов "1".|  
|`9*`|Выделить ноль или больше символов "9".|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-one-or-more-times-"></a>Совпадение один или несколько раз: +  
 Квантификатор `+` сопоставляет предыдущий элемент один или несколько раз. Он эквивалентен `{1,}`. `+` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `+?`.  
  
 Например, с помощью регулярного выражения `\ban+\w*?\b` осуществляется сопоставление целых слов, начинающихся с буквы `a`, за которой следует одна или несколько букв `n`. В следующем примере показано, как использовать это регулярное выражение. Регулярное выражение соответствует словам `an`, `annual`, `announcement` и `antique` и не соответствует словам `autumn` и `all`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`an+`|Совпадение с "a"с последующим одним или несколькими символами "n".|  
|`\w*?`|Совпадение со словообразующим символом ноль или несколько раз (по возможности минимальное количество раз).|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-zero-or-one-time-"></a>Совпадение ноль или один раз: ?  
 Квантификатор `?` сопоставляет предыдущий элемент ноль или один раз. Он эквивалентен `{0,1}`. `?` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `??`.  
  
 Например, с помощью регулярного выражения `\ban?\b` осуществляется сопоставление целых слов, начинающихся с буквы `a`, за которой следует одна буква `n` или не следует ни одной такой буквы. Иными словами, предпринимается попытка найти слова `a` и `an`. В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`an?`|Совпадение с "a"с последующими символами "n" (при их наличии).|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-exactly-n-times-n"></a>Совпадение ровно n раз: {n}  
 Квантификатор `{`*n*`}` сопоставляет предыдущий элемент ровно *n* раз, где *n* — любое целое число. `{`*n*`}` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `{`*n*`}?`.  
  
 Например, с помощью регулярного выражения `\b\d+\,\d{3}\b` осуществляется поиск границы слова, за которой следует один или более десятичных знаков, еще три десятичных знака и граница слова. В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`\d+`|Совпадение с одной или несколькими десятичными цифрами.|  
|`\,`|Совпадение с символом запятой.|  
|`\d{3}`|Совпадение с тремя десятичными цифрами.|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-at-least-n-times-n"></a>Совпадение как минимум n раз: {n,}  
 Квантификатор `{`*n*`,}` сопоставляет предыдущий элемент как минимум *n* раз, где *n* — любое целое число. `{`*n*`,}` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `{`*n*`,}?`.  
  
 Например, с помощью регулярного выражения `\b\d{2,}\b\D+` осуществляется поиск границы слова, за которой следует по крайней мере два десятичных знака, граница слова и знак, не являющийся числом. В следующем примере показано, как использовать это регулярное выражение. Это регулярное выражение не соответствует фразе `"7 days"`, так как она содержит всего одну десятичную цифру, но соответствует фразам `"10 weeks and 300 years"`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`\d{2,}`|Совпадение как минимум с двумя десятичными цифрами.|  
|`\b`|Соответствует границе слова.|  
|`\D+`|Совпадение как минимум с одной цифрой, не являющейся десятичной.|  
  
### <a name="match-between-n-and-m-times-nm"></a>Совпадение от n до m раз: {n,m}  
 Квантификатор `{`*n*`,`*m*`}` сопоставляет предыдущий элемент минимум *n* раз, но не больше *m* раз, где *n* и *m* — целые числа. `{`*n*`,`*m*`}` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `{`*n*`,`*m*`}?`.  
  
 В следующем примере с помощью регулярного выражения `(00\s){2,4}` осуществляется поиск от двух до четырех вхождений двух нулей, за которыми следует пробел. Обратите внимание, что в конце входной строки имеются пять вхождений этого фрагмента при максимуме в четыре вхождения. Однако только начало этой части строки (до пробела и пятой пары нулей) соответствует шаблону регулярного выражения.  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a>Совпадение ноль или несколько раз (ленивое совпадение): *?  
 Квантификатор `*?` сопоставляет предыдущий элемент ноль или несколько раз, но как можно меньшее число раз. Это ленивый квантификатор, являющийся аналогом жадного квантификатора `*`.  
  
 В следующем примере регулярное выражение `\b\w*?oo\w*?\b` сопоставляет все слова, которые содержат строку `oo`.  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`\w*?`|Совпадение с нулем или минимально возможным числом словообразующих символов.|  
|`oo`|Совпадение со строкой "oo".|  
|`\w*?`|Совпадение с нулем или минимально возможным числом словообразующих символов.|  
|`\b`|Конец на границе слова.|  
  
### <a name="match-one-or-more-times-lazy-match-"></a>Совпадение один или несколько раз (ленивое совпадение): +?  
 Квантификатор `+?` сопоставляет предыдущий элемент один или более раз, но как можно меньшее число раз. Это ленивый квантификатор, являющийся аналогом жадного квантификатора `+`.  
  
 Например, регулярное выражение `\b\w+?\b` соответствует одному или нескольким символам, разделенным границами слов. В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a>Совпадение ноль или один раз (ленивое совпадение): ??  
 Квантификатор `??` сопоставляет предыдущий элемент ноль или один раз, но как можно меньшее число раз. Это ленивый квантификатор, являющийся аналогом жадного квантификатора `?`.  
  
 Например, регулярное выражение `^\s*(System.)??Console.Write(Line)??\(??` пытается сопоставить строки "Console.Write" или "Console.WriteLine". Строка может также включать "System." перед "Console", за ней может следовать открывающая скобка. Искомый текст должен находиться в начале строки, хотя перед ним может стоять пробел. В следующем примере показано, как использовать это регулярное выражение.  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Соответствует концу входной строки.|  
|`\s*`|Соответствует нулю или нескольким символам пробела.|  
|`(System.)??`|Совпадение с нулевым или единичным вхождением строки "System.".|  
|`Console.Write`|Совпадение со строкой "Console.Write".|  
|`(Line)??`|Совпадение с нулевым или единичным вхождением строки "Line".|  
|`\(??`|Совпадение с нулем или одним экземпляром открывающих круглых скобок.|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a>Совпадение ровно n раз (ленивое совпадение): {n}?  
 Квантификатор `{`*n*`}?` сопоставляет предыдущий элемент ровно `n` раз, где *n* — любое целое число. Это ленивый квантификатор, являющийся аналогом жадного квантификатора `{`*n*`}`.  
  
 В следующем примере регулярное выражение `\b(\w{3,}?\.){2}?\w{3,}?\b` используется для определения адреса веб-сайта. Обратите внимание, что есть совпадение с "www.microsoft.com" и "msdn.microsoft.com", но нет совпадения с "mywebsite" или "mycompany.com".  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`(\w{3,}?\.)`|Совпадение с минимум тремя словообразующими символами как можно меньшее количество раз, зак которыми следует символ точки. Это первая группа записи.|  
|`(\w{3,}?\.){2}?`|Совпадение с шаблоном в первой группе два раза, но как можно меньшее количество раз.|  
|`\b`|Сопоставление заканчивается на границе слова.|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a>Совпадение как минимум n раз (ленивое совпадение): {n,}?  
 Квантификатор `{`*n*`,}?` сопоставляет предыдущий элемент как минимум `n` раз (где *n* — любое целое число), но как можно меньшее количество раз. Это ленивый квантификатор, являющийся аналогом жадного квантификатора `{`*n*`,}`.  
  
 Его поведение приводится в описании квантификатора `{`*n*`}?` в предыдущем разделе. В регулярном выражении из этого примера квантификатор `{`*n*`,}` используется для поиска строки, состоящей по крайней мере из трех символов, после которых стоит точка.  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a>Совпадение от n до m раз (ленивое совпадение): {n,m}?  
 Квантификатор `{`*n*`,`*m*`}?` сопоставляет предыдущий элемент от `n` до `m` раз (где *n* и *m* — целые числа), но как можно меньшее количество раз. Это ленивый квантификатор, являющийся аналогом жадного квантификатора `{`*n*`,`*m*`}`.  
  
 В следующем примере регулярное выражение `\b[A-Z](\w*?\s*?){1,10}[.!?]` сопоставляет фразы, содержащие от одного до десяти слов. Ему соответствуют все предложения в исходной строке кроме одного, длина которого составляет 18 слов.  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 Шаблон регулярного выражения определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`[A-Z]`|Совпадение с любым символом верхнего регистра от А до Z.|  
|`(\w*?\s*?)`|Совпадение с нулем или несколькими словообразующими символами, за которыми следует один или несколько пробелов, но как можно меньшее количество раз. Это первая захватываемая группа.|  
|`{1,10}`|Совпадение с предыдущим шаблоном от 1 до 10 раз.|  
|`[.!?]`|Совпадение с любым из знаков препинания ".", "!" или "?".|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a>Жадные и ленивые квантификаторы  
 У некоторых квантификаторов есть две версии.  
  
- Жадная версия.  
  
     Жадный квантификатор пытается найти максимально возможное число соответствий элемента.  
  
- Нежадная (ленивая) версия.  
  
     При использовании нежадных идентификаторов предпринимается попытка найти минимально возможное число соответствий элемента. Чтобы превратить любой жадный квантификатор в ленивый, добавьте к нему `?`.  
  
 Представьте простое регулярное выражение, позволяющее находить последние четыре цифры в числовой строке, например в номере кредитной карты. Версия регулярного выражения с жадным квантификатором `*` будет выглядеть так: `\b.*([0-9]{4})\b`. Однако если строка содержит два числа, то с помощью такого регулярного выражения будут найдены только последние четыре цифры второго числа, как показано в следующем примере.  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 Регулярное выражение не совпадает с первым числом, так как квантификатор `*` ищет максимально возможное число совпадений во всей строке, и здесь он находит его в конце строки.  
  
 Это не то, что нам нужно. Вместо этого вы можете применить ленивый квантификатор `*?`, чтобы получить цифры из обоих чисел, как показано в следующем примере.  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 В большинстве случаев регулярные выражения с жадными и ленивыми квантификаторами возвращают одни и те же результаты. Как правило, они возвращают разные значения, если применяется подстановочный метасимвол (`.`), который соответствует любому символу.  
  
## <a name="quantifiers-and-empty-matches"></a>Квантификаторы и пустые соответствия  
 Квантификаторы `*`, `+` и `{`*n*`,`*m*`}` и их ленивые аналоги никогда не повторяются после пустого соответствия, если найдено минимальное количество совпадений. Это правило препятствует вхождению квантификаторов в бесконечные циклы при пустых соответствиях частей выражений, если максимальное количество возможных фиксаций группы бесконечно или приближено к бесконечному.  
  
 Например, ниже в коде показан результат вызова метода <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> с шаблоном регулярного выражения `(a?)*`, который соответствует нулю или одному символу "a" ноль или несколько раз. Обратите внимание, что отдельная захватываемая группа записывает каждое вхождение "a" и <xref:System.String.Empty?displayProperty=nameWithType>, но второго пустого совпадения нет, потому что квантификатор прекращает поиск после первого пустого совпадения.  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 Чтобы увидеть практическое различие между захватываемой группой, определяющей минимальное и максимальное количество записей, и группой, определяющей фиксированное количество записей, воспользуйтесь шаблонами регулярных выражений `(a\1|(?(1)\1)){0,2}` и `(a\1|(?(1)\1)){2}`. Оба регулярных выражения состоят из одной захватываемой группы, которая определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(a\1`|Сопоставление "a" вместе со значением первой захваченной группы...|  
|<code>&#124;(?(1)</code>|… или проверка того, была ли определена первая захваченная группа. (Обратите внимание, что конструкция `(?(1)` не определяет захватываемую группу.)|  
|`\1))`|Если первая захваченная группа существует, следует сопоставить ее значение. Если такая группа отсутствует, для нее сопоставляется значение <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Первое регулярное выражение пытается сопоставить этот шаблон от нуля до двух раз. Второй — ровно два раза. Так как первый шаблон достигает своего минимального количества записей при первой записи значения <xref:System.String.Empty?displayProperty=nameWithType>, он не повторяет попытку сопоставить `a\1`. Квантификатор `{0,2}` допускает только пустые соответствия в последней итерации. Напротив, второе регулярное выражение соответствует "а", потому что оно вычисляет `a\1` второй раз. Минимальное число итераций (2) предписывает обработчику выполнять повтор после пустого соответствия.  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a>См. также

- [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [Поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
