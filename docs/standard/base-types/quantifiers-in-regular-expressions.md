---
title: кванторы в регулярных выражениях
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET Framework regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: f1627248cbed0f03c6fb76ce660f9b2bf7764781
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "78160018"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="e97b2-102">кванторы в регулярных выражениях</span><span class="sxs-lookup"><span data-stu-id="e97b2-102">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="e97b2-103">Квантификаторы определяют количество экземпляров символа, группы или класса символов, которое должно присутствовать во входных данных, чтобы было зафиксировано совпадение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-103">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="e97b2-104">В приведенной ниже таблице перечислены квантификаторы, поддерживаемые платформой .NET.</span><span class="sxs-lookup"><span data-stu-id="e97b2-104">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="e97b2-105">Жадный квантификатор</span><span class="sxs-lookup"><span data-stu-id="e97b2-105">Greedy quantifier</span></span>|<span data-ttu-id="e97b2-106">Ленивый квантификатор</span><span class="sxs-lookup"><span data-stu-id="e97b2-106">Lazy quantifier</span></span>|<span data-ttu-id="e97b2-107">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-107">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="e97b2-108">Совпадение ноль или несколько раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-108">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="e97b2-109">Совпадение один или несколько раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-109">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="e97b2-110">Совпадение ноль или один раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-110">Match zero or one time.</span></span>|  
|<span data-ttu-id="e97b2-111">`{` *n* `}`</span><span class="sxs-lookup"><span data-stu-id="e97b2-111">`{` *n* `}`</span></span>|<span data-ttu-id="e97b2-112">`{` *n* `}?`</span><span class="sxs-lookup"><span data-stu-id="e97b2-112">`{` *n* `}?`</span></span>|<span data-ttu-id="e97b2-113">Совпадение ровно *n* раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-113">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="e97b2-114">`{` *n* `,}`</span><span class="sxs-lookup"><span data-stu-id="e97b2-114">`{` *n* `,}`</span></span>|<span data-ttu-id="e97b2-115">`{` *n* `,}?`</span><span class="sxs-lookup"><span data-stu-id="e97b2-115">`{` *n* `,}?`</span></span>|<span data-ttu-id="e97b2-116">Совпадение как минимум *n* раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-116">Match at least *n* times.</span></span>|  
|<span data-ttu-id="e97b2-117">`{` *n* `,` *m* `}`</span><span class="sxs-lookup"><span data-stu-id="e97b2-117">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="e97b2-118">`{` *n* `,` *m* `}?`</span><span class="sxs-lookup"><span data-stu-id="e97b2-118">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="e97b2-119">Совпадение от *n* до *m* раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-119">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="e97b2-120">Количества `n` и `m` являются целочисленными константами.</span><span class="sxs-lookup"><span data-stu-id="e97b2-120">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="e97b2-121">Обычно квантификаторы "жадные" — они заставляют обработчик регулярных выражений выделить максимально возможное число вхождений определенного шаблона.</span><span class="sxs-lookup"><span data-stu-id="e97b2-121">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="e97b2-122">Добавление символа `?` в квантификатор делает его отложенным (или ленивым). Это приводит к тому, что обработчик регулярных выражений пытается сопоставить так мало вхождений, как это возможно.</span><span class="sxs-lookup"><span data-stu-id="e97b2-122">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="e97b2-123">Полное описание различий между "жадными" и "ленивыми" квантификаторами см. в разделе [Жадные и ленивые квантификаторы](#Greedy) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="e97b2-123">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="e97b2-124">Вложенные квантификаторы (например, шаблон регулярного выражения `(a*)*`) могут увеличить количество сравнений, которые должен выполнять обработчик регулярных выражений, как экспоненциальная функция количества символов во входной строке.</span><span class="sxs-lookup"><span data-stu-id="e97b2-124">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="e97b2-125">Дополнительные сведения об этом поведении и способах его обхода см. в статье [о поиске с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e97b2-125">For more information about this behavior and its workarounds, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="e97b2-126">Квантификаторы регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="e97b2-126">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="e97b2-127">В следующих разделах перечислены квантификаторы, поддерживаемые регулярными выражениями платформы .NET.</span><span class="sxs-lookup"><span data-stu-id="e97b2-127">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e97b2-128">Если в шаблоне регулярных выражений встречаются символы \*, +, ?, { или }, обработчик регулярных выражений интерпретирует их как квантификаторы или как часть конструкций квантификаторов, если они не включены в [класс символов](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e97b2-128">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="e97b2-129">Чтобы они интерпретировались как символы-литералы за пределами класса символов, необходимо ставить перед ними escape-символ — обратную косую черту.</span><span class="sxs-lookup"><span data-stu-id="e97b2-129">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="e97b2-130">Например, строка `\*` в шаблоне регулярного выражения интерпретируется как литеральный символ звездочки ("\*").</span><span class="sxs-lookup"><span data-stu-id="e97b2-130">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="e97b2-131">Совпадение ноль или несколько раз: \*</span><span class="sxs-lookup"><span data-stu-id="e97b2-131">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="e97b2-132">Квалификатор `*` выделяет предыдущий элемент, повторяющийся ноль или более раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-132">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="e97b2-133">Это свойство эквивалентно квантификатору `{0,}`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-133">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="e97b2-134">`*` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `*?`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-134">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="e97b2-135">В следующем примере показано, как использовать это регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-135">The following example illustrates this regular expression.</span></span> <span data-ttu-id="e97b2-136">Пять из девяти чисел в исходной строке соответствуют заданному шаблону, четыре числа (`95`, `929`, `9219` и `9919`) — нет.</span><span class="sxs-lookup"><span data-stu-id="e97b2-136">Of the nine digits in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="e97b2-137">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-137">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-138">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-138">Pattern</span></span>|<span data-ttu-id="e97b2-139">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-139">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e97b2-140">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-140">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="e97b2-141">Совпадение с символом "9", за которыми следует ноль или более символов "1".</span><span class="sxs-lookup"><span data-stu-id="e97b2-141">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="e97b2-142">Выделить ноль или больше символов "9".</span><span class="sxs-lookup"><span data-stu-id="e97b2-142">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="e97b2-143">Конец на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-143">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="e97b2-144">Совпадение один или несколько раз: +</span><span class="sxs-lookup"><span data-stu-id="e97b2-144">Match One or More Times: +</span></span>  
 <span data-ttu-id="e97b2-145">Квантификатор `+` сопоставляет предыдущий элемент один или несколько раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-145">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="e97b2-146">Он эквивалентен `{1,}`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-146">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="e97b2-147">`+` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `+?`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-147">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="e97b2-148">Например, с помощью регулярного выражения `\ban+\w*?\b` осуществляется сопоставление целых слов, начинающихся с буквы `a`, за которой следует одна или несколько букв `n`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-148">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="e97b2-149">В следующем примере показано, как использовать это регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-149">The following example illustrates this regular expression.</span></span> <span data-ttu-id="e97b2-150">Регулярное выражение соответствует словам `an`, `annual`, `announcement` и `antique` и не соответствует словам `autumn` и `all`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-150">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="e97b2-151">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-151">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-152">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-152">Pattern</span></span>|<span data-ttu-id="e97b2-153">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-153">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e97b2-154">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-154">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="e97b2-155">Совпадение с "a"с последующим одним или несколькими символами "n".</span><span class="sxs-lookup"><span data-stu-id="e97b2-155">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="e97b2-156">Совпадение со словообразующим символом ноль или несколько раз (по возможности минимальное количество раз).</span><span class="sxs-lookup"><span data-stu-id="e97b2-156">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="e97b2-157">Конец на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-157">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="e97b2-158">Совпадение ноль или один раз: ?</span><span class="sxs-lookup"><span data-stu-id="e97b2-158">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="e97b2-159">Квантификатор `?` сопоставляет предыдущий элемент ноль или один раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-159">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="e97b2-160">Он эквивалентен `{0,1}`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-160">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="e97b2-161">`?` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `??`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-161">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="e97b2-162">Например, с помощью регулярного выражения `\ban?\b` осуществляется сопоставление целых слов, начинающихся с буквы `a`, за которой следует одна буква `n` или не следует ни одной такой буквы.</span><span class="sxs-lookup"><span data-stu-id="e97b2-162">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="e97b2-163">Иными словами, предпринимается попытка найти слова `a` и `an`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-163">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="e97b2-164">В следующем примере показано, как использовать это регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-164">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="e97b2-165">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-165">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-166">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-166">Pattern</span></span>|<span data-ttu-id="e97b2-167">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-167">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e97b2-168">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-168">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="e97b2-169">Совпадение с "a"с последующими символами "n" (при их наличии).</span><span class="sxs-lookup"><span data-stu-id="e97b2-169">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="e97b2-170">Конец на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-170">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="e97b2-171">Совпадение ровно n раз: {n}</span><span class="sxs-lookup"><span data-stu-id="e97b2-171">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="e97b2-172">Квантификатор `{`*n*`}` сопоставляет предыдущий элемент ровно *n* раз, где *n* — любое целое число.</span><span class="sxs-lookup"><span data-stu-id="e97b2-172">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="e97b2-173">`{`*n*`}` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `{`*n*`}?`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-173">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="e97b2-174">Например, с помощью регулярного выражения `\b\d+\,\d{3}\b` осуществляется поиск границы слова, за которой следует один или более десятичных знаков, еще три десятичных знака и граница слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-174">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="e97b2-175">В следующем примере показано, как использовать это регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-175">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="e97b2-176">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-176">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-177">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-177">Pattern</span></span>|<span data-ttu-id="e97b2-178">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-178">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e97b2-179">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-179">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="e97b2-180">Совпадение с одной или несколькими десятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="e97b2-180">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="e97b2-181">Совпадение с символом запятой.</span><span class="sxs-lookup"><span data-stu-id="e97b2-181">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="e97b2-182">Совпадение с тремя десятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="e97b2-182">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="e97b2-183">Конец на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-183">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="e97b2-184">Совпадение как минимум n раз: {n,}</span><span class="sxs-lookup"><span data-stu-id="e97b2-184">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="e97b2-185">Квантификатор `{`*n*`,}` сопоставляет предыдущий элемент как минимум *n* раз, где *n* — любое целое число.</span><span class="sxs-lookup"><span data-stu-id="e97b2-185">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="e97b2-186">`{`*n*`,}` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `{`*n*`,}?`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-186">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="e97b2-187">Например, с помощью регулярного выражения `\b\d{2,}\b\D+` осуществляется поиск границы слова, за которой следует по крайней мере два десятичных знака, граница слова и знак, не являющийся числом.</span><span class="sxs-lookup"><span data-stu-id="e97b2-187">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="e97b2-188">В следующем примере показано, как использовать это регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-188">The following example illustrates this regular expression.</span></span> <span data-ttu-id="e97b2-189">Это регулярное выражение не соответствует фразе `"7 days"`, так как она содержит всего одну десятичную цифру, но соответствует фразам `"10 weeks and 300 years"`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-189">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="e97b2-190">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-190">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-191">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-191">Pattern</span></span>|<span data-ttu-id="e97b2-192">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-192">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e97b2-193">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-193">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="e97b2-194">Совпадение как минимум с двумя десятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="e97b2-194">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="e97b2-195">Соответствует границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-195">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="e97b2-196">Совпадение как минимум с одной цифрой, не являющейся десятичной.</span><span class="sxs-lookup"><span data-stu-id="e97b2-196">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="e97b2-197">Совпадение от n до m раз: {n,m}</span><span class="sxs-lookup"><span data-stu-id="e97b2-197">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="e97b2-198">Квантификатор `{`*n*`,`*m*`}` сопоставляет предыдущий элемент минимум *n* раз, но не больше *m* раз, где *n* и *m* — целые числа.</span><span class="sxs-lookup"><span data-stu-id="e97b2-198">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="e97b2-199">`{`*n*`,`*m*`}` — жадный квантификатор, ленивым эквивалентом которого является квантификатор `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-199">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="e97b2-200">В следующем примере с помощью регулярного выражения `(00\s){2,4}` осуществляется поиск от двух до четырех вхождений двух нулей, за которыми следует пробел.</span><span class="sxs-lookup"><span data-stu-id="e97b2-200">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="e97b2-201">Обратите внимание, что в конце входной строки имеются пять вхождений этого фрагмента при максимуме в четыре вхождения.</span><span class="sxs-lookup"><span data-stu-id="e97b2-201">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="e97b2-202">Однако только начало этой части строки (до пробела и пятой пары нулей) соответствует шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="e97b2-202">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="e97b2-203">Совпадение ноль или несколько раз (ленивое совпадение): \*?</span><span class="sxs-lookup"><span data-stu-id="e97b2-203">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="e97b2-204">Квантификатор `*?` сопоставляет предыдущий элемент ноль или несколько раз, но как можно меньшее число раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-204">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="e97b2-205">Это ленивый квантификатор, являющийся аналогом жадного квантификатора `*`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-205">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="e97b2-206">В следующем примере регулярное выражение `\b\w*?oo\w*?\b` сопоставляет все слова, которые содержат строку `oo`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-206">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="e97b2-207">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-207">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-208">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-208">Pattern</span></span>|<span data-ttu-id="e97b2-209">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-209">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e97b2-210">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-210">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="e97b2-211">Совпадение с нулем или минимально возможным числом словообразующих символов.</span><span class="sxs-lookup"><span data-stu-id="e97b2-211">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="e97b2-212">Совпадение со строкой "oo".</span><span class="sxs-lookup"><span data-stu-id="e97b2-212">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="e97b2-213">Совпадение с нулем или минимально возможным числом словообразующих символов.</span><span class="sxs-lookup"><span data-stu-id="e97b2-213">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="e97b2-214">Конец на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-214">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="e97b2-215">Совпадение один или несколько раз (ленивое совпадение): +?</span><span class="sxs-lookup"><span data-stu-id="e97b2-215">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="e97b2-216">Квантификатор `+?` сопоставляет предыдущий элемент один или более раз, но как можно меньшее число раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-216">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="e97b2-217">Это ленивый квантификатор, являющийся аналогом жадного квантификатора `+`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-217">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="e97b2-218">Например, регулярное выражение `\b\w+?\b` соответствует одному или нескольким символам, разделенным границами слов.</span><span class="sxs-lookup"><span data-stu-id="e97b2-218">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="e97b2-219">В следующем примере показано, как использовать это регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-219">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="e97b2-220">Совпадение ноль или один раз (ленивое совпадение): ??</span><span class="sxs-lookup"><span data-stu-id="e97b2-220">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="e97b2-221">Квантификатор `??` сопоставляет предыдущий элемент ноль или один раз, но как можно меньшее число раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-221">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="e97b2-222">Это ленивый квантификатор, являющийся аналогом жадного квантификатора `?`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-222">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="e97b2-223">Например, регулярное выражение `^\s*(System.)??Console.Write(Line)??\(??` пытается сопоставить строки "Console.Write" или "Console.WriteLine".</span><span class="sxs-lookup"><span data-stu-id="e97b2-223">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="e97b2-224">Строка может также включать "System."</span><span class="sxs-lookup"><span data-stu-id="e97b2-224">The string can also include "System."</span></span> <span data-ttu-id="e97b2-225">перед "Console", за ней может следовать открывающая скобка.</span><span class="sxs-lookup"><span data-stu-id="e97b2-225">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="e97b2-226">Искомый текст должен находиться в начале строки, хотя перед ним может стоять пробел.</span><span class="sxs-lookup"><span data-stu-id="e97b2-226">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="e97b2-227">В следующем примере показано, как использовать это регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-227">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="e97b2-228">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-228">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-229">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-229">Pattern</span></span>|<span data-ttu-id="e97b2-230">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-230">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="e97b2-231">Соответствует концу входной строки.</span><span class="sxs-lookup"><span data-stu-id="e97b2-231">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="e97b2-232">Соответствует нулю или нескольким символам пробела.</span><span class="sxs-lookup"><span data-stu-id="e97b2-232">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="e97b2-233">Совпадение с нулевым или единичным вхождением строки "System.".</span><span class="sxs-lookup"><span data-stu-id="e97b2-233">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="e97b2-234">Совпадение со строкой "Console.Write".</span><span class="sxs-lookup"><span data-stu-id="e97b2-234">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="e97b2-235">Совпадение с нулевым или единичным вхождением строки "Line".</span><span class="sxs-lookup"><span data-stu-id="e97b2-235">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="e97b2-236">Совпадение с нулем или одним экземпляром открывающих круглых скобок.</span><span class="sxs-lookup"><span data-stu-id="e97b2-236">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="e97b2-237">Совпадение ровно n раз (ленивое совпадение): {n}?</span><span class="sxs-lookup"><span data-stu-id="e97b2-237">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="e97b2-238">Квантификатор `{`*n*`}?` сопоставляет предыдущий элемент ровно `n` раз, где *n* — любое целое число.</span><span class="sxs-lookup"><span data-stu-id="e97b2-238">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="e97b2-239">Это ленивый квантификатор, являющийся аналогом жадного квантификатора `{`*n*`}`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-239">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="e97b2-240">В следующем примере регулярное выражение `\b(\w{3,}?\.){2}?\w{3,}?\b` используется для определения адреса веб-сайта.</span><span class="sxs-lookup"><span data-stu-id="e97b2-240">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="e97b2-241">Обратите внимание, что есть совпадение с "www.microsoft.com" и "msdn.microsoft.com", но нет совпадения с "mywebsite" или "mycompany.com".</span><span class="sxs-lookup"><span data-stu-id="e97b2-241">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="e97b2-242">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-242">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-243">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-243">Pattern</span></span>|<span data-ttu-id="e97b2-244">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-244">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e97b2-245">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-245">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="e97b2-246">Совпадение с минимум тремя словообразующими символами как можно меньшее количество раз, зак которыми следует символ точки.</span><span class="sxs-lookup"><span data-stu-id="e97b2-246">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="e97b2-247">Это первая группа записи.</span><span class="sxs-lookup"><span data-stu-id="e97b2-247">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="e97b2-248">Совпадение с шаблоном в первой группе два раза, но как можно меньшее количество раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-248">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="e97b2-249">Сопоставление заканчивается на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-249">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="e97b2-250">Совпадение как минимум n раз (ленивое совпадение): {n,}?</span><span class="sxs-lookup"><span data-stu-id="e97b2-250">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="e97b2-251">Квантификатор `{`*n*`,}?` сопоставляет предыдущий элемент как минимум `n` раз (где *n* — любое целое число), но как можно меньшее количество раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-251">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="e97b2-252">Это ленивый квантификатор, являющийся аналогом жадного квантификатора `{`*n*`,}`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-252">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="e97b2-253">Его поведение приводится в описании квантификатора `{`*n*`}?` в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="e97b2-253">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="e97b2-254">В регулярном выражении из этого примера квантификатор `{`*n*`,}` используется для поиска строки, состоящей по крайней мере из трех символов, после которых стоит точка.</span><span class="sxs-lookup"><span data-stu-id="e97b2-254">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="e97b2-255">Совпадение от n до m раз (ленивое совпадение): {n,m}?</span><span class="sxs-lookup"><span data-stu-id="e97b2-255">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="e97b2-256">Квантификатор `{`*n*`,`*m*`}?` сопоставляет предыдущий элемент от `n` до `m` раз (где *n* и *m* — целые числа), но как можно меньшее количество раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-256">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="e97b2-257">Это ленивый квантификатор, являющийся аналогом жадного квантификатора `{`*n*`,`*m*`}`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-257">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="e97b2-258">В следующем примере регулярное выражение `\b[A-Z](\w*?\s*?){1,10}[.!?]` сопоставляет фразы, содержащие от одного до десяти слов.</span><span class="sxs-lookup"><span data-stu-id="e97b2-258">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="e97b2-259">Ему соответствуют все предложения в исходной строке кроме одного, длина которого составляет 18 слов.</span><span class="sxs-lookup"><span data-stu-id="e97b2-259">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="e97b2-260">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-260">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-261">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-261">Pattern</span></span>|<span data-ttu-id="e97b2-262">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-262">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="e97b2-263">Начало на границе слова.</span><span class="sxs-lookup"><span data-stu-id="e97b2-263">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="e97b2-264">Совпадение с любым символом верхнего регистра от А до Z.</span><span class="sxs-lookup"><span data-stu-id="e97b2-264">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="e97b2-265">Совпадение с нулем или несколькими словообразующими символами, за которыми следует один или несколько пробелов, но как можно меньшее количество раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-265">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="e97b2-266">Это первая захватываемая группа.</span><span class="sxs-lookup"><span data-stu-id="e97b2-266">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="e97b2-267">Совпадение с предыдущим шаблоном от 1 до 10 раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-267">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="e97b2-268">Совпадение с любым из знаков препинания ".", "!" или "?".</span><span class="sxs-lookup"><span data-stu-id="e97b2-268">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="e97b2-269">Жадные и ленивые квантификаторы</span><span class="sxs-lookup"><span data-stu-id="e97b2-269">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="e97b2-270">У некоторых квантификаторов есть две версии.</span><span class="sxs-lookup"><span data-stu-id="e97b2-270">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="e97b2-271">Жадная версия.</span><span class="sxs-lookup"><span data-stu-id="e97b2-271">A greedy version.</span></span>  
  
     <span data-ttu-id="e97b2-272">Жадный квантификатор пытается найти максимально возможное число соответствий элемента.</span><span class="sxs-lookup"><span data-stu-id="e97b2-272">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="e97b2-273">Нежадная (ленивая) версия.</span><span class="sxs-lookup"><span data-stu-id="e97b2-273">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="e97b2-274">При использовании нежадных идентификаторов предпринимается попытка найти минимально возможное число соответствий элемента.</span><span class="sxs-lookup"><span data-stu-id="e97b2-274">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="e97b2-275">Чтобы превратить любой жадный квантификатор в ленивый, добавьте к нему `?`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-275">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="e97b2-276">Представьте простое регулярное выражение, позволяющее находить последние четыре цифры в числовой строке, например в номере кредитной карты.</span><span class="sxs-lookup"><span data-stu-id="e97b2-276">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="e97b2-277">Версия регулярного выражения с жадным квантификатором `*` будет выглядеть так: `\b.*([0-9]{4})\b`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-277">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="e97b2-278">Однако если строка содержит два числа, то с помощью такого регулярного выражения будут найдены только последние четыре цифры второго числа, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="e97b2-278">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="e97b2-279">Регулярное выражение не совпадает с первым числом, так как квантификатор `*` ищет максимально возможное число совпадений во всей строке, и здесь он находит его в конце строки.</span><span class="sxs-lookup"><span data-stu-id="e97b2-279">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="e97b2-280">Это не то, что нам нужно.</span><span class="sxs-lookup"><span data-stu-id="e97b2-280">This is not the desired behavior.</span></span> <span data-ttu-id="e97b2-281">Вместо этого вы можете применить ленивый квантификатор `*?`, чтобы получить цифры из обоих чисел, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="e97b2-281">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="e97b2-282">В большинстве случаев регулярные выражения с жадными и ленивыми квантификаторами возвращают одни и те же результаты.</span><span class="sxs-lookup"><span data-stu-id="e97b2-282">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="e97b2-283">Как правило, они возвращают разные значения, если применяется подстановочный метасимвол (`.`), который соответствует любому символу.</span><span class="sxs-lookup"><span data-stu-id="e97b2-283">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="e97b2-284">Квантификаторы и пустые соответствия</span><span class="sxs-lookup"><span data-stu-id="e97b2-284">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="e97b2-285">Квантификаторы `*`, `+` и `{`*n*`,`*m*`}` и их ленивые аналоги никогда не повторяются после пустого соответствия, если найдено минимальное количество совпадений.</span><span class="sxs-lookup"><span data-stu-id="e97b2-285">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="e97b2-286">Это правило препятствует вхождению квантификаторов в бесконечные циклы при пустых соответствиях частей выражений, если максимальное количество возможных фиксаций группы бесконечно или приближено к бесконечному.</span><span class="sxs-lookup"><span data-stu-id="e97b2-286">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="e97b2-287">Например, ниже в коде показан результат вызова метода <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> с шаблоном регулярного выражения `(a?)*`, который соответствует нулю или одному символу "a" ноль или несколько раз.</span><span class="sxs-lookup"><span data-stu-id="e97b2-287">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="e97b2-288">Обратите внимание, что отдельная захватываемая группа записывает каждое вхождение "a" и <xref:System.String.Empty?displayProperty=nameWithType>, но второго пустого совпадения нет, потому что квантификатор прекращает поиск после первого пустого совпадения.</span><span class="sxs-lookup"><span data-stu-id="e97b2-288">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="e97b2-289">Чтобы увидеть практическое различие между захватываемой группой, определяющей минимальное и максимальное количество записей, и группой, определяющей фиксированное количество записей, воспользуйтесь шаблонами регулярных выражений `(a\1|(?(1)\1)){0,2}` и `(a\1|(?(1)\1)){2}`.</span><span class="sxs-lookup"><span data-stu-id="e97b2-289">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="e97b2-290">Оба регулярных выражения состоят из одной захватываемой группы, которая определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="e97b2-290">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="e97b2-291">Модель</span><span class="sxs-lookup"><span data-stu-id="e97b2-291">Pattern</span></span>|<span data-ttu-id="e97b2-292">Описание</span><span class="sxs-lookup"><span data-stu-id="e97b2-292">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="e97b2-293">Сопоставление "a" вместе со значением первой захваченной группы...</span><span class="sxs-lookup"><span data-stu-id="e97b2-293">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="e97b2-294">…</span><span class="sxs-lookup"><span data-stu-id="e97b2-294">…</span></span> <span data-ttu-id="e97b2-295">или проверка того, была ли определена первая захваченная группа.</span><span class="sxs-lookup"><span data-stu-id="e97b2-295">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="e97b2-296">(Обратите внимание, что конструкция `(?(1)` не определяет захватываемую группу.)</span><span class="sxs-lookup"><span data-stu-id="e97b2-296">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="e97b2-297">Если первая захваченная группа существует, следует сопоставить ее значение.</span><span class="sxs-lookup"><span data-stu-id="e97b2-297">If the first captured group exists, match its value.</span></span> <span data-ttu-id="e97b2-298">Если такая группа отсутствует, для нее сопоставляется значение <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e97b2-298">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="e97b2-299">Первое регулярное выражение пытается сопоставить этот шаблон от нуля до двух раз. Второй — ровно два раза.</span><span class="sxs-lookup"><span data-stu-id="e97b2-299">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="e97b2-300">Так как первый шаблон достигает своего минимального количества записей при первой записи значения <xref:System.String.Empty?displayProperty=nameWithType>, он не повторяет попытку сопоставить `a\1`. Квантификатор `{0,2}` допускает только пустые соответствия в последней итерации.</span><span class="sxs-lookup"><span data-stu-id="e97b2-300">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="e97b2-301">Напротив, второе регулярное выражение соответствует "а", потому что оно вычисляет `a\1` второй раз. Минимальное число итераций (2) предписывает обработчику выполнять повтор после пустого соответствия.</span><span class="sxs-lookup"><span data-stu-id="e97b2-301">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="e97b2-302">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="e97b2-302">See also</span></span>

- [<span data-ttu-id="e97b2-303">Элементы языка регулярных выражений — краткий справочник</span><span class="sxs-lookup"><span data-stu-id="e97b2-303">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="e97b2-304">Поиск с возвратом</span><span class="sxs-lookup"><span data-stu-id="e97b2-304">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
