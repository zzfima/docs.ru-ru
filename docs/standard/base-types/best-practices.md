---
title: Рекомендации по использованию регулярных выражений в .NET
description: Узнайте, как создавать эффективные регулярные выражения в .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.custom: seodec18
ms.openlocfilehash: 56014469f14280deae5f220da6d786f4363ea98f
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73105723"
---
# <a name="best-practices-for-regular-expressions-in-net"></a>Рекомендации по использованию регулярных выражений в .NET

Обработчик регулярных выражений в .NET — мощное средство, обрабатывающее текст на основе совпадения шаблонов, а не сравнивающее непосредственно текст. В большинстве случаев сопоставление шаблонов выполняется быстро и эффективно. Однако в некоторых случаях обработчик регулярных выражений может работать очень медленно. В крайних случаях он даже может перестать отвечать, обрабатывая относительно небольшой объем входной информации в течение часов или даже дней.

В этом разделе приведены некоторые рекомендации для разработчиков по обеспечению оптимальной производительности регулярных выражений.

## <a name="consider-the-input-source"></a>Учет источника входных данных

Регулярные выражения могут принимать два типа входных данных: определенные и произвольные. Определенные входные данные — это текст, происходящий из известного надежного источника в заранее определенном формате. Произвольные входные данные — это текст, происходящий из ненадежного источника, например от пользователя в Интернете, который может не соответствовать заданному или ожидаемому формату.

Шаблоны регулярных выражений обычно ориентированы на подходящие входные данные. Это значит, что разработчик анализирует текст, который требуется найти, и составляет шаблон регулярного выражения. Затем разработчик определяет, требуется ли корректировка шаблона или его уточнение, тестируя его с различными подходящими входными данными. Когда шаблон соответствует всем возможным подходящим вариантам входных данных, считается, что он готов и его можно включить в выпускаемое приложение. В результате этих действий шаблон регулярного выражения готов для сопоставления с определенными входными данными. Но он не готов для сопоставления с произвольными входными данными.

Для сопоставления с произвольными входными данными шаблон регулярного выражения должен уметь обрабатывать три вида текста:

- Текст, соответствующий шаблону регулярного выражения.

- Текст, не соответствующий шаблону регулярного выражения.

- Текст, почти соответствующий шаблону регулярного выражения.

Последний вид текста представляет особую проблему для регулярных выражений, написанных для обработки определенных входных данных. Если в регулярном выражении также широко используется [поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), обработчик регулярных выражений может неожиданно долго (в некоторых случаях часы или дни) обрабатывать, казалось бы, безобидный текст.

> [!WARNING]
> В следующем примере используется регулярное выражение, которое подвержено избыточному использованию поиска с возвратом и может отклонить допустимые адреса электронной почты. Использовать его для проверки электронной почты не следует. Если требуется регулярное выражение, которое проверяет адреса электронной почты, см. раздел [Руководство. Проверка строк на соответствие формату электронной почты](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).

Например, рассмотрим очень часто используемое и при этом весьма проблематичное регулярное выражение для проверки псевдонима адреса электронной почты. Регулярное выражение `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` предназначено для обработки допустимого адреса электронной почты и состоит из алфавитно-цифрового символа, за которым следует ноль или более знаков, которые могут представлять собой алфавитно-цифровые символы, точки или дефисы. Регулярное выражение должно оканчиваться алфавитно-цифровым символом. Однако, как показывает следующий пример, несмотря на то что это регулярное выражение хорошо обрабатывает подходящие входные данные, оно очень неэффективно при обработке почти подходящих входных данных.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

Как видно по выводу примера, обработчик регулярных выражений обрабатывает подходящие псевдонимы электронной почты различной длины практически за одинаковое время. С другой стороны, если почти подходящий адрес электронной почты содержит более 5 символов, время обработки удваивается для каждого дополнительного символа в строке. Это значит, что почти подходящая строка из 28 символов будет обрабатываться более часа, а на обработку почти подходящей строки из 33 символов уйдет около дня.

Поскольку это регулярное выражение ориентировано только на формат подходящих входных данных, оно плохо работает со входными данными, не соответствующими шаблону. А это может привести к тому, что произвольные входные данные, почти соответствующие шаблону регулярного выражения, могут существенно снизить производительность.

Чтобы устранить эту проблему, можно выполнить одно из следующих действий.

- При создании шаблона необходимо учитывать, как поиск с возвратом может повлиять на производительность обработчика регулярных выражений, особенно если регулярное выражение должно обрабатывать произвольные входные данные. Дополнительные сведения см. в подразделе [Грамотное использование поиска с возвратом](#take-charge-of-backtracking).

- Следует тщательно протестировать регулярное выражение с использованием неподходящих и почти подходящих входных данных. Для генерации произвольных входных данных для конкретного регулярного выражения можно использовать [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/) — средство исследования регулярных выражений, разработанное группой Microsoft Research.

## <a name="handle-object-instantiation-appropriately"></a>Правильное создание объектов

Сердцем объектной модели регулярных выражений в .NET является класс <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>, представляющий обработчик регулярных выражений. Часто производительность регулярного выражения зависит именно от того, как используется обработчик <xref:System.Text.RegularExpressions.Regex>. Определение регулярного выражения предполагает установление тесной взаимозависимости между обработчиком регулярных выражений и шаблоном регулярного выражения. Процесс установления этой взаимозависимости является затратным, независимо от того, происходит ли создание объекта <xref:System.Text.RegularExpressions.Regex> путем передачи его конструктору шаблона регулярного выражения или происходит вызов статического метода путем передачи ему шаблона регулярного выражения и входной строки.

> [!NOTE]
> Более подробно производительно интерпретированные и скомпилированные регулярные выражения рассматриваются в записи блога [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking (Оптимизация производительности регулярных выражений, часть 2. Грамотное использование поиска с возвратом)](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) в блоге команды BCL.

Можно установить связь между обработчиком регулярных выражений и конкретным шаблоном регулярного выражения, а затем использовать обработчик для поиска совпадения в тексте несколькими способами.

- Можно вызвать статический метод поиска совпадения с шаблоном, такой как <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>. При этом не требуется создание объекта регулярного выражения.

- Можно создать экземпляр объекта <xref:System.Text.RegularExpressions.Regex> и вызвать метод поиска совпадения с шаблоном этого экземпляра для интерпретированного регулярного выражения. Это метод по умолчанию для привязки обработчика регулярных выражений к шаблону регулярного выражения. Он дает результат, когда объект <xref:System.Text.RegularExpressions.Regex> создается без аргумента `options`, включающего флажок <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.

- Можно создать экземпляр объекта <xref:System.Text.RegularExpressions.Regex> и вызвать метод поиска совпадения с шаблоном этого экземпляра для скомпилированного регулярного выражения. Объекты регулярных выражений представляют скомпилированные шаблоны, когда объект <xref:System.Text.RegularExpressions.Regex> создается с аргументом `options` с флажком <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.

- Можно целенаправленно создать объект <xref:System.Text.RegularExpressions.Regex>, связанный с конкретным шаблоном регулярного выражения, скомпилировать его и сохранить в отдельной сборке. Это можно сделать, вызвав метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>.

Способ вызова методов сопоставления регулярных выражений может существенно влиять на ваше приложение. В последующих разделах рассказывается, когда лучше использовать вызовы статического метода, интерпретированные регулярные выражения и скомпилированные регулярные выражения для повышения производительности приложения.

> [!IMPORTANT]
> Способ вызова метода (статический, интерпретированный, скомпилированный) влияет на производительность, если одно регулярное выражение используется многократно при вызове методов или если приложение активно использует объекты регулярных выражений.

### <a name="static-regular-expressions"></a>Статические регулярные выражения

Статические методы регулярных выражений рекомендуется использовать как альтернативу многократному созданию объектов регулярных выражений с одним регулярным выражением. В отличие от шаблонов регулярных выражений, используемых объектами регулярных выражений, коды операций или скомпилированный MSIL-код шаблонов, используемых при вызове статического метода, кэшируются внутренне обработчиком регулярных выражений.

Например, обработчик событий часто вызывает другой метод для проверки пользовательского ввода. Это отражено в следующем коде, где событие <xref:System.Windows.Forms.Button> элемента управления <xref:System.Windows.Forms.Control.Click> используется для вызова метода с именем `IsValidCurrency`, проверяющего, что пользователь ввел обозначение денежной единицы и еще по крайней мере один десятичный знак.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

Очень неэффективная реализация метода `IsValidCurrency` показана в следующем примере. Обратите внимание, что при каждом вызове метода заново создается объект <xref:System.Text.RegularExpressions.Regex> с одним и тем же шаблоном. А это значит, что шаблон регулярного выражения перекомпилируется при каждом вызове метода.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

Этот неэффективный код следует заменить вызовом статического метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType>. Исчезнет необходимость заново создавать объект <xref:System.Text.RegularExpressions.Regex> при каждом вызове метода поиска совпадения с шаблоном, обработчик регулярных выражений сможет извлекать скомпилированную версию регулярного выражения из кэша.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

По умолчанию кэшируется 15 последних использованных шаблонов статических регулярных выражений. Для приложений, которым требуется большее число кэшированных статических регулярных выражений, размер кэша можно задать с помощью свойства <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>.

Регулярное выражение `\p{Sc}+\s*\d+`, используемое в этом примере, проверяет, что входная строка состоит из обозначения валюты и по меньшей мере одного десятичного знака. Шаблон определяется, как показано в следующей таблице.

|Шаблон|ОПИСАНИЕ|
|-------------|-----------------|
|`\p{Sc}+`|Совпадение с одним или несколькими символами Unicode Symbol, Currency (символ валюты в Юникоде).|
|`\s*`|Соответствует нулю или нескольким символам пробела.|
|`\d+`|Совпадение с одной или несколькими десятичными цифрами.|

### <a name="interpreted-vs-compiled-regular-expressions"></a>Интерпретированные и скомпилированные регулярные выражения

Шаблоны регулярных выражений, не привязанные к обработчику регулярных выражений указанием параметра <xref:System.Text.RegularExpressions.RegexOptions.Compiled>, интерпретируются. При создании объекта регулярного выражения обработчик регулярных выражений преобразует регулярное выражение в набор кодов операций. При вызове метода экземпляра коды операций преобразуются в MSIL-код и выполняются JIT-компилятором. Аналогично, при вызове статического метода регулярного выражения, если не удается найти регулярное выражение в кэше, обработчик регулярных выражений преобразует регулярное выражение в набор кодов операций и хранит их в кэше. Затем эти коды операций преобразуются в MSIL-код, чтобы JIT-компилятор мог выполнить их. Интерпретированные регулярные выражения снижают время запуска ценой более медленного выполнения. Поэтому их лучше всего использовать, когда регулярное выражение используется с небольшим числом вызовов методов или если точное число вызовов методов регулярных выражений неизвестно, но предполагается, что оно будет небольшим. По мере увеличения числа вызовов методов выгоду по производительности от быстрого запуска перевешивает низкая скорость выполнения.

Шаблоны регулярных выражений, привязанные к обработчику регулярных выражений указанием параметра <xref:System.Text.RegularExpressions.RegexOptions.Compiled>, компилируются. Это значит, что при создании объекта регулярного выражения или при вызове статического метода регулярного выражения, если не удается найти регулярное выражение в кэше, обработчик регулярных выражений преобразует регулярное выражение в промежуточный набор кодов операций, который затем преобразуется в MSIL-код. Когда вызывается метод, JIT-компилятор выполняет MSIL-код. В отличие от интерпретированных регулярных выражений, скомпилированные регулярные выражения увеличивают время запуска, но позволяют выполнять отдельные методы поиска совпадения с шаблоном быстрее. В результате выгода по производительности от скомпилированных регулярных выражений увеличивается пропорционально числу вызовов методов регулярных выражений.

Подводя итог, мы рекомендуем использовать интерпретированные регулярные выражения, когда методы регулярного выражения с конкретным регулярным выражением вызываются относительно редко. Скомпилированные регулярные выражения следует использовать, когда методы регулярного выражения с конкретным регулярным выражением вызываются относительно часто. Точное пороговое значение, начиная с которого низкая скорость выполнения интерпретированных регулярных выражений перевешивает выгоду от быстрого запуска, или пороговое значение, при котором медленный запуск скомпилированных регулярных выражений перевешивает выгоду от быстрого выполнения, трудно указать. Оно зависит от нескольких факторов, в том числе от сложности регулярного выражения и конкретных обрабатываемых данных. Чтобы определить, что позволит добиться лучшей производительности — интерпретированные или скомпилированные регулярные выражения, — можно использовать класс <xref:System.Diagnostics.Stopwatch>, чтобы сравнить время выполнения в обоих случаях.

В следующем примере сравнивается производительность скомпилированных и интерпретированных регулярных выражений при чтении первых десяти предложений, а также при чтении всех предложений текста книги *Финансист* Теодора Драйзера. Как показывает вывод примера, если требуется выполнить только 10 вызовов методов поиска совпадения, интерпретированное регулярное выражение дает более высокую производительность. Однако скомпилированное регулярное выражение обеспечивает более высокую производительность при большом числе вызовов (в данном случае 13 000).

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

Используемый в примере шаблон регулярного выражения `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]` определяется, как показано в следующей таблице.

|Шаблон|ОПИСАНИЕ|
|-------------|-----------------|
|`\b`|Совпадение должно начинаться на границе слова.|
|`\w+`|Совпадение с одним или несколькими символами слова.|
|<code>(\r?\n)&#124;,?\s)</code>|Соответствует нулю или одному возврату каретки и последующему символу новой строки; или нулю или одной запятой с последующим пробелом.|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|Совпадение с одним или несколькими символами слова, за которыми следует ноль или один возврат каретки и символ новой строки, или ноль или одна запятая с последующим пробелом.|
|`\w+`|Совпадение с одним или несколькими символами слова.|
|`[.?:;!]`|Совпадение с точкой, вопросительным знаком, двоеточием, точкой с запятой или восклицательным знаком.|

### <a name="regular-expressions-compiled-to-an-assembly"></a>Регулярные выражения: скомпилированные в сборку

Также .NET позволяет создать сборку, которая содержит скомпилированные регулярные выражения. Это позволяет переместить основные затраты на компиляцию регулярных выражений на время разработки (вместо времени выполнения). Однако требуются дополнительные действия. Необходимо заранее определить регулярные выражения и скомпилировать их в сборку. Затем компилятор может сослаться на эту сборку при компиляции исходного кода, использующего регулярные выражения из сборки. Каждое скомпилированное регулярное выражение в сборке представлено классом, унаследованным от <xref:System.Text.RegularExpressions.Regex>.

Для компиляции регулярных выражений в сборку вызывается метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> и ему передается массив объектов <xref:System.Text.RegularExpressions.RegexCompilationInfo>, представляющих регулярные выражения, которые требуется скомпилировать, и объект <xref:System.Reflection.AssemblyName> с информацией о создаваемой сборке.

Рекомендуется компилировать регулярные выражения в сборку в следующих случаях:

- Если вы являетесь разработчиком компонентов и вам требуется создать библиотеку регулярных выражений для повторного использования.

- Если вы предполагаете, что методы поиска совпадения с шаблоном вашего регулярного выражения будут вызываться неопределенное количество раз (от одного–двух раз до тысяч или десятков тысяч раз). В отличие от интерпретированных и скомпилированных регулярных выражений, регулярные выражения, скомпилированные в отдельные сборки, обеспечивают стабильную производительность, независимо от числа вызовов методов.

Если вы используете скомпилированные регулярные выражения для оптимизации производительности, не следует использовать отражение для создания сборки, загрузки обработчика регулярных выражений и выполнения его методов поиска совпадения с шаблоном. Следует избегать динамического построения шаблонов регулярных выражений. Кроме того, необходимо задать все параметры поиска совпадения с шаблоном (например, чувствительность к регистру) в момент создания сборки. Также необходимо отделить код, создающий сборку, от кода, использующего регулярное выражение.

В следующем примере показано, как создать сборку, содержащую скомпилированное регулярное выражение. В примере создается сборка с именем `RegexLib.dll` с одним классом регулярных выражений, `SentencePattern`, содержащим шаблон регулярного выражения для поиска предложений, который использовался в разделе [Интерпретированные и скомпилированные регулярные выражения](#interpreted-vs-compiled-regular-expressions).

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

Когда код примера компилируется в исполняемый файл и выполняется, создается сборка с именем `RegexLib.dll`. Регулярное выражение представлено классом с именем `Utilities.RegularExpressions.SentencePattern`, унаследованным от <xref:System.Text.RegularExpressions.Regex>. В следующем примере скомпилированное регулярное выражение используется для извлечения предложений из текста книги *Финансист* Теодора Драйзера.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a>Грамотное использование поиска с возвратом

Обычно обработчик регулярных выражений двигается по входной строке линейным образом, сравнивая ее с шаблоном регулярного выражения. Однако когда в шаблоне регулярного выражения используются неопределенные квантификаторы, такие как `*`, `+` или `?`, обработчик регулярных выражений может отбрасывать частичное совпадение и возвращаться к ранее сохраненному состоянию, чтобы искать совпадение с шаблоном целиком. Этот процесс известен как поиск с возвратом.

> [!NOTE]
> Дополнительные сведения о поиске с возвратом см. в статьях [Подробные сведения о поведении регулярных выражений](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) и [Поиск с возвратом в регулярных выражениях](../../../docs/standard/base-types/backtracking-in-regular-expressions.md). Поиска с возвратом подробно рассматривается в записи блога [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking (Оптимизация производительности регулярных выражений, часть 2. Грамотное использование поиска с возвратом)](https://blogs.msdn.microsoft.com/bclteam/2010/08/03/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha/) в блоге команды BCL.

Поддержка поиска с возвратом обеспечивает мощность и гибкость регулярных выражений. При этом ответственность за управление работой обработчика регулярных выражений лежит на разработчике регулярных выражений. Поскольку разработчики часто не отдают себе отчет в этой ответственности, неправильное или излишнее использование поиска с возвратом часто становится причиной снижения производительности регулярных выражений. В самом неблагоприятном случае время обработки может удваиваться при каждом добавлении символа во входную строку. Чрезмерно используя поиск с возвратом, очень легко создать программный аналог бесконечной петли, если входные данные почти совпадают с шаблоном регулярного выражения. Обработчик регулярных выражений может в течение часов или даже дней обрабатывать относительно короткую входную строку.

Часто приложения имеют сниженную производительность из-за использования поиска с возвратом, хотя поиск с возвратом не очень важен для обнаружения совпадения. Например, регулярное выражение `\b\p{Lu}\w*\b` совпадает со всеми словами, начинающимися с символа верхнего регистра, как показано в следующей таблице.

|Шаблон|ОПИСАНИЕ|
|-|-|
|`\b`|Совпадение должно начинаться на границе слова.|
|`\p{Lu}`|Совпадение с символом верхнего регистра.|
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|
|`\b`|Совпадение должно заканчиваться на границе слова.|

Поскольку граница слова не является символом слова (или подмножеством символов слова), нет шанса, что регулярное выражение перейдет границу слова, сопоставляя символы слова. Это значит, что для этого регулярного выражения поиск с возвратом не принесет никакой пользы, а только снизит производительность, поскольку обработчик регулярных выражений вынужден сохранять свое состояние для каждого возможного совпадения.

Если вы понимаете, что нет необходимости использовать поиск с возвратом, его можно отключить с помощью языкового элемента `(?>subexpression)`. В следующем примере производится анализ входной строки с использованием двух регулярных выражений. Функционирование первого регулярного выражения, `\b\p{Lu}\w*\b`, основано на поиске с возвратом. Второе регулярное выражение, `\b\p{Lu}(?>\w*)\b`, отключает поиск с возвратом. Как видно по выводу, выражения дают одинаковый результат.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

Часто поиск с возвратом очень важен для поиска во входной строке совпадения с шаблоном регулярного выражения. Тем не менее избыточное использование поиска с возвратом может сильно снизить производительность и создать впечатление, что приложение перестало отвечать. Например, так происходит, когда используются вложенные квантификаторы и текст, совпадающий со внешней частью выражения, является подмножеством текста, совпадающего со внутренней частью выражения.

> [!WARNING]
> Помимо того, что следует избегать избыточного использования поиска с возвратом, необходимо использовать возможность времени ожидания, чтобы убедиться, что избыточный поиск с возвратом не слишком сильно снижает производительность регулярного выражения. Дополнительные сведения см. в статье [Использование значений времени ожидания](#use-time-out-values).

Например, шаблон регулярного выражения `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` должен искать номер части, состоящий из по крайней мере одного алфавитно-цифрового символа. Дополнительные символы могут включать в себя алфавитно-цифровые символы, дефис, подчеркивание или точку, но последний символ должен быть алфавитно-цифровым. Знак доллара завершает номер части. В некоторых случаях этот шаблон регулярного выражения может привести к очень низкой производительности, поскольку в нем используются вложенные квантификаторы и часть выражения `[0-9A-Z]` является подмножеством части выражения `[-.\w]*`.

В таких случаях можно оптимизировать производительность, удалив вложенные квантификаторы и заменив внешнюю часть выражения утверждением просмотра вперед или назад нулевой ширины. Утверждения просмотра вперед и назад являются "якорями". Они не перемещают указатель во входной строке, а выполняют поиск впереди или позади, проверяя, выполняется ли заданное условие. Например, регулярное выражение для поиска номера части можно записать следующим образом: `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`. Этот шаблон регулярного выражения определяется, как показано в следующей таблице.

|Шаблон|ОПИСАНИЕ|
|-------------|-----------------|
|`^`|Начало совпадения в начале входной строки.|
|`[0-9A-Z]`|Совпадение с алфавитно-цифровым символом. Номер части должен состоять по меньшей мере из этого символа.|
|`[-.\w]*`|Совпадение с нулем или большим числом вхождений любого символа слова, дефиса или точки.|
|`\$`|Совпадение со знаком доллара.|
|`(?<=[0-9A-Z])`|Поиск за конечным знаком доллара с целью проверить, что предыдущий символ алфавитно-цифровой.|
|`$`|Совпадение должно заканчиваться в конце входной строки.|

В приведенном ниже примере демонстрируется использование этого регулярного выражения для поиска совпадений в массиве потенциальных номеров частей.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

Язык регулярных выражений в .NET включает следующие языковые элементы, которые можно использовать для исключения вложенных квантификаторов. Для получения дополнительной информации см. [Конструкции группирования](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).

|Элемент языка|ОПИСАНИЕ|
|----------------------|-----------------|
|`(?=` `subexpression` `)`|Положительный просмотр вперед нулевой ширины. Поиск за текущей позицией с целью проверить, совпадает ли параметр `subexpression` со входной строкой.|
|`(?!` `subexpression` `)`|Отрицательный просмотр вперед нулевой ширины. Поиск за текущей позицией с целью проверить, что параметр `subexpression` не совпадает со входной строкой.|
|`(?<=` `subexpression` `)`|Положительный просмотр назад нулевой ширины. Поиск перед текущей позицией с целью проверить, совпадает ли параметр `subexpression` со входной строкой.|
|`(?<!` `subexpression` `)`|Отрицательный просмотр назад нулевой ширины. Поиск перед текущей позицией с целью проверить, что параметр `subexpression` не совпадает со входной строкой.|

## <a name="use-time-out-values"></a>Использование значений времени ожидания

Если регулярные выражения обрабатывают входные данные, которые почти совпадают с шаблоном регулярного выражения, зачастую они могут использовать избыточный поиск с возвратом, что сильно влияет на их производительность. Помимо того, что следует тщательно обдумывать использование поиска с возвратом и тестировать регулярное выражение на почти совпадающих входных данных, необходимо всегда устанавливать значение времени ожидания для минимизации влияния на производительность избыточного поиска с возвратом, если он все же используется.

Интервал времени ожидания регулярного выражения определяет период времени, в течение которого обработчик регулярных выражений выполняет поиск одного совпадения, после чего время ожидания истекает. По умолчанию интервал времени ожидания равен <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, что означает, что регулярное выражение имеет неограниченное время ожидания. Можно переопределить это значение и задать интервал времени ожидания следующим образом:

- предоставив значение времени ожидания при создании экземпляра объекта <xref:System.Text.RegularExpressions.Regex> путем вызова конструктора <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>;

- путем вызова статического метода поиска совпадения с шаблоном, такого как <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, который имеет параметр `matchTimeout`;

- для скомпилированных регулярных выражений, созданных путем вызова метода <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>, — путем вызова конструктора, который имеет параметр типа <xref:System.TimeSpan>.

Если определен интервал времени ожидания и по истечении этого интервала совпадение не найдено, метод регулярного выражения вызывает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>. В обработчике исключений можно принять решение о том, повторить ли поиск совпадения с более длинным интервалом времени ожидания, отказаться от попытки поиска совпадения и предположить, что совпадение не найдено, или же отказаться от попытки поиска совпадения и зарегистрировать сведения об исключении в журнале для анализа в дальнейшем.

В следующем примере определяется метод `GetWordData`, который создает регулярное выражение с интервалом времени ожидания 350 миллисекунд, чтобы вычислить количество слов и среднее количество символов в слове в текстовом документе. Если время ожидания для операции поиска совпадения истекает, интервал времени ожидания увеличивается на 350 миллисекунд и объект <xref:System.Text.RegularExpressions.Regex> создается заново. Если новый интервал времени ожидания превышает 1 секунду, метод передает исключение вызывающему объекту.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a>Захват только в случае необходимости

Регулярные выражения в .NET поддерживают ряд конструкций группирования, позволяющих группировать шаблон регулярного выражения в виде одной или более частей. Наиболее часто в языке регулярных выражений .NET используются конструкции группирования `(`*часть_выражения*`)`, которая определяет нумерованную группу записи, и `(?<`*имя*`>`*часть_выражения*`)`, которая определяет именованную группу записи. Конструкции группирования крайне важны для создания обратных ссылок и для определения части выражения, к которой должен применяться квантификатор.

Однако использование этих языковых элементов имеет последствия. Объект <xref:System.Text.RegularExpressions.GroupCollection>, возвращаемый свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> заполняется наиболее новыми неименованными или именованными захваченными объектами, и если одна конструкция группирования захватила несколько подстрок из входной строки, они заполняют объект <xref:System.Text.RegularExpressions.CaptureCollection>, возвращаемый свойством <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> определенной группы захвата с несколькими объектами <xref:System.Text.RegularExpressions.Capture>.

Часто конструкции группирования используются в регулярном выражении только для того, чтобы к нему можно было применить квантификаторы, и группы, захваченные этими частями выражения затем не используются. Например, регулярное выражение `\b(\w+[;,]?\s?)+[.?!]` предназначено для записи всего предложения. В следующей таблице описаны языковые элементы этого шаблона регулярных выражений и их влияние на коллекции <xref:System.Text.RegularExpressions.Match> и <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> объекта <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.

|Шаблон|ОПИСАНИЕ|
|-------------|-----------------|
|`\b`|Совпадение должно начинаться на границе слова.|
|`\w+`|Совпадение с одним или несколькими символами слова.|
|`[;,]?`|Совпадение с нулем или одной запятой или точкой с запятой.|
|`\s?`|Совпадение с нулем или одним символом пробела.|
|`(\w+[;,]?\s?)+`|Совпадение с одним или большим числом символов слова; затем, необязательно, запятой или точкой с запятой; затем, необязательно, пробелом. Здесь определена первая группа захвата, которая необходима, чтобы набор нескольких символов слова (то есть слово) и необязательно следующий за ним знак препинания повторялись, пока регулярное выражение не достигнет конца предложения.|
|`[.?!]`|Совпадение с точкой, вопросительным знаком или восклицательным знаком.|

Как показано в следующем примере, когда совпадение найдено, объекты <xref:System.Text.RegularExpressions.GroupCollection> и <xref:System.Text.RegularExpressions.CaptureCollection> заполняются захваченными объектами из совпадения. В этом случае используется группа записи `(\w+[;,]?\s?)`, чтобы к ней можно было применить квантификатор `+`, который позволяет шаблону регулярного выражения сопоставить каждое слово в предложении. В противном случае было бы найдено совпадение только с последним словом предложения.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

Если части выражения используются только для применения к ним квантификаторов и захваченный текст не нужен, следует отменить захваты групп. Например, языковой элемент `(?:subexpression)` запрещает группе, к которой он применен, захватывать совпавшие подстроки. В следующем примере шаблон регулярного выражения из предыдущего примера изменен на `\b(?:\w+[;,]?\s?)+[.?!]`. Как показывает вывод, обработчик регулярных выражений не заполняет коллекции <xref:System.Text.RegularExpressions.GroupCollection> и <xref:System.Text.RegularExpressions.CaptureCollection>.

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

Отключить захват можно одним из следующих способов:

- Используйте языковой элемент `(?:subexpression)`. Этот элемент отключает захват совпавших подстрок в группе, к которой он применен. Во вложенных группах захват подстрок не отключается.

- Использовать параметр <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>. Он отключает все неименованные и неявные захваты для шаблона регулярных выражений. При использовании этого параметра захват выполняется только для тех подстрок, которые совпадают с именованными группами, определенными с помощью языкового элемента `(?<name>subexpression)`. Флажок <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> можно передать в параметр `options` конструктора класса <xref:System.Text.RegularExpressions.Regex> или в параметр `options` статического метода поиска совпадения <xref:System.Text.RegularExpressions.Regex>.

- Использовать параметр `n` в языковом элементе `(?imnsx)`. Этот параметр отключает все неименованные или неявные захваты, начиная с того места, на котором находится этот элемент в шаблоне регулярного выражения. Захват отключается либо до конца шаблона, либо пока захват для неименованных и неявных объектов не будет включен параметром `(-n)`. Для получения дополнительной информации см. [Прочие конструкции](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).

- Использовать параметр `n` в языковом элементе `(?imnsx:subexpression)`. Этот параметр отключает все неименованные и неявные захваты в части выражения `subexpression`. Захваты для всех вложенных неименованных и неявных групп также отключаются.

## <a name="related-topics"></a>См. также

|Заголовок|ОПИСАНИЕ|
|-----------|-----------------|
|[Подробные сведения о поведении регулярных выражений](../../../docs/standard/base-types/details-of-regular-expression-behavior.md)|Описание реализации обработчика регулярных выражений в .NET. В этом разделе основное внимание уделено гибкости регулярных выражений; кроме того, рассказывается об ответственности разработчика за эффективную и надежную работу обработчика регулярных выражений.|
|[Поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|Описание поиска с возвратом и того, как он влияет на производительность регулярных выражений. Описание языковых элементов, которые можно использовать вместо поиска с возвратом.|
|[Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|Описание элементов языка регулярных выражений в .NET и ссылки на подробную документацию для каждого языкового элемента.|
