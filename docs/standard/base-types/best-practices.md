---
title: Рекомендации по использованию регулярных выражений в .NET
description: Узнайте, как создавать эффективные регулярные выражения в .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, best practices
- regular expressions, best practices
ms.assetid: 618e5afb-3a97-440d-831a-70e4c526a51c
ms.openlocfilehash: 9b09f5a2505888c6154a58a3512c94c51f89295b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "77124426"
---
# <a name="best-practices-for-regular-expressions-in-net"></a><span data-ttu-id="8f65c-103">Рекомендации по использованию регулярных выражений в .NET</span><span class="sxs-lookup"><span data-stu-id="8f65c-103">Best practices for regular expressions in .NET</span></span>

<span data-ttu-id="8f65c-104">Обработчик регулярных выражений в .NET — мощное средство, обрабатывающее текст на основе совпадения шаблонов, а не сравнивающее непосредственно текст.</span><span class="sxs-lookup"><span data-stu-id="8f65c-104">The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text.</span></span> <span data-ttu-id="8f65c-105">В большинстве случаев сопоставление шаблонов выполняется быстро и эффективно.</span><span class="sxs-lookup"><span data-stu-id="8f65c-105">In most cases, it performs pattern matching rapidly and efficiently.</span></span> <span data-ttu-id="8f65c-106">Однако в некоторых случаях обработчик регулярных выражений может работать очень медленно.</span><span class="sxs-lookup"><span data-stu-id="8f65c-106">However, in some cases, the regular expression engine can appear to be very slow.</span></span> <span data-ttu-id="8f65c-107">В крайних случаях он даже может перестать отвечать, обрабатывая относительно небольшой объем входной информации в течение часов или даже дней.</span><span class="sxs-lookup"><span data-stu-id="8f65c-107">In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</span></span>

<span data-ttu-id="8f65c-108">В этом разделе приведены некоторые рекомендации для разработчиков по обеспечению оптимальной производительности регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-108">This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</span></span>

## <a name="consider-the-input-source"></a><span data-ttu-id="8f65c-109">Учет источника входных данных</span><span class="sxs-lookup"><span data-stu-id="8f65c-109">Consider the input source</span></span>

<span data-ttu-id="8f65c-110">Регулярные выражения могут принимать два типа входных данных: определенные и произвольные.</span><span class="sxs-lookup"><span data-stu-id="8f65c-110">In general, regular expressions can accept two types of input: constrained or unconstrained.</span></span> <span data-ttu-id="8f65c-111">Определенные входные данные — это текст, происходящий из известного надежного источника в заранее определенном формате.</span><span class="sxs-lookup"><span data-stu-id="8f65c-111">Constrained input is text that originates from a known or reliable source and follows a predefined format.</span></span> <span data-ttu-id="8f65c-112">Произвольные входные данные — это текст, происходящий из ненадежного источника, например от пользователя в Интернете, который может не соответствовать заданному или ожидаемому формату.</span><span class="sxs-lookup"><span data-stu-id="8f65c-112">Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</span></span>

<span data-ttu-id="8f65c-113">Шаблоны регулярных выражений обычно ориентированы на подходящие входные данные.</span><span class="sxs-lookup"><span data-stu-id="8f65c-113">Regular expression patterns are typically written to match valid input.</span></span> <span data-ttu-id="8f65c-114">Это значит, что разработчик анализирует текст, который требуется найти, и составляет шаблон регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-114">That is, developers examine the text that they want to match and then write a regular expression pattern that matches it.</span></span> <span data-ttu-id="8f65c-115">Затем разработчик определяет, требуется ли корректировка шаблона или его уточнение, тестируя его с различными подходящими входными данными.</span><span class="sxs-lookup"><span data-stu-id="8f65c-115">Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items.</span></span> <span data-ttu-id="8f65c-116">Когда шаблон соответствует всем возможным подходящим вариантам входных данных, считается, что он готов и его можно включить в выпускаемое приложение.</span><span class="sxs-lookup"><span data-stu-id="8f65c-116">When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application.</span></span> <span data-ttu-id="8f65c-117">В результате этих действий шаблон регулярного выражения готов для сопоставления с определенными входными данными.</span><span class="sxs-lookup"><span data-stu-id="8f65c-117">This makes a regular expression pattern suitable for matching constrained input.</span></span> <span data-ttu-id="8f65c-118">Но он не готов для сопоставления с произвольными входными данными.</span><span class="sxs-lookup"><span data-stu-id="8f65c-118">However, it does not make it suitable for matching unconstrained input.</span></span>

<span data-ttu-id="8f65c-119">Для сопоставления с произвольными входными данными шаблон регулярного выражения должен уметь обрабатывать три вида текста:</span><span class="sxs-lookup"><span data-stu-id="8f65c-119">To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</span></span>

- <span data-ttu-id="8f65c-120">Текст, соответствующий шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-120">Text that matches the regular expression pattern.</span></span>

- <span data-ttu-id="8f65c-121">Текст, не соответствующий шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-121">Text that does not match the regular expression pattern.</span></span>

- <span data-ttu-id="8f65c-122">Текст, почти соответствующий шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-122">Text that nearly matches the regular expression pattern.</span></span>

<span data-ttu-id="8f65c-123">Последний вид текста представляет особую проблему для регулярных выражений, написанных для обработки определенных входных данных.</span><span class="sxs-lookup"><span data-stu-id="8f65c-123">The last text type is especially problematic for a regular expression that has been written to handle constrained input.</span></span> <span data-ttu-id="8f65c-124">Если в регулярном выражении также широко используется [поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), обработчик регулярных выражений может неожиданно долго (в некоторых случаях часы или дни) обрабатывать, казалось бы, безобидный текст.</span><span class="sxs-lookup"><span data-stu-id="8f65c-124">If that regular expression also relies on extensive [backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md), the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</span></span>

> [!WARNING]
> <span data-ttu-id="8f65c-125">В следующем примере используется регулярное выражение, которое подвержено избыточному использованию поиска с возвратом и может отклонить допустимые адреса электронной почты.</span><span class="sxs-lookup"><span data-stu-id="8f65c-125">The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses.</span></span> <span data-ttu-id="8f65c-126">Использовать его для проверки электронной почты не следует.</span><span class="sxs-lookup"><span data-stu-id="8f65c-126">You should not use it in an email validation routine.</span></span> <span data-ttu-id="8f65c-127">Если требуется регулярное выражение, которое проверяет адреса электронной почты, см. раздел [Руководство. Проверка строк на соответствие формату электронной почты](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="8f65c-127">If you would like a regular expression that validates email addresses, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

<span data-ttu-id="8f65c-128">Например, рассмотрим очень часто используемое и при этом весьма проблематичное регулярное выражение для проверки псевдонима адреса электронной почты.</span><span class="sxs-lookup"><span data-stu-id="8f65c-128">For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address.</span></span> <span data-ttu-id="8f65c-129">Регулярное выражение `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` предназначено для обработки допустимого адреса электронной почты и состоит из алфавитно-цифрового символа, за которым следует ноль или более знаков, которые могут представлять собой алфавитно-цифровые символы, точки или дефисы.</span><span class="sxs-lookup"><span data-stu-id="8f65c-129">The regular expression `^[0-9A-Z]([-.\w]*[0-9A-Z])*$` is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens.</span></span> <span data-ttu-id="8f65c-130">Регулярное выражение должно оканчиваться алфавитно-цифровым символом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-130">The regular expression must end with an alphanumeric character.</span></span> <span data-ttu-id="8f65c-131">Однако, как показывает следующий пример, несмотря на то что это регулярное выражение хорошо обрабатывает подходящие входные данные, оно очень неэффективно при обработке почти подходящих входных данных.</span><span class="sxs-lookup"><span data-stu-id="8f65c-131">However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/design2.cs#1)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/design2.vb#1)]

<span data-ttu-id="8f65c-132">Как видно по выводу примера, обработчик регулярных выражений обрабатывает подходящие псевдонимы электронной почты различной длины практически за одинаковое время.</span><span class="sxs-lookup"><span data-stu-id="8f65c-132">As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length.</span></span> <span data-ttu-id="8f65c-133">С другой стороны, если почти подходящий адрес электронной почты содержит более 5 символов, время обработки удваивается для каждого дополнительного символа в строке.</span><span class="sxs-lookup"><span data-stu-id="8f65c-133">On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string.</span></span> <span data-ttu-id="8f65c-134">Это значит, что почти подходящая строка из 28 символов будет обрабатываться более часа, а на обработку почти подходящей строки из 33 символов уйдет около дня.</span><span class="sxs-lookup"><span data-stu-id="8f65c-134">This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</span></span>

<span data-ttu-id="8f65c-135">Поскольку это регулярное выражение ориентировано только на формат подходящих входных данных, оно плохо работает со входными данными, не соответствующими шаблону.</span><span class="sxs-lookup"><span data-stu-id="8f65c-135">Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern.</span></span> <span data-ttu-id="8f65c-136">А это может привести к тому, что произвольные входные данные, почти соответствующие шаблону регулярного выражения, могут существенно снизить производительность.</span><span class="sxs-lookup"><span data-stu-id="8f65c-136">This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</span></span>

<span data-ttu-id="8f65c-137">Чтобы устранить эту проблему, можно выполнить одно из следующих действий.</span><span class="sxs-lookup"><span data-stu-id="8f65c-137">To solve this problem, you can do the following:</span></span>

- <span data-ttu-id="8f65c-138">При создании шаблона необходимо учитывать, как поиск с возвратом может повлиять на производительность обработчика регулярных выражений, особенно если регулярное выражение должно обрабатывать произвольные входные данные.</span><span class="sxs-lookup"><span data-stu-id="8f65c-138">When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input.</span></span> <span data-ttu-id="8f65c-139">Дополнительные сведения см. в подразделе [Грамотное использование поиска с возвратом](#take-charge-of-backtracking).</span><span class="sxs-lookup"><span data-stu-id="8f65c-139">For more information, see the [Take Charge of Backtracking](#take-charge-of-backtracking) section.</span></span>

- <span data-ttu-id="8f65c-140">Следует тщательно протестировать регулярное выражение с использованием неподходящих и почти подходящих входных данных.</span><span class="sxs-lookup"><span data-stu-id="8f65c-140">Thoroughly test your regular expression using invalid and near-valid input as well as valid input.</span></span> <span data-ttu-id="8f65c-141">Для генерации произвольных входных данных для конкретного регулярного выражения можно использовать [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/) — средство исследования регулярных выражений, разработанное группой Microsoft Research.</span><span class="sxs-lookup"><span data-stu-id="8f65c-141">To generate input for a particular regular expression randomly, you can use [Rex](https://www.microsoft.com/research/project/rex-regular-expression-exploration/), which is a regular expression exploration tool from Microsoft Research.</span></span>

## <a name="handle-object-instantiation-appropriately"></a><span data-ttu-id="8f65c-142">Правильное создание объектов</span><span class="sxs-lookup"><span data-stu-id="8f65c-142">Handle object instantiation appropriately</span></span>

<span data-ttu-id="8f65c-143">Сердцем объектной модели регулярных выражений в .NET является класс <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>, представляющий обработчик регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-143">At the heart of .NET’s regular expression object model is the <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class, which represents the regular expression engine.</span></span> <span data-ttu-id="8f65c-144">Часто производительность регулярного выражения зависит именно от того, как используется обработчик <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-144">Often, the single greatest factor that affects regular expression performance is the way in which the <xref:System.Text.RegularExpressions.Regex> engine is used.</span></span> <span data-ttu-id="8f65c-145">Определение регулярного выражения предполагает установление тесной взаимозависимости между обработчиком регулярных выражений и шаблоном регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-145">Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern.</span></span> <span data-ttu-id="8f65c-146">Процесс установления этой взаимозависимости является затратным, независимо от того, происходит ли создание объекта <xref:System.Text.RegularExpressions.Regex> путем передачи его конструктору шаблона регулярного выражения или происходит вызов статического метода путем передачи ему шаблона регулярного выражения и входной строки.</span><span class="sxs-lookup"><span data-stu-id="8f65c-146">That coupling process, whether it involves instantiating a <xref:System.Text.RegularExpressions.Regex> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</span></span>

> [!NOTE]
> <span data-ttu-id="8f65c-147">Более подробно производительно интерпретированные и скомпилированные регулярные выражения рассматриваются в записи блога [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking (Оптимизация производительности регулярных выражений, часть 2. Грамотное использование поиска с возвратом)](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) в блоге команды BCL.</span><span class="sxs-lookup"><span data-stu-id="8f65c-147">For a more detailed discussion of the performance implications of using interpreted and compiled regular expressions, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="8f65c-148">Можно установить связь между обработчиком регулярных выражений и конкретным шаблоном регулярного выражения, а затем использовать обработчик для поиска совпадения в тексте несколькими способами.</span><span class="sxs-lookup"><span data-stu-id="8f65c-148">You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</span></span>

- <span data-ttu-id="8f65c-149">Можно вызвать статический метод поиска совпадения с шаблоном, такой как <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-149">You can call a static pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8f65c-150">При этом не требуется создание объекта регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-150">This does not require instantiation of a regular expression object.</span></span>

- <span data-ttu-id="8f65c-151">Можно создать экземпляр объекта <xref:System.Text.RegularExpressions.Regex> и вызвать метод поиска совпадения с шаблоном этого экземпляра для интерпретированного регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-151">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of an interpreted regular expression.</span></span> <span data-ttu-id="8f65c-152">Это метод по умолчанию для привязки обработчика регулярных выражений к шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-152">This is the default method for binding the regular expression engine to a regular expression pattern.</span></span> <span data-ttu-id="8f65c-153">Он дает результат, когда объект <xref:System.Text.RegularExpressions.Regex> создается без аргумента `options`, включающего флажок <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-153">It results when a <xref:System.Text.RegularExpressions.Regex> object is instantiated without an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="8f65c-154">Можно создать экземпляр объекта <xref:System.Text.RegularExpressions.Regex> и вызвать метод поиска совпадения с шаблоном этого экземпляра для скомпилированного регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-154">You can instantiate a <xref:System.Text.RegularExpressions.Regex> object and call an instance pattern-matching method of a compiled regular expression.</span></span> <span data-ttu-id="8f65c-155">Объекты регулярных выражений представляют скомпилированные шаблоны, когда объект <xref:System.Text.RegularExpressions.Regex> создается с аргументом `options` с флажком <xref:System.Text.RegularExpressions.RegexOptions.Compiled>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-155">Regular expression objects represent compiled patterns when a <xref:System.Text.RegularExpressions.Regex> object is instantiated with an `options` argument that includes the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> flag.</span></span>

- <span data-ttu-id="8f65c-156">Можно целенаправленно создать объект <xref:System.Text.RegularExpressions.Regex>, связанный с конкретным шаблоном регулярного выражения, скомпилировать его и сохранить в отдельной сборке.</span><span class="sxs-lookup"><span data-stu-id="8f65c-156">You can create a special-purpose <xref:System.Text.RegularExpressions.Regex> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly.</span></span> <span data-ttu-id="8f65c-157">Это можно сделать, вызвав метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-157">You do this by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="8f65c-158">Способ вызова методов сопоставления регулярных выражений может существенно влиять на ваше приложение.</span><span class="sxs-lookup"><span data-stu-id="8f65c-158">The particular way in which you call regular expression matching methods can have a significant impact on your application.</span></span> <span data-ttu-id="8f65c-159">В последующих разделах рассказывается, когда лучше использовать вызовы статического метода, интерпретированные регулярные выражения и скомпилированные регулярные выражения для повышения производительности приложения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-159">The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8f65c-160">Способ вызова метода (статический, интерпретированный, скомпилированный) влияет на производительность, если одно регулярное выражение используется многократно при вызове методов или если приложение активно использует объекты регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-160">The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</span></span>

### <a name="static-regular-expressions"></a><span data-ttu-id="8f65c-161">Статические регулярные выражения</span><span class="sxs-lookup"><span data-stu-id="8f65c-161">Static regular expressions</span></span>

<span data-ttu-id="8f65c-162">Статические методы регулярных выражений рекомендуется использовать как альтернативу многократному созданию объектов регулярных выражений с одним регулярным выражением.</span><span class="sxs-lookup"><span data-stu-id="8f65c-162">Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression.</span></span> <span data-ttu-id="8f65c-163">В отличие от шаблонов регулярных выражений, используемых объектами регулярных выражений, коды операций или скомпилированный MSIL-код шаблонов, используемых при вызове статического метода, кэшируются внутренне обработчиком регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-163">Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</span></span>

<span data-ttu-id="8f65c-164">Например, обработчик событий часто вызывает другой метод для проверки пользовательского ввода.</span><span class="sxs-lookup"><span data-stu-id="8f65c-164">For example, an event handler frequently calls another method to validate user input.</span></span> <span data-ttu-id="8f65c-165">Это отражено в следующем коде, где событие <xref:System.Windows.Forms.Button> элемента управления <xref:System.Windows.Forms.Control.Click> используется для вызова метода с именем `IsValidCurrency`, проверяющего, что пользователь ввел обозначение денежной единицы и еще по крайней мере один десятичный знак.</span><span class="sxs-lookup"><span data-stu-id="8f65c-165">This is reflected in the following code, in which a <xref:System.Windows.Forms.Button> control's <xref:System.Windows.Forms.Control.Click> event is used to call a method named `IsValidCurrency`, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#2)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#2)]

<span data-ttu-id="8f65c-166">Очень неэффективная реализация метода `IsValidCurrency` показана в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="8f65c-166">A very inefficient implementation of the `IsValidCurrency` method is shown in the following example.</span></span> <span data-ttu-id="8f65c-167">Обратите внимание, что при каждом вызове метода заново создается объект <xref:System.Text.RegularExpressions.Regex> с одним и тем же шаблоном.</span><span class="sxs-lookup"><span data-stu-id="8f65c-167">Note that each method call reinstantiates a <xref:System.Text.RegularExpressions.Regex> object with the same pattern.</span></span> <span data-ttu-id="8f65c-168">А это значит, что шаблон регулярного выражения перекомпилируется при каждом вызове метода.</span><span class="sxs-lookup"><span data-stu-id="8f65c-168">This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static1.cs#3)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static1.vb#3)]

<span data-ttu-id="8f65c-169">Этот неэффективный код следует заменить вызовом статического метода <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-169">You should replace this inefficient code with a call to the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8f65c-170">Исчезнет необходимость заново создавать объект <xref:System.Text.RegularExpressions.Regex> при каждом вызове метода поиска совпадения с шаблоном, обработчик регулярных выражений сможет извлекать скомпилированную версию регулярного выражения из кэша.</span><span class="sxs-lookup"><span data-stu-id="8f65c-170">This eliminates the need to instantiate a <xref:System.Text.RegularExpressions.Regex> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/static2.cs#4)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/static2.vb#4)]

<span data-ttu-id="8f65c-171">По умолчанию кэшируется 15 последних использованных шаблонов статических регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-171">By default, the last 15 most recently used static regular expression patterns are cached.</span></span> <span data-ttu-id="8f65c-172">Для приложений, которым требуется большее число кэшированных статических регулярных выражений, размер кэша можно задать с помощью свойства <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-172">For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> property.</span></span>

<span data-ttu-id="8f65c-173">Регулярное выражение `\p{Sc}+\s*\d+`, используемое в этом примере, проверяет, что входная строка состоит из обозначения валюты и по меньшей мере одного десятичного знака.</span><span class="sxs-lookup"><span data-stu-id="8f65c-173">The regular expression `\p{Sc}+\s*\d+` that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit.</span></span> <span data-ttu-id="8f65c-174">Шаблон определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="8f65c-174">The pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="8f65c-175">Шаблон</span><span class="sxs-lookup"><span data-stu-id="8f65c-175">Pattern</span></span>|<span data-ttu-id="8f65c-176">Описание</span><span class="sxs-lookup"><span data-stu-id="8f65c-176">Description</span></span>|
|-------------|-----------------|
|`\p{Sc}+`|<span data-ttu-id="8f65c-177">Совпадение с одним или несколькими символами Unicode Symbol, Currency (символ валюты в Юникоде).</span><span class="sxs-lookup"><span data-stu-id="8f65c-177">Match one or more characters in the Unicode Symbol, Currency category.</span></span>|
|`\s*`|<span data-ttu-id="8f65c-178">Соответствует нулю или нескольким символам пробела.</span><span class="sxs-lookup"><span data-stu-id="8f65c-178">Match zero or more white-space characters.</span></span>|
|`\d+`|<span data-ttu-id="8f65c-179">Совпадение с одной или несколькими десятичными цифрами.</span><span class="sxs-lookup"><span data-stu-id="8f65c-179">Match one or more decimal digits.</span></span>|

### <a name="interpreted-vs-compiled-regular-expressions"></a><span data-ttu-id="8f65c-180">Интерпретированные и скомпилированные регулярные выражения</span><span class="sxs-lookup"><span data-stu-id="8f65c-180">Interpreted vs. compiled regular expressions</span></span>

<span data-ttu-id="8f65c-181">Шаблоны регулярных выражений, не привязанные к обработчику регулярных выражений указанием параметра <xref:System.Text.RegularExpressions.RegexOptions.Compiled>, интерпретируются.</span><span class="sxs-lookup"><span data-stu-id="8f65c-181">Regular expression patterns that are not bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are interpreted.</span></span> <span data-ttu-id="8f65c-182">При создании объекта регулярного выражения обработчик регулярных выражений преобразует регулярное выражение в набор кодов операций.</span><span class="sxs-lookup"><span data-stu-id="8f65c-182">When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes.</span></span> <span data-ttu-id="8f65c-183">При вызове метода экземпляра коды операций преобразуются в MSIL-код и выполняются JIT-компилятором.</span><span class="sxs-lookup"><span data-stu-id="8f65c-183">When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler.</span></span> <span data-ttu-id="8f65c-184">Аналогично, при вызове статического метода регулярного выражения, если не удается найти регулярное выражение в кэше, обработчик регулярных выражений преобразует регулярное выражение в набор кодов операций и хранит их в кэше.</span><span class="sxs-lookup"><span data-stu-id="8f65c-184">Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache.</span></span> <span data-ttu-id="8f65c-185">Затем эти коды операций преобразуются в MSIL-код, чтобы JIT-компилятор мог выполнить их.</span><span class="sxs-lookup"><span data-stu-id="8f65c-185">It then converts these operation codes to MSIL so that the JIT compiler can execute them.</span></span> <span data-ttu-id="8f65c-186">Интерпретированные регулярные выражения снижают время запуска ценой более медленного выполнения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-186">Interpreted regular expressions reduce startup time at the cost of slower execution time.</span></span> <span data-ttu-id="8f65c-187">Поэтому их лучше всего использовать, когда регулярное выражение используется с небольшим числом вызовов методов или если точное число вызовов методов регулярных выражений неизвестно, но предполагается, что оно будет небольшим.</span><span class="sxs-lookup"><span data-stu-id="8f65c-187">Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small.</span></span> <span data-ttu-id="8f65c-188">По мере увеличения числа вызовов методов выгоду по производительности от быстрого запуска перевешивает низкая скорость выполнения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-188">As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</span></span>

<span data-ttu-id="8f65c-189">Шаблоны регулярных выражений, привязанные к обработчику регулярных выражений указанием параметра <xref:System.Text.RegularExpressions.RegexOptions.Compiled>, компилируются.</span><span class="sxs-lookup"><span data-stu-id="8f65c-189">Regular expression patterns that are bound to the regular expression engine through the specification of the <xref:System.Text.RegularExpressions.RegexOptions.Compiled> option are compiled.</span></span> <span data-ttu-id="8f65c-190">Это значит, что при создании объекта регулярного выражения или при вызове статического метода регулярного выражения, если не удается найти регулярное выражение в кэше, обработчик регулярных выражений преобразует регулярное выражение в промежуточный набор кодов операций, который затем преобразуется в MSIL-код.</span><span class="sxs-lookup"><span data-stu-id="8f65c-190">This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL.</span></span> <span data-ttu-id="8f65c-191">Когда вызывается метод, JIT-компилятор выполняет MSIL-код.</span><span class="sxs-lookup"><span data-stu-id="8f65c-191">When a method is called, the JIT compiler executes the MSIL.</span></span> <span data-ttu-id="8f65c-192">В отличие от интерпретированных регулярных выражений, скомпилированные регулярные выражения увеличивают время запуска, но позволяют выполнять отдельные методы поиска совпадения с шаблоном быстрее.</span><span class="sxs-lookup"><span data-stu-id="8f65c-192">In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster.</span></span> <span data-ttu-id="8f65c-193">В результате выгода по производительности от скомпилированных регулярных выражений увеличивается пропорционально числу вызовов методов регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-193">As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</span></span>

<span data-ttu-id="8f65c-194">Подводя итог, мы рекомендуем использовать интерпретированные регулярные выражения, когда методы регулярного выражения с конкретным регулярным выражением вызываются относительно редко.</span><span class="sxs-lookup"><span data-stu-id="8f65c-194">To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently.</span></span> <span data-ttu-id="8f65c-195">Скомпилированные регулярные выражения следует использовать, когда методы регулярного выражения с конкретным регулярным выражением вызываются относительно часто.</span><span class="sxs-lookup"><span data-stu-id="8f65c-195">You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently.</span></span> <span data-ttu-id="8f65c-196">Точное пороговое значение, начиная с которого низкая скорость выполнения интерпретированных регулярных выражений перевешивает выгоду от быстрого запуска, или пороговое значение, при котором медленный запуск скомпилированных регулярных выражений перевешивает выгоду от быстрого выполнения, трудно указать.</span><span class="sxs-lookup"><span data-stu-id="8f65c-196">The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine.</span></span> <span data-ttu-id="8f65c-197">Оно зависит от нескольких факторов, в том числе от сложности регулярного выражения и конкретных обрабатываемых данных.</span><span class="sxs-lookup"><span data-stu-id="8f65c-197">It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes.</span></span> <span data-ttu-id="8f65c-198">Чтобы определить, что позволит добиться лучшей производительности — интерпретированные или скомпилированные регулярные выражения, — можно использовать класс <xref:System.Diagnostics.Stopwatch>, чтобы сравнить время выполнения в обоих случаях.</span><span class="sxs-lookup"><span data-stu-id="8f65c-198">To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <xref:System.Diagnostics.Stopwatch> class to compare their execution times.</span></span>

<span data-ttu-id="8f65c-199">В следующем примере сравнивается производительность скомпилированных и интерпретированных регулярных выражений при чтении первых десяти предложений, а также при чтении всех предложений текста книги *Финансист* Теодора Драйзера.</span><span class="sxs-lookup"><span data-stu-id="8f65c-199">The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's *The Financier*.</span></span> <span data-ttu-id="8f65c-200">Как показывает вывод примера, если требуется выполнить только 10 вызовов методов поиска совпадения, интерпретированное регулярное выражение дает более высокую производительность.</span><span class="sxs-lookup"><span data-stu-id="8f65c-200">As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression.</span></span> <span data-ttu-id="8f65c-201">Однако скомпилированное регулярное выражение обеспечивает более высокую производительность при большом числе вызовов (в данном случае 13 000).</span><span class="sxs-lookup"><span data-stu-id="8f65c-201">However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compare1.cs#5)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compare1.vb#5)]

<span data-ttu-id="8f65c-202">Используемый в примере шаблон регулярного выражения `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]` определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="8f65c-202">The regular expression pattern used in the example, `\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]`, is defined as shown in the following table.</span></span>

|<span data-ttu-id="8f65c-203">Шаблон</span><span class="sxs-lookup"><span data-stu-id="8f65c-203">Pattern</span></span>|<span data-ttu-id="8f65c-204">Описание</span><span class="sxs-lookup"><span data-stu-id="8f65c-204">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="8f65c-205">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="8f65c-205">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="8f65c-206">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="8f65c-206">Match one or more word characters.</span></span>|
|<code>(\r?\n)&#124;,?\s)</code>|<span data-ttu-id="8f65c-207">Соответствует нулю или одному возврату каретки и последующему символу новой строки; или нулю или одной запятой с последующим пробелом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-207">Match either zero or one carriage return followed by a newline character, or zero or one comma followed by a white-space character.</span></span>|
|<code>(\w+((\r?\n)&#124;,?\s))*</code>|<span data-ttu-id="8f65c-208">Совпадение с одним или несколькими символами слова, за которыми следует ноль или один возврат каретки и символ новой строки, или ноль или одна запятая с последующим пробелом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-208">Match zero or more occurrences of one or more word characters that are followed either by zero or one carriage return and a newline character, or by zero or one comma followed by a white-space character.</span></span>|
|`\w+`|<span data-ttu-id="8f65c-209">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="8f65c-209">Match one or more word characters.</span></span>|
|`[.?:;!]`|<span data-ttu-id="8f65c-210">Совпадение с точкой, вопросительным знаком, двоеточием, точкой с запятой или восклицательным знаком.</span><span class="sxs-lookup"><span data-stu-id="8f65c-210">Match a period, question mark, colon, semicolon, or exclamation point.</span></span>|

### <a name="regular-expressions-compiled-to-an-assembly"></a><span data-ttu-id="8f65c-211">Регулярные выражения: скомпилированные в сборку</span><span class="sxs-lookup"><span data-stu-id="8f65c-211">Regular expressions: Compiled to an assembly</span></span>

<span data-ttu-id="8f65c-212">Также .NET позволяет создать сборку, которая содержит скомпилированные регулярные выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-212">.NET also enables you to create an assembly that contains compiled regular expressions.</span></span> <span data-ttu-id="8f65c-213">Это позволяет переместить основные затраты на компиляцию регулярных выражений на время разработки (вместо времени выполнения).</span><span class="sxs-lookup"><span data-stu-id="8f65c-213">This moves the performance hit of regular expression compilation from run time to design time.</span></span> <span data-ttu-id="8f65c-214">Однако требуются дополнительные действия. Необходимо заранее определить регулярные выражения и скомпилировать их в сборку.</span><span class="sxs-lookup"><span data-stu-id="8f65c-214">However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly.</span></span> <span data-ttu-id="8f65c-215">Затем компилятор может сослаться на эту сборку при компиляции исходного кода, использующего регулярные выражения из сборки.</span><span class="sxs-lookup"><span data-stu-id="8f65c-215">The compiler can then reference this assembly when compiling source code that uses the assembly’s regular expressions.</span></span> <span data-ttu-id="8f65c-216">Каждое скомпилированное регулярное выражение в сборке представлено классом, унаследованным от <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-216">Each compiled regular expression in the assembly is represented by a class that derives from <xref:System.Text.RegularExpressions.Regex>.</span></span>

<span data-ttu-id="8f65c-217">Для компиляции регулярных выражений в сборку вызывается метод <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> и ему передается массив объектов <xref:System.Text.RegularExpressions.RegexCompilationInfo>, представляющих регулярные выражения, которые требуется скомпилировать, и объект <xref:System.Reflection.AssemblyName> с информацией о создаваемой сборке.</span><span class="sxs-lookup"><span data-stu-id="8f65c-217">To compile regular expressions to an assembly, you call the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29?displayProperty=nameWithType> method and pass it an array of <xref:System.Text.RegularExpressions.RegexCompilationInfo> objects that represent the regular expressions to be compiled, and an <xref:System.Reflection.AssemblyName> object that contains information about the assembly to be created.</span></span>

<span data-ttu-id="8f65c-218">Рекомендуется компилировать регулярные выражения в сборку в следующих случаях:</span><span class="sxs-lookup"><span data-stu-id="8f65c-218">We recommend that you compile regular expressions to an assembly in the following situations:</span></span>

- <span data-ttu-id="8f65c-219">Если вы являетесь разработчиком компонентов и вам требуется создать библиотеку регулярных выражений для повторного использования.</span><span class="sxs-lookup"><span data-stu-id="8f65c-219">If you are a component developer who wants to create a library of reusable regular expressions.</span></span>

- <span data-ttu-id="8f65c-220">Если вы предполагаете, что методы поиска совпадения с шаблоном вашего регулярного выражения будут вызываться неопределенное количество раз (от одного–двух раз до тысяч или десятков тысяч раз).</span><span class="sxs-lookup"><span data-stu-id="8f65c-220">If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times.</span></span> <span data-ttu-id="8f65c-221">В отличие от интерпретированных и скомпилированных регулярных выражений, регулярные выражения, скомпилированные в отдельные сборки, обеспечивают стабильную производительность, независимо от числа вызовов методов.</span><span class="sxs-lookup"><span data-stu-id="8f65c-221">Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</span></span>

<span data-ttu-id="8f65c-222">Если вы используете скомпилированные регулярные выражения для оптимизации производительности, не следует использовать отражение для создания сборки, загрузки обработчика регулярных выражений и выполнения его методов поиска совпадения с шаблоном.</span><span class="sxs-lookup"><span data-stu-id="8f65c-222">If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods.</span></span> <span data-ttu-id="8f65c-223">Следует избегать динамического построения шаблонов регулярных выражений. Кроме того, необходимо задать все параметры поиска совпадения с шаблоном (например, чувствительность к регистру) в момент создания сборки.</span><span class="sxs-lookup"><span data-stu-id="8f65c-223">This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created.</span></span> <span data-ttu-id="8f65c-224">Также необходимо отделить код, создающий сборку, от кода, использующего регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="8f65c-224">It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</span></span>

<span data-ttu-id="8f65c-225">В следующем примере показано, как создать сборку, содержащую скомпилированное регулярное выражение.</span><span class="sxs-lookup"><span data-stu-id="8f65c-225">The following example shows how to create an assembly that contains a compiled regular expression.</span></span> <span data-ttu-id="8f65c-226">В примере создается сборка с именем `RegexLib.dll` с одним классом регулярных выражений, `SentencePattern`, содержащим шаблон регулярного выражения для поиска предложений, который использовался в разделе [Интерпретированные и скомпилированные регулярные выражения](#interpreted-vs-compiled-regular-expressions).</span><span class="sxs-lookup"><span data-stu-id="8f65c-226">It creates an assembly named `RegexLib.dll` with a single regular expression class, `SentencePattern`, that contains the sentence-matching regular expression pattern used in the [Interpreted vs. Compiled Regular Expressions](#interpreted-vs-compiled-regular-expressions) section.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile1.cs#6)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile1.vb#6)]

<span data-ttu-id="8f65c-227">Когда код примера компилируется в исполняемый файл и выполняется, создается сборка с именем `RegexLib.dll`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-227">When the example is compiled to an executable and run, it creates an assembly named `RegexLib.dll`.</span></span> <span data-ttu-id="8f65c-228">Регулярное выражение представлено классом с именем `Utilities.RegularExpressions.SentencePattern`, унаследованным от <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-228">The regular expression is represented by a class named `Utilities.RegularExpressions.SentencePattern` that is derived from <xref:System.Text.RegularExpressions.Regex>.</span></span> <span data-ttu-id="8f65c-229">В следующем примере скомпилированное регулярное выражение используется для извлечения предложений из текста книги *Финансист* Теодора Драйзера.</span><span class="sxs-lookup"><span data-stu-id="8f65c-229">The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's *The Financier*.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/compile2.cs#7)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/compile2.vb#7)]

## <a name="take-charge-of-backtracking"></a><span data-ttu-id="8f65c-230">Грамотное использование поиска с возвратом</span><span class="sxs-lookup"><span data-stu-id="8f65c-230">Take charge of backtracking</span></span>

<span data-ttu-id="8f65c-231">Обычно обработчик регулярных выражений двигается по входной строке линейным образом, сравнивая ее с шаблоном регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-231">Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern.</span></span> <span data-ttu-id="8f65c-232">Однако когда в шаблоне регулярного выражения используются неопределенные квантификаторы, такие как `*`, `+` или `?`, обработчик регулярных выражений может отбрасывать частичное совпадение и возвращаться к ранее сохраненному состоянию, чтобы искать совпадение с шаблоном целиком.</span><span class="sxs-lookup"><span data-stu-id="8f65c-232">However, when indeterminate quantifiers such as `*`, `+`, and `?` are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern.</span></span> <span data-ttu-id="8f65c-233">Этот процесс известен как поиск с возвратом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-233">This process is known as backtracking.</span></span>

> [!NOTE]
> <span data-ttu-id="8f65c-234">Дополнительные сведения о поиске с возвратом см. в статьях [Подробные сведения о поведении регулярных выражений](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) и [Поиск с возвратом в регулярных выражениях](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="8f65c-234">For more information on backtracking, see [Details of Regular Expression Behavior](../../../docs/standard/base-types/details-of-regular-expression-behavior.md) and [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span> <span data-ttu-id="8f65c-235">Поиска с возвратом подробно рассматривается в записи блога [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking (Оптимизация производительности регулярных выражений, часть 2. Грамотное использование поиска с возвратом)](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) в блоге команды BCL.</span><span class="sxs-lookup"><span data-stu-id="8f65c-235">For a detailed discussion of backtracking, see [Optimizing Regular Expression Performance, Part II: Taking Charge of Backtracking](https://docs.microsoft.com/archive/blogs/bclteam/optimizing-regular-expression-performance-part-ii-taking-charge-of-backtracking-ron-petrusha) in the BCL Team blog.</span></span>

<span data-ttu-id="8f65c-236">Поддержка поиска с возвратом обеспечивает мощность и гибкость регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-236">Support for backtracking gives regular expressions power and flexibility.</span></span> <span data-ttu-id="8f65c-237">При этом ответственность за управление работой обработчика регулярных выражений лежит на разработчике регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-237">It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers.</span></span> <span data-ttu-id="8f65c-238">Поскольку разработчики часто не отдают себе отчет в этой ответственности, неправильное или излишнее использование поиска с возвратом часто становится причиной снижения производительности регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-238">Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance.</span></span> <span data-ttu-id="8f65c-239">В самом неблагоприятном случае время обработки может удваиваться при каждом добавлении символа во входную строку.</span><span class="sxs-lookup"><span data-stu-id="8f65c-239">In a worst-case scenario, execution time can double for each additional character in the input string.</span></span> <span data-ttu-id="8f65c-240">Чрезмерно используя поиск с возвратом, очень легко создать программный аналог бесконечной петли, если входные данные почти совпадают с шаблоном регулярного выражения. Обработчик регулярных выражений может в течение часов или даже дней обрабатывать относительно короткую входную строку.</span><span class="sxs-lookup"><span data-stu-id="8f65c-240">In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</span></span>

<span data-ttu-id="8f65c-241">Часто приложения имеют сниженную производительность из-за использования поиска с возвратом, хотя поиск с возвратом не очень важен для обнаружения совпадения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-241">Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match.</span></span> <span data-ttu-id="8f65c-242">Например, регулярное выражение `\b\p{Lu}\w*\b` совпадает со всеми словами, начинающимися с символа верхнего регистра, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="8f65c-242">For example, the regular expression `\b\p{Lu}\w*\b` matches all words that begin with an uppercase character, as the following table shows.</span></span>

|<span data-ttu-id="8f65c-243">Шаблон</span><span class="sxs-lookup"><span data-stu-id="8f65c-243">Pattern</span></span>|<span data-ttu-id="8f65c-244">Описание</span><span class="sxs-lookup"><span data-stu-id="8f65c-244">Description</span></span>|
|-|-|
|`\b`|<span data-ttu-id="8f65c-245">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="8f65c-245">Begin the match at a word boundary.</span></span>|
|`\p{Lu}`|<span data-ttu-id="8f65c-246">Совпадение с символом верхнего регистра.</span><span class="sxs-lookup"><span data-stu-id="8f65c-246">Match an uppercase character.</span></span>|
|`\w*`|<span data-ttu-id="8f65c-247">Совпадение с нулем или большим числом буквенных символов.</span><span class="sxs-lookup"><span data-stu-id="8f65c-247">Match zero or more word characters.</span></span>|
|`\b`|<span data-ttu-id="8f65c-248">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="8f65c-248">End the match at a word boundary.</span></span>|

<span data-ttu-id="8f65c-249">Поскольку граница слова не является символом слова (или подмножеством символов слова), нет шанса, что регулярное выражение перейдет границу слова, сопоставляя символы слова.</span><span class="sxs-lookup"><span data-stu-id="8f65c-249">Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters.</span></span> <span data-ttu-id="8f65c-250">Это значит, что для этого регулярного выражения поиск с возвратом не принесет никакой пользы, а только снизит производительность, поскольку обработчик регулярных выражений вынужден сохранять свое состояние для каждого возможного совпадения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-250">This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</span></span>

<span data-ttu-id="8f65c-251">Если вы понимаете, что нет необходимости использовать обратное отслеживание, его можно отключить с помощью языкового элемента `(?>subexpression)`, называемого атомарной группой.</span><span class="sxs-lookup"><span data-stu-id="8f65c-251">If you determine that backtracking is not necessary, you can disable it by using the `(?>subexpression)` language element, known as an atomic group.</span></span> <span data-ttu-id="8f65c-252">В следующем примере производится анализ входной строки с использованием двух регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-252">The following example parses an input string by using two regular expressions.</span></span> <span data-ttu-id="8f65c-253">Функционирование первого регулярного выражения, `\b\p{Lu}\w*\b`, основано на поиске с возвратом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-253">The first, `\b\p{Lu}\w*\b`, relies on backtracking.</span></span> <span data-ttu-id="8f65c-254">Второе регулярное выражение, `\b\p{Lu}(?>\w*)\b`, отключает поиск с возвратом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-254">The second, `\b\p{Lu}(?>\w*)\b`, disables backtracking.</span></span> <span data-ttu-id="8f65c-255">Как видно по выводу, выражения дают одинаковый результат.</span><span class="sxs-lookup"><span data-stu-id="8f65c-255">As the output from the example shows, they both produce the same result.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack2.cs#10)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack2.vb#10)]

<span data-ttu-id="8f65c-256">Часто поиск с возвратом очень важен для поиска во входной строке совпадения с шаблоном регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-256">In many cases, backtracking is essential for matching a regular expression pattern to input text.</span></span> <span data-ttu-id="8f65c-257">Тем не менее избыточное использование поиска с возвратом может сильно снизить производительность и создать впечатление, что приложение перестало отвечать.</span><span class="sxs-lookup"><span data-stu-id="8f65c-257">However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding.</span></span> <span data-ttu-id="8f65c-258">Например, так происходит, когда используются вложенные квантификаторы и текст, совпадающий со внешней частью выражения, является подмножеством текста, совпадающего со внутренней частью выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-258">In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</span></span>

> [!WARNING]
> <span data-ttu-id="8f65c-259">Помимо того, что следует избегать избыточного использования поиска с возвратом, необходимо использовать возможность времени ожидания, чтобы убедиться, что избыточный поиск с возвратом не слишком сильно снижает производительность регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-259">In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance.</span></span> <span data-ttu-id="8f65c-260">Дополнительные сведения см. в статье [Использование значений времени ожидания](#use-time-out-values).</span><span class="sxs-lookup"><span data-stu-id="8f65c-260">For more information, see the [Use Time-out Values](#use-time-out-values) section.</span></span>

<span data-ttu-id="8f65c-261">Например, шаблон регулярного выражения `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` должен искать номер части, состоящий из по крайней мере одного алфавитно-цифрового символа.</span><span class="sxs-lookup"><span data-stu-id="8f65c-261">For example, the regular expression pattern `^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$` is intended to match a part number that consists of at least one alphanumeric character.</span></span> <span data-ttu-id="8f65c-262">Дополнительные символы могут включать в себя алфавитно-цифровые символы, дефис, подчеркивание или точку, но последний символ должен быть алфавитно-цифровым.</span><span class="sxs-lookup"><span data-stu-id="8f65c-262">Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric.</span></span> <span data-ttu-id="8f65c-263">Знак доллара завершает номер части.</span><span class="sxs-lookup"><span data-stu-id="8f65c-263">A dollar sign terminates the part number.</span></span> <span data-ttu-id="8f65c-264">В некоторых случаях этот шаблон регулярного выражения может привести к очень низкой производительности, поскольку в нем используются вложенные квантификаторы и часть выражения `[0-9A-Z]` является подмножеством части выражения `[-.\w]*`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-264">In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression `[0-9A-Z]` is a subset of the subexpression `[-.\w]*`.</span></span>

<span data-ttu-id="8f65c-265">В таких случаях можно оптимизировать производительность, удалив вложенные квантификаторы и заменив внешнюю часть выражения утверждением просмотра вперед или назад нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="8f65c-265">In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion.</span></span> <span data-ttu-id="8f65c-266">Утверждения просмотра вперед и назад являются "якорями". Они не перемещают указатель во входной строке, а выполняют поиск впереди или позади, проверяя, выполняется ли заданное условие.</span><span class="sxs-lookup"><span data-stu-id="8f65c-266">Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met.</span></span> <span data-ttu-id="8f65c-267">Например, регулярное выражение для поиска номера части можно записать следующим образом: `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-267">For example, the part number regular expression can be rewritten as `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$`.</span></span> <span data-ttu-id="8f65c-268">Этот шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="8f65c-268">This regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="8f65c-269">Шаблон</span><span class="sxs-lookup"><span data-stu-id="8f65c-269">Pattern</span></span>|<span data-ttu-id="8f65c-270">Описание</span><span class="sxs-lookup"><span data-stu-id="8f65c-270">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="8f65c-271">Начало совпадения в начале входной строки.</span><span class="sxs-lookup"><span data-stu-id="8f65c-271">Begin the match at the beginning of the input string.</span></span>|
|`[0-9A-Z]`|<span data-ttu-id="8f65c-272">Совпадение с алфавитно-цифровым символом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-272">Match an alphanumeric character.</span></span> <span data-ttu-id="8f65c-273">Номер части должен состоять по меньшей мере из этого символа.</span><span class="sxs-lookup"><span data-stu-id="8f65c-273">The part number must consist of at least this character.</span></span>|
|`[-.\w]*`|<span data-ttu-id="8f65c-274">Совпадение с нулем или большим числом вхождений любого символа слова, дефиса или точки.</span><span class="sxs-lookup"><span data-stu-id="8f65c-274">Match zero or more occurrences of any word character, hyphen, or period.</span></span>|
|`\$`|<span data-ttu-id="8f65c-275">Совпадение со знаком доллара.</span><span class="sxs-lookup"><span data-stu-id="8f65c-275">Match a dollar sign.</span></span>|
|`(?<=[0-9A-Z])`|<span data-ttu-id="8f65c-276">Поиск за конечным знаком доллара с целью проверить, что предыдущий символ алфавитно-цифровой.</span><span class="sxs-lookup"><span data-stu-id="8f65c-276">Look ahead of the ending dollar sign to ensure that the previous character is alphanumeric.</span></span>|
|`$`|<span data-ttu-id="8f65c-277">Совпадение должно заканчиваться в конце входной строки.</span><span class="sxs-lookup"><span data-stu-id="8f65c-277">End the match at the end of the input string.</span></span>|

<span data-ttu-id="8f65c-278">В приведенном ниже примере демонстрируется использование этого регулярного выражения для поиска совпадений в массиве потенциальных номеров частей.</span><span class="sxs-lookup"><span data-stu-id="8f65c-278">The following example illustrates the use of this regular expression to match an array containing possible part numbers.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/backtrack4.cs#11)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/backtrack4.vb#11)]

<span data-ttu-id="8f65c-279">Язык регулярных выражений в .NET включает следующие языковые элементы, которые можно использовать для исключения вложенных квантификаторов.</span><span class="sxs-lookup"><span data-stu-id="8f65c-279">The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers.</span></span> <span data-ttu-id="8f65c-280">Для получения дополнительной информации см. [Конструкции группирования](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="8f65c-280">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

|<span data-ttu-id="8f65c-281">Элемент языка</span><span class="sxs-lookup"><span data-stu-id="8f65c-281">Language element</span></span>|<span data-ttu-id="8f65c-282">Описание</span><span class="sxs-lookup"><span data-stu-id="8f65c-282">Description</span></span>|
|----------------------|-----------------|
|<span data-ttu-id="8f65c-283">`(?=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="8f65c-283">`(?=` `subexpression` `)`</span></span>|<span data-ttu-id="8f65c-284">Положительный просмотр вперед нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="8f65c-284">Zero-width positive lookahead.</span></span> <span data-ttu-id="8f65c-285">Поиск за текущей позицией с целью проверить, совпадает ли параметр `subexpression` со входной строкой.</span><span class="sxs-lookup"><span data-stu-id="8f65c-285">Look ahead of the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="8f65c-286">`(?!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="8f65c-286">`(?!` `subexpression` `)`</span></span>|<span data-ttu-id="8f65c-287">Отрицательный просмотр вперед нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="8f65c-287">Zero-width negative lookahead.</span></span> <span data-ttu-id="8f65c-288">Поиск за текущей позицией с целью проверить, что параметр `subexpression` не совпадает со входной строкой.</span><span class="sxs-lookup"><span data-stu-id="8f65c-288">Look ahead of the current position to determine whether `subexpression` does not match the input string.</span></span>|
|<span data-ttu-id="8f65c-289">`(?<=` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="8f65c-289">`(?<=` `subexpression` `)`</span></span>|<span data-ttu-id="8f65c-290">Положительный просмотр назад нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="8f65c-290">Zero-width positive lookbehind.</span></span> <span data-ttu-id="8f65c-291">Поиск перед текущей позицией с целью проверить, совпадает ли параметр `subexpression` со входной строкой.</span><span class="sxs-lookup"><span data-stu-id="8f65c-291">Look behind the current position to determine whether `subexpression` matches the input string.</span></span>|
|<span data-ttu-id="8f65c-292">`(?<!` `subexpression` `)`</span><span class="sxs-lookup"><span data-stu-id="8f65c-292">`(?<!` `subexpression` `)`</span></span>|<span data-ttu-id="8f65c-293">Отрицательный просмотр назад нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="8f65c-293">Zero-width negative lookbehind.</span></span> <span data-ttu-id="8f65c-294">Поиск перед текущей позицией с целью проверить, что параметр `subexpression` не совпадает со входной строкой.</span><span class="sxs-lookup"><span data-stu-id="8f65c-294">Look behind the current position to determine whether `subexpression` does not match the input string.</span></span>|

## <a name="use-time-out-values"></a><span data-ttu-id="8f65c-295">Использование значений времени ожидания</span><span class="sxs-lookup"><span data-stu-id="8f65c-295">Use time-out values</span></span>

<span data-ttu-id="8f65c-296">Если регулярные выражения обрабатывают входные данные, которые почти совпадают с шаблоном регулярного выражения, зачастую они могут использовать избыточный поиск с возвратом, что сильно влияет на их производительность.</span><span class="sxs-lookup"><span data-stu-id="8f65c-296">If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly.</span></span> <span data-ttu-id="8f65c-297">Помимо того, что следует тщательно обдумывать использование поиска с возвратом и тестировать регулярное выражение на почти совпадающих входных данных, необходимо всегда устанавливать значение времени ожидания для минимизации влияния на производительность избыточного поиска с возвратом, если он все же используется.</span><span class="sxs-lookup"><span data-stu-id="8f65c-297">In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</span></span>

<span data-ttu-id="8f65c-298">Интервал времени ожидания регулярного выражения определяет период времени, в течение которого обработчик регулярных выражений выполняет поиск одного совпадения, после чего время ожидания истекает. По умолчанию интервал времени ожидания равен <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, что означает, что регулярное выражение имеет неограниченное время ожидания. Можно переопределить это значение и задать интервал времени ожидания следующим образом:</span><span class="sxs-lookup"><span data-stu-id="8f65c-298">The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</span></span>

- <span data-ttu-id="8f65c-299">предоставив значение времени ожидания при создании экземпляра объекта <xref:System.Text.RegularExpressions.Regex> путем вызова конструктора <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>;</span><span class="sxs-lookup"><span data-stu-id="8f65c-299">By providing a time-out value when you instantiate a <xref:System.Text.RegularExpressions.Regex> object by calling the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor.</span></span>

- <span data-ttu-id="8f65c-300">путем вызова статического метода поиска совпадения с шаблоном, такого как <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, который имеет параметр `matchTimeout`;</span><span class="sxs-lookup"><span data-stu-id="8f65c-300">By calling a static pattern matching method, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType>, that includes a `matchTimeout` parameter.</span></span>

- <span data-ttu-id="8f65c-301">для скомпилированных регулярных выражений, созданных путем вызова метода <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType>, — путем вызова конструктора, который имеет параметр типа <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-301">For compiled regular expressions that are created by calling the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, by calling the constructor that has a parameter of type <xref:System.TimeSpan>.</span></span>

<span data-ttu-id="8f65c-302">Если определен интервал времени ожидания и по истечении этого интервала совпадение не найдено, метод регулярного выражения вызывает исключение <xref:System.Text.RegularExpressions.RegexMatchTimeoutException>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-302">If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="8f65c-303">В обработчике исключений можно принять решение о том, повторить ли поиск совпадения с более длинным интервалом времени ожидания, отказаться от попытки поиска совпадения и предположить, что совпадение не найдено, или же отказаться от попытки поиска совпадения и зарегистрировать сведения об исключении в журнале для анализа в дальнейшем.</span><span class="sxs-lookup"><span data-stu-id="8f65c-303">In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</span></span>

<span data-ttu-id="8f65c-304">В следующем примере определяется метод `GetWordData`, который создает регулярное выражение с интервалом времени ожидания 350 миллисекунд, чтобы вычислить количество слов и среднее количество символов в слове в текстовом документе.</span><span class="sxs-lookup"><span data-stu-id="8f65c-304">The following example defines a `GetWordData` method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document.</span></span> <span data-ttu-id="8f65c-305">Если время ожидания для операции поиска совпадения истекает, интервал времени ожидания увеличивается на 350 миллисекунд и объект <xref:System.Text.RegularExpressions.Regex> создается заново.</span><span class="sxs-lookup"><span data-stu-id="8f65c-305">If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <xref:System.Text.RegularExpressions.Regex> object is re-instantiated.</span></span> <span data-ttu-id="8f65c-306">Если новый интервал времени ожидания превышает 1 секунду, метод передает исключение вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="8f65c-306">If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/timeout1.cs#12)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/timeout1.vb#12)]

## <a name="capture-only-when-necessary"></a><span data-ttu-id="8f65c-307">Захват только в случае необходимости</span><span class="sxs-lookup"><span data-stu-id="8f65c-307">Capture only when necessary</span></span>

<span data-ttu-id="8f65c-308">Регулярные выражения в .NET поддерживают ряд конструкций группирования, позволяющих группировать шаблон регулярного выражения в виде одной или более частей.</span><span class="sxs-lookup"><span data-stu-id="8f65c-308">Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions.</span></span> <span data-ttu-id="8f65c-309">Наиболее часто в языке регулярных выражений .NET используются конструкции группирования `(`*часть_выражения*`)`, которая определяет нумерованную группу записи, и `(?<`*имя*`>`*часть_выражения*`)`, которая определяет именованную группу записи.</span><span class="sxs-lookup"><span data-stu-id="8f65c-309">The most commonly used grouping constructs in .NET regular expression language are `(`*subexpression*`)`, which defines a numbered capturing group, and `(?<`*name*`>`*subexpression*`)`, which defines a named capturing group.</span></span> <span data-ttu-id="8f65c-310">Конструкции группирования крайне важны для создания обратных ссылок и для определения части выражения, к которой должен применяться квантификатор.</span><span class="sxs-lookup"><span data-stu-id="8f65c-310">Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</span></span>

<span data-ttu-id="8f65c-311">Однако использование этих языковых элементов имеет последствия.</span><span class="sxs-lookup"><span data-stu-id="8f65c-311">However, the use of these language elements has a cost.</span></span> <span data-ttu-id="8f65c-312">Объект <xref:System.Text.RegularExpressions.GroupCollection>, возвращаемый свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> заполняется наиболее новыми неименованными или именованными захваченными объектами, и если одна конструкция группирования захватила несколько подстрок из входной строки, они заполняют объект <xref:System.Text.RegularExpressions.CaptureCollection>, возвращаемый свойством <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> определенной группы захвата с несколькими объектами <xref:System.Text.RegularExpressions.Capture>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-312">They cause the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property of a particular capturing group with multiple <xref:System.Text.RegularExpressions.Capture> objects.</span></span>

<span data-ttu-id="8f65c-313">Часто конструкции группирования используются в регулярном выражении только для того, чтобы к нему можно было применить квантификаторы, и группы, захваченные этими частями выражения затем не используются.</span><span class="sxs-lookup"><span data-stu-id="8f65c-313">Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used.</span></span> <span data-ttu-id="8f65c-314">Например, регулярное выражение `\b(\w+[;,]?\s?)+[.?!]` предназначено для записи всего предложения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-314">For example, the regular expression `\b(\w+[;,]?\s?)+[.?!]` is designed to capture an entire sentence.</span></span> <span data-ttu-id="8f65c-315">В следующей таблице описаны языковые элементы этого шаблона регулярных выражений и их влияние на коллекции <xref:System.Text.RegularExpressions.Match> и <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> объекта <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-315">The following table describes the language elements in this regular expression pattern and their effect on the <xref:System.Text.RegularExpressions.Match> object's <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collections.</span></span>

|<span data-ttu-id="8f65c-316">Шаблон</span><span class="sxs-lookup"><span data-stu-id="8f65c-316">Pattern</span></span>|<span data-ttu-id="8f65c-317">Описание</span><span class="sxs-lookup"><span data-stu-id="8f65c-317">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="8f65c-318">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="8f65c-318">Begin the match at a word boundary.</span></span>|
|`\w+`|<span data-ttu-id="8f65c-319">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="8f65c-319">Match one or more word characters.</span></span>|
|`[;,]?`|<span data-ttu-id="8f65c-320">Совпадение с нулем или одной запятой или точкой с запятой.</span><span class="sxs-lookup"><span data-stu-id="8f65c-320">Match zero or one comma or semicolon.</span></span>|
|`\s?`|<span data-ttu-id="8f65c-321">Совпадение с нулем или одним символом пробела.</span><span class="sxs-lookup"><span data-stu-id="8f65c-321">Match zero or one white-space character.</span></span>|
|`(\w+[;,]?\s?)+`|<span data-ttu-id="8f65c-322">Совпадение с одним или большим числом символов слова; затем, необязательно, запятой или точкой с запятой; затем, необязательно, пробелом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-322">Match one or more occurrences of one or more word characters followed by an optional comma or semicolon followed by an optional white-space character.</span></span> <span data-ttu-id="8f65c-323">Здесь определена первая группа захвата, которая необходима, чтобы набор нескольких символов слова (то есть слово) и необязательно следующий за ним знак препинания повторялись, пока регулярное выражение не достигнет конца предложения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-323">This defines the first capturing group, which is necessary so that the combination of multiple word characters (that is, a word) followed by an optional punctuation symbol will be repeated until the regular expression engine reaches the end of a sentence.</span></span>|
|`[.?!]`|<span data-ttu-id="8f65c-324">Совпадение с точкой, вопросительным знаком или восклицательным знаком.</span><span class="sxs-lookup"><span data-stu-id="8f65c-324">Match a period, question mark, or exclamation point.</span></span>|

<span data-ttu-id="8f65c-325">Как показано в следующем примере, когда совпадение найдено, объекты <xref:System.Text.RegularExpressions.GroupCollection> и <xref:System.Text.RegularExpressions.CaptureCollection> заполняются захваченными объектами из совпадения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-325">As the following example shows, when a match is found, both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> objects are populated with captures from the match.</span></span> <span data-ttu-id="8f65c-326">В этом случае используется группа записи `(\w+[;,]?\s?)`, чтобы к ней можно было применить квантификатор `+`, который позволяет шаблону регулярного выражения сопоставить каждое слово в предложении.</span><span class="sxs-lookup"><span data-stu-id="8f65c-326">In this case, the capturing group `(\w+[;,]?\s?)` exists so that the `+` quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence.</span></span> <span data-ttu-id="8f65c-327">В противном случае было бы найдено совпадение только с последним словом предложения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-327">Otherwise, it would match the last word in a sentence.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group1.cs#8)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group1.vb#8)]

<span data-ttu-id="8f65c-328">Если части выражения используются только для применения к ним квантификаторов и захваченный текст не нужен, следует отменить захваты групп.</span><span class="sxs-lookup"><span data-stu-id="8f65c-328">When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures.</span></span> <span data-ttu-id="8f65c-329">Например, языковой элемент `(?:subexpression)` запрещает группе, к которой он применен, захватывать совпавшие подстроки.</span><span class="sxs-lookup"><span data-stu-id="8f65c-329">For example, the `(?:subexpression)` language element prevents the group to which it applies from capturing matched substrings.</span></span> <span data-ttu-id="8f65c-330">В следующем примере шаблон регулярного выражения из предыдущего примера изменен на `\b(?:\w+[;,]?\s?)+[.?!]`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-330">In the following example, the regular expression pattern from the previous example is changed to `\b(?:\w+[;,]?\s?)+[.?!]`.</span></span> <span data-ttu-id="8f65c-331">Как показывает вывод, обработчик регулярных выражений не заполняет коллекции <xref:System.Text.RegularExpressions.GroupCollection> и <xref:System.Text.RegularExpressions.CaptureCollection>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-331">As the output shows, it prevents the regular expression engine from populating the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collections.</span></span>

[!code-csharp[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/cs/group2.cs#9)]
[!code-vb[Conceptual.RegularExpressions.BestPractices#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.bestpractices/vb/group2.vb#9)]

<span data-ttu-id="8f65c-332">Отключить захват можно одним из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="8f65c-332">You can disable captures in one of the following ways:</span></span>

- <span data-ttu-id="8f65c-333">Используйте языковой элемент `(?:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-333">Use the `(?:subexpression)` language element.</span></span> <span data-ttu-id="8f65c-334">Этот элемент отключает захват совпавших подстрок в группе, к которой он применен.</span><span class="sxs-lookup"><span data-stu-id="8f65c-334">This element prevents the capture of matched substrings in the group to which it applies.</span></span> <span data-ttu-id="8f65c-335">Во вложенных группах захват подстрок не отключается.</span><span class="sxs-lookup"><span data-stu-id="8f65c-335">It does not disable substring captures in any nested groups.</span></span>

- <span data-ttu-id="8f65c-336">Использовать параметр <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-336">Use the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> option.</span></span> <span data-ttu-id="8f65c-337">Он отключает все неименованные и неявные захваты для шаблона регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-337">It disables all unnamed or implicit captures in the regular expression pattern.</span></span> <span data-ttu-id="8f65c-338">При использовании этого параметра захват выполняется только для тех подстрок, которые совпадают с именованными группами, определенными с помощью языкового элемента `(?<name>subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-338">When you use this option, only substrings that match named groups defined with the `(?<name>subexpression)` language element can be captured.</span></span> <span data-ttu-id="8f65c-339">Флажок <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> можно передать в параметр `options` конструктора класса <xref:System.Text.RegularExpressions.Regex> или в параметр `options` статического метода поиска совпадения <xref:System.Text.RegularExpressions.Regex>.</span><span class="sxs-lookup"><span data-stu-id="8f65c-339">The <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture> flag can be passed to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> static matching method.</span></span>

- <span data-ttu-id="8f65c-340">Использовать параметр `n` в языковом элементе `(?imnsx)`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-340">Use the `n` option in the `(?imnsx)` language element.</span></span> <span data-ttu-id="8f65c-341">Этот параметр отключает все неименованные или неявные захваты, начиная с того места, на котором находится этот элемент в шаблоне регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="8f65c-341">This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears.</span></span> <span data-ttu-id="8f65c-342">Захват отключается либо до конца шаблона, либо пока захват для неименованных и неявных объектов не будет включен параметром `(-n)`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-342">Captures are disabled either until the end of the pattern or until the `(-n)` option enables unnamed or implicit captures.</span></span> <span data-ttu-id="8f65c-343">Для получения дополнительной информации см. [Прочие конструкции](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="8f65c-343">For more information, see [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="8f65c-344">Использовать параметр `n` в языковом элементе `(?imnsx:subexpression)`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-344">Use the `n` option in the `(?imnsx:subexpression)` language element.</span></span> <span data-ttu-id="8f65c-345">Этот параметр отключает все неименованные и неявные захваты в части выражения `subexpression`.</span><span class="sxs-lookup"><span data-stu-id="8f65c-345">This option disables all unnamed or implicit captures in `subexpression`.</span></span> <span data-ttu-id="8f65c-346">Захваты для всех вложенных неименованных и неявных групп также отключаются.</span><span class="sxs-lookup"><span data-stu-id="8f65c-346">Captures by any unnamed or implicit nested capturing groups are disabled as well.</span></span>

## <a name="related-topics"></a><span data-ttu-id="8f65c-347">См. также</span><span class="sxs-lookup"><span data-stu-id="8f65c-347">Related topics</span></span>

|<span data-ttu-id="8f65c-348">Заголовок</span><span class="sxs-lookup"><span data-stu-id="8f65c-348">Title</span></span>|<span data-ttu-id="8f65c-349">Описание</span><span class="sxs-lookup"><span data-stu-id="8f65c-349">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="8f65c-350">Подробные сведения о поведении регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="8f65c-350">Details of Regular Expression Behavior</span></span>](../../../docs/standard/base-types/details-of-regular-expression-behavior.md)|<span data-ttu-id="8f65c-351">Описание реализации обработчика регулярных выражений в .NET.</span><span class="sxs-lookup"><span data-stu-id="8f65c-351">Examines the implementation of the regular expression engine in .NET.</span></span> <span data-ttu-id="8f65c-352">В этом разделе основное внимание уделено гибкости регулярных выражений; кроме того, рассказывается об ответственности разработчика за эффективную и надежную работу обработчика регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="8f65c-352">The topic focuses on the flexibility of regular expressions and explains the developer's responsibility for ensuring the efficient and robust operation of the regular expression engine.</span></span>|
|[<span data-ttu-id="8f65c-353">Поиск с возвратом</span><span class="sxs-lookup"><span data-stu-id="8f65c-353">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="8f65c-354">Описание поиска с возвратом и того, как он влияет на производительность регулярных выражений. Описание языковых элементов, которые можно использовать вместо поиска с возвратом.</span><span class="sxs-lookup"><span data-stu-id="8f65c-354">Explains what backtracking is and how it affects regular expression performance, and examines language elements that provide alternatives to backtracking.</span></span>|
|[<span data-ttu-id="8f65c-355">Элементы языка регулярных выражений — краткий справочник</span><span class="sxs-lookup"><span data-stu-id="8f65c-355">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="8f65c-356">Описание элементов языка регулярных выражений в .NET и ссылки на подробную документацию для каждого языкового элемента.</span><span class="sxs-lookup"><span data-stu-id="8f65c-356">Describes the elements of the regular expression language in .NET and provides links to detailed documentation for each language element.</span></span>|
