---
title: Конструкции группировки в регулярных выражениях
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
ms.openlocfilehash: 87cc3d53cf06457191d9c87020c4151e3f848c51
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77124329"
---
# <a name="grouping-constructs-in-regular-expressions"></a>Конструкции группировки в регулярных выражениях
Конструкции группирования отображают части выражений регулярных выражений и захватывают части строки входной строки. Конструкции группирования можно использовать в следующих целях.  
  
- Сопоставление с частью выражения, которая повторяется во входной строке.  
  
- Применение квантификатору к части выражения с несколькими языковыми элементами регулярных выражений. Дополнительные сведения о квантификаторах см. в разделе [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).  
  
- Добавление в строку части выражения, которая возвращается методами <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> и <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> .  
  
- Извлечение отдельных частей выражения из свойства <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> и обработка их по отдельности от всего текста.  
  
 В следующей таблице перечислены конструкции группирования, поддерживаемые механизмом регулярных выражений .NET, с указанием, выполняют ли они захват выражений.  
  
|Конструкция группирования|Захватываемая или незахватываемая|  
|------------------------|-------------------------------|  
|[Сопоставляемые части выражения](#matched_subexpression)|Захватываемая|  
|[Именованные сопоставленные части выражения](#named_matched_subexpression)|Захватываемая|  
|[Сбалансированные определения группы](#balancing_group_definition)|Захватываемая|  
|[Незахватываемые группы](#noncapturing_group)|Незахватываемая|  
|[Параметры группы](#group_options)|Незахватываемая|  
|[Утверждения положительного просмотра вперед нулевой ширины](#zerowidth_positive_lookahead_assertion)|Незахватываемая|  
|[Утверждения отрицательного просмотра вперед нулевой ширины](#zerowidth_negative_lookahead_assertion)|Незахватываемая|  
|[Утверждения положительного просмотра назад нулевой ширины](#zerowidth_positive_lookbehind_assertion)|Незахватываемая|  
|[Утверждения отрицательного просмотра назад нулевой ширины](#zerowidth_negative_lookbehind_assertion)|Незахватываемая|  
|[Атомарные группы](#atomic_groups)|Незахватываемая|  
  
 Сведения о группах и объектной модели регулярных выражений см. в разделе [Конструкции группирования и объекты регулярных выражений](#Objects).  
  
<a name="matched_subexpression"></a>   
## <a name="matched-subexpressions"></a>Сопоставляемые части выражения  
 Следующая конструкция группирования выделяет сопоставленную часть выражения:  
  
 `(` *subexpression* `)`  
  
 Где *часть выражения* — любой допустимый шаблон регулярного выражения. Выделения, использующие круглые скобки, нумеруются автоматически слева направо в зависимости от порядка открывающих скобок в регулярном выражении, начиная с 1. Выделение с нулевым номером — это текст, сопоставленный всем регулярным выражением.  
  
> [!NOTE]
> По умолчанию языковой элемент `(`*часть выражения*`)` выделяет сопоставленную часть выражения. Но если параметр <xref:System.Text.RegularExpressions.RegexOptions> метода сопоставления шаблона регулярного выражения содержит флаг <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> или к части выражения применен параметр `n` (см. [Параметры группы](#group_options) далее в этой статье), сопоставленная часть выражения не выделяется.  
  
 Доступ к захватываемым группам можно получить четырьмя способами:  
  
- Используя конструкцию обратной ссылки в регулярном выражении. Сопоставленная часть выражения указывается в том же регулярном выражении с помощью синтаксиса `\`*number*, где *number* — это порядковый номер выделенной части выражения.  
  
- Используя именованную конструкцию обратной ссылки в регулярном выражении. Сопоставленная часть выражения указывается в том же регулярном выражении с помощью синтаксиса `\k<`*name*`>`, где *name* — это имя захватываемой группы, или `\k<`*number*`>`, где *number* — это порядковый номер захватываемой группы. Имя захватываемой группы по умолчанию совпадает с ее порядковым номером. Дополнительные сведения см. в разделе [Именованные сопоставляемые части выражения](#named_matched_subexpression) далее в этой статье.  
  
- Используя последовательность замены `$`*number* в вызове метода <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> , где *number* — это порядковый номер выделенной части выражения.  
  
- Программным способом, используя объект <xref:System.Text.RegularExpressions.GroupCollection> , возвращаемый свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> . Член коллекции в нулевой позиции представляет все сопоставление регулярного выражения. Каждый последующий член представляет сопоставленную часть выражения. Дополнительные сведения см. в разделе [Grouping Constructs and Regular Expression Objects](#Objects) .  
  
 В следующем примере показано регулярное выражение, которое определяет повторяющиеся слова в тексте. Две захватываемые группы шаблона регулярного выражения представляют два экземпляра повторяющегося слова. Второй экземпляр выделяется для определения его начальной позиции во входной строке.  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
`(\w+)\s(\1)\W`  
  
 В следующей таблице показано, как интерпретируется шаблон регулярного выражения.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(\w+)`|Совпадение с одним или несколькими символами слова. Это первая группа записи.|  
|`\s`|Соответствует пробелу.|  
|`(\1)`|Сопоставление строки в первой захватываемой группе. Это вторая группа записи. Этот пример назначает ее захватываемой группе таким образом, что начальную позицию повторяющегося слова можно извлечь из свойства `Match.Index` .|  
|`\W`|Сопоставление несловообразующего символа, включая пробел и знак пунктуации. Это не позволяет шаблону регулярного выражения сопоставить слово, которое начинается со слова из первой захватываемой группы.|  
  
<a name="named_matched_subexpression"></a>   
## <a name="named-matched-subexpressions"></a>Именованные сопоставленные части выражения  
 Следующая конструкция группировки выделяет сопоставленную часть выражения и позволяет получить к ней доступ по имени или номеру:  
  
`(?<name>subexpression)`  
  
 или  
  
`(?'name'subexpression)`  
  
 Где *имя* — это допустимое имя группы, а *часть выражения* — любой допустимый шаблон регулярного выражения. Параметр*имя* не должен содержать знаки пунктуации и не может начинаться с цифры.  
  
> [!NOTE]
> Если параметр <xref:System.Text.RegularExpressions.RegexOptions> метода сопоставления шаблона регулярного выражения содержит флаг <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> или к части выражения применен параметр `n` (см. [Параметры группы](#group_options) далее в этой статье), выделить часть выражения можно только с помощью явного имени захватываемых групп.  
  
 Доступ к именованным захватываемым группам можно получить следующими способами:  
  
- Используя именованную конструкцию обратной ссылки в регулярном выражении. Сопоставленная часть выражения указывается в том же регулярном выражении с помощью синтаксиса `\k<`*name*`>`, где *name* — это имя захватываемой части выражения.  
  
- Используя конструкцию обратной ссылки в регулярном выражении. Сопоставленная часть выражения указывается в том же регулярном выражении с помощью синтаксиса `\`*number*, где *number* — это порядковый номер выделенной части выражения. Именованные сопоставленные части выражения нумеруются последовательно слева направо после сопоставленных частей выражения.  
  
- Используя последовательность замены `${`*name*`}` в вызове метода <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> , где *name* — это имя захватываемой части выражения.  
  
- Используя последовательность замены `$`*число* в вызове метода <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> или <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType>, где *число* обозначает порядковый номер захваченной части выражения.  
  
- Программным способом, используя объект <xref:System.Text.RegularExpressions.GroupCollection> , возвращаемый свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> . Член коллекции в нулевой позиции представляет все сопоставление регулярного выражения. Каждый последующий член представляет сопоставленную часть выражения. Именованные захватываемые группы хранятся в коллекции после нумерованных захватываемых групп.  
  
- Программно, передавая имя части выражения индексатору объекта <xref:System.Text.RegularExpressions.GroupCollection> (в C#) или свойству <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> (в Visual Basic).  
  
 В простом шаблоне регулярного выражения показано, как нумерованные (безымянные) и именованные группы можно указывать программно или с помощью языка регулярных выражений. Регулярное выражение `((?<One>abc)\d+)?(?<Two>xyz)(.*)` формирует следующие захватываемые группы по номеру и имени. Первая захватываемая группа (с номером 0) всегда указывает на весь шаблон.  
  
|number|name|Шаблон|  
|------------|----------|-------------|  
|0|0 (имя по умолчанию)|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|1|1 (имя по умолчанию)|`((?<One>abc)\d+)`|  
|2|2 (имя по умолчанию)|`(.*)`|  
|3|Один|`(?<One>abc)`|  
|4|Два|`(?<Two>xyz)`|  
  
 В следующем примере показано регулярное выражение, которое определяет повторяющиеся слова и слова, которые следуют за каждым повторяющимся словом. Шаблон регулярного выражения определяет две именованных части выражения: `duplicateWord`, которая представляет повторяющееся слово, и `nextWord`, которая представляет слово после повторяющегося слова.  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
`(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)`  
  
 В следующей таблице показано, как интерпретируется регулярное выражение.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|Совпадение с одним или несколькими символами слова. Установка для группы имени `duplicateWord`.|  
|`\s`|Соответствует пробелу.|  
|`\k<duplicateWord>`|Сопоставление строки из захватываемой группы с именем `duplicateWord`.|  
|`\W`|Сопоставление несловообразующего символа, включая пробел и знак пунктуации. Это не позволяет шаблону регулярного выражения сопоставить слово, которое начинается со слова из первой захватываемой группы.|  
|`(?<nextWord>\w+)`|Совпадение с одним или несколькими символами слова. Установка для группы имени `nextWord`.|  
  
 Обратите внимание на то, что имя группы может повторяться в регулярном выражении. Например, несколько групп могут называться `digit`, как показано в примере ниже. В случае повторяющихся имен значение объекта <xref:System.Text.RegularExpressions.Group> определяется последней успешной записью во входной строке. Кроме того, коллекция <xref:System.Text.RegularExpressions.CaptureCollection> заполняется сведениями о каждой записи так же, как и в случае, когда имя группы не повторяется.  
  
 В примере ниже регулярное выражение `\D+(?<digit>\d+)\D+(?<digit>\d+)?` включает два вхождения группы с именем `digit`. Первая группа с именем `digit` записывает одну или несколько цифр. Вторая группа с именем `digit` записывает нуль или одно вхождение одной или нескольких цифр. Как видно из выходных данных примера, если вторая захватывающая группа соответствует тексту, этот текст определяет значение объекта <xref:System.Text.RegularExpressions.Group> . Если вторая захватывающая группа не соответствует входной строке, значение последнего успешного сопоставления определяет значение объекта <xref:System.Text.RegularExpressions.Group> .  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 В следующей таблице показано, как интерпретируется регулярное выражение.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\D+`|Совпадение с одной или несколькими недесятичными цифрами.|  
|`(?<digit>\d+)`|Совпадение с одной или несколькими десятичными цифрами. Назначение соответствия для группы с именем `digit`.|  
|`\D+`|Совпадение с одной или несколькими недесятичными цифрами.|  
|`(?<digit>\d+)?`|Совпадение с нулем или одним вхождением одной или нескольких десятичных цифр. Назначение соответствия для группы с именем `digit` .|  
  
<a name="balancing_group_definition"></a>   
## <a name="balancing-group-definitions"></a>Сбалансированные определения группы  
 Сбалансированное определение группы удаляет определение ранее заданной группы и сохраняет в текущей группе интервал между предыдущей и текущей группами. Конструкция группировки использует следующий формат:  
  
`(?<name1-name2>subexpression)`  
  
 или  
  
`(?'name1-name2' subexpression)`
  
 Где *name1* — текущая группа (необязательный параметр), *name2* — ранее заданная группа, а *subexpression* — любой допустимый шаблон регулярного выражения. Это сбалансированное определение группы удаляет определение *name2* и сохраняет интервал между *name2* и *name1* в *name1*. Если группа *name2* не определена, для соответствия выполняется обратный поиск. Так как удаление последнего определения *name2* предоставляет доступ к предыдущему определению *name2*, эта конструкция позволяет использовать стек выделений для группы *name2* в качестве счетчика вложенный конструкций, например круглых скобок или открывающих и закрывающих квадратных скобок.  
  
 Сбалансированное определение группы использует в качестве стека *name2* . Начальный символ каждой вложенной конструкции размещается в группе и в коллекции <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> . При сопоставлении закрывающего символа соответствующий открывающий символ удаляется из группы, а коллекция <xref:System.Text.RegularExpressions.Group.Captures%2A> уменьшается на один элемент. После сопоставления открывающих и закрывающих символов всех вложенных конструкций, группа *name2* оказывается пустой.  
  
> [!NOTE]
> Если изменить регулярное выражение в следующем примере для использования соответствующего открывающего и закрывающего символа вложенной конструкции, вы сможете использовать его для обработки большинства вложенных конструкций, таких как математические выражения или строки программного кода, которые могут содержать множества вложенных вызовов методов.  
  
 В следующем примере сбалансированное определение группы используется для сопоставления левой и правой угловой скобки (<>) во входной строке. В примере определены две именованные группы, `Open` и `Close`, которые используются как стек для отслеживания соответствующих пар угловых скобок. Каждая выделенная левая угловая скобка помещается в коллекцию группы `Open` , а каждая выделенная правая угловая скобка помещается в коллекцию группы `Close` . Сбалансированное определение группы позволяет убедиться, что для каждой левой угловой скобки существует соответствующая правая угловая скобка. В противном случае последний подшаблон, `(?(Open)(?!))`, вычисляется, только если группа `Open` не пуста (следовательно, все вложенные конструкции не закрыты). Если последний подшаблон вычисляется, сопоставление вызывает ошибку, так как подшаблон `(?!)` является утверждением отрицательного поиска вперед нулевой ширины, которое всегда возвращает ошибку.  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 Шаблон регулярного выражения выглядит следующим образом:  
  
`^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$`  
  
 Регулярное выражение интерпретируется следующим образом:  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`^`|Начало с первого символа строки.|  
|`[^<>]*`|Сопоставление нуля или большего числа символов, которые не являются правой или левой угловой скобкой.|  
|`(?'Open'<)`|Сопоставление левой угловой скобки и ее назначение группе `Open`.|  
|`[^<>]*`|Сопоставление нуля или большего числа символов, которые не являются правой или левой угловой скобкой.|  
|`((?'Open'<)[^<>]*)+`|Сопоставление одного или нескольких вхождений левой угловой скобки, за которой следует ноль или больше символов, не являющихся левой или правой угловой скобкой. Это вторая группа записи.|  
|`(?'Close-Open'>)`|Сопоставление правой угловой скобки, назначение подстроки между группой `Open` и текущей группой группе `Close` и удаление определения группы `Open` .|  
|`[^<>]*`|Сопоставление нуля или большего числа вхождений любого символа, не являющегося левой или правой угловой скобкой.|  
|`((?'Close-Open'>)[^<>]*)+`|Сопоставление одного или нескольких вхождений правой угловой скобки, за которой следует ноль или больше символов, не являющихся левой или правой угловой скобкой. При сопоставлении правой угловой скобки подстрока между группой `Open` и текущей группой назначается группе `Close` , а определение группы `Open` удаляется. Это третья группа записи.|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|Сопоставление нуля или большего числа вхождений следующего шаблона: одно или несколько вхождений левой угловой скобки, за которой следуют ноль или большее число символов, отличных от угловых скобок, одно или несколько вхождений правой угловой скобки и ноль или большее число символов, отличных от угловых скобок. При сопоставлении правой угловой скобки определение группы `Open` удаляется, а подстрока между группой `Open` и текущей группой назначается группе `Close` . Это первая группа записи.|  
|`(?(Open)(?!))`|Если группа `Open` существует, поиск совпадения прекращается, если возможно сопоставление пустой строки, но позиция механизма регулярных выражений в строке не изменяется. Это утверждение отрицательного просмотра вперед нулевой ширины. Так как пустая строка всегда неявно присутствует во входной строке, это сопоставление всегда возвращает ошибку. Ошибка этого сопоставления указывает на то, что угловые скобки не сбалансированы.|  
|`$`|Соответствует концу входной строки.|  
  
 Последняя часть выражения, `(?(Open)(?!))`, указывает, правильно ли сбалансированы вложенные конструкции во входной строке (например, существует ли для каждой левой угловой скобки соответствующая правая угловая скобка). В ней используется условное сопоставление на основе действительной захватываемой группы. Дополнительные сведения см. в разделе [Конструкции изменения в регулярных выражениях](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md). Если группа `Open` определена, механизм регулярных выражений пытается сопоставить часть выражения `(?!)` во входной строке. Группа `Open` должна быть определена, только если вложенные конструкции не сбалансированы. Поэтому шаблон для сопоставления во входной строке должен всегда вызывать ошибку соответствия. В этом случае `(?!)` — это утверждение отрицательного просмотра вперед нулевой ширины, которое всегда вызывает ошибку, так как пустая строка всегда неявно присутствует в следующей позиции во входной строке.  
  
 В этом примере механизм регулярных выражений обрабатывает входную строку "\<abc><mno\<xyz>>" так, как показано в следующей таблице.  
  
|Шаг|Шаблон|Результат|  
|----------|-------------|------------|  
|1|`^`|Начало соответствия в начале входной строки.|  
|2|`[^<>]*`|Поиск символов, отличных от угловых скобок, до левой угловой скобки. Совпадения не найдены.|  
|3|`(((?'Open'<)`|Сопоставляет левую угловую скобку в строке "\<abc>" и присваивает ее группе `Open`.|  
|4|`[^<>]*`|Сопоставляется строка "abc".|  
|5|`)+`|"<abc" — это значение второй захватываемой группы.<br /><br /> Следующий символ во входной строке не является левой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `(?'Open'<)[^<>]*)` .|  
|6|`((?'Close-Open'>)`|Сопоставляет правую угловую скобку в "<abc\<" и назначает подстроку "abc", расположенную между группой `Open` и правой угловой скобкой, группе записи `Close`, а также удаляет текущее значение ("<") из группы записи `Open`, которая теперь становится пустой.|  
|7|`[^<>]*`|Поиск символов, отличных от угловых скобок, после правой угловой скобки. Совпадения не найдены.|  
|8|`)+`|Значение третьей захватываемой группы — ">".<br /><br /> Следующий символ во входной строке не является правой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `((?'Close-Open'>)[^<>]*)` .|  
|9|`)*`|Первой группе записи присвоено значение "\<abc>".<br /><br /> Следующий символ во входной строке является левой угловой скобкой, поэтому механизм регулярных выражений возвращается к подшаблону `(((?'Open'<)` .|  
|10|`(((?'Open'<)`|Сопоставляет левую угловую скобку в строке "\<mno" и назначает ее группе `Open`. Теперь ее коллекция <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> содержит один символ, "<".|  
|11|`[^<>]*`|Сопоставляется подстрока "mno".|  
|12|`)+`|"<mno" — это значение второй захватываемой группы.<br /><br /> Следующий символ во входной строке является левой угловой скобкой, поэтому механизм регулярных выражений возвращается к подшаблону `(?'Open'<)[^<>]*)` .|  
|13|`(((?'Open'<)`|Сопоставляет левую угловую скобку в строке "\<xyz>" и назначает ее группе `Open`. Коллекция <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> группы записи `Open` теперь содержит два захвата: левую угловую скобку из "\<mno" и левую угловую скобку из "\<xyz>".|  
|14|`[^<>]*`|Сопоставляется подстрока "xyz".|  
|15|`)+`|"<xyz" — это значение второй захватываемой группы.<br /><br /> Следующий символ во входной строке не является левой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `(?'Open'<)[^<>]*)` .|  
|16|`((?'Close-Open'>)`|Сопоставляет правую угловую скобку в строке "\<xyz>". "xyz" задает подстроку между группой `Open` и правой угловой скобкой группы `Close` и удаляет текущее значение группы `Open` . Значение предыдущего захвата (левая угловая скобка из "\<mno") становится текущим значением группы `Open`. Коллекция <xref:System.Text.RegularExpressions.Group.Captures%2A> группы `Open` теперь содержит один символ: левую угловую скобку из "\<xyz>".|  
|17|`[^<>]*`|Поиск символов, отличных от угловых скобок. Совпадения не найдены.|  
|18|`)+`|Значение третьей захватываемой группы — ">".<br /><br /> Следующий символ во входной строке является правой угловой скобкой, поэтому механизм регулярных выражений возвращается к подшаблону `((?'Close-Open'>)[^<>]*)` .|  
|19|`((?'Close-Open'>)`|Сопоставляет последнюю правую угловую скобку в "xyz>>" и назначает подстроку "mno\<xyz>", которая располагается между группой `Open` и правой угловой скобкой, группе `Close`, а также удаляет текущее значение группы `Open`. Теперь группа `Open` пуста.|  
|20|`[^<>]*`|Поиск символов, отличных от угловых скобок. Совпадения не найдены.|  
|21|`)+`|Значение третьей захватываемой группы — ">".<br /><br /> Следующий символ во входной строке не является правой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `((?'Close-Open'>)[^<>]*)` .|  
|22|`)*`|Присваивает первой группе записи значение "<mno\<xyz>>".<br /><br /> Следующий символ во входной строке не является левой угловой скобкой, поэтому механизм регулярных выражений не возвращается к подшаблону `(((?'Open'<)` .|  
|23|`(?(Open)(?!))`|Группа `Open` не определена, поиск соответствий не выполняется.|  
|24|`$`|Сопоставление конца входной строки.|  
  
<a name="noncapturing_group"></a>   
## <a name="noncapturing-groups"></a>Незахватываемые группы  
 Следующая конструкция группировки не захватывает подстроку, сопоставленную частью выражения:  
  
`(?:subexpression)`
  
 Где *часть выражения* — любой допустимый шаблон регулярного выражения. Незахватываемая конструкция группировки обычно используется, если к группе применяется квантификатор, но подстроки, выделенные группой, не представляют интереса.  
  
> [!NOTE]
> Если регулярное выражение содержит вложенные конструкции группировки, внешняя незахватываемая конструкция группировки не применяется к внутренним вложенным конструкциям группировки.  
  
 В следующем примере показано регулярное выражение, содержащее незахватываемые группы. Обратите внимание, что результат не содержит захватываемые группы.  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 Регулярное выражение `(?:\b(?:\w+)\W*)+\.` сопоставляет предложение, которое заканчивается точкой. Так как оно ищет предложения, а не отдельные слова, конструкции группировки используются только как квантификаторы. Возможные интерпретации шаблона регулярного выражения показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?:\w+)`|Совпадение с одним или несколькими символами слова. Сопоставленные текст не назначается захватываемой группе.|  
|`\W*`|Совпадение с нулем или большим числом несловообразующих символов.|  
|`(?:\b(?:\w+)\W*)+`|Совпадение шаблона с одним или несколькими словообразующими символами начиная с границы слова, за которыми следует ноль и более несловообразующих символов, один или более раз. Сопоставленные текст не назначается захватываемой группе.|  
|`\.`|Сопоставляется точка.|  
  
<a name="group_options"></a>   
## <a name="group-options"></a>Параметры группы  
 Следующая конструкция группировки применяет или отключает указанные параметры в части выражения:  
  
 `(?imnsx-imnsx:` *subexpression* `)`  
  
 Где *часть выражения* — любой допустимый шаблон регулярного выражения. Например, `(?i-s:)` отключает учет регистра и однострочный режим. Дополнительные сведения о доступных встроенных параметрах см. в разделе [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).  
  
> [!NOTE]
> Вы можете указать параметры, которые применяются ко всему регулярному выражению, а не его части, используя конструктор класса <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> или статичный метод. Также можно указать встроенные параметры, которые применяются после определенной точки в регулярном выражении с использованием языковой конструкции `(?imnsx-imnsx)` .  
  
 Конструкция параметров группы не является захватываемой группой. Это значит, что несмотря на то, что любая часть строки, захватываемая *частью выражения* , включается в соответствие, она не добавляется в захватываемую группу и не используется для заполнения объекта <xref:System.Text.RegularExpressions.GroupCollection> .  
  
 Например, регулярное выражение `\b(?ix: d \w+)\s` в следующем примере использует встроенные параметры в конструкции группировки, чтобы включить сопоставление без учета регистра и игнорировать пробелы при определении слов, начинающихся с буквы "d". Определение регулярного выражения показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?ix: d \w+)`|Выполняется сопоставление буквы "d", за которой следует один или более словообразующих символов без учета регистра, пробелы в шаблоне пропускаются.|  
|`\s`|Соответствует пробелу.|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>   
## <a name="zero-width-positive-lookahead-assertions"></a>Утверждения положительного просмотра вперед нулевой ширины  
 Следующая конструкция группировки определяет утверждение положительного просмотра вперед нулевой ширины:  
  
 `(?=` *subexpression* `)`  
  
 Где *часть выражения* — любой шаблон регулярного выражения. Для успешного сопоставления входная строка должна соответствовать шаблону регулярного выражения в *части выражения*, хотя сопоставленная подстрока не включается в результат сопоставления. Утверждение положительного просмотра вперед нулевой ширины не выполняет обратный поиск.  
  
 Обычно утверждение положительного просмотра вперед нулевой ширины находится в конце шаблона регулярного выражения. Оно определяет подстроку, которую необходимо найти в конце строки для сопоставления, но которая не включается в сопоставление. Это также полезно для предотвращения излишнего обратного поиска. Утверждение положительного просмотра вперед нулевой ширины можно использовать, чтобы определенная захватываемая группа начиналась с текста, соответствующего подмножеству шаблона, заданного для этой группы. Например, если захватываемая группа соответствует последовательным словообразующим символом, вы можете использовать утверждение положительного просмотра вперед нулевой ширины, чтобы указать, что первый символ должен быть прописной буквой.  
  
 Следующий пример использует утверждение положительного просмотра вперед нулевой ширины для сопоставления слова, которое идет перед глаголом "is" во входной строке.  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 Возможные интерпретации регулярного выражения `\b\w+(?=\sis\b)` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`(?=\sis\b)`|Определяется, следуют ли за словообразующими словами пробел и строка "is", которая оканчивается на границе слова. Если это так, совпадение успешно.|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>   
## <a name="zero-width-negative-lookahead-assertions"></a>Утверждения отрицательного просмотра вперед нулевой ширины  
 Следующая конструкция группировки определяет утверждение отрицательного просмотра вперед нулевой ширины:  
  
 `(?!` *subexpression* `)`  
  
 Где *часть выражения* — любой шаблон регулярного выражения. Для успешного сопоставления входная строка не должна соответствовать шаблону регулярного выражения в *части выражения*, хотя сопоставленная подстрока не включается в результат сопоставления.  
  
 Утверждение отрицательного просмотра вперед нулевой ширины обычно используется в начале или в конце регулярного выражения. В начале регулярного выражения оно может определить шаблон, для которого не должно быть совпадения, когда в начале регулярного выражения определен похожий, но более общий шаблон для сопоставления. В этом случае утверждение часто используется для ограничения обратного поиска. В конце регулярного выражения утверждение может определять часть выражения, которое не должно присутствовать в конце совпадения.  
  
 В следующем примере определяется регулярное выражение, использующее утверждение просмотра вперед нулевой ширины в начале регулярного выражения для сопоставления слов, которые не начинаются на "un".  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 Возможные интерпретации регулярного выражения `\b(?!un)\w+\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(?!un)`|Определяется, являются ли два следующих символа "un". Если это не так, сопоставление возможно.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 В следующем примере определяется регулярное выражение, использующее утверждение просмотра вперед нулевой ширины в конце регулярного выражения для сопоставления слов, которые не начинаются на знак пунктуации.  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 Возможные интерпретации регулярного выражения `\b\w+\b(?!\p{P})` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
|`\p{P})`|Если следующий символ — не знак пунктуации (например, точка или запятая), сопоставление выполняется успешно.|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>   
## <a name="zero-width-positive-lookbehind-assertions"></a>Утверждения положительного просмотра назад нулевой ширины  
 Следующая конструкция группировки определяет утверждение положительного просмотра назад нулевой ширины:  
  
 `(?<=` *subexpression* `)`  
  
 Где *часть выражения* — любой шаблон регулярного выражения. Для успешного сопоставления *часть выражения* должна содержаться во входной строке слева от текущей позиции, хотя `subexpression` не включается в результат. Утверждение положительного просмотра назад нулевой ширины не выполняет обратный поиск.  
  
 Утверждения положительного просмотра назад нулевой ширины обычно используются в начале регулярных выражений. Определяемый ими шаблон — это предварительное условие сопоставления, но не часть результата сопоставления.  
  
 Например, следующий пример сопоставляет две последних цифры года для 21-го века (т. е. сопоставляемой строке должны предшествовать цифры "20").  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 Возможные интерпретации шаблона регулярного выражения `(?<=\b20)\d{2}\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\d{2}`|Совпадение с двумя десятичными цифрами.|  
|`(?<=\b20)`|Сопоставление продолжается, если двум десятичным цифрам предшествуют десятичные цифры "20" на границе слова.|  
|`\b`|Совпадение должно заканчиваться на границе слова.|  
  
 Утверждения положительного просмотра назад нулевой ширины также используются для ограничения обратного поиска, если последний символ или символы в захватываемой группе должны быть подмножеством символов, соответствующих шаблону регулярного выражения. Например, если группа захватывает все последовательные словообразующие символы, вы можете использовать утверждение положительного просмотра назад нулевой ширины, чтобы указать, что последний символ должен быть буквой.  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>   
## <a name="zero-width-negative-lookbehind-assertions"></a>Утверждения отрицательного просмотра назад нулевой ширины  
 Следующая конструкция группировки определяет утверждение отрицательного просмотра назад нулевой ширины:  
  
 `(?<!` *subexpression* `)`  
  
 Где *часть выражения* — любой шаблон регулярного выражения. Для успешного сопоставления *часть выражения* не должна находиться во входной строке слева от текущей позиции. Однако любая подстрока, не соответствующая `subexpression` , не включается в результат сопоставления.  
  
 Утверждения отрицательного просмотра назад нулевой ширины обычно используются в начале регулярных выражений. Определяемый ими шаблон препятствует сопоставлению в последующей строке. Они также используются для ограничения обратного поиска, если последний символ или символы в захватываемой группе не должны соответствовать одному или нескольким символам, соответствующим шаблону регулярного выражения группы. Например, если группа захватывает все последовательные словообразующие символы, вы можете использовать утверждение положительного просмотра назад нулевой ширины, чтобы указать, что последний символ не должен быть символом подчеркивания (\_).  
  
 Следующий пример сопоставляет дату каждого дня буднего недели (т. е. не субботы или воскресенья).  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 Возможные интерпретации шаблона регулярного выражения `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` показаны в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`\w+`|Сопоставляется один или несколько словообразующих символов, за которыми следует пробел.|  
|`\d{1,2},`|Сопоставляется одна или две десятичные цифры, за которыми следует пробел и запятая.|  
|`\d{4}\b`|Сопоставляются 4 десятичные цифры, сопоставление прекращается на границе слова.|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|Если сопоставлению предшествуют строки, отличные от "Saturday" или "Sunday", за которыми следует пробел, сопоставление выполняется успешно.|  
  
<a name="atomic_groups"></a>   
## <a name="atomic-groups"></a>Атомарные группы  
 Следующая конструкция группировки представляет атомарную группу (в некоторых других обработчиках регулярных выражений называемую частью выражения без обратного отслеживания, атомарной частью выражения или однократной частью выражения):
  
 `(?>` *subexpression* `)`  
  
 Где *часть выражения* — любой шаблон регулярного выражения.  
  
 Обычно, если регулярное выражение содержит необязательный или альтернативный шаблон сопоставления, а сопоставление завершается неудачно, механизм регулярных выражений может разветвляться по разным направлениям для сопоставления входной строки с шаблоном. Если сопоставление не найдено в первой ветви, механизм регулярных выражений может вернуться к точке, где было найдено первое сопоставление и повторить попытку во второй ветви. Этот процесс может продолжаться, пока не будут обойдены все ветви.  
  
 Группа `(?>`*часть выражения*`)` отключает обратное отслеживание. Механизм регулярных выражений сопоставляет максимально возможное число символов во входной строке. Если дальнейшее сопоставление невозможно, обратный поиск для применения альтернативных шаблонов не выполняется. (Т. е. часть выражения сопоставляет только строки, которые могут быть сопоставлены только частью выражения, попытка сопоставить строку на основе этой и последующих частей выражения не осуществляется.)  
  
 Этот вариант рекомендуется, если вы знаете, что обратный поиск не даст результатов. Если запретить механизму регулярных выражений выполнять ненужные операции поиска, производительность станет выше.  
  
 В следующем примере показано, как атомарная группа изменяет результаты сопоставления шаблона. Возвращающееся регулярное выражение успешно сопоставляет ряд повторяющихся символов, за которыми следует один или более экземпляров того же символа на границе слова, а невозвращающееся регулярное выражение — нет.  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 Определение невозвращающегося регулярного выражения `(?>(\w)\1+).\b` показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`(\w)`|Сопоставляется один словообразующий символ, который назначается первой захватываемой группе.|  
|`\1+`|Значение первой захваченной подстроки сопоставляется один или несколько раз.|  
|`.`|Сопоставляется любой символ.|  
|`\b`|Сопоставление заканчивается на границе слова.|  
|`(?>(\w)\1+)`|Сопоставляется один или несколько экземпляров повторяющегося словообразующего слова, но обратный поиск для сопоставления последнего символа на границе слова не выполняется.|  
  
<a name="Objects"></a>   
## <a name="grouping-constructs-and-regular-expression-objects"></a>Конструкции группирования и объекты регулярных выражений  
 Подстроки, сопоставляемые захватываемой группой регулярного выражения, представлены объектами <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> , которые можно извлечь из объекта <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> , возвращаемого свойством <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> . Объект <xref:System.Text.RegularExpressions.GroupCollection> заполняется следующим образом:  
  
- Первый объект <xref:System.Text.RegularExpressions.Group> в коллекции (объект с нулевым индексом) представляет все сопоставление.  
  
- Следующий набор объектов <xref:System.Text.RegularExpressions.Group> представляет неименованные (нумерованные) захватываемые группы. Они указываются в том порядке, в котором они определены в регулярном выражении, слева направо. Значения индекса этих групп лежат в диапазоне от 1 до числа неименованных захватываемых групп в коллекции. (Индекс определенной группы эквивалентен нумерованной обратной ссылке. Дополнительные сведения об обратных ссылках см. в разделе [Конструкции обратных ссылок в регулярных выражениях](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)  
  
- Последний набор объектов <xref:System.Text.RegularExpressions.Group> представляет именованные захватываемые группы. Они указываются в том порядке, в котором они определены в регулярном выражении, слева направо. Значение индекса первой именованной захватываемой группы на единицу больше индекса, последней неименованной захватываемой группы. Если в регулярном выражении нет неименованных захватываемых групп, индекс первой именованной захватываемой группы равен единице.  
  
 Если к захватываемой группе применяется квантификатор, соответствующие свойства <xref:System.Text.RegularExpressions.Group> , <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>и <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>объекта <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> отражают последнюю подстроку, выделяемую захватываемой группой. Вы можете получить полный набор подстрок, выделяемые группами с квантификаторами, из объекта <xref:System.Text.RegularExpressions.CaptureCollection> , возвращаемого свойством <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> .  
  
 В следующем примере показана связь между объектами <xref:System.Text.RegularExpressions.Group> и <xref:System.Text.RegularExpressions.Capture> .  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 Шаблон регулярного выражения `(\b(\w+)\W+)+` извлекает отдельные слова из строки. Определяется, как показано в следующей таблице.  
  
|Шаблон|Описание|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(\w+)`|Совпадение с одним или несколькими символами слова. Вместе эти символы формируют слово. Это вторая группа записи.|  
|`\W+`|Совпадение с одним или большим числом несловообразующих символов.|  
|`(\b(\w+)\W+)`|Шаблон из одного или нескольких словообразующих символов, за которыми следует ноль или несколько словообразующих слов, выделяется один или несколько раз. Это первая группа записи.|  
  
 Вторая группа сопоставляет каждое слово предложения. Первая группа сопоставляет каждое слово вместе со знаками пунктуации и пробелом после слова. Объект <xref:System.Text.RegularExpressions.Group> с индексом 2 предоставляет сведения о тексте, сопоставленном второй группой. Полный набор слов, выделенных захватываемой группой, доступен в объекте <xref:System.Text.RegularExpressions.CaptureCollection> , который возвращается свойством <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> .  
  
## <a name="see-also"></a>См. также

- [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [Поиск с возвратом](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
