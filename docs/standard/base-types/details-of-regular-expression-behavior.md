---
title: Поведение регулярных выражений
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 504e315dda4e76f56a88d97149b1515b6743668b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "77124355"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="1c59f-102">Подробные сведения о поведении регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="1c59f-102">Details of regular expression behavior</span></span>

<span data-ttu-id="1c59f-103">Обработчик регулярных выражений .NET Framework выполняет поиск с возвратом для регулярных выражений и является реализацией традиционного механизма NFA (недетерминированного конечного автомата), аналогично тем, которые используются в Perl, Python, Emacs и Tcl.</span><span class="sxs-lookup"><span data-stu-id="1c59f-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="1c59f-104">Это отличает его от более быстрых, но и более ограниченных DFA-машин (детерминированный конечный автомат), предназначенных только для регулярных выражений и используемых в awk, egrep или lex.</span><span class="sxs-lookup"><span data-stu-id="1c59f-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="1c59f-105">Это также отличает его от типовых, но более медленных POSIX NFA-машин.</span><span class="sxs-lookup"><span data-stu-id="1c59f-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="1c59f-106">В следующем разделе представлено описание трех типов обработчиков регулярных выражений и объясняется причина реализации регулярных выражений на платформе .NET с помощью классического механизма NFA.</span><span class="sxs-lookup"><span data-stu-id="1c59f-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="1c59f-107">Преимущества NFA-машин</span><span class="sxs-lookup"><span data-stu-id="1c59f-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="1c59f-108">Когда DFA-машины выполняют сопоставление шаблонов, порядок обработки определяется входной строкой.</span><span class="sxs-lookup"><span data-stu-id="1c59f-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="1c59f-109">Машина начинает обработку с начала входной строки и продолжает последовательную обработку для определения соответствия следующего символа шаблону регулярного выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="1c59f-110">Их можно обнаружить как соответствия максимальной длины.</span><span class="sxs-lookup"><span data-stu-id="1c59f-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="1c59f-111">Так как DFA-машины не проверяют один и тот же знак дважды, они не поддерживают поиск с возвратом.</span><span class="sxs-lookup"><span data-stu-id="1c59f-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="1c59f-112">Но поскольку DFA-машина поддерживает только ограниченный режим работы, она не способна выполнять поиск соответствий по шаблону с обратными ссылками. Кроме того, она не создает явные выражения и не способна выделять части выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="1c59f-113">В отличие от DFA-машин обычные NFA-машины выполняют поиск соответствий по шаблонам, и порядок обработки определяется шаблоном регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="1c59f-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="1c59f-114">По мере обработки определенного элемента языка машина использует жадное сопоставление: она выполняет сопоставление как можно большей части входной строки.</span><span class="sxs-lookup"><span data-stu-id="1c59f-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="1c59f-115">И кроме того, она сохраняет свое состояние после успешного поиска соответствия части выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="1c59f-116">Если поиск соответствия в конечном счете завершился с ошибкой, машина может вернуться в сохраненное состояние, поэтому она может попытаться найти дополнительные соответствия.</span><span class="sxs-lookup"><span data-stu-id="1c59f-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="1c59f-117">Такой процесс, при котором успешно найденное соответствие части выражения "откладывается" для поиска соответствий с последующими языковыми элементами в регулярном выражении, называется *поиском с возвратом*.</span><span class="sxs-lookup"><span data-stu-id="1c59f-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="1c59f-118">NFA-машины используют поиск с возвратом, проверяя все возможные расширения регулярного выражения в определенном порядке и принимая первое соответствие.</span><span class="sxs-lookup"><span data-stu-id="1c59f-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="1c59f-119">Поскольку обычная NFA-машина создает определенное расширение регулярного выражения для успешного сопоставления, она способна находить соответствия для частей выражений и обратных ссылок.</span><span class="sxs-lookup"><span data-stu-id="1c59f-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="1c59f-120">Но так как обычная NFA-машина выполняет поиск с возвратом, она может анализировать одно и то же состояние несколько раз, если к нему ведут несколько разных путей.</span><span class="sxs-lookup"><span data-stu-id="1c59f-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="1c59f-121">В результате в наихудшем случае работа может замедляться по экспоненте.</span><span class="sxs-lookup"><span data-stu-id="1c59f-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="1c59f-122">Так как обычная NFA-машина принимает первое найденное соответствие, другие (возможно, более длинные) соответствия могут остаться необнаруженными.</span><span class="sxs-lookup"><span data-stu-id="1c59f-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="1c59f-123">POSIX NFA-машины похожи на обычные NFA-машины, за исключением того, что они продолжают поиск с возвратом до тех пор, пока не будет найдено наиболее длинное совпадение.</span><span class="sxs-lookup"><span data-stu-id="1c59f-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="1c59f-124">В результате POSIX NFA-машина работает медленнее обычной NFA-машины, и при использовании POSIX NFA-машины, изменив порядок поиска с возвратом, невозможно задать предпочтение короткому совпадению вместо более длинного.</span><span class="sxs-lookup"><span data-stu-id="1c59f-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="1c59f-125">Программисты предпочитают обычные NFA-машины, поскольку они превосходят по возможностям управления строковыми соответствиями обычные DFA-машины или POSIX NFA-машины.</span><span class="sxs-lookup"><span data-stu-id="1c59f-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="1c59f-126">Несмотря на то, что в наихудшем случае быстродействие NFA-машин снижается, ими можно управлять так, что поиск соответствий будет проходить по линейному или полиномиальному времени. Добиться этого можно с помощью шаблонов, уменьшающих неоднозначности и ограничивающих количество возвратов.</span><span class="sxs-lookup"><span data-stu-id="1c59f-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="1c59f-127">Другими словами, хотя NFA-машины отличаются характеризуются мощностью и гибкостью за счет производительности, в большинстве случаев они обеспечивают хорошую (или хотя бы приемлемую) производительность, если регулярное выражение грамотно составлено и позволяет избежать ситуаций, при которых производительность поиска с возвратом снижается экспоненциально.</span><span class="sxs-lookup"><span data-stu-id="1c59f-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="1c59f-128">Сведения о том, как чрезмерное использование поиска с возвратом влияет на производительность и как избегать его в регулярных выражениях, см. в статье [Поиск с возвратом в регулярных выражениях](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="1c59f-129">Возможности модуля .NET Framework</span><span class="sxs-lookup"><span data-stu-id="1c59f-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="1c59f-130">Чтобы использовать все сильные стороны классического механизма NFA, в обработчик регулярных выражений для платформы .NET включен полный набор конструкций, позволяющий программистам управлять процессом поиска с возвратом.</span><span class="sxs-lookup"><span data-stu-id="1c59f-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="1c59f-131">Эти структуры можно использовать для ускорения поиска или для выбора предпочтительных расширений.</span><span class="sxs-lookup"><span data-stu-id="1c59f-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="1c59f-132">Ниже представлены другие возможности обработчика регулярных выражений .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="1c59f-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="1c59f-133">Ленивые квантификаторы: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="1c59f-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="1c59f-134">В первую очередь они указывают обработчику на необходимость ведения поиска минимального числа повторений.</span><span class="sxs-lookup"><span data-stu-id="1c59f-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="1c59f-135">Обычные "жадные" квантификаторы, наоборот, пытаются сначала найти наибольшее число повторений.</span><span class="sxs-lookup"><span data-stu-id="1c59f-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="1c59f-136">В следующем примере кода демонстрируется различие между двумя квантификаторами.</span><span class="sxs-lookup"><span data-stu-id="1c59f-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="1c59f-137">Регулярное выражение соответствует предложению, оканчивающемуся на число, и захваченная группа должна извлечь это число.</span><span class="sxs-lookup"><span data-stu-id="1c59f-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="1c59f-138">Регулярное выражение `.+(\d+)\.` содержит жадный квантификатор `.+`, под влиянием которого обработчик регулярных выражений захватывает только последнюю цифру числа.</span><span class="sxs-lookup"><span data-stu-id="1c59f-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="1c59f-139">И наоборот, регулярное выражение `.+?(\d+)\.` содержит ленивый квантификатор `.+?`, под влиянием которого обработчик регулярных выражений захватывает все число.</span><span class="sxs-lookup"><span data-stu-id="1c59f-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="1c59f-140">Описания "жадной" и "ленивой" версий этого регулярного выражения представлены в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="1c59f-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="1c59f-141">Шаблон</span><span class="sxs-lookup"><span data-stu-id="1c59f-141">Pattern</span></span>|<span data-ttu-id="1c59f-142">Описание</span><span class="sxs-lookup"><span data-stu-id="1c59f-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="1c59f-143">`.+` ("жадный" квантификатор)</span><span class="sxs-lookup"><span data-stu-id="1c59f-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="1c59f-144">Соответствие как минимум одному вхождению любого символа.</span><span class="sxs-lookup"><span data-stu-id="1c59f-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="1c59f-145">Это дает обработчику регулярных выражений команду на сопоставление всей строки и выполнение поиска с возвратом, который требуется для сопоставления оставшейся части шаблона.</span><span class="sxs-lookup"><span data-stu-id="1c59f-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="1c59f-146">`.+?` ("ленивый" квантификатор)</span><span class="sxs-lookup"><span data-stu-id="1c59f-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="1c59f-147">Соответствие как минимум одному вхождению любого символа, но как можно меньшему количеству.</span><span class="sxs-lookup"><span data-stu-id="1c59f-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="1c59f-148">Соответствие как минимум одной цифре и назначение ее для первой захваченной группы.</span><span class="sxs-lookup"><span data-stu-id="1c59f-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="1c59f-149">Сопоставляется точка.</span><span class="sxs-lookup"><span data-stu-id="1c59f-149">Match a period.</span></span>|

     <span data-ttu-id="1c59f-150">Дополнительные сведения о ленивых квантификаторах см. в статье о [квантификаторах в регулярных выражениях](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="1c59f-151">Положительный поиск вперед: `(?=`*часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="1c59f-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="1c59f-152">Эта функция позволяет обработчику с поиском с возвратом возвращаться в начальное место в тексте после сопоставления части выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="1c59f-153">Эта функция полезна при осуществлении поиска с одной позиции с помощью нескольких шаблонов.</span><span class="sxs-lookup"><span data-stu-id="1c59f-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="1c59f-154">Она также позволяет обработчику проверять существование части строки в конце соответствия, не включая при этом часть строки в сопоставленный текст.</span><span class="sxs-lookup"><span data-stu-id="1c59f-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="1c59f-155">В следующем примере используется положительный поиск вперед для извлечения слов в предложении, после которых нет знаков препинания.</span><span class="sxs-lookup"><span data-stu-id="1c59f-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="1c59f-156">Определение регулярного выражения `\b[A-Z]+\b(?=\P{P})` показано в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="1c59f-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="1c59f-157">Шаблон</span><span class="sxs-lookup"><span data-stu-id="1c59f-157">Pattern</span></span>|<span data-ttu-id="1c59f-158">Описание</span><span class="sxs-lookup"><span data-stu-id="1c59f-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="1c59f-159">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="1c59f-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="1c59f-160">Совпадение с любым символом один или более раз.</span><span class="sxs-lookup"><span data-stu-id="1c59f-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="1c59f-161">Поскольку метод <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> вызывается с параметром <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, при сравнении не учитывается регистр символов.</span><span class="sxs-lookup"><span data-stu-id="1c59f-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="1c59f-162">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="1c59f-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="1c59f-163">Поиск для определения, является ли следующий символ знаком препинания.</span><span class="sxs-lookup"><span data-stu-id="1c59f-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="1c59f-164">Если не является, соответствие считается успешным.</span><span class="sxs-lookup"><span data-stu-id="1c59f-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="1c59f-165">Дополнительные сведения об утверждениях положительного поиска вперед см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="1c59f-166">Отрицательный поиск вперед: `(?!`*часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="1c59f-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="1c59f-167">Сопоставление выражения выполняется только в том случае, когда не было обнаружено соответствия части выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="1c59f-168">Это существенно упрощает поиск, поскольку часто бывает проще описать выражения, не соответствующие правилу, чем само правило.</span><span class="sxs-lookup"><span data-stu-id="1c59f-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="1c59f-169">Например, трудно написать выражение для поиска слов, которые не начинаются с "non".</span><span class="sxs-lookup"><span data-stu-id="1c59f-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="1c59f-170">В следующем примере для их исключения используется отрицательный поиск.</span><span class="sxs-lookup"><span data-stu-id="1c59f-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="1c59f-171">Шаблон регулярного выражения `\b(?!non)\w+\b` определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="1c59f-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="1c59f-172">Шаблон</span><span class="sxs-lookup"><span data-stu-id="1c59f-172">Pattern</span></span>|<span data-ttu-id="1c59f-173">Описание</span><span class="sxs-lookup"><span data-stu-id="1c59f-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="1c59f-174">Совпадение должно начинаться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="1c59f-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="1c59f-175">Поиск для определения, не начинается ли текущая строка с "non".</span><span class="sxs-lookup"><span data-stu-id="1c59f-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="1c59f-176">Если начинается, соответствие считается неудачным.</span><span class="sxs-lookup"><span data-stu-id="1c59f-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="1c59f-177">Совпадение с одним или несколькими символами слова.</span><span class="sxs-lookup"><span data-stu-id="1c59f-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="1c59f-178">Совпадение должно заканчиваться на границе слова.</span><span class="sxs-lookup"><span data-stu-id="1c59f-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="1c59f-179">Дополнительные сведения об утверждениях отрицательного поиска вперед см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="1c59f-180">Условная оценка: `(?(`*выражение*`)`*да*`|`*нет*`)` and `(?(`*имя*`)`*да*`|`*нет*`)`, где *выражение* — сопоставляемая часть выражения, *имя* — имя группы захвата, *да* — сопоставляемая строка, если *выражение* найдено в тексте или *имя* является допустимой непустой захваченной группой, а *нет* — сопоставляемая строка, если *выражение* не найдено или *имя* не является допустимой непустой захваченной группой.</span><span class="sxs-lookup"><span data-stu-id="1c59f-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="1c59f-181">Эта функция позволяет обработчику вести поиск с использованием нескольких альтернативных шаблонов в зависимости от результатов сопоставлений предыдущей части выражения или утверждения нулевой ширины.</span><span class="sxs-lookup"><span data-stu-id="1c59f-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="1c59f-182">Это более действенный вид обратной ссылки, позволяющий, например, искать соответствия части выражения в зависимости от соответствия предыдущей части выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="1c59f-183">Регулярное выражение в следующем примере соответствует абзацам, предназначенным для общего и внутреннего использования.</span><span class="sxs-lookup"><span data-stu-id="1c59f-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="1c59f-184">Абзацы, предназначенные только для внутреннего использования, начинаются с тега `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="1c59f-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="1c59f-185">Шаблон регулярного выражения `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` использует условную оценку для назначения содержимого абзацев, предназначенных для общего и внутреннего использования, для отдельных захваченных групп.</span><span class="sxs-lookup"><span data-stu-id="1c59f-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="1c59f-186">Поэтому эти абзацы можно обработать по-разному.</span><span class="sxs-lookup"><span data-stu-id="1c59f-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="1c59f-187">Шаблон регулярного выражения определяется, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="1c59f-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="1c59f-188">Шаблон</span><span class="sxs-lookup"><span data-stu-id="1c59f-188">Pattern</span></span>|<span data-ttu-id="1c59f-189">Описание</span><span class="sxs-lookup"><span data-stu-id="1c59f-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="1c59f-190">Начало совпадения в начале строки.</span><span class="sxs-lookup"><span data-stu-id="1c59f-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="1c59f-191">Соответствует вхождениям в количестве 0 или 1 строки `<PRIVATE>` за которым следует символ пробела.</span><span class="sxs-lookup"><span data-stu-id="1c59f-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="1c59f-192">Назначение соответствия для захваченной группы с именем `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="1c59f-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="1c59f-193">Если захваченная группа `Pvt` существует, сопоставление одного или нескольких вхождений одного или нескольких вхождений символов слов, за которыми следует 0 или 1 пунктуационный разделитель с последующим любым пробелом.</span><span class="sxs-lookup"><span data-stu-id="1c59f-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="1c59f-194">Назначение части строки первой захваченной группе.</span><span class="sxs-lookup"><span data-stu-id="1c59f-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="1c59f-195">Если захваченная группа `Pvt` не существует, сопоставление одного или нескольких вхождений одного или нескольких вхождений символов слов, за которыми следует 0 или 1 пунктуационный разделитель с последующим любым пробелом.</span><span class="sxs-lookup"><span data-stu-id="1c59f-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="1c59f-196">Назначение части строки третьей захваченной группе.</span><span class="sxs-lookup"><span data-stu-id="1c59f-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="1c59f-197">Соответствует концу строки.</span><span class="sxs-lookup"><span data-stu-id="1c59f-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="1c59f-198">Дополнительные сведения об условной оценке см. в статье [Конструкции изменения в регулярных выражениях](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="1c59f-199">Сбалансированные определения группы: `(?<`*имя1*`-`*имя2*`>` *часть_выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="1c59f-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="1c59f-200">Эта функция позволяет обработчику регулярных выражений отслеживать вложенные конструкции, такие как скобки или открывающие и закрывающие круглые скобки.</span><span class="sxs-lookup"><span data-stu-id="1c59f-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="1c59f-201">Пример см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="1c59f-202">Атомарные группы: `(?>`*часть выражения*`)`.</span><span class="sxs-lookup"><span data-stu-id="1c59f-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="1c59f-203">Эта функция обеспечивает для подвыражения верность только первого соответствия, как будто выражение запускалось независимо от содержащего его выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="1c59f-204">Без этой конструкции поиск в большом выражении с использованием поиска с возвратом может изменить поведение части выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="1c59f-205">Например, регулярное выражение `(a+)\w` соответствует одному или нескольким символам "a", а также символу слова, которое следует за последовательностью символов "a", и присваивает последовательность символов "a" первой группе захвата.</span><span class="sxs-lookup"><span data-stu-id="1c59f-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="1c59f-206">Но если последний символ входной строки также является "a", он соответствует элементу языка `\w` и не включается в захваченную группу.</span><span class="sxs-lookup"><span data-stu-id="1c59f-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="1c59f-207">Регулярное выражение `((?>a+))\w` препятствует такому поведению.</span><span class="sxs-lookup"><span data-stu-id="1c59f-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="1c59f-208">Поскольку все последовательные символы "a" имеют соответствия без поиска с возвратом, первая захваченная группа содержит все последовательные символы "a".</span><span class="sxs-lookup"><span data-stu-id="1c59f-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="1c59f-209">Если после символов "a" не следует ни один символ, отличный от "a", соответствие считается неудачным.</span><span class="sxs-lookup"><span data-stu-id="1c59f-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="1c59f-210">Дополнительные сведения об атомарных группах см. в статье [Конструкции группировки](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="1c59f-211">Поиск совпадений справа налево, для применения которого нужно передать параметр <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> в конструктор класса <xref:System.Text.RegularExpressions.Regex> или в статический метод сопоставления экземпляров.</span><span class="sxs-lookup"><span data-stu-id="1c59f-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="1c59f-212">Эта функция полезна при поиске справа налево вместо обычного поиска слева направо, а также бывает более эффективно начинать поиск с правой части шаблона, а не с левой.</span><span class="sxs-lookup"><span data-stu-id="1c59f-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="1c59f-213">Как показано в примере ниже, использование поиска соответствий справа налево может изменить поведение жадных квантификаторов.</span><span class="sxs-lookup"><span data-stu-id="1c59f-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="1c59f-214">В примере выполняется два поисковых запроса предложения, оканчивающегося на число.</span><span class="sxs-lookup"><span data-stu-id="1c59f-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="1c59f-215">При поиске слева направо с использованием жадного квантификатора `+` имеется соответствие одной из шести цифр в предложении, тогда как при поиске справа налево — всем шести цифрам.</span><span class="sxs-lookup"><span data-stu-id="1c59f-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="1c59f-216">Описание шаблона регулярного выражения см. в примере с ленивыми квантификаторами ранее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="1c59f-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="1c59f-217">Дополнительные сведения о поиске соответствий справа налево см. в разделе [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="1c59f-218">Положительный и отрицательный поиск назад: `(?<=`*часть_выражения*`)` для положительного поиска назад и `(?<!`*часть_выражения*`)` для отрицательного просмотра назад.</span><span class="sxs-lookup"><span data-stu-id="1c59f-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="1c59f-219">Эта функция аналогична поиску вперед, рассмотренному ранее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="1c59f-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="1c59f-220">Поскольку обработчик регулярных выражений позволяет выполнять поиск справа налево, к регулярным выражениям можно применять поиск назад без каких-либо ограничений.</span><span class="sxs-lookup"><span data-stu-id="1c59f-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="1c59f-221">С помощью положительного и отрицательного поиска назад также можно избегать вложенных квантификаторов, когда вложенная часть выражения является супермножеством внешнего выражения.</span><span class="sxs-lookup"><span data-stu-id="1c59f-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="1c59f-222">Регулярные выражения с такими вложенными квантификаторами часто являются причиной низкой производительности.</span><span class="sxs-lookup"><span data-stu-id="1c59f-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="1c59f-223">В следующем примере выполняется проверка, начинается ли и оканчивается ли строка с буквы или цифры, а также является ли любой другой символ в строке символом большего подмножества.</span><span class="sxs-lookup"><span data-stu-id="1c59f-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="1c59f-224">В результате формируется часть регулярного выражения для проверки адресов электронной почты. Дополнительные сведения см. в статье [Руководство. Проверка строк на соответствие формату электронной почты](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="1c59f-225">Определение регулярного выражения ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` показано в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="1c59f-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="1c59f-226">Шаблон</span><span class="sxs-lookup"><span data-stu-id="1c59f-226">Pattern</span></span>|<span data-ttu-id="1c59f-227">Описание</span><span class="sxs-lookup"><span data-stu-id="1c59f-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="1c59f-228">Начало совпадения в начале строки.</span><span class="sxs-lookup"><span data-stu-id="1c59f-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="1c59f-229">Соответствие любому алфавитно-цифровому символу.</span><span class="sxs-lookup"><span data-stu-id="1c59f-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="1c59f-230">(При сравнении регистр не учитывается.)</span><span class="sxs-lookup"><span data-stu-id="1c59f-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="1c59f-231">Соответствие нулю или нескольким вхождениям любого символа слова или любого символа из следующего набора: -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124; или ~.</span><span class="sxs-lookup"><span data-stu-id="1c59f-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="1c59f-232">Поиск назад предыдущего символа, который должен являться числом или буквенно-цифровым символом.</span><span class="sxs-lookup"><span data-stu-id="1c59f-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="1c59f-233">(При сравнении регистр не учитывается.)</span><span class="sxs-lookup"><span data-stu-id="1c59f-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="1c59f-234">Совпадение должно заканчиваться в конце строки.</span><span class="sxs-lookup"><span data-stu-id="1c59f-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="1c59f-235">Дополнительные сведения о положительном и отрицательном поиске назад см. в статье [Конструкции группировки в регулярных выражениях](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1c59f-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="1c59f-236">Связанные статьи</span><span class="sxs-lookup"><span data-stu-id="1c59f-236">Related articles</span></span>

|<span data-ttu-id="1c59f-237">Заголовок</span><span class="sxs-lookup"><span data-stu-id="1c59f-237">Title</span></span>|<span data-ttu-id="1c59f-238">Описание</span><span class="sxs-lookup"><span data-stu-id="1c59f-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="1c59f-239">Поиск с возвратом</span><span class="sxs-lookup"><span data-stu-id="1c59f-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="1c59f-240">Сведения об использовании поиска с возвратом для поиска альтернативных соответствий.</span><span class="sxs-lookup"><span data-stu-id="1c59f-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="1c59f-241">Компиляция и многократное использование</span><span class="sxs-lookup"><span data-stu-id="1c59f-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="1c59f-242">Сведения о компиляции и многократном использовании регулярных выражений для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="1c59f-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="1c59f-243">Потокобезопасность</span><span class="sxs-lookup"><span data-stu-id="1c59f-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="1c59f-244">Сведения о потокобезопасности регулярных выражений и времени синхронизации доступа к объектам регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="1c59f-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="1c59f-245">Регулярные выражения в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="1c59f-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="1c59f-246">Общие сведения о регулярных выражениях в контексте языка программирования.</span><span class="sxs-lookup"><span data-stu-id="1c59f-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="1c59f-247">Объектная модель регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="1c59f-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="1c59f-248">Сведения об использовании классов регулярных выражений и примеры кода.</span><span class="sxs-lookup"><span data-stu-id="1c59f-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="1c59f-249">Примеры регулярных выражений</span><span class="sxs-lookup"><span data-stu-id="1c59f-249">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="1c59f-250">Примеры кодов, иллюстрирующих использование регулярных выражений в обычных приложениях.</span><span class="sxs-lookup"><span data-stu-id="1c59f-250">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|
|[<span data-ttu-id="1c59f-251">Элементы языка регулярных выражений — краткий справочник</span><span class="sxs-lookup"><span data-stu-id="1c59f-251">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="1c59f-252">Сведения о наборе символов, операторов и конструкций, которые можно использовать для определения регулярных выражений.</span><span class="sxs-lookup"><span data-stu-id="1c59f-252">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="1c59f-253">Справочник</span><span class="sxs-lookup"><span data-stu-id="1c59f-253">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
