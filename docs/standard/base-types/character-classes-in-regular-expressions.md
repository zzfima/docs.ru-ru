---
title: Классы символов в регулярных выражениях .NET
description: Сведения об использовании классов символов для представления набора символов в регулярных выражениях .NET.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- character classes
- regular expressions, character classes
- characters, matching syntax
- .NET Framework regular expressions, character classes
ms.assetid: 0f8bffab-ee0d-4e0e-9a96-2b4a252bb7e4
ms.custom: seodec18
ms.openlocfilehash: dbfa61077cbfdd7da104dc12f304a4096b3c032d
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73120615"
---
# <a name="character-classes-in-regular-expressions"></a>Классы символов в регулярных выражениях

Класс символов определяет набор символов, любой из которых может присутствовать во входной строке для успешного сопоставления. Язык регулярных выражений в .NET поддерживает следующие классы символов:  
  
- Положительные группы символов. Входная строка должна содержать символ из указанного набора. Дополнительные сведения см. в разделе [Положительная группа символов](#PositiveGroup).  
  
- Отрицательные группы символов. Входная строка не должна содержать символ из указанного набора. Дополнительные сведения см. в разделе [Отрицательная группа символов](#NegativeGroup).  
  
- Любой символ. Символ `.` (точка) в регулярных выражениях является подстановочным знаком, который соответствует всем символам, кроме `\n`. Дополнительные сведения см. в разделе [Любой символ](#AnyCharacter).  
  
- Общая категория Юникода или именованный блок. Входная строка должна содержать символ из определенной категории Юникода или непрерывного диапазона символов Юникода. Дополнительные сведения см. в разделе [Категория Юникода или блок Юникода](#CategoryOrBlock).  
  
- Отрицательная общая категория Юникода или именованный блок. Входная строка не должна содержать символ из определенной категории Юникода или непрерывного диапазона символов Юникода. Дополнительные сведения см. в разделе [Отрицательная категория Юникода или блок Юникода](#NegativeCategoryOrBlock).  
  
- Словообразующий символ. Входная строка может содержать символ, относящийся к любой категории Юникода, соответствующей символам в словах. Дополнительные сведения см. в разделе [Словообразующий символ](#WordCharacter).  
  
- Несловообразующий символ. Входная строка может содержать символ, относящийся к любой категории Юникода, не соответствующей словообразующим символам. Дополнительные сведения см. в разделе [Несловообразующий символ](#NonWordCharacter).  
  
- Символ пробела. Входная строка может содержать любой разделитель Юникода, а также любой из множества управляющих символов. Дополнительные сведения см. в разделе [Символ пробела](#WhitespaceCharacter).  
  
- Символ, не являющийся пробелом. Входная строка может содержать любой символ, кроме пробела. Дополнительные сведения см. в разделе [Символ, не являющийся пробелом](#NonWhitespaceCharacter).  
  
- Десятичная цифра. Входная строка может содержать любой набор знаков, классифицируемых как десятичные цифры Юникода. Дополнительные сведения см. в разделе [Десятичная цифра](#DigitCharacter).  
  
- Недесятичная цифра. Входная строка может содержать любой символ, кроме десятичных цифр Юникода. Дополнительные сведения см. в разделе [Десятичная цифра](#NonDigitCharacter).  
  
 Платформа .NET поддерживает выражения вычитания в классах знаков, которые позволяют в результате исключения одного класса знаков из другого класса знаков определить набор знаков. Дополнительные сведения см. в разделе [Вычитание класса знаков](#CharacterClassSubtraction).  
  
> [!NOTE]
> Классы символов, которые сопоставляют символы по категориям, например [\w](#WordCharacter), для соответствия символов слов или [\p{}](#CategoryOrBlock) для соответствия категории Юникод, используют класс <xref:System.Globalization.CharUnicodeInfo> для получения сведений о категориях символов.  Начиная с .NET Framework 4.6.2 категории символов основаны на [Стандарте Юникода, версия 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). В версиях .NET Framework с 4 по 4.6.1 они основаны на [Стандарте Юникода, версия 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
<a name="PositiveGroup"></a>   
## <a name="positive-character-group--"></a>Положительная группа символов: [ ]  
 Положительная группа символов задает список символов, один из которых должен присутствовать во входной строке для успешного сопоставления. Символы можно задать по отдельности или в виде диапазона.  
  
 Синтаксис для указания списка отдельных символов выглядит следующим образом:  

`[*character_group*]`

 Здесь *character_group* — это список отдельных символов, которые могут присутствовать во входной строке для успешного сопоставления. *character_group* может включать в себя любое сочетание литеральных символов, [escape-символов](../../../docs/standard/base-types/character-escapes-in-regular-expressions.md) или классов символов.  
  
 Синтаксис для указания диапазона символов выглядит следующим образом:  
  
`[firstCharacter-lastCharacter]`  
  
 Здесь *firstCharacter* — это символ, с которого начинается диапазон, а *lastCharacter* — символ, которым он заканчивается. Диапазон символов — это непрерывная последовательность знаков, которая задается указанием первого и последнего знака в последовательности и дефиса между ними. Два знака являются смежными, если они имеют соседние кодовые точки в Юникоде. *firstCharacter* должен быть символом с самой нижней кодовой точкой, а *lastCharacter* должен быть символом с самой высокой кодовой точкой.

> [!NOTE]
> Так как группа положительных символов может включать набор символов и диапазон символов, дефис (`-`) всегда интерпретируется как разделитель диапазонов, если только он не является первым или последним символом группы.

В следующей таблице перечислены некоторые распространенные шаблоны регулярных выражений, содержащие классы положительных символов.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`[aeiou]`|Соответствует всем гласным.|  
|`[\p{P}\d]`|Соответствует всем знакам препинания и десятичным цифрам.|  
|`[\s\p{P}]`|Соответствует всем символам пробела и знакам препинания.|  
  
 В следующем примере определена положительная группа знаков, которая содержит символы "a" и "e", таким образом, чтобы входная строка содержала слова grey или gray и еще одно слово.  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/positivecharclasses.cs#1)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/positivecharclasses.vb#1)]  
  
 Регулярное выражение `gr[ae]y\s\S+?[\s|\p{P}]` определяется следующим образом:  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`gr`|Соответствует буквенным символам "gr".|  
|`[ae]`|Соответствует букве "a" или "e".|  
|`y\s`|Соответствует буквенному символу "y", за которым следует пробел.|  
|`\S+?`|Соответствует одному или нескольким символам, отличным от пробела.|  
|`[\s\p{P}]`|Соответствует символу пробела или знаку препинания.|  
  
 В следующем примере выделяются слова, начинающиеся с любой прописной буквы. Вложенное выражение `[A-Z]` представляет диапазон прописных букв от A до Z.  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/range.cs#3)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/range.vb#3)]  
  
 Определение регулярного выражения `\b[A-Z]\w*\b` показано в таблице ниже.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`[A-Z]`|Соответствует любому символу верхнего регистра от А до Z.|  
|`\w*`|Совпадение с нулем или большим числом буквенных символов.|  
|`\b`|Соответствует границе слова.|  
  
<a name="NegativeGroup"></a>   
## <a name="negative-character-group-"></a>Отрицательная группа символов: [^]  
 Отрицательная группа символов задает список символов, которые не должны присутствовать во входной строке для успешного сопоставления. Символы можно задать по отдельности или в виде диапазона.  
  
Синтаксис для указания списка отдельных символов выглядит следующим образом:  

`[*^character_group*]`

 Здесь *character_group* — это список отдельных символов, которые не могут присутствовать во входной строке для успешного сопоставления. *character_group* может включать в себя любое сочетание литеральных символов, [escape-символов](../../../docs/standard/base-types/character-escapes-in-regular-expressions.md) или классов символов.  
  
 Синтаксис для указания диапазона символов выглядит следующим образом:  

`[^*firstCharacter*-*lastCharacter*]`

Здесь *firstCharacter* — это символ, с которого начинается диапазон, а *lastCharacter* — символ, которым он заканчивается. Диапазон символов — это непрерывная последовательность знаков, которая задается указанием первого и последнего знака в последовательности и дефиса между ними. Два знака являются смежными, если они имеют соседние кодовые точки в Юникоде. *firstCharacter* должен быть символом с самой нижней кодовой точкой, а *lastCharacter* должен быть символом с самой высокой кодовой точкой.

> [!NOTE]
> Так как группа отрицательных символов может включать набор символов и диапазон символов, дефис (`-`) всегда интерпретируется как разделитель диапазонов, если только он не является первым или последним символом группы.
  
 Два или более диапазона знаков могут быть объединены. Например, чтобы задать диапазон десятичных цифр от "0" до "9", диапазон строчных букв от "a" до "f" и диапазон прописных букв от "A" до "F" используйте строку `[0-9a-fA-F]`.  
  
 Начальный знак (`^`) отрицательной группы символов является обязательным и указывает на то, что группа знаков является отрицательной, а не положительной.  
  
> [!IMPORTANT]
> Отрицательная группа символов в больших шаблонах регулярных выражений не является утверждением нулевой ширины. То есть после оценки отрицательной группы символов обработчик регулярных выражений перемещает один символ во входную строку.  
  
 В следующей таблице перечислены некоторые распространенные шаблоны регулярных выражений, содержащие отрицательные группы символов.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`[^aeiou]`|Соответствует всем символам, кроме гласных.|  
|`[^\p{P}\d]`|Соответствует всем символам, кроме знаков препинания и десятичных цифр.|  
  
 Следующий пример соответствует любому слову, начинающемуся с символов "th", за которыми нет символа "o".  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/negativecharclasses.cs#2)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/negativecharclasses.vb#2)]  
  
 Определение регулярного выражения `\bth[^o]\w+\b` показано в таблице ниже.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`th`|Соответствует буквенным символам "th".|  
|`[^o]`|Соответствует любому символу, отличающемуся от "o".|  
|`\w+`|Совпадение с одним или несколькими символами слова.|  
|`\b`|Конец на границе слова.|  
  
<a name="AnyCharacter"></a>   
## <a name="any-character-"></a>Любой символ: .  
 Символ точки (.) соответствует любому символу, кроме `\n` (символ перевода строки, \u000A), с использованием указанных ниже двух квалификаторов.  
  
- Если шаблон регулярного выражения изменяется параметром <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> или если часть этого шаблона, содержащая класс символов `.`, изменяется параметром `s`, то `.` соответствует любому символу. Для получения дополнительной информации см. [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).  
  
     В следующем примере показано различное поведение класса символов `.` по умолчанию и с параметром <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>. Регулярное выражение `^.+` начинается с начала строки и соответствует любому знаку. По умолчанию соответствие заканчивается в конце первой строки; шаблон регулярного выражения соответствует символу возврата каретки, `\r` или \u000D, но не соответствует `\n`. Поскольку параметр <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> интерпретирует всю входную строку как единую строку, он сопоставляет каждый символ в строке ввода, включая `\n`.  
  
     [!code-csharp[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)]
     [!code-vb[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)]  
  
> [!NOTE]
> Так как класс символов `.` соответствует любому символу, кроме `\n`, он также соответствует символу `\r` (символ возврата каретки, \u000D).  
  
- Точка в положительной или отрицательной группе символов рассматривается как литеральный символ точки, а не как класс символов. Дополнительные сведения см. в разделах [Положительная группа символов](#PositiveGroup) и [Отрицательная группа символов](#NegativeGroup) ранее в этой статье. В следующем примере представлено определение регулярного выражения, содержащее символ точки (`.`) как класс символов и как член положительной группы символов. Регулярное выражение `\b.*[.?!;:](\s|\z)` начинается на границе слова, выделяет все символы, пока не встретится один из пяти знаков препинания (включая точку), после чего выделяет символ пробела или конца строки.  
  
     [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any1.cs#4)]
     [!code-vb[Conceptual.RegEx.Language.CharacterClasses#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any1.vb#4)]  
  
> [!NOTE]
> Поскольку элемент языка `.` соответствует любому символу, он часто используется с отложенным квантификатором, если шаблон регулярного выражения пытается несколько раз найти соответствие любому символу. Для получения дополнительной информации см. [Квантификаторы](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).  
  
<a name="CategoryOrBlock"></a>   
## <a name="unicode-category-or-unicode-block-p"></a>Категория Юникода или блок Юникода: \p{}  
 В стандарте Юникода каждому символу присваивается общая категория. Например, определенный символ может быть прописной буквой (категория `Lu`), десятичной цифрой (категория `Nd`), математическим символом (категория `Sm`) или разделителем абзацев (категория `Zl`). Определенные наборы символов стандарта Юникод также занимают некоторый диапазон или блок последовательных кодовых точек. Например, базовая латинская кодировка находится в диапазоне от \u0000 до \u007F, а арабская кодировка находится в диапазоне от \u0600 до \u06FF.  
  
 Конструкция регулярного выражения  
  
 `\p{` *имя* `}`  
  
 соответствует любым символам, которые относятся к общей категории Юникода или именованному блоку, где *name* — сокращенное название категории или имя блока. Список сокращений категорий см. в подразделе [Поддерживаемые общие категории Юникода](#SupportedUnicodeGeneralCategories) далее в этом разделе. Список именованных блоков см. в подразделе [Поддерживаемые именованные блоки](#SupportedNamedBlocks) далее в этом разделе.  
  
 В примере ниже конструкция `\p{`*name*`}` используется для выделения общей категории Юникода (в данном случае `Pd`, т. е. категории знаков препинания и тире) и именованного блока (`IsGreek` и `IsBasicLatin`).  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/category1.cs#6)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/category1.vb#6)]  
  
 Определение регулярного выражения `\b(\p{IsGreek}+(\s)?)+\p{Pd}\s(\p{IsBasicLatin}+(\s)?)+` показано в таблице ниже.  
  
|Шаблон|ОПИСАНИЕ|  
|-------------|-----------------|  
|`\b`|Начало на границе слова.|  
|`\p{IsGreek}+`|Соответствует одному или нескольким греческим символам.|  
|`(\s)?`|Совпадение с нулем или одним символом пробела.|  
|`(\p{IsGreek}+(\s)?)+`|Выделяет один или несколько раз шаблон из одного или нескольких греческих символов, за которыми следует ноль или один символ пробела.|  
|`\p{Pd}`|Соответствует знакам препинания и тире.|  
|`\s`|Соответствует пробелу.|  
|`\p{IsBasicLatin}+`|Соответствует одному или нескольким базовым латинским символам.|  
|`(\s)?`|Совпадение с нулем или одним символом пробела.|  
|`(\p{IsBasicLatin}+(\s)?)+`|Выделяет один или несколько раз шаблон из одного или нескольких базовых латинских символов, за которыми следует ноль или один символ пробела.|  
  
<a name="NegativeCategoryOrBlock"></a>   
## <a name="negative-unicode-category-or-unicode-block-p"></a>Отрицательная категория Юникода или блок Юникода: \P{}  
 В стандарте Юникода каждому символу присваивается общая категория. Например, определенный символ может быть прописной буквой (категория `Lu`), десятичной цифрой (категория `Nd`), математическим символом (категория `Sm`) или разделителем абзацев (категория `Zl`). Определенные наборы символов стандарта Юникод также занимают некоторый диапазон или блок последовательных кодовых точек. Например, базовая латинская кодировка находится в диапазоне от \u0000 до \u007F, а арабская кодировка находится в диапазоне от \u0600 до \u06FF.  
  
 Конструкция регулярного выражения  
  
 `\P{` *имя* `}`  
  
 соответствует любым символам, которые не относятся к общей категории Юникода или именованному блоку, где *name* — сокращенное название категории или имя блока. Список сокращений категорий см. в подразделе [Поддерживаемые общие категории Юникода](#SupportedUnicodeGeneralCategories) далее в этом разделе. Список именованных блоков см. в подразделе [Поддерживаемые именованные блоки](#SupportedNamedBlocks) далее в этом разделе.  
  
 В примере ниже конструкция `\P{`*name*`}` используется для удаления любых символов валют (в данном случае `Sc`, т. е. категории символов и валют) из числовых строк.  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/notcategory1.cs#7)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/notcategory1.vb#7)]  
  
 Шаблон регулярного выражения `(\P{Sc})+` выделяет один или несколько символов, которые не являются символами валют. Это позволяет удалить любой символ валюты из строки результата.  
  
<a name="WordCharacter"></a>   
## <a name="word-character-w"></a>Словообразующий символ: \w  
 `\w` соответствует любому словообразующему символу. Словообразующий символ входит во все категории Юникода, перечисленные в следующей таблице.  
  
|Категория|ОПИСАНИЕ|  
|--------------|-----------------|  
|Ll|Буква: строчные буквы|  
|Lu|Буква: прописные буквы|  
|Lt|Буква: заглавный регистр|  
|Lo|Буква: другие|  
|Lm|Буква: модификатор|  
|Mn|Метка: не занимающая место|  
|Nd|Число: десятичная цифра|  
|Pc|Пунктуация, соединитель. Эта категория включает десять символов, наиболее часто используемым из которых является знак подчеркивания (_), u+005F.|  
  
 Если задано поведение, совместимое с ECMAScript, то параметр `\w` эквивалентен `[a-zA-Z_0-9]`. Информацию о регулярных выражениях ECMAScript см. в подразделе "Поведение сопоставления ECMAScript" раздела [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).  
  
> [!NOTE]
> Так как элемент языка `\w` соответствует любому словообразующему символу, он часто используется с отложенным квантификатором, если шаблон регулярного выражения пытается несколько раз найти соответствие любому словообразующему символу, за которым следует определенный словообразующий символ. Для получения дополнительной информации см. [Квантификаторы](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).  
  
 В примере ниже элемент языка `\w` используется для выделения повторяющихся символов в слове. В примере определяется шаблон регулярного выражения `(\w)\1`, который можно интерпретировать указанным ниже образом.  
  
|Элемент|ОПИСАНИЕ|  
|-------------|-----------------|  
|(\w)|Соответствует словообразующему символу. Это первая группа записи.|  
|\1|Соответствует значению первой записи.|  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/wordchar1.cs#8)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/wordchar1.vb#8)]  
  
<a name="NonWordCharacter"></a>   
## <a name="non-word-character-w"></a>Несловообразующий символ: \W  
 `\W` соответствует любому несловообразующему символу. Элемент языка \W эквивалентен следующему классу символов:  
  
`[^\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]`  
  
 Другими словами, он соответствует любому символу, за исключением символов в категории Юникода, перечисленных в следующей таблице.  
  
|Категория|ОПИСАНИЕ|  
|--------------|-----------------|  
|Ll|Буква: строчные буквы|  
|Lu|Буква: прописные буквы|  
|Lt|Буква: заглавный регистр|  
|Lo|Буква: другие|  
|Lm|Буква: модификатор|  
|Mn|Метка: не занимающая место|  
|Nd|Число: десятичная цифра|  
|Pc|Пунктуация, соединитель. Эта категория включает десять символов, наиболее часто используемым из которых является знак подчеркивания (_), u+005F.|  
  
 Если задано поведение, совместимое с ECMAScript, то параметр `\W` эквивалентен `[^a-zA-Z_0-9]`. Информацию о регулярных выражениях ECMAScript см. в подразделе "Поведение сопоставления ECMAScript" раздела [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).  
  
> [!NOTE]
> Так как элемент языка `\W` соответствует любому несловообразующему символу, он часто используется с отложенным квантификатором, если шаблон регулярного выражения пытается несколько раз найти соответствие любому несловообразующему символу, за которым следует определенный несловообразующий символ. Для получения дополнительной информации см. [Квантификаторы](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).  
  
 В примере ниже показан класс символов `\W`.  Он определяет шаблон регулярного выражения `\b(\w+)(\W){1,2}`, выделяющий слово, за которым следует один или два несловообразующих символа, например пробелы или знаки препинания. Возможные интерпретации регулярного выражения показаны в следующей таблице.  
  
|Элемент|ОПИСАНИЕ|  
|-------------|-----------------|  
|\b|Совпадение должно начинаться на границе слова.|  
|(\w+)|Совпадение с одним или несколькими символами слова. Это первая группа записи.|  
|(\W){1,2}|Выделяет несловообразующий символ один или два раза. Это вторая группа записи.|  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/nonwordchar1.cs#9)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/nonwordchar1.vb#9)]  
  
 Поскольку объект <xref:System.Text.RegularExpressions.Group> для второй группы записи содержит только один захваченный несловообразующий символ, в примере извлекаются все захваченные несловообразующие символы из объекта <xref:System.Text.RegularExpressions.CaptureCollection>, который возвращается свойством <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType>.  
  
<a name="WhitespaceCharacter"></a>   
## <a name="whitespace-character-s"></a>Символ пробела: \s  
 `\s` соответствует любому символу пробела. Это эквивалентно управляющим последовательностям и категориям Юникода, перечисленным в следующей таблице.  
  
|Категория|ОПИСАНИЕ|  
|--------------|-----------------|  
|`\f`|Символ перевода страницы, \u000C.|  
|`\n`|Символ новой строки, \u000A.|  
|`\r`|Символ возврата каретки, \u000D.|  
|`\t`|Символ табуляции, \u0009.|  
|`\v`|Символ вертикальной табуляции, \u000B.|  
|`\x85`|Многоточие или символ NEXT LINE (NEL) (…), \u0085.|  
|`\p{Z}`|Соответствует любому разделительному символу.|  
  
 Если задано поведение, совместимое с ECMAScript, то параметр `\s` эквивалентен `[ \f\n\r\t\v]`. Информацию о регулярных выражениях ECMAScript см. в подразделе "Поведение сопоставления ECMAScript" раздела [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).  
  
 В примере ниже показан класс символов `\s`. Он определяет шаблон регулярного выражения `\b\w+(e)?s(\s|$)`, выделяющий слово, заканчивающееся на "s" или "es", за которым следует знак пробела или конец входной строки. Возможные интерпретации регулярного выражения показаны в следующей таблице.  
  
|Элемент|ОПИСАНИЕ|  
|-------------|-----------------|  
|\b|Совпадение должно начинаться на границе слова.|  
|\w+|Совпадение с одним или несколькими символами слова.|  
|(e)?|Выделяет "e" ноль или один раз.|  
|s|Выделяет "s".|  
|(\s|$)|Совпадает с символом пробела или концом входной строки.|  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/whitespace1.cs#10)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/whitespace1.vb#10)]  
  
<a name="NonWhitespaceCharacter"></a>   
## <a name="non-whitespace-character-s"></a>Символ, не являющийся пробелом: \S  
 `\S` соответствует любому символу, не являющемуся пробелом. Он эквивалентен шаблону регулярного выражения `[^\f\n\r\t\v\x85\p{Z}]` или противоположному шаблону, эквивалентному `\s`, выделяющему символы пробела. Дополнительные сведения см. в разделе [Символ пробела: \s](#WhitespaceCharacter).  
  
 Если задано поведение, совместимое с ECMAScript, то параметр `\S` эквивалентен `[^ \f\n\r\t\v]`. Информацию о регулярных выражениях ECMAScript см. в подразделе "Поведение сопоставления ECMAScript" раздела [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).  
  
 В примере ниже показан элемент языка `\S`. Шаблон регулярного выражения `\b(\S+)\s?` выделяет строки, разделенные символами пробела. Второй элемент в объекте <xref:System.Text.RegularExpressions.GroupCollection> содержит совпадающую строку. Возможные интерпретации регулярного выражения показаны в следующей таблице.  
  
|Элемент|ОПИСАНИЕ|  
|-------------|-----------------|  
|`\b`|Совпадение должно начинаться на границе слова.|  
|`(\S+)`|Соответствует одному или нескольким символам, которые не являются пробелами. Это первая группа записи.|  
|`\s?`|Совпадение с нулем или одним символом пробела.|  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/nonwhitespace1.cs#11)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/nonwhitespace1.vb#11)]  
  
<a name="DigitCharacter"></a>   
## <a name="decimal-digit-character-d"></a>Десятичная цифра: \d  
 `\d` соответствует любой десятичной цифре. Он эквивалентен шаблону регулярного выражения `\p{Nd}`, который включает стандартные десятичные цифры 0–9, а также десятичные цифры из некоторых других наборов символов.  
  
 Если задано поведение, совместимое с ECMAScript, то параметр `\d` эквивалентен `[0-9]`. Информацию о регулярных выражениях ECMAScript см. в подразделе "Поведение сопоставления ECMAScript" раздела [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).  
  
 В примере ниже показан элемент языка `\d`. Проверяет, представляет ли входная строка допустимый телефонный номер в США и Канаде. Шаблон регулярного выражения `^(\(?\d{3}\)?[\s-])?\d{3}-\d{4}$` определяется, как показано в следующей таблице.  
  
|Элемент|ОПИСАНИЕ|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале входной строки.|  
|`\(?`|Выделяет ноль или один символ "(".|  
|`\d{3}`|Совпадение с тремя десятичными цифрами.|  
|`\)?`|Выделяет ноль или один символ ")".|  
|`[\s-]`|Выделяет дефис или пробел.|  
|`(\(?\d{3}\)?[\s-])?`|Выделяет несколько раз необязательные открывающие скобки с последующими тремя десятичными цифрами, необязательную закрывающую скобку, а также знак пробела или дефис (если они есть). Это первая группа записи.|  
|`\d{3}-\d{4}`|Выделяет три десятичных цифры, следующий за ними дефис и еще четыре десятичные цифры.|  
|`$`|Соответствует концу входной строки.|  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/digit1.cs#12)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/digit1.vb#12)]  
  
<a name="NonDigitCharacter"></a>   
## <a name="non-digit-character-d"></a>Символ, не являющийся цифрой: \D  
 `\D` соответствует любому символу, не являющемуся цифрой. Он эквивалентен шаблону регулярного выражения `\P{Nd}`.  
  
 Если задано поведение, совместимое с ECMAScript, то параметр `\D` эквивалентен `[^0-9]`. Информацию о регулярных выражениях ECMAScript см. в подразделе "Поведение сопоставления ECMAScript" раздела [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md).  
  
 В следующем примере показан элемент языка \D. Он проверяет, включает ли строка (например, номер продукта) соответствующее сочетание десятичных и недесятичных символов. Шаблон регулярного выражения `^\D\d{1,5}\D*$` определяется, как показано в следующей таблице.  
  
|Элемент|ОПИСАНИЕ|  
|-------------|-----------------|  
|`^`|Начало совпадения в начале входной строки.|  
|`\D`|Выделяет любой символ, не являющийся цифрой.|  
|`\d{1,5}`|Выделяет от одной до пяти десятичных цифр.|  
|`\D*`|Выделяет нуль, одну или несколько недесятичных цифр.|  
|`$`|Соответствует концу входной строки.|  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/nondigit1.cs#13)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/nondigit1.vb#13)]  
  
<a name="SupportedUnicodeGeneralCategories"></a>   
## <a name="supported-unicode-general-categories"></a>Поддерживаемые общие категории Юникода  
 В Юникоде определяются общие категории, приведенные в следующей таблице. Дополнительные сведения см. в подразделах "Формат файлов UCD" и "Значения общих категорий" в разделе [База данных символов Юникода](https://www.unicode.org/reports/tr44/).  
  
|Категория|ОПИСАНИЕ|  
|--------------|-----------------|  
|`Lu`|Буква: прописные буквы|  
|`Ll`|Буква: строчные буквы|  
|`Lt`|Буква: заглавный регистр|  
|`Lm`|Буква: модификатор|  
|`Lo`|Буква: другие|  
|`L`|Все буквенные символы. Включает символы `Lu`, `Ll`, `Lt`, `Lm` и `Lo`|  
|`Mn`|Метка: не занимающая место|  
|`Mc`|Метка: комбинированная|  
|`Me`|Метка: вложенная|  
|`M`|Все диакритические знаки. Включает категории `Mn`, `Mc` и `Me`.|  
|`Nd`|Число: десятичная цифра|  
|`Nl`|Число: буква|  
|`No`|Число: другое|  
|`N`|Все числа. Включает категории `Nd`, `Nl` и `No`.|  
|`Pc`|Пунктуация: соединитель|  
|`Pd`|Пунктуация: тире|  
|`Ps`|Пунктуация: открывающий знак пунктуации|  
|`Pe`|Пунктуация: закрывающий знак пунктуации|  
|`Pi`|Пунктуация: открывающая кавычка (в зависимости от использования поведение может быть аналогичным Ps или Pe)|  
|`Pf`|Пунктуация: закрывающая кавычка (в зависимости от использования поведение может быть аналогичным Ps или Pe)|  
|`Po`|Пунктуация: другие знаки пунктуации|  
|`P`|Все знаки препинания. Включает категории `Pc`, `Pd`, `Ps`, `Pe`, `Pi`, `Pf` и `Po`.|  
|`Sm`|Символ: математический|  
|`Sc`|Символ денежной единицы|  
|`Sk`|Символ: модификатор|  
|`So`|Символ: другие|  
|`S`|Все символы. Включает категории `Sm`, `Sc`, `Sk` и `So`.|  
|`Zs`|Разделитель: пробел|  
|`Zl`|Разделитель: строка|  
|`Zp`|Разделитель: абзац|  
|`Z`|Все знаки разделения. Включает категории `Zs`, `Zl` и `Zp`.|  
|`Cc`|Другое: управляющий символ|  
|`Cf`|Другое: формат|  
|`Cs`|Другое: заменяющий символ|  
|`Co`|Другое: индивидуальное использование|  
|`Cn`|Другое: неназначенные символы (ни один символ не имеет этого свойства)|  
|`C`|Все управляющие символы. Включает категории `Cc`, `Cf`, `Cs`, `Co` и `Cn`.|  
  
 Можно определить категорию Юникода для любого отдельного символа, передав его в метод <xref:System.Char.GetUnicodeCategory%2A>. В следующем примере метод <xref:System.Char.GetUnicodeCategory%2A> используется для определения категории каждого элемента в массиве, содержащем выбранные латинские символы.  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/getunicodecategory1.cs#14)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/getunicodecategory1.vb#14)]  
  
<a name="SupportedNamedBlocks"></a>   
## <a name="supported-named-blocks"></a>Поддерживаемые именованные блоки

Платформа .NET предоставляет именованные блоки, перечисленные в следующей таблице. Набор поддерживаемых именованных блоков составлен на основе Юникода версии 4.0 и Perl версии 5.6. Сведения о регулярном выражении, которое использует именованные блоки, см. в разделе [Категория Юникода или блок Юникода: \\p{}](#unicode-category-or-unicode-block-p).  
  
|Диапазон кодовых точек|Имя блока|  
|----------------------|----------------|  
|0000 - 007F|`IsBasicLatin`|  
|0080 - 00FF|`IsLatin-1Supplement`|  
|0100 - 017F|`IsLatinExtended-A`|  
|0180 - 024F|`IsLatinExtended-B`|  
|0250 - 02AF|`IsIPAExtensions`|  
|02B0 - 02FF|`IsSpacingModifierLetters`|  
|0300 - 036F|`IsCombiningDiacriticalMarks`|  
|0370 - 03FF|`IsGreek`<br /><br /> -или-<br /><br /> `IsGreekandCoptic`|  
|0400 - 04FF|`IsCyrillic`|  
|0500 - 052F|`IsCyrillicSupplement`|  
|0530 - 058F|`IsArmenian`|  
|0590 - 05FF|`IsHebrew`|  
|0600 - 06FF|`IsArabic`|  
|0700 - 074F|`IsSyriac`|  
|0780 - 07BF|`IsThaana`|  
|0900 - 097F|`IsDevanagari`|  
|0980 - 09FF|`IsBengali`|  
|0A00 - 0A7F|`IsGurmukhi`|  
|0A80 - 0AFF|`IsGujarati`|  
|0B00 - 0B7F|`IsOriya`|  
|0B80 - 0BFF|`IsTamil`|  
|0C00 - 0C7F|`IsTelugu`|  
|0C80 - 0CFF|`IsKannada`|  
|0D00 - 0D7F|`IsMalayalam`|  
|0D80 - 0DFF|`IsSinhala`|  
|0E00 - 0E7F|`IsThai`|  
|0E80 - 0EFF|`IsLao`|  
|0F00 - 0FFF|`IsTibetan`|  
|1000 - 109F|`IsMyanmar`|  
|10A0 - 10FF|`IsGeorgian`|  
|1100 - 11FF|`IsHangulJamo`|  
|1200 - 137F|`IsEthiopic`|  
|13A0 - 13FF|`IsCherokee`|  
|1400 - 167F|`IsUnifiedCanadianAboriginalSyllabics`|  
|1680 - 169F|`IsOgham`|  
|16A0 - 16FF|`IsRunic`|  
|1700 - 171F|`IsTagalog`|  
|1720 - 173F|`IsHanunoo`|  
|1740 - 175F|`IsBuhid`|  
|1760 - 177F|`IsTagbanwa`|  
|1780 - 17FF|`IsKhmer`|  
|1800 - 18AF|`IsMongolian`|  
|1900 - 194F|`IsLimbu`|  
|1950 - 197F|`IsTaiLe`|  
|19E0 - 19FF|`IsKhmerSymbols`|  
|1D00 - 1D7F|`IsPhoneticExtensions`|  
|1E00 - 1EFF|`IsLatinExtendedAdditional`|  
|1F00 - 1FFF|`IsGreekExtended`|  
|2000 - 206F|`IsGeneralPunctuation`|  
|2070 - 209F|`IsSuperscriptsandSubscripts`|  
|20A0 - 20CF|`IsCurrencySymbols`|  
|20D0 - 20FF|`IsCombiningDiacriticalMarksforSymbols`<br /><br /> -или-<br /><br /> `IsCombiningMarksforSymbols`|  
|2100 - 214F|`IsLetterlikeSymbols`|  
|2150 - 218F|`IsNumberForms`|  
|2190 - 21FF|`IsArrows`|  
|2200 - 22FF|`IsMathematicalOperators`|  
|2300 - 23FF|`IsMiscellaneousTechnical`|  
|2400 - 243F|`IsControlPictures`|  
|2440 - 245F|`IsOpticalCharacterRecognition`|  
|2460 - 24FF|`IsEnclosedAlphanumerics`|  
|2500 - 257F|`IsBoxDrawing`|  
|2580 - 259F|`IsBlockElements`|  
|25A0 - 25FF|`IsGeometricShapes`|  
|2600 - 26FF|`IsMiscellaneousSymbols`|  
|2700 - 27BF|`IsDingbats`|  
|27C0 - 27EF|`IsMiscellaneousMathematicalSymbols-A`|  
|27F0 - 27FF|`IsSupplementalArrows-A`|  
|2800 - 28FF|`IsBraillePatterns`|  
|2900 - 297F|`IsSupplementalArrows-B`|  
|2980 - 29FF|`IsMiscellaneousMathematicalSymbols-B`|  
|2A00 - 2AFF|`IsSupplementalMathematicalOperators`|  
|2B00 - 2BFF|`IsMiscellaneousSymbolsandArrows`|  
|2E80 - 2EFF|`IsCJKRadicalsSupplement`|  
|2F00 - 2FDF|`IsKangxiRadicals`|  
|2FF0 - 2FFF|`IsIdeographicDescriptionCharacters`|  
|3000 - 303F|`IsCJKSymbolsandPunctuation`|  
|3040 - 309F|`IsHiragana`|  
|30A0 - 30FF|`IsKatakana`|  
|3100 - 312F|`IsBopomofo`|  
|3130 - 318F|`IsHangulCompatibilityJamo`|  
|3190 - 319F|`IsKanbun`|  
|31A0 - 31BF|`IsBopomofoExtended`|  
|31F0 - 31FF|`IsKatakanaPhoneticExtensions`|  
|3200 - 32FF|`IsEnclosedCJKLettersandMonths`|  
|3300 - 33FF|`IsCJKCompatibility`|  
|3400 - 4DBF|`IsCJKUnifiedIdeographsExtensionA`|  
|4DC0 - 4DFF|`IsYijingHexagramSymbols`|  
|4E00 - 9FFF|`IsCJKUnifiedIdeographs`|  
|A000 - A48F|`IsYiSyllables`|  
|A490 - A4CF|`IsYiRadicals`|  
|AC00 - D7AF|`IsHangulSyllables`|  
|D800 - DB7F|`IsHighSurrogates`|  
|DB80 - DBFF|`IsHighPrivateUseSurrogates`|  
|DC00 - DFFF|`IsLowSurrogates`|  
|E000 - F8FF|`IsPrivateUse` или `IsPrivateUseArea`|  
|F900 - FAFF|`IsCJKCompatibilityIdeographs`|  
|FB00 - FB4F|`IsAlphabeticPresentationForms`|  
|FB50 - FDFF|`IsArabicPresentationForms-A`|  
|FE00 - FE0F|`IsVariationSelectors`|  
|FE20 - FE2F|`IsCombiningHalfMarks`|  
|FE30 - FE4F|`IsCJKCompatibilityForms`|  
|FE50 - FE6F|`IsSmallFormVariants`|  
|FE70 - FEFF|`IsArabicPresentationForms-B`|  
|FF00 - FFEF|`IsHalfwidthandFullwidthForms`|  
|FFF0 - FFFF|`IsSpecials`|  
  
<a name="CharacterClassSubtraction"></a>   
## <a name="character-class-subtraction-base_group---excluded_group"></a>Вычитание класса символов: [базовая_группа - [исключенная_группа]]  
 Класс знаков определяет набор знаков. Результатом вычитания класса знаков является набор знаков, полученный в результате исключения одного класса знаков из другого класса знаков.  
  
 Выражение вычитания класса знаков имеет следующий вид:  
  
 `[` *base_group* `-[` *excluded_group* `]]`  
  
 Квадратные скобки (`[]`) и дефис (`-`) являются обязательными. *base_group* представляет собой [положительную](#PositiveGroup) или [отрицательную](#NegativeGroup) группу символов. Компонент *excluded_group* — это другая положительная или отрицательная группа символов или другое выражение вычитания класса символов (то есть можно осуществлять вложение выражений вычитания класса символов).  
  
 Например, предположим, что имеется базовая группа, состоящая из диапазона знаков от "а" до "z". Чтобы задать набор знаков, состоящий из базовой группы за исключением знака "m", используйте команду `[a-z-[m]]`. Чтобы задать набор знаков, состоящий из базовой группы за исключением знаков "d", "j", и "p", используйте команду `[a-z-[djp]]`. Чтобы определить набор знаков, состоящий из базовой группы за исключением диапазона знаков от "m" до "p", используйте команду `[a-z-[m-p]]`.  
  
 Рассмотрим вложенное выражение вычитания классов знаков `[a-z-[d-w-[m-o]]]`. Вычисление выражения начинается из самого внутреннего диапазона знаков. Сначала диапазон знаков от "m" до "o" вычитается из диапазона знаков от "d" до "w", в результате чего остается набор знаков от "d" до "i" и от "p" до "w". Затем этот набор вычитается из диапазона знаков от "a" до "z", вследствие чего получается набор знаков `[abcmnoxyz]`.  
  
 При вычитании класса знаков можно использовать любой класс знаков. Чтобы определить набор символов, состоящий из всех символов Юникода от \u0000 до \uFFFF, за исключением пробела (`\s`), знаков препинания в общей категории (`\p{P}`), символов в именованном блоке `IsGreek` (`\p{IsGreek}`) и управляющего символа Юникода "следующая строка" (\x85), используйте `[\u0000-\uFFFF-[\s\p{P}\p{IsGreek}\x85]]`.  
  
 Выберите классы знаков для выражения вычитания класса знаков, которое возвратит полезные результаты. Избегайте выражений, в результате которых возвращается пустой набор знаков, который ничему не соответствует, и выражений, эквивалентных исходной базовой группе. Например, пустой набор является результатом выражения `[\p{IsBasicLatin}-[\x00-\x7F]]`, которое вычитает все символы диапазона `IsBasicLatin` из общей категории `IsBasicLatin`. Аналогично, результатом выражения `[a-z-[0-9]]` является исходная базовая группа.  Это происходит из-за того, что базовая группа, которая является диапазоном букв от "a" до "z", не содержит знаков исключаемой группы, которая является диапазоном десятичных цифр от "0" до "9".  
  
 В следующем примере определяется регулярное выражение `^[0-9-[2468]]+$`, которое выделяет ноль и нечетные цифры во входной строке.  Возможные интерпретации регулярного выражения показаны в следующей таблице.  
  
|Элемент|ОПИСАНИЕ|  
|-------------|-----------------|  
|^|Соответствие должно обнаруживаться в начале входной строки.|  
|`[0-9-[2468]]+`|Соответствует одному или нескольким вхождениям любого символа от 0 до 9, за исключением 2, 4, 6 и 8. Другими словами, выделяется одно или несколько вхождений нуля или нечетной цифры.|  
|$|Совпадение должно заканчиваться в конце входной строки.|  
  
 [!code-csharp[Conceptual.RegEx.Language.CharacterClasses#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/classsubtraction1.cs#15)]
 [!code-vb[Conceptual.RegEx.Language.CharacterClasses#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/classsubtraction1.vb#15)]  
  
## <a name="see-also"></a>См. также

- <xref:System.Char.GetUnicodeCategory%2A>
- [Элементы языка регулярных выражений — краткий справочник](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [Параметры регулярных выражений](../../../docs/standard/base-types/regular-expression-options.md)
