---
title: "Обзор .NET"
description: "Обзор некоторых важных функций платформы .NET."
keywords: ".NET, .NET Core, обзор, языки программирования, небезопасный, управление памятью, безопасность типа, асинхронный"
author: cartermp
ms.author: wiwagn
ms.date: 02/09/2016
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.translationtype: Machine Translation
ms.sourcegitcommit: d00f2096e0799107a8a2ff1d12274c6026d4c27a
ms.openlocfilehash: 50e5b333f892cf469e9f3fe57a0325ac6d8e641f
ms.contentlocale: ru-ru
ms.lasthandoff: 05/22/2017

---

# <a name="tour-of-net"></a>Обзор .NET

.NET — это платформа разработки общего назначения.  Она включает несколько основных функций (к примеру, несколько языков программирования, модели асинхронного и параллельного программирования и взаимодействие на уровне машинного кода), благодаря которым на различных платформах доступно множество разнообразных сценариев.

В этой статье представлен обзор некоторых основных функций платформы .NET.

В разделе об [архитектурных компонентах .NET](components.md) вы сможете узнать о каждом фрагменте архитектуры .NET и его целевом предназначении.

## <a name="how-to-run-the-code-samples"></a>Выполнение примеров кода

Сведения о том, как настроить среду разработки для выполнения примеров кода, представлены в разделе [о начале работы](get-started.md).  Можно скопировать примеры кода с этой страницы и вставить их в вашу среду для выполнения. 

> [!NOTE]
В будущем на этом сайте с документацией появится возможность запускать примеры кода прямо в браузере.

## <a name="programming-languages"></a>Языки программирования

Архитектура .NET поддерживает различные языки программирования.  Среды выполнения .NET реализуют [инфраструктуру CLI (Common Language Infrastructure)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), которая, среди прочего, указывает среду выполнения, не зависящую от языка, а также взаимодействие языков.  Это означает, что для создания приложений и служб на платформе .NET можно выбрать любой язык .NET.

Корпорация Майкрософт активно занимается разработкой и поддержкой трех языков .NET: C#, F# и Visual Basic .NET. 

* C# — это простой, эффективный, типобезопасный и объектно-ориентированный язык, сохраняющий выразительность и элегантность, присущую языкам C. Все, кто знаком с C и схожими языками, смогут без проблем перейти на C#.  Чтобы узнать больше о языке C#, ознакомьтесь с [этим руководством](../csharp/index.md).

* F# — это кроссплатформенный и функционально-императивный язык программирования, который также поддерживает объектно-ориентированное и императивное программирование.  Чтобы узнать больше о языке F#, ознакомьтесь с [этим руководством](../fsharp/index.md).

* Visual Basic — это простой язык, позволяющий научиться разрабатывать разнообразные приложения на платформе .NET.

## <a name="automatic-memory-management"></a>Автоматическое управление памятью

Архитектура .NET использует [сборку мусора](garbagecollection/index.md), чтобы обеспечить автоматическое управление памятью для программ.  Сборщик мусора отражает отложенный подход к управлению памятью, когда пропускная способность приложения предпочитается немедленной сборке памяти.  Чтобы узнать больше о сборке мусора в .NET, см. статью [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md) (Базовые понятия сборки мусора).

Обе приведенные ниже строки выделяют память:

[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]

Аналогичных ключевых слов для отмены выделения памяти не существует, так как отмена осуществляется автоматически, когда сборщик мусора освобождает память в рамках запланированного выполнения.

Сборщик мусора — это лишь одна из служб, которые помогают обеспечить *безопасность памяти*.  Инвариантность безопасности памяти очень проста: программа является безопасной с точки зрения памяти, если обращается только к выделенной (и не освобожденной) памяти.  Например, среда выполнения гарантирует, что программы не выйдут за пределы массива и не будут обращаться к фантомным полям за пределами объекта.

В следующем примере среда выполнения порождает исключение `InvalidIndexException` для обеспечения безопасности памяти.

[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]

## <a name="working-with-unmanaged-resources"></a>Работа с неуправляемыми ресурсами

Некоторые объекты ссылаются на *неуправляемые ресурсы*. Неуправляемые ресурсы — это ресурсы, которые не обслуживаются средой выполнения .NET автоматически.  Например, к неуправляемым ресурсам относятся дескрипторы файлов.  Объект @System.IO.FileStream — управляемый, но он ссылается на дескриптор файла, который является неуправляемым ресурсом.  После окончания работы с FileStream нужно освободить дескриптор файла.

В среде .NET объекты, которые ссылаются на неуправляемые ресурсы, реализуют интерфейс @System.IDisposable.  После окончания работы с объектом вызовите метод @System.IDisposable.Dispose, который отвечает за освобождение неуправляемых ресурсов.  В языках .NET для таких объектов есть удобный синтаксис `using`, как показано в следующем примере:

[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]

После окончания блока `using` среда выполнения .NET автоматически вызывает метод @System.IDisposable.Dispose объекта `stream`, который освобождает дескриптор файла.  Среда выполнения также сделает это, если управление переходит за пределы блока из-за исключения.

Дополнительные сведения см. на следующих страницах:

* для C#: [Оператор using](../csharp/language-reference/keywords/using-statement.md);
* для F#: [Управление ресурсами: ключевое слово `use`](../fsharp/language-reference/resource-management-the-use-keyword.md);
* для Visual Basic: [Оператор using](../visual-basic/language-reference/statements/using-statement.md).

## <a name="type-safety"></a>Безопасность типа

Объекты выделяются с учетом типов. Разрешенные операции и занимаемая память для заданного объекта определяются его типом. Тип `Dog` может иметь методы `Jump` и `WagTail`, но не метод `SumTotal`. Программа может вызывать только объявленные методы заданного типа. Все другие вызовы приведут к ошибке во время компиляции или исключению во время выполнения (при использовании динамических функций или `object`).

Языки .NET являются объектно-ориентированными и имеют иерархии базовых и производных классов. Среда выполнения .NET допускает только те приведения и вызовы объектов, которые соответствуют иерархии объектов. Помните, что любой тип, определенный в любом языке .NET, является производным от базового типа `object`.

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L18-L23)]

Безопасность типа также используется для принудительной инкапсуляции, обеспечивая точность ключевых слов метода доступа. Ключевые слова метода доступа являются артефактами, которые управляют доступом к членам определенного типа из другого кода. Обычно они используются для различных видов данных внутри типа, которые позволяют управлять его поведением.

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]

Языки C#, Visual Basic и F# поддерживают **вывод локального типа**. Определение типа означает, что компилятор выводит тип выражения в левой части из выражения в правой части. Это не значит, что безопасность типа нарушается или исключается. Результирующий тип **имеет** строгий тип со всем, что подразумевается. Давайте перепишем две первые строки в предыдущем примере, чтобы ввести определение типа. Обратите внимание, что остальная часть примера остается неизменной.

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]

В языке F# имеется даже больше возможностей вывода для типов, чем локальных выводов для типов методов в языках C# и Visual Basic.  Для получения дополнительных сведений ознакомьтесь с разделом о [выводе для типов](../fsharp/language-reference/type-inference.md).

## <a name="delegates-and-lambdas"></a>Делегаты и лямбда-выражения

Делегаты похожи на указатели функций в C++, однако имеют значительное отличие — безопасность типа. Они представляют собой разновидность отключенного метода в системе типов CLR. Обычные методы присоединены к классу и вызываются только напрямую с помощью соглашений о статических вызовах или вызовах экземпляров.

Делегаты используются в различных API и компонентах .NET, особенно через лямбда-выражения, которые являются основой LINQ.

Дополнительные сведения см. в документе [Делегаты и лямбда-выражения](delegates-lambdas.md).

## <a name="generics"></a>Универсальные шаблоны

Универсальные шаблоны были добавлены в .NET Framework 2.0. Проще говоря, универсальные шаблоны позволяют программисту при разработке своих классов вводить "параметр типа", который позволяет клиентскому коду (пользователям типа) указать точный тип, используемый вместо параметра типа.

Универсальные шаблоны были добавлены, чтобы помочь программистам реализовывать универсальные структуры данных. До их появления, чтобы, к примеру, тип `List` был универсальным, он должен был работать с элементами, имеющими тип `object`. Это бы вызвало различные проблемы, связанные с производительностью и семантикой, а также неочевидные ошибки во время выполнения. Наиболее печально известным вариантом последних является ситуация, когда структура данных содержит, например, как целые числа, так и строки, и при работе с элементами списка возникает исключение `InvalidCastException`.

В следующем примере показан запуск простой программы, использующей экземпляр типов @System.Collections.Generic.List%601.

[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]

Дополнительные сведения см. в разделе [Обзор универсальных типов (универсальных шаблонов)](generics.md).

## <a name="async-programming"></a>Асинхронное программирование

Асинхронное программирование является одной из ключевых концепций на платформе .NET, включающей асинхронную поддержку среды выполнения, библиотек платформы и языковых конструкций .NET. На внутреннем уровне это основано на объектах (таких как `Task`), которые используют возможности операционной системы для максимально эффективного выполнения заданий ввода-вывода.

Дополнительные сведения об асинхронном программировании в .NET см. в разделе [Обзор асинхронной модели](async.md).

## <a name="language-integrated-query-linq"></a>Синтаксис LINQ

LINQ — это эффективный набор функций для C# и VB, которые позволяют писать простой и декларативный код для работы с данными. Данные могут быть представлены разными формами (например, объектами в памяти, содержимым базы данных SQL или XML-документом), но обычно создаваемый код LINQ не отличается для каждого из источников данных.

Для получения дополнительных сведений и ознакомления с примерами см. раздел [Синтаксис LINQ](using-linq.md).

## <a name="native-interoperability"></a>Взаимодействие на уровне машинного кода

Все используемые в настоящее время операционные системы предоставляют значительную платформенную поддержку для различных задач программирования. .NET предоставляет несколько способов использовать эти API. В совокупности такая поддержка называется "взаимодействием на уровне машинного кода". В этом разделе мы рассмотрим, как обратиться к собственным API из управляемого кода .NET.

Основным способом осуществления такого взаимодействия является вызов неуправляемого кода или сокращенно P/Invoke. Такая поддержка в .NET Core доступна на платформах Windows и Linux. Другой способ, который подходит только для Windows, называется "COM-взаимодействием" и используется для работы с [COM-компонентами](https://msdn.microsoft.com/library/bwa2bx93.aspx) в управляемом коде. Он основан на инфраструктуре P/Invoke, но работает иначе.

Основная часть поддержки взаимодействия Mono (и, следовательно, Xamarin) для Java и Objective-C построена аналогичным образом, то есть использует схожие принципы.

Дополнительные сведения см. в документе [Взаимодействие на уровне машинного кода](native-interop.md).

## <a name="unsafe-code"></a>Небезопасный код

Среда CLR позволяет обращаться к внутренней памяти и выполнять арифметические операции с указателями в коде `unsafe`. Эти операции необходимы для реализации определенных алгоритмов и системного взаимодействия. Хотя небезопасный код и предоставляет обширные возможности, использовать его не рекомендуется, если только это не требуется для взаимодействия с системными API или реализации максимально эффективного алгоритма. Небезопасный код может выполняться по-разному в разных средах, а также теряет преимущества сборщика мусора и безопасности типов. Рекомендуется четко отделить и централизовать небезопасный код, а также тщательно протестировать его.

В следующем примере показана измененная версия метода `ToString()` из класса `StringBuilder`.  Этот пример иллюстрирует, как с помощью кода `unsafe` можно эффективно реализовать алгоритм, перемещая блоки памяти напрямую:

[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]

## <a name="next-steps"></a>Дальнейшие действия

Если вас интересуют возможности языка C#, ознакомьтесь с [соответствующим обзором](../csharp/tour-of-csharp/index.md).

Если вас интересуют возможности языка F#, ознакомьтесь с [соответствующим обзором](../fsharp/tour.md).

Если вы хотите приступить к написанию собственного кода, ознакомьтесь с [руководством по началу работы](get-started.md).

Дополнительные сведения о важных [компонентах архитектуры .NET](components.md).

