---
title: "Концепции сериализации"
ms.date: 08/07/2017
ms.prod: .net
ms.topic: article
ms.assetid: e1ff4740-20a1-4c76-a8ad-d857db307054
caps.latest.revision: "4"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 76946ed1b714ba0bd01c79bb772524c84cf8b2ca
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/23/2017
---
# <a name="serialization-concepts"></a>Концепции сериализации
Для чего нужна сериализация? Двумя наиболее важными причинами являются сохранение состояния объекта в среде хранения, чтобы впоследствии можно было воссоздать точную копию, и отправить объект по значению из одного домена приложения в другой. Например, сериализация используется, чтобы сохранить состояние сеанса в ASP.NET и скопировать объекты в буфер обмена в Windows Forms. Она также используется при удаленном взаимодействии для передачи объектов по значению с одного домена приложения в другой.

[!INCLUDE [binary-serialization-warning](../../../includes/binary-serialization-warning.md)]

## <a name="persistent-storage"></a>Постоянное хранилище
Часто необходимо сохранить значение полей объекта на диск, а впоследствии извлечь эти данные. Несмотря на то что это несложно сделать и без сериализации, такой подход часто утомителен, и существует большая вероятность возникновения ошибок, и, кроме того, он постепенно усложняется по мере необходимости отслеживания иерархии объектов. Например, написание большого бизнес-приложения, содержащего тысячи объектов, и необходимость написания кода для сохранения полей и свойств на диск и их восстановления для каждого объекта. Сериализация обеспечивает удобный механизм достижения этой цели.

Среда CLR управляет способом хранения объектов в памяти и обеспечивает механизм автоматической сериализации с помощью [отражения](../../../docs/framework/reflection-and-codedom/reflection.md). При сериализации объекта имя класса, сборка и все члены данных экземпляра класса записываются в хранилище. Объекты часто содержат ссылки на другие экземпляры в переменных-членах. При сериализации класса модуль сериализации отслеживает уже сериализованные объекты, на которые указывает ссылка, чтобы предотвратить повторную сериализацию объекта. Архитектура сериализации, обеспечиваемая [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)], автоматически правильно обрабатывает графы объектов и циклические ссылки. Единственным требованием к графам объектов является то, что все объекты, на которые ссылается сериализуемый объект, также должны быть отмечены как `Serializable` (дополнительные сведения см. в разделе [Базовая сериализация](basic-serialization.md)). Если этого не сделать, при попытке сериализовать неотмеченный объект модулем сериализации будет выдано исключение.

При десериализации сериализованного класса он создается заново, а значения всех членов данных автоматически восстанавливаются.

## <a name="marshal-by-value"></a>Маршалинг по значению
Объекты являются допустимыми только в том домене приложения, в котором они были созданы. Любая попытка передать объект как параметр или вернуть его как результат будет завершаться ошибкой, пока объект наследуется от `MarshalByRefObject` или отмечен как `Serializable`. Если объект отмечен как `Serializable`, он будет автоматически сериализован, передан из одного домена приложений в другой, а затем десериализован с целью создания точной копии объекта во втором домене приложения. Этот процесс обычно называют маршалинг по значению.
 
Когда объект наследуется от `MarshalByRefObject`, из одного домена приложения в другой передается ссылка на объект, а не сам объект. Можно также пометить объект, который является производным от `MarshalByRefObject`, как `Serializable`. Когда этот объект используется для удаленного взаимодействия, модуль форматирования, отвечающий за сериализацию и предварительно настроенный с помощью суррогатного селектора (`SurrogateSelector`), берет на себя управление процессом сериализации и заменяет все объекты, унаследованные от `MarshalByRefObject` с помощью прокси. При отсутствии `SurrogateSelector` архитектура сериализации следует стандартным правилам сериализации, представленным в разделе [Этапы процесса сериализации](steps-in-the-serialization-process.md).  

## <a name="related-sections"></a>Связанные разделы  
 [Двоичная сериализация](../../../docs/standard/serialization/binary-serialization.md)  
 Описывает механизм двоичной сериализации, входящий в среду CLR.  
  
 [Удаленные объекты](http://msdn.microsoft.com/en-us/515686e6-0a8d-42f7-8188-73abede57c58)  
 Описывает различные методы взаимодействия, доступные в платформе .NET Framework для удаленного взаимодействия.  
  
 [Сериализация XML и SOAP](../../../docs/standard/serialization/xml-and-soap-serialization.md)  
 Описывает механизм сериализации XML и SOAP, входящий в среду CLR.
