---
title: Концепции сериализации
ms.date: 08/07/2017
ms.assetid: e1ff4740-20a1-4c76-a8ad-d857db307054
ms.openlocfilehash: 1a7fa7c3e5561fc9e48cf627a703abc747a72ba0
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/28/2020
ms.locfileid: "78159836"
---
# <a name="serialization-concepts"></a><span data-ttu-id="47aa0-102">Концепции сериализации</span><span class="sxs-lookup"><span data-stu-id="47aa0-102">Serialization concepts</span></span>
<span data-ttu-id="47aa0-103">Для чего нужна сериализация?</span><span class="sxs-lookup"><span data-stu-id="47aa0-103">Why would you want to use serialization?</span></span> <span data-ttu-id="47aa0-104">Двумя наиболее важными причинами являются сохранение состояния объекта в среде хранения, чтобы впоследствии можно было воссоздать точную копию, и отправить объект по значению из одного домена приложения в другой.</span><span class="sxs-lookup"><span data-stu-id="47aa0-104">The two most important reasons are to persist the state of an object to a storage medium so an exact copy can be re-created at a later stage, and to send the object by value from one application domain to another.</span></span> <span data-ttu-id="47aa0-105">Например, сериализация используется, чтобы сохранить состояние сеанса в ASP.NET и скопировать объекты в буфер обмена в Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="47aa0-105">For example, serialization is used to save session state in ASP.NET and to copy objects to the Clipboard in Windows Forms.</span></span> <span data-ttu-id="47aa0-106">Она также используется при удаленном взаимодействии для передачи объектов по значению с одного домена приложения в другой.</span><span class="sxs-lookup"><span data-stu-id="47aa0-106">It is also used by remoting to pass objects by value from one application domain to another.</span></span>

[!INCLUDE [binary-serialization-warning](../../../includes/binary-serialization-warning.md)]

## <a name="persistent-storage"></a><span data-ttu-id="47aa0-107">Постоянное хранилище</span><span class="sxs-lookup"><span data-stu-id="47aa0-107">Persistent storage</span></span>
<span data-ttu-id="47aa0-108">Часто необходимо сохранить значение полей объекта на диск, а впоследствии извлечь эти данные.</span><span class="sxs-lookup"><span data-stu-id="47aa0-108">It is often necessary to store the value of the fields of an object to disk and then, later, retrieve this data.</span></span> <span data-ttu-id="47aa0-109">Несмотря на то что это несложно сделать и без сериализации, такой подход часто утомителен, и существует большая вероятность возникновения ошибок, и, кроме того, он постепенно усложняется по мере необходимости отслеживания иерархии объектов.</span><span class="sxs-lookup"><span data-stu-id="47aa0-109">Although this is easy to achieve without relying on serialization, this approach is often cumbersome and error prone, and becomes progressively more complex when you need to track a hierarchy of objects.</span></span> <span data-ttu-id="47aa0-110">Например, написание большого бизнес-приложения, содержащего тысячи объектов, и необходимость написания кода для сохранения полей и свойств на диск и их восстановления для каждого объекта.</span><span class="sxs-lookup"><span data-stu-id="47aa0-110">Imagine writing a large business application, that contains thousands of objects, and having to write code to save and restore the fields and properties to and from disk for each object.</span></span> <span data-ttu-id="47aa0-111">Сериализация обеспечивает удобный механизм достижения этой цели.</span><span class="sxs-lookup"><span data-stu-id="47aa0-111">Serialization provides a convenient mechanism for achieving this objective.</span></span>

<span data-ttu-id="47aa0-112">Среда CLR управляет способом хранения объектов в памяти и обеспечивает механизм автоматической сериализации с помощью [отражения](../../../docs/framework/reflection-and-codedom/reflection.md).</span><span class="sxs-lookup"><span data-stu-id="47aa0-112">The common language runtime manages how objects are stored in memory and provides an automated serialization mechanism by using [reflection](../../../docs/framework/reflection-and-codedom/reflection.md).</span></span> <span data-ttu-id="47aa0-113">При сериализации объекта имя класса, сборка и все члены данных экземпляра класса записываются в хранилище.</span><span class="sxs-lookup"><span data-stu-id="47aa0-113">When an object is serialized, the name of the class, the assembly, and all the data members of the class instance are written to storage.</span></span> <span data-ttu-id="47aa0-114">Объекты часто содержат ссылки на другие экземпляры в переменных-членах.</span><span class="sxs-lookup"><span data-stu-id="47aa0-114">Objects often store references to other instances in member variables.</span></span> <span data-ttu-id="47aa0-115">При сериализации класса модуль сериализации отслеживает уже сериализованные объекты, на которые указывает ссылка, чтобы предотвратить повторную сериализацию объекта.</span><span class="sxs-lookup"><span data-stu-id="47aa0-115">When the class is serialized, the serialization engine tracks referenced objects, already serialized, to ensure that the same object is not serialized more than once.</span></span> <span data-ttu-id="47aa0-116">Архитектура сериализации, обеспечиваемая .NET Framework, правильно обрабатывает графы объектов и циклические ссылки автоматически.</span><span class="sxs-lookup"><span data-stu-id="47aa0-116">The serialization architecture provided with the .NET Framework correctly handles object graphs and circular references automatically.</span></span> <span data-ttu-id="47aa0-117">Единственным требованием к графам объектов является то, что все объекты, на которые ссылается сериализуемый объект, также должны быть отмечены как `Serializable` (дополнительные сведения см. в разделе [Базовая сериализация](basic-serialization.md)).</span><span class="sxs-lookup"><span data-stu-id="47aa0-117">The only requirement placed on object graphs is that all objects, referenced by the serialized object, must also be marked as `Serializable` (for more information, see [Basic Serialization](basic-serialization.md)).</span></span> <span data-ttu-id="47aa0-118">Если этого не сделать, при попытке сериализовать неотмеченный объект модулем сериализации будет выдано исключение.</span><span class="sxs-lookup"><span data-stu-id="47aa0-118">If this is not done, an exception will be thrown when the serializer attempts to serialize the unmarked object.</span></span>

<span data-ttu-id="47aa0-119">При десериализации сериализованного класса он создается заново, а значения всех членов данных автоматически восстанавливаются.</span><span class="sxs-lookup"><span data-stu-id="47aa0-119">When the serialized class is deserialized, the class is recreated and the values of all the data members are automatically restored.</span></span>

## <a name="marshal-by-value"></a><span data-ttu-id="47aa0-120">Маршалинг по значению</span><span class="sxs-lookup"><span data-stu-id="47aa0-120">Marshal by value</span></span>
<span data-ttu-id="47aa0-121">Объекты являются допустимыми только в том домене приложения, в котором они были созданы.</span><span class="sxs-lookup"><span data-stu-id="47aa0-121">Objects are valid only in the application domain where they are created.</span></span> <span data-ttu-id="47aa0-122">Любая попытка передать объект как параметр или вернуть его как результат будет завершаться ошибкой, пока объект наследуется от `MarshalByRefObject` или отмечен как `Serializable`.</span><span class="sxs-lookup"><span data-stu-id="47aa0-122">Any attempt to pass the object as a parameter or return it as a result will fail unless the object derives from `MarshalByRefObject` or is marked as `Serializable`.</span></span> <span data-ttu-id="47aa0-123">Если объект отмечен как `Serializable`, он будет автоматически сериализован, передан из одного домена приложений в другой, а затем десериализован с целью создания точной копии объекта во втором домене приложения.</span><span class="sxs-lookup"><span data-stu-id="47aa0-123">If the object is marked as `Serializable`, the object will automatically be serialized, transported from the one application domain to the other, and then deserialized to produce an exact copy of the object in the second application domain.</span></span> <span data-ttu-id="47aa0-124">Этот процесс обычно называют маршалинг по значению.</span><span class="sxs-lookup"><span data-stu-id="47aa0-124">This process is typically referred to as marshal-by-value.</span></span>

<span data-ttu-id="47aa0-125">Когда объект наследуется от `MarshalByRefObject`, из одного домена приложения в другой передается ссылка на объект, а не сам объект.</span><span class="sxs-lookup"><span data-stu-id="47aa0-125">When an object derives from `MarshalByRefObject`, an object reference is passed from one application domain to another, rather than the object itself.</span></span> <span data-ttu-id="47aa0-126">Можно также пометить объект, который является производным от `MarshalByRefObject`, как `Serializable`.</span><span class="sxs-lookup"><span data-stu-id="47aa0-126">You can also mark an object that derives from `MarshalByRefObject` as `Serializable`.</span></span> <span data-ttu-id="47aa0-127">Когда этот объект используется для удаленного взаимодействия, модуль форматирования, отвечающий за сериализацию и предварительно настроенный с помощью суррогатного селектора (`SurrogateSelector`), берет на себя управление процессом сериализации и заменяет все объекты, унаследованные от `MarshalByRefObject` с помощью прокси.</span><span class="sxs-lookup"><span data-stu-id="47aa0-127">When this object is used with remoting, the formatter responsible for serialization, which has been preconfigured with a surrogate selector (`SurrogateSelector`), takes control of the serialization process, and replaces all objects derived from `MarshalByRefObject` with a proxy.</span></span> <span data-ttu-id="47aa0-128">При отсутствии `SurrogateSelector` архитектура сериализации следует стандартным правилам сериализации, представленным в разделе [Этапы процесса сериализации](steps-in-the-serialization-process.md).</span><span class="sxs-lookup"><span data-stu-id="47aa0-128">Without the `SurrogateSelector` in place, the serialization architecture follows the standard serialization rules described in [Steps in the Serialization Process](steps-in-the-serialization-process.md).</span></span>  

## <a name="related-sections"></a><span data-ttu-id="47aa0-129">См. также</span><span class="sxs-lookup"><span data-stu-id="47aa0-129">Related sections</span></span>  
 [<span data-ttu-id="47aa0-130">Двоичная сериализация</span><span class="sxs-lookup"><span data-stu-id="47aa0-130">Binary Serialization</span></span>](../../../docs/standard/serialization/binary-serialization.md)  
 <span data-ttu-id="47aa0-131">Описывает механизм двоичной сериализации, входящий в среду CLR.</span><span class="sxs-lookup"><span data-stu-id="47aa0-131">Describes the binary serialization mechanism that is included with the common language runtime.</span></span>  
  
 <span data-ttu-id="47aa0-132">\ [удаленного взаимодействия .NET](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="47aa0-132">[.NET Remoting](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/72x4h507(v=vs.100))\</span></span>
 <span data-ttu-id="47aa0-133">Описывает различные методы взаимодействия, доступные в платформе .NET Framework для удаленного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="47aa0-133">Describes the various communications methods available in the .NET Framework for remote communications.</span></span>  
  
 [<span data-ttu-id="47aa0-134">Сериализация XML и SOAP</span><span class="sxs-lookup"><span data-stu-id="47aa0-134">XML and SOAP Serialization</span></span>](../../../docs/standard/serialization/xml-and-soap-serialization.md)  
 <span data-ttu-id="47aa0-135">Описывает механизм сериализации XML и SOAP, входящий в среду CLR.</span><span class="sxs-lookup"><span data-stu-id="47aa0-135">Describes the XML and SOAP serialization mechanism that is included with the common language runtime.</span></span>
