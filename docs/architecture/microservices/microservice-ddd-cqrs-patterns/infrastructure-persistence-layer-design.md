---
title: Проектирование уровня сохраняемости инфраструктуры
description: Архитектура микрослужб .NET для контейнерных приложений .NET | Шаблон репозитория при проектировании уровня сохраняемости инфраструктуры.
ms.date: 10/08/2018
ms.openlocfilehash: f1c5df1cc5672760374610a416ae22b45cd76c25
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/07/2019
ms.locfileid: "73737942"
---
# <a name="design-the-infrastructure-persistence-layer"></a>Проектирование уровня сохраняемости инфраструктуры

Компоненты сохраняемости данных предоставляют доступ к данным, размещенным в границах микрослужбы (то есть в границах базы данных микрослужбы). Они содержат фактическую реализацию компонентов, таких как репозитории и классы [единиц работы](https://martinfowler.com/eaaCatalog/unitOfWork.html), например пользовательские объекты Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext>. DbContext в EF реализует оба шаблона: репозитория и единицы работы.

## <a name="the-repository-pattern"></a>Шаблон репозитория

Репозитории — это классы или компоненты, которые содержат логику, необходимую для доступа к источникам данных. Репозитории предоставляют централизованные функции для доступа к данным, позволяя улучшить управление и отделить инфраструктуру или технологию, используемую для доступа к данным, от модели предметной области. Если вы используете объектно-реляционное сопоставление (ORM), например Entity Framework, код, который необходимо реализовать, упрощается благодаря LINQ и строгой типизации. Это позволяет сосредоточиться на логике сохраняемости данных, а не на вспомогательных функциях для доступа к данным.

Шаблон репозитория представляет собой хорошо задокументированный способ работы с источниками данных. В книге [Шаблоны архитектуры корпоративных приложений](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/) Мартин Фаулер описывает репозиторий следующим образом.

> Репозиторий выполняет задачи в роли посредника между уровнями модели предметной области и сопоставлением данных и действует похожим образом для набора объектов предметной области в памяти. Клиентские объекты декларативно создают запросы и отправляют их в репозитории для получения ответов. По существу, репозиторий инкапсулирует набор объектов, хранящихся в базе данных, и операции, которые можно выполнить над этими объектами, и предоставляет уровень, который находится ближе к уровню сохраняемости. Кроме того, репозитории поддерживают четкое и однонаправленное разделение между рабочей предметной областью и распределением или сопоставлением данных.

### <a name="define-one-repository-per-aggregate"></a>Определение одного репозитория для каждого агрегата

Для каждого агрегата или корня агрегации следует создать только один класс репозитория. В микрослужбе на основе шаблонов предметно-ориентированного проектирования единственный канал, который следует использовать для обновления базы данных, — репозитории. Это вызвано тем, что у репозитория есть связь "один к одному" с корнем агрегации, который управляет инвариантностью агрегата и согласованностью транзакций. Отправлять запросы к базе данных также можно через другие каналы (например, с использованием подхода CQRS), так как запросы не изменяют состояния базы данных. Однако область транзакций (то есть обновления) всегда должна контролироваться репозиториями и корнями агрегации.

По сути, репозиторий позволяет заполнять данные в памяти, которые поступают из базы данных в форме объектов предметной области. После того как объекты оказываются в памяти, их можно изменить и затем сохранить обратно в базе данных с помощью транзакций.

Как уже отмечалось, если вы используете шаблон архитектуры CQS/CQRS, то начальные запросы будут выполнены с помощью сторонних запросов модели предметной области, которые выполняются с помощью простых инструкций SQL с использованием Dapper. Этот подход является гораздо более гибким по сравнению с репозиториями, так как вы можете отправлять запросы к любым необходимым таблицам и объединять эти таблицы, и эти запросы не ограничены правилами агрегатов. Эти данные перейдут на уровень представления или в клиентское приложение.

Если пользователь вносит изменения, то данные для обновления поступают из клиентского приложения или с уровня представления на уровень приложения (например, в службу веб-API). При получении команды в обработчике команд вы получаете данные, которые хотите обновить, из базы данных с помощью репозитория. Вы обновляете эти данные в памяти, используя данные, переданные с командами, а затем добавляете или обновляете данные (объекты предметной области) в базе данных с помощью транзакций.

Важно еще раз подчеркнуть, что следует определять только один репозиторий для одного корня агрегации, как показано на рис. 7-17. Чтобы корень агрегации поддерживал транзакционную согласованность между всеми объектами в агрегате, не следует создавать репозиторий для каждой таблицы в базе данных.

![Схема, на которой показана связь между предметной областью и остальной инфраструктурой.](./media/infrastructure-persistence-layer-design/repository-aggregate-database-table-relationships.png)

**Рис. 7-17**. Связь между репозиториями, агрегатами и таблицами базы данных

На схеме выше показаны связи между уровнями предметной области и инфраструктуры. агрегат Buyer зависит от интерфейса IBuyerRepository, а агрегат Order — от интерфейса IOrderRepository. Эти интерфейсы реализуются на уровне инфраструктуры соответствующими репозиториями, зависимыми от UnitOfWork, которая реализуется там же и обращается к таблицам на уровне данных.

### <a name="enforce-one-aggregate-root-per-repository"></a>Использование только одного корня агрегации для одного репозитория

При создании архитектуры репозитория может оказаться полезным правило, которое позволяет создать только один репозиторий для одного корня агрегации. Вы можете создать универсальный или базовый репозиторий, ограничивающий типы объектов, с которым он работает, интерфейсом метки `IAggregateRoot`.

Таким образом, в каждом классе репозитория, реализованном на уровне инфраструктуры, реализуется собственный контракт или интерфейс, как показано в следующем коде:

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

Каждый интерфейс репозитория реализует общий интерфейс IRepository:

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

Тем не менее более эффективный способ с помощью кода внедрить соглашение о том, что каждый репозиторий связан с одним корнем агрегации, — реализовать общий тип репозитория. Таким образом, вы явным образом используете репозиторий для нацеливания на определенный агрегат. Это можно сделать, реализовав общий репозиторий в базовом интерфейсе `IRepository`, как показано в следующем коде:

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a>Шаблон репозитория упрощает тестирование логики приложения

Шаблон репозитория дает возможность легко протестировать приложение с помощью модульных тестов. Помните, что модульные тесты проверяют только код, а не инфраструктуру, поэтому для проверки инфраструктуры лучше использовать абстракции репозитория.

Как отмечалось в предыдущем разделе, рекомендуется определить и разместить интерфейсы репозитория на уровне модели предметной области, чтобы уровень приложения (например, микрослужба веб-API) напрямую не зависел от уровня инфраструктуры, на котором реализованы фактические классы репозитория. Сделав это и используя внедрение зависимостей в контроллерах веб-API, вы можете реализовать макеты репозиториев, которые возвращают псевдоданные вместо данных из базы данных. Этот подход с разделением позволяет создавать и запускать модульные тесты, которые нацелены на логику приложения и не требуют подключения к базе данных.

Подключение к базе данных может завершиться неудачно, а главное — выполнение нескольких сотен тестов для базы данных не рекомендуется по двум причинам. Во-первых, это может занять много времени из-за большого количества тестов. Во-вторых, записи в базе данных могут измениться и повлиять на результаты тестов, поэтому они могут быть несогласованными. Тесты, которые выполняются над базой данных, — это не модульные тесты, а тесты интеграции. У вас должно быть много модульных тестов, которые быстро выполняются, и меньшее количество тестов интеграции, которые выполняются над базами данных.

С точки зрения проблемы разделения для модульных тестов, ваша логика работает над объектами предметной области в памяти. Предполагается, что класс репозитория доставил эти объекты. После того как логика изменяет объекты предметной области, предполагается, что класс репозитория правильно сохраняет их. Важно создавать модульные тесты для модели предметной области и ее логики. Корни агрегации представляют собой главные границы согласованности в предметно-ориентированном проектировании.

Репозитории, реализованные в eShopOnContainers, зависят от реализации класса DbContext в EF Core для шаблонов репозитория и единицы работы с помощью средства отслеживания изменений, которое помогает избежать дублирования функций.

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a>Разница между шаблоном репозитория и устаревшим шаблоном класса для доступа к данным

Объект доступа к данным осуществляет доступ к данным и операции сохраняемости в хранилище. Репозиторий отмечает данные операциями, которые вы хотите выполнить в памяти, для объекта единицы работы (как в EF при использовании класса <xref:Microsoft.EntityFrameworkCore.DbContext>), но эти обновления не выполняются в базе данных немедленно.

Единица работы — это одна транзакция, которая включает несколько операций вставки, обновления или удаления. Проще говоря, это означает, что все операции по вставке, обновлению и удалению данных для конкретного действия пользователя (например, регистрация на веб-сайте) обрабатываются в рамках одной транзакции. Это более эффективно, чем использовать несколько транзакций базы данных, которые выполняются поочередно.

Эти несколько операций сохраняемости выполняются позднее в одном действии, когда из кода на уровне приложения поступает команда на их выполнение. Решение о применении изменений в памяти к фактическому хранилищу базы данных обычно основано на [шаблоне единицы работы](https://martinfowler.com/eaaCatalog/unitOfWork.html). В EF шаблон единицы работы реализуется как <xref:Microsoft.EntityFrameworkCore.DbContext>.

Во многих случаях этот шаблон, или способ применения операций к хранилищам, может повысить производительность приложения и снизить риск возникновения несоответствий. Кроме того, он снижает блокировку транзакций в таблицах базы данных, потому что все необходимые операции фиксируются как часть одной транзакции. Это более эффективно по сравнению с выполнением многих изолированных операций в базе данных. Таким образом, в выбранных ORM можно оптимизировать выполнение запросов к базам данных путем группирования нескольких действий обновления в одной и той же транзакции в отличие от выполнения нескольких отдельных мелких транзакций.

### <a name="repositories-shouldnt-be-mandatory"></a>Репозитории не должны быть обязательными

Пользовательские репозитории удобны по перечисленным выше причинам, и именно: этот подход используется для упорядочивания микрослужб в eShopOnContainers. Однако этот подход необязателен в предметно-ориентированном проектировании и даже при разработке в .NET в целом.

Например, Джимми Богард в качестве прямого отзыва на это руководство отметил следующее:

> Пожалуй, это мой самый большой отзыв. Я не большой поклонник репозиториев, главным образом, потому, что они скрывают важные детали механизма сохраняемости. Именно поэтому я пользуюсь MediatR для команд. Я могу использовать все возможности уровня сохраняемости и отправить все это поведение предметной области в корни агрегации. Обычно я не хочу создавать макеты репозиториев, так как этот тест интеграции нужно проводить на реальной системе. Переход на CQRS означал, что у нас действительно больше не было потребности в репозиториях.

Репозитории могут быть удобны, но они не так важны для предметно-ориентированного проектирования, как шаблон агрегата и обширная модель предметной области. Поэтому вы сами должны решить, стоит ли использовать шаблон репозитория в каждом конкретном случае. В любом случае вы будете использовать шаблон репозитория при каждом использовании EF Core, хотя в этом случае репозиторий охватывает всю микрослужбу или ограниченный контекст.

## <a name="additional-resources"></a>Дополнительные ресурсы

### <a name="repository-pattern"></a>Шаблон репозитория

- **Шаблон репозитория** \
  <https://deviq.com/repository-pattern/>

- **Эдвард Хиятт и Роб Ми (Edward Hieatt и Rob Mee). Шаблон репозитория.** \
  <https://martinfowler.com/eaaCatalog/repository.html>

- **Шаблон репозитория** \
  <https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)>

- **Эрик Эванс (Eric Evans). Domain-Driven Design: Tackling Complexity in the Heart of Software**. (Книга; включает в себя обсуждение шаблона репозитория) \
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="unit-of-work-pattern"></a>Шаблон единицы работы

- **Мартин Фоулер (Martin Fowler). Шаблон единицы работы.** \
  <https://martinfowler.com/eaaCatalog/unitOfWork.html>

- **Реализация шаблонов репозитория и единиц работы в приложении ASP.NET MVC** \
  <https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application>

>[!div class="step-by-step"]
>[Назад](domain-events-design-implementation.md)
>[Вперед](infrastructure-persistence-layer-implemenation-entity-framework-core.md)
