---
title: Проектирование модели предметной области микрослужбы
description: Архитектура микрослужб .NET для контейнерных приложений .NET | Ключевые понятия при разработке модели предметной области, ориентированной на DDD.
ms.date: 01/30/2020
ms.openlocfilehash: 628fb5c76362ec8f48367b3d69d16ea6ebd24f09
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "77502325"
---
# <a name="design-a-microservice-domain-model"></a><span data-ttu-id="30235-103">Проектирование модели предметной области микрослужбы</span><span class="sxs-lookup"><span data-stu-id="30235-103">Design a microservice domain model</span></span>

<span data-ttu-id="30235-104">*Определите одну расширенную модель предметной области для каждой бизнес-микрослужбы или ограниченного контекста.*</span><span class="sxs-lookup"><span data-stu-id="30235-104">*Define one rich domain model for each business microservice or Bounded Context.*</span></span>

<span data-ttu-id="30235-105">Ваша цель состоит в создании одной целостной модели предметной области для каждой бизнес-микрослужбы или ограниченного контекста (BC).</span><span class="sxs-lookup"><span data-stu-id="30235-105">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="30235-106">Однако следует помнить, что BC или бизнес-микрослужба иногда может состоять из нескольких физических служб, совместно использующих одну модель предметной области.</span><span class="sxs-lookup"><span data-stu-id="30235-106">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="30235-107">Модель предметной области должна определять правила, поведение, бизнес-язык и ограничения для одного ограниченного контекста или бизнес-микрослужбы, которая его представляет.</span><span class="sxs-lookup"><span data-stu-id="30235-107">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="30235-108">Шаблон сущности предметной области</span><span class="sxs-lookup"><span data-stu-id="30235-108">The Domain Entity pattern</span></span>

<span data-ttu-id="30235-109">Сущности представляют объекты предметной области и в первую очередь определяются их идентификаторами, непрерывностью и сохраняемостью с течением временем, а не только атрибутами, которые их составляют.</span><span class="sxs-lookup"><span data-stu-id="30235-109">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="30235-110">Как сказал Эрик Эванс (Eric Evans), "объект, определяемый в первую очередь по идентификатору, называется сущностью".</span><span class="sxs-lookup"><span data-stu-id="30235-110">As Eric Evans says, “an object primarily defined by its identity is called an Entity.”</span></span> <span data-ttu-id="30235-111">Сущности являются очень важным понятием в модели предметной области, так как они являются основой модели.</span><span class="sxs-lookup"><span data-stu-id="30235-111">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="30235-112">Следовательно, вы должны идентифицировать и разрабатывать их очень внимательно.</span><span class="sxs-lookup"><span data-stu-id="30235-112">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="30235-113">*Идентификатор сущности может пересекать несколько микрослужб или ограниченных контекстов.*</span><span class="sxs-lookup"><span data-stu-id="30235-113">*An entity’s identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="30235-114">Один и тот же идентификатор (то есть то же значение `Id`, хотя и необязательно та же сущность предметной области) может быть смоделирован в нескольких ограниченных контекстах или микрослужбах.</span><span class="sxs-lookup"><span data-stu-id="30235-114">The same identity (that is, the same `Id` value, although perhaps not the same domain entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="30235-115">Однако это не означает, что в нескольких ограниченных контекстах будет реализована одна и та же сущность с теми же атрибутами и логикой.</span><span class="sxs-lookup"><span data-stu-id="30235-115">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="30235-116">Вместо этого атрибуты и поведение сущностей в каждом ограниченном контексте находятся в рамках требований предметной области каждого конкретного ограниченного контекста.</span><span class="sxs-lookup"><span data-stu-id="30235-116">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context’s domain.</span></span>

<span data-ttu-id="30235-117">Например, сущность "покупатель" может иметь большинство атрибутов человека, определенных в сущности "пользователь" в микрослужбе профиля или идентификации, включая идентификатор пользователя.</span><span class="sxs-lookup"><span data-stu-id="30235-117">For instance, the buyer entity might have most of a person’s attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="30235-118">Но сущность "покупатель" в микрослужбе заказов может иметь меньше атрибутов, так как только некоторые данные покупателя связаны с обработкой заказа.</span><span class="sxs-lookup"><span data-stu-id="30235-118">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="30235-119">Контекст каждой микрослужбы или ограниченного контекста влияет на его модель предметной области.</span><span class="sxs-lookup"><span data-stu-id="30235-119">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="30235-120">*Помимо реализации атрибутов данных, сущности предметной области должны реализовывать поведение.*</span><span class="sxs-lookup"><span data-stu-id="30235-120">*Domain entities must implement behavior in addition to implementing data attributes.*</span></span>

<span data-ttu-id="30235-121">Сущность предметной области в DDD должна реализовывать логику предметной области или поведение, связанное с данными этой сущности (объекта, доступного в памяти).</span><span class="sxs-lookup"><span data-stu-id="30235-121">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="30235-122">Например, в рамках класса сущности заказа должна быть задана бизнес-логика и операции, реализованные как методы для таких задач, как добавление позиции заказа, проверка данных и итоговый расчет.</span><span class="sxs-lookup"><span data-stu-id="30235-122">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="30235-123">Методы сущности обеспечивают инварианты и правила сущности вместо определения этих правил как распределенных на уровне приложения.</span><span class="sxs-lookup"><span data-stu-id="30235-123">The entity’s methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="30235-124">На рис. 7-8 показана сущность предметной области, реализующая не только атрибуты данных, но также и операции или методы с логикой, связанной с предметной областью.</span><span class="sxs-lookup"><span data-stu-id="30235-124">Figure 7-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![Схема, на которой показан шаблон сущности предметной области.](./media/microservice-domain-model/domain-entity-pattern.png)

<span data-ttu-id="30235-126">**Рис. 7-8**.</span><span class="sxs-lookup"><span data-stu-id="30235-126">**Figure 7-8**.</span></span> <span data-ttu-id="30235-127">Пример структуры сущности предметной области, реализующей данные и поведение</span><span class="sxs-lookup"><span data-stu-id="30235-127">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="30235-128">Сущность модели предметной области реализует поведение через методы, то есть это не "слабая" модель.</span><span class="sxs-lookup"><span data-stu-id="30235-128">A domain model entity implements behaviors through methods, that is, it's not an "anemic" model.</span></span> <span data-ttu-id="30235-129">Конечно, иногда у вас могут быть сущности, не реализующие никакую логику в рамках класса сущностей.</span><span class="sxs-lookup"><span data-stu-id="30235-129">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="30235-130">Это может произойти в дочерних сущностях в агрегате, если дочерняя сущность не имеет никакой специальной логики, так как большая часть логики определяется в корне агрегата.</span><span class="sxs-lookup"><span data-stu-id="30235-130">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="30235-131">При наличии сложной микрослужбы со значительным объемом логики, реализуемой в классах службы вместо сущностей предметной области, вы рискуете попасть в слабую модель предметной области, что объясняется в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="30235-131">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="30235-132">Сравнение расширенной и слабой моделей предметной области</span><span class="sxs-lookup"><span data-stu-id="30235-132">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="30235-133">В своей записи в блоге [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html) Мартин Фаулер (Martin Fowler) описывает слабую модель предметной области следующим образом.</span><span class="sxs-lookup"><span data-stu-id="30235-133">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="30235-134">Основным признаком слабой модели предметной области является то, что на первый взгляд она выглядит как что-то реальное.</span><span class="sxs-lookup"><span data-stu-id="30235-134">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="30235-135">Там есть объекты, многие из которых названы по именам в пространстве предметной области, и эти объекты связаны широкими отношениями и структурой, которую имеют настоящие модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="30235-135">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="30235-136">Замкнутый круг возникает, когда вы посмотрите на поведение и поймете, что это вряд ли поведение в этих объектах, делающее их чем-то большим, чем контейнеры методов получения и задания.</span><span class="sxs-lookup"><span data-stu-id="30235-136">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="30235-137">Конечно, при использовании слабой модели предметной области эти модели данных будут использоваться из набора объектов службы (обычно называемого *слоем предметной области*), который фиксирует всю бизнес-логику или логику предметной области.</span><span class="sxs-lookup"><span data-stu-id="30235-137">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="30235-138">Слой предметной области находится вверху модели данных и использует модель данных так же, как данные.</span><span class="sxs-lookup"><span data-stu-id="30235-138">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="30235-139">Слабая модель предметной области — это просто структура процедурного стиля.</span><span class="sxs-lookup"><span data-stu-id="30235-139">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="30235-140">Слабые объекты сущности не являются реальными объектами из-за отсутствия поведения (методов).</span><span class="sxs-lookup"><span data-stu-id="30235-140">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="30235-141">Они лишь содержат свойства данных, и, таким образом, это не объектно-ориентированный проект.</span><span class="sxs-lookup"><span data-stu-id="30235-141">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="30235-142">Помещая все поведение в объекты служб (слой предметной области), вы, в сущности, получаете [плохо структурированный код](https://en.wikipedia.org/wiki/Spaghetti_code) или [сценарии транзакции](https://martinfowler.com/eaaCatalog/transactionScript.html) и таким образом теряете преимущества, которые предоставляет модель предметной области.</span><span class="sxs-lookup"><span data-stu-id="30235-142">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="30235-143">Как бы там ни было, если вы имеете очень простой ограниченный контекст или микрослужбу (службу CRUD), слабая модель предметной области в форме объектов сущности только со свойствами данных может быть достаточно хороша, и, возможно, не имеет смысла реализовывать более сложные шаблоны DDD.</span><span class="sxs-lookup"><span data-stu-id="30235-143">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="30235-144">В таком случае это будет просто модель сохраняемости, так как вы намеренно создали сущность только с данными для целей CRUD.</span><span class="sxs-lookup"><span data-stu-id="30235-144">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="30235-145">Именно поэтому архитектуры микрослужб прекрасно сочетаются с мультиархитектурным подходом, учитывающим каждый ограниченный контекст.</span><span class="sxs-lookup"><span data-stu-id="30235-145">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="30235-146">Например, в приложении eShopOnContainers микрослужба заказов реализует шаблоны DDD, а микрослужба каталога, представляющая собой простую службу CRUD, — нет.</span><span class="sxs-lookup"><span data-stu-id="30235-146">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="30235-147">Некоторые говорят, что слабая модель предметной области является антишаблоном.</span><span class="sxs-lookup"><span data-stu-id="30235-147">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="30235-148">В действительности это зависит от того, что вы реализуете.</span><span class="sxs-lookup"><span data-stu-id="30235-148">It really depends on what you are implementing.</span></span> <span data-ttu-id="30235-149">Если вы создаете довольно простую микрослужбу (например, службу CRUD), то слабая модель предметной области не является антишаблоном.</span><span class="sxs-lookup"><span data-stu-id="30235-149">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="30235-150">Однако если вам предстоит иметь дело со сложной предметной областью микрослужбы, имеющей множество постоянно меняющихся бизнес-правил, слабая модель предметной области может быть антишаблоном для этой микрослужбы или ограниченного контекста.</span><span class="sxs-lookup"><span data-stu-id="30235-150">However, if you need to tackle the complexity of a microservice’s domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="30235-151">В этом случае проектирование в соответствии с расширенной моделью предметной области с сущностями, содержащими данные и поведение, а также с реализацией дополнительных шаблонов DDD (агрегатов, объектов значений и т. п.) может обеспечить огромные преимущества для долгосрочного успешного существования такой микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="30235-151">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="30235-152">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="30235-152">Additional resources</span></span>

- <span data-ttu-id="30235-153">**DevIQ. Сущность предметной области** </span><span class="sxs-lookup"><span data-stu-id="30235-153">**DevIQ. Domain Entity** </span></span>\
  <https://deviq.com/entity/>

- <span data-ttu-id="30235-154">**Мартин Фоулер (Martin Fowler). Модель предметной области** </span><span class="sxs-lookup"><span data-stu-id="30235-154">**Martin Fowler. The Domain Model** </span></span>\
  <https://martinfowler.com/eaaCatalog/domainModel.html>

- <span data-ttu-id="30235-155">**Мартин Фоулер (Martin Fowler). Слабая модель предметной области** </span><span class="sxs-lookup"><span data-stu-id="30235-155">**Martin Fowler. The Anemic Domain Model** </span></span>\
  <https://martinfowler.com/bliki/AnemicDomainModel.html>

### <a name="the-value-object-pattern"></a><span data-ttu-id="30235-156">Шаблон объекта значения</span><span class="sxs-lookup"><span data-stu-id="30235-156">The Value Object pattern</span></span>

<span data-ttu-id="30235-157">Как заметил Эрик Эванс (Eric Evans), "многие объекты не имеют концептуальной идентификации.</span><span class="sxs-lookup"><span data-stu-id="30235-157">As Eric Evans has noted, “Many objects do not have conceptual identity.</span></span> <span data-ttu-id="30235-158">Эти объекты описывают определенные характеристики предмета".</span><span class="sxs-lookup"><span data-stu-id="30235-158">These objects describe certain characteristics of a thing.”</span></span>

<span data-ttu-id="30235-159">Сущности требуется идентификатор, но в системе имеется множество объектов, у которых он отсутствует, например шаблон объекта значения.</span><span class="sxs-lookup"><span data-stu-id="30235-159">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="30235-160">Объект значения — это объект без концептуального идентификатора, который описывает аспект предметной области.</span><span class="sxs-lookup"><span data-stu-id="30235-160">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="30235-161">Это объекты, создаваемые для представления элементов структуры, которые вы считаете временными.</span><span class="sxs-lookup"><span data-stu-id="30235-161">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="30235-162">Вас интересует, *что* они собой представляют, а не *чем* они являются.</span><span class="sxs-lookup"><span data-stu-id="30235-162">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="30235-163">В качестве примеров можно привести числа и строки, но это также могут быть высокоуровневые понятия, такие как группы атрибутов.</span><span class="sxs-lookup"><span data-stu-id="30235-163">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="30235-164">То, что является сущностью в микрослужбе, может не быть сущностью в другой микрослужбе, поскольку во втором случае ограниченный контекст может иметь другой смысл.</span><span class="sxs-lookup"><span data-stu-id="30235-164">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="30235-165">Например, адрес в приложении электронной коммерции может вообще не иметь идентификатора, так как он может лишь представлять группу атрибутов профиля клиента — человека или компании.</span><span class="sxs-lookup"><span data-stu-id="30235-165">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer’s profile for a person or company.</span></span> <span data-ttu-id="30235-166">В этом случае адрес должен классифицироваться как объект значения.</span><span class="sxs-lookup"><span data-stu-id="30235-166">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="30235-167">Однако в приложении для компании, обслуживающей электроэнергетическую систему общего пользования, адрес клиента может быть важен для предметной области бизнеса.</span><span class="sxs-lookup"><span data-stu-id="30235-167">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="30235-168">Следовательно, адрес должен иметь идентификатор, чтобы систему выставления счетов можно было привязать непосредственно к адресу.</span><span class="sxs-lookup"><span data-stu-id="30235-168">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="30235-169">В этом случае адрес должен классифицироваться как сущность предметной области.</span><span class="sxs-lookup"><span data-stu-id="30235-169">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="30235-170">Человек с именем и фамилией обычно является сущностью, так как человек имеет идентификатор, даже если имя и фамилия совпадают с другим набором значений, например, если эти имя и фамилия также относятся к другому человеку.</span><span class="sxs-lookup"><span data-stu-id="30235-170">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="30235-171">Объектами значений трудно управлять в реляционных базах данных и моделях ORM, таких как Entity Framework (EF), тогда как в документоориентированных базах данных их гораздо проще реализовать и использовать.</span><span class="sxs-lookup"><span data-stu-id="30235-171">Value objects are hard to manage in relational databases and ORMs like Entity Framework (EF), whereas in document-oriented databases they are easier to implement and use.</span></span>

<span data-ttu-id="30235-172">В EF Core 2.0 и более поздних версий представлена функция [Принадлежащие сущности](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting), которая упрощает обработку объектов значений, как мы рассмотрим подробно позже.</span><span class="sxs-lookup"><span data-stu-id="30235-172">EF Core 2.0 and later versions include the [Owned Entities](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) feature that makes it easier to handle value objects, as we’ll see in detail later on.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="30235-173">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="30235-173">Additional resources</span></span>

- <span data-ttu-id="30235-174">**Мартин Фоулер (Martin Fowler). Шаблон объекта значения** </span><span class="sxs-lookup"><span data-stu-id="30235-174">**Martin Fowler. Value Object pattern** </span></span>\
  <https://martinfowler.com/bliki/ValueObject.html>

- <span data-ttu-id="30235-175">**Объект значения** </span><span class="sxs-lookup"><span data-stu-id="30235-175">**Value Object** </span></span>\
  <https://deviq.com/value-object/>

- <span data-ttu-id="30235-176">**Объекты значений при разработке на основе тестирования** </span><span class="sxs-lookup"><span data-stu-id="30235-176">**Value Objects in Test-Driven Development** </span></span>\
  [https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)

- <span data-ttu-id="30235-177">**Эрик Эванс (Eric Evans). Domain-Driven Design: Tackling Complexity in the Heart of Software**.</span><span class="sxs-lookup"><span data-stu-id="30235-177">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="30235-178">(Книга, в которой рассматриваются объекты значений) </span><span class="sxs-lookup"><span data-stu-id="30235-178">(Book; includes a discussion of value objects) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="30235-179">Шаблон агрегата</span><span class="sxs-lookup"><span data-stu-id="30235-179">The Aggregate pattern</span></span>

<span data-ttu-id="30235-180">Модель предметной области содержит кластеры разных сущностей данных и процессы, которые могут управлять значительными областями функций, такими как выполнение заказов или инвентаризация.</span><span class="sxs-lookup"><span data-stu-id="30235-180">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfillment or inventory.</span></span> <span data-ttu-id="30235-181">Более мелкой единицей DDD является агрегат, описывающий кластер или группу сущностей и поведений, которые могут рассматриваться как единый блок.</span><span class="sxs-lookup"><span data-stu-id="30235-181">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="30235-182">Агрегат обычно определяется на основе необходимых транзакций.</span><span class="sxs-lookup"><span data-stu-id="30235-182">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="30235-183">Классический пример — заказ, который также содержит список позиций заказа.</span><span class="sxs-lookup"><span data-stu-id="30235-183">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="30235-184">Позиция заказа обычно является сущностью.</span><span class="sxs-lookup"><span data-stu-id="30235-184">An order item will usually be an entity.</span></span> <span data-ttu-id="30235-185">Но это будет дочерняя сущность в агрегате заказа, который также будет содержать сущность "заказ" как корневую сущность, обычно называемую корнем агрегата.</span><span class="sxs-lookup"><span data-stu-id="30235-185">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="30235-186">Идентифицировать агрегаты может быть довольно трудно.</span><span class="sxs-lookup"><span data-stu-id="30235-186">Identifying aggregates can be hard.</span></span> <span data-ttu-id="30235-187">Агрегат — это группа объектов, которые должны быть согласованы друг с другом, но нельзя просто выбрать группу объектов и пометить их как агрегат.</span><span class="sxs-lookup"><span data-stu-id="30235-187">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="30235-188">Вы должны начать с концепции предметной области и обдумать сущности, которые используются в наиболее распространенных транзакциях, связанных с этой концепцией.</span><span class="sxs-lookup"><span data-stu-id="30235-188">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="30235-189">Именно такие сущности, которые должны быть согласованными на уровне транзакций, и формируют агрегат.</span><span class="sxs-lookup"><span data-stu-id="30235-189">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="30235-190">Обдумывание транзакционных операций, скорее всего, является лучшим способом определения агрегатов.</span><span class="sxs-lookup"><span data-stu-id="30235-190">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="30235-191">Шаблон корня агрегата или корневой сущности</span><span class="sxs-lookup"><span data-stu-id="30235-191">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="30235-192">В агрегате содержится по крайней мере одна сущность — корень агрегата, также называемый корневой или основной сущностью.</span><span class="sxs-lookup"><span data-stu-id="30235-192">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity.</span></span> <span data-ttu-id="30235-193">Кроме того, в агрегате может находиться несколько дочерних сущностей и объектов значений, причем все сущности и объекты работают совместно для реализации необходимого поведения и транзакций.</span><span class="sxs-lookup"><span data-stu-id="30235-193">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="30235-194">Цель корня агрегата заключается в обеспечении согласованности агрегата; он должен быть единственной точкой входа для обновлений агрегата с помощью методов или операций в классе корня агрегата.</span><span class="sxs-lookup"><span data-stu-id="30235-194">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="30235-195">Изменения сущностей в агрегате должны происходить только через корень агрегата.</span><span class="sxs-lookup"><span data-stu-id="30235-195">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="30235-196">Это защитник согласованности агрегата, учитывающий все инварианты и правила целостности, соблюдение которых может требоваться в агрегате.</span><span class="sxs-lookup"><span data-stu-id="30235-196">It is the aggregate’s consistency guardian, considering all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="30235-197">Если изменить дочернюю сущность или объект значения независимо, корень агрегата не сможет обеспечить правильное состояние агрегата.</span><span class="sxs-lookup"><span data-stu-id="30235-197">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="30235-198">Это было бы похоже на стол с оторванной ножкой.</span><span class="sxs-lookup"><span data-stu-id="30235-198">It would be like a table with a loose leg.</span></span> <span data-ttu-id="30235-199">Обеспечение согласованности является главной задачей корня агрегата.</span><span class="sxs-lookup"><span data-stu-id="30235-199">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="30235-200">На рис. 7-9 показаны примеры агрегатов, например агрегат "покупатель", содержащий одну сущность (корень агрегации Buyer).</span><span class="sxs-lookup"><span data-stu-id="30235-200">In Figure 7-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="30235-201">Агрегат "заказ" содержит несколько сущностей и объект значения.</span><span class="sxs-lookup"><span data-stu-id="30235-201">The order aggregate contains multiple entities and a value object.</span></span>

![Схема сравнения агрегатов Buyer (Покупатель) и Order (Заказ).](./media/microservice-domain-model/buyer-order-aggregate-pattern.png)

<span data-ttu-id="30235-203">**Рис. 7-9**.</span><span class="sxs-lookup"><span data-stu-id="30235-203">**Figure 7-9**.</span></span> <span data-ttu-id="30235-204">Пример агрегатов с одной или несколькими сущностями</span><span class="sxs-lookup"><span data-stu-id="30235-204">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="30235-205">Модель предметной области DDD состоит из агрегатов, агрегат может иметь только одну сущность или несколько сущностей, а также включать объекты значений.</span><span class="sxs-lookup"><span data-stu-id="30235-205">A DDD domain model is composed from aggregates, an aggregate can have just one entity or more, and can include value objects as well.</span></span> <span data-ttu-id="30235-206">Обратите внимание, что агрегат Buyer может иметь дополнительные дочерние сущности в зависимости от предметной области, как, например, в микрослужбе заказов в эталонном приложении eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="30235-206">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="30235-207">На рис. 7-9 просто показан случай, в котором покупатель состоит из одной сущности, в качестве примера агрегата, содержащего только корень агрегации.</span><span class="sxs-lookup"><span data-stu-id="30235-207">Figure 7-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="30235-208">Для поддержки разделения агрегатов и сохранения четких границ между ними рекомендуется в модели предметной области DDD запретить прямой переход между агрегатами и иметь только поле внешнего ключа (FK), как реализовано в [модели предметной области микрослужбы заказов](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) в приложении eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="30235-208">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="30235-209">Сущность Order имеет только поле FK для покупателя, и в ней отсутствует свойство навигации EF Core, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="30235-209">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;
    // ... Additional code
}
```

<span data-ttu-id="30235-210">Для идентификации агрегатов и работы с ними требуется опыт и проведение исследования.</span><span class="sxs-lookup"><span data-stu-id="30235-210">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="30235-211">Дополнительные сведения см. в следующем списке дополнительных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="30235-211">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="30235-212">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="30235-212">Additional resources</span></span>

- <span data-ttu-id="30235-213">**Вон Вернон (Vaughn Vernon). Эффективная конструкция агрегата. Часть I. Моделирование одиночного агрегата** (из <http://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="30235-213">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf>

- <span data-ttu-id="30235-214">**Вон Вернон (Vaughn Vernon). Эффективная конструкция агрегата. Часть II. Организация совместной работы агрегатов** (из <http://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="30235-214">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf>

- <span data-ttu-id="30235-215">**Вон Вернон (Vaughn Vernon). Эффективная конструкция агрегата. Часть III. Постижение через обнаружение** (из <http://dddcommunity.org/>) </span><span class="sxs-lookup"><span data-stu-id="30235-215">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf>

- <span data-ttu-id="30235-216">**Сергей Грибняк (Sergey Grybniak). Тактические конструктивные шаблоны DDD** </span><span class="sxs-lookup"><span data-stu-id="30235-216">**Sergey Grybniak. DDD Tactical Design Patterns** </span></span>\
  <https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part>

- <span data-ttu-id="30235-217">**Крис Ричардсон (Chris Richardson). Разработка транзакционных микрослужб с помощью агрегатов** </span><span class="sxs-lookup"><span data-stu-id="30235-217">**Chris Richardson. Developing Transactional Microservices Using Aggregates** </span></span>\
  <https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson>

- <span data-ttu-id="30235-218">**DevIQ. Шаблон агрегата** </span><span class="sxs-lookup"><span data-stu-id="30235-218">**DevIQ. The Aggregate pattern** </span></span>\
  <https://deviq.com/aggregate-pattern/>

>[!div class="step-by-step"]
><span data-ttu-id="30235-219">[Назад](ddd-oriented-microservice.md)
>[Вперед](net-core-microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="30235-219">[Previous](ddd-oriented-microservice.md)
[Next](net-core-microservice-domain-model.md)</span></span>
