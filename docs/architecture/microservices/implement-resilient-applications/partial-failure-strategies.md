---
title: Стратегии для обработки частичного сбоя
description: Узнайте о нескольких стратегиях правильной обработки частичных сбоев.
ms.date: 10/16/2018
ms.openlocfilehash: e96fe99ab44b924460e01abaad30aa3e2432117a
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "68674511"
---
# <a name="strategies-to-handle-partial-failure"></a>Стратегии обработки частичного сбоя

Ниже приведены стратегии для обработки частичных сбоев.

**Использование асинхронного взаимодействия (например, взаимодействия на основе сообщений) между внутренними микрослужбами**. Настоятельно рекомендуется не создавать длинные цепочки синхронных HTTP-вызовов между внутренними микрослужбами, так как этот подход в конечном счете приведет к сбоям. Напротив, асинхронный (на основе сообщений) обмен данными следует использовать только после выполнения начального цикла "запрос — ответ" между внутренними микрослужбами. Исключение составляет интерфейсное взаимодействие между клиентскими приложениями и первым уровнем микрослужб или детально настроенными шлюзами API. Итоговая согласованность и управляемые событиями архитектуры помогут свести к минимуму волновой эффект. Эти подходы обеспечивают более высокий уровень автономности микрослужбы и, таким образом, позволяют избежать возникновения указанной здесь проблемы.

**Использование повторных попыток с экспоненциальной выдержкой**. Этот метод помогает не допускать короткие и временные сбои, выполняя многократные повторные попытки вызова в случае, если служба была недоступна в течение небольшого промежутка времени. Такая проблема может возникать из-за периодических неполадок сети или при перемещении микрослужбы или контейнера на другой узел в кластере. Однако, если эти повторные попытки неправильно настроены с размыкателями цепи, волновой эффект может усилиться, что в конечном итоге не исключает даже [отказ в обслуживании (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).

**Обход времени ожидания сети**. Как правило, клиенты должны разрабатываться так, чтобы не переходить в состояние блокировки на неопределенное время и всегда использовать таймауты при ожидании ответа. Время ожидания исключает постоянную занятость ресурсов.

**Использование шаблона размыкателя цепи**. В этом случае клиентский процесс отслеживает количество неудачных запросов. Если частота ошибок превышает установленный предел, размыкатель цепи отключается, поэтому дальнейшие попытки немедленно завершаются сбоем. (Если количество невыполненных запросов слишком велико, это говорит о том, что служба недоступна и отправка запросов не имеет смысла.) По истечении времени ожидания клиент должен повторить попытку и, если новые запросы выполняются успешно, закрыть размыкатель цепи.

**Предоставление резервных механизмов**. При использовании этого подхода клиентский процесс в случае сбоя запроса реализует резервную логику, например возвращает кэшированные данные или значение по умолчанию. Этот вариант подходит для запросов, но несколько сложен для обновлений или команд.

**Ограничение на максимальное количество запросов в очереди**. Клиенты должны также устанавливать верхний предел на количество ожидающих запросов, отправляемых клиентской микрослужбой в конкретную службу. Если предел был достигнут, вероятно, нет никакого смысла выполнять дополнительные запросы, так как эти попытки сразу же завершатся ошибкой. С точки зрения реализации для выполнения этого требования можно использовать политику [изоляции отсеков](https://github.com/App-vNext/Polly/wiki/Bulkhead) Polly. По сути, этот подход представляет собой регулирование распараллеливания с использованием <xref:System.Threading.SemaphoreSlim> в качестве реализации. Он также позволяет формировать очередь вне переборки. Избыточную нагрузку можно распределить заранее — еще до выполнения (например, если считается, что достигнута полная мощность). В результате он реагирует на определенные сценарии сбоя быстрее, чем это сделал бы размыкатель цепи, поскольку размыкатель цепи ждет возникновения сбоев. Объект BulkheadPolicy в [Polly](http://www.thepollyproject.org/) отображает степень заполнения переборки и очереди и предлагает события на случай переполнения, поэтому его также можно использовать для выполнения автоматического горизонтального масштабирования.

## <a name="additional-resources"></a>Дополнительные ресурсы

- **Шаблоны устойчивости**\
  [https://docs.microsoft.com/azure/architecture/patterns/category/resiliency](/azure/architecture/patterns/category/resiliency)

- **Повышение устойчивости и оптимизация производительности**\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591574(v=pandp.10)>

- **Переборка.** Репозиторий GitHub. Реализация с помощью политики Polly.\
  <https://github.com/App-vNext/Polly/wiki/Bulkhead>

- **Проектирование устойчивых приложений для Azure**\
  [https://docs.microsoft.com/azure/architecture/resiliency/](/azure/architecture/resiliency/)

- **Обработка временных сбоев**\
  [https://docs.microsoft.com/azure/architecture/best-practices/transient-faults](/azure/architecture/best-practices/transient-faults)

>[!div class="step-by-step"]
>[Назад](handle-partial-failure.md)
>[Вперед](implement-retries-exponential-backoff.md)
