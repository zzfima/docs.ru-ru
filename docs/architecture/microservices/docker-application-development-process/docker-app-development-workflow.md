---
title: Рабочий процесс разработки для приложений Docker
description: Сведения о рабочем процессе для разработки приложений Docker. Начнем по шагам, рассмотрим подробности оптимизации файлов Dockerfile и закончим на упрощенном рабочем процессе, доступном при использовании Visual Studio.
ms.date: 01/30/2020
ms.openlocfilehash: c58ea2436027968143777a19286a1a0a72107717
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/20/2020
ms.locfileid: "77502745"
---
# <a name="development-workflow-for-docker-apps"></a>Рабочий процесс разработки для приложений Docker

Жизненный цикл разработки приложений начинается на компьютере разработчика, где разработчик локально программирует приложение на предпочитаемом языке и тестирует его. Независимо от выбранного языка, инфраструктуры и платформы, в рамках этого рабочего процесса разработчик всегда разрабатывает и тестирует контейнеры Docker, но делает это локально.

В каждый контейнер (экземпляр образа Docker) входят следующие компоненты:

- Выбранная операционная система (например, дистрибутив Linux, Windows Nano Server или Windows Server Core).

- Файлы, добавленные во время разработки, например исходный код и двоичные файлы и приложения.

- Сведения о конфигурации, например параметры среды и зависимости.

## <a name="workflow-for-developing-docker-container-based-applications"></a>Рабочий процесс разработки приложений Docker на основе контейнера

В этом разделе описывается рабочий процесс *внутреннего цикла* разработки приложений на основе контейнера Docker. Рабочий процесс внутреннего цикла означает, что речь идет только о разработке, которая выполняется на компьютере разработчика, не касаясь более широкого рабочего процесса DevOps. Начальные этапы настройки среды здесь не рассматриваются, так как они выполняются только один раз.

Приложение состоит из ваших собственных служб и дополнительных библиотек (зависимостей). Ниже приведены основные шаги, которые обычно выполняются при сборке приложения Docker, как показано на рисунке 5-1.

:::image type="complex" source="./media/docker-app-development-workflow/life-cycle-containerized-apps-docker-cli.png" alt-text="Схема, на которой показаны семь шагов, необходимых для создания контейнерного приложения.":::
Процесс разработки для приложений на основе Docker: 1) создайте код приложения; 2) напишите файлы Dockerfile; 3) создайте образы, определенные в файлах Dockerfile; 4) (необязательно) создайте службы в файле docker-compose.yml; 5) запустите контейнер или приложение docker-compose; 6) проведите тестирование приложений или микрослужб; 7) отправьте все в репозиторий и повторите.
:::image-end:::

**Рис. 5-1**. Пошаговый рабочий процесс разработки приложения на основе контейнера Docker

В этом разделе подробно описывается весь процесс, и каждый важный шаг объясняется с акцентом на среду Visual Studio.

Если разработка выполняется с помощью редактора и CLI (например, Visual Studio Code и Docker CLI на macOS или Windows), то необходимо знать каждый шаг и обычно более детально, чем при использовании Visual Studio. Дополнительные сведения о работе в среде CLI см. в электронной книге [Жизненный цикл приложений в контейнерах Docker с платформами и средствами Майкрософт](https://aka.ms/dockerlifecycleebook/).

При использовании Visual Studio 2019 многие из этих шагов выполняются автоматически, что значительно повышает производительность. Это особенно справедливо в тех случаях, когда используется Visual Studio 2019 и планируется создание многоконтейнерных приложений. Например, всего лишь одним щелчком мыши Visual Studio добавляет `Dockerfile` и файл `docker-compose.yml` в проекты с конфигурацией для вашего приложения. При запуске приложения в Visual Studio он создает образ Docker и запускает многоконтейнерное приложение непосредственно в Docker; вы даже можете отлаживать несколько контейнеров одновременно. Эти возможности значительно повышают скорость разработки.

Однако то, что Visual Studio автоматизирует эти действия, не означает, что вам не нужно знать, что происходит внутри Docker. Таким образом, каждый шаг подробно описывается в следующих рекомендациях.

![Изображение для шага 1.](./media/docker-app-development-workflow/step-1-code-your-app.png)

## <a name="step-1-start-coding-and-create-your-initial-application-or-service-baseline"></a>Шаг 1. Начало программирования и создание первого приложения или базовой службы

Разработка приложения Docker аналогична разработке приложения без Docker. Разница заключается в том, что при разработке для Docker развертывание и тестирование приложения или служб, работающих в контейнерах Docker, выполняется в локальной среде (в ВМ Linux или напрямую в Windows, если используются контейнеры Windows).

### <a name="set-up-your-local-environment-with-visual-studio"></a>Настройка локальной среды с помощью Visual Studio

Перед началом работы убедитесь, что [Docker Community Edition (CE)](https://docs.docker.com/docker-for-windows/) для Windows установлен, как описано в следующих инструкциях:

[Начало работы с Docker CE для Windows](https://docs.docker.com/docker-for-windows/)

Кроме того, вам нужна Visual Studio 2019 (версия 16.4 или более поздняя) с установленной рабочей нагрузкой **Кроссплатформенная разработка .NET Core**, как показано на рис. 5.2.

![Снимок экрана: выбор рабочей нагрузки "Кроссплатформенная разработка .NET Core".](./media/docker-app-development-workflow/dotnet-core-cross-platform-development.png)

**Рис. 5-2**. Выбор рабочей нагрузки **Кроссплатформенная разработка .NET Core** при установке Visual Studio 2019

Можно приступать к программированию приложения в обычной среде .NET (как правило, в .NET Core, если вы планируете использовать контейнеры) даже до включения Docker в вашем приложении и развертывания и тестирования в Docker. Тем не менее рекомендуется начать работу в Docker как можно быстрее, поскольку это будет реальная среда, и любые проблемы можно будет обнаружить гораздо раньше. Это также рекомендуется потому, что Visual Studio настолько упрощает работу с Docker, что практически все действия очевидны; лучший пример — отладка многоконтейнерного приложения в Visual Studio.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Начало работы с Docker CE для Windows** \
  <https://docs.docker.com/docker-for-windows/>

- **Visual Studio 2019** \
  [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019)

![Изображение для шага 2.](./media/docker-app-development-workflow/step-2-write-dockerfile.png)

## <a name="step-2-create-a-dockerfile-related-to-an-existing-net-base-image"></a>Шаг 2. Создание файла Dockerfile, связанного с существующим базовым образом .NET

Dockerfile необходим для каждого пользовательского образа, который вы хотите создать; кроме того, Dockerfile потребуется для каждого контейнера, который будет развертываться автоматически из Visual Studio или вручную с помощью Docker CLI (с помощью команд docker run и docker-compose). Если в приложении имеется единственный экземпляр пользовательской службы, необходим один Dockerfile. Если в приложении имеется несколько служб (как в архитектуре на основе микрослужб), потребуется по одному Dockerfile для каждой службы.

Dockerfile размещается в корневой папке приложения или службы. Он содержит команды, которые указывают Docker, как настраивать и запускать приложение или службу в контейнере. Можно вручную создать Dockerfile в коде и добавить его в проект вместе с зависимостями .NET.

В Visual Studio со средствами для Docker эта задача выполняется лишь несколькими щелчками мыши. При создании нового проекта в Visual Studio 2019 можно выбрать параметр **Enable Docker Support** (Включить поддержку Docker), как показано на рисунке 5-3.

![Снимок экрана: флажок Enable Docker Support (Включить поддержку Docker).](./media/docker-app-development-workflow/enable-docker-support-check-box.png)

**Рис. 5-3**. Включение поддержки Docker при создании нового проекта ASP.NET Core в Visual Studio 2019

Поддержку Docker в существующий проект веб-приложения ASP.NET Core можно также включить, щелкнув правой кнопкой мыши проект в **обозревателе решений** и выбрав **Добавить** > **Поддержка Docker**, как показано на рисунке 5-4.

![Снимок экрана: пункт "Поддержка Docker" в меню "Добавить".](./media/docker-app-development-workflow/add-docker-support-option.png)

**Рис. 5-4**. Включение поддержки Docker в существующем проекте Visual Studio 2019

Это действие добавляет *Dockerfile* в проект с необходимой конфигурацией и доступно только для проектов ASP.NET Core.

Аналогичным образом, Visual Studio также позволяет добавить файл `docker-compose.yml` для всего решения при помощи параметра **Добавить > Поддержка оркестратора контейнеров**. На шаге 4 мы рассмотрим этот параметр более подробно.

### <a name="using-an-existing-official-net-docker-image"></a>Использование существующего официального образа .NET Docker

Обычно вы создаете пользовательский образ для своего контейнера на основе базового образа, который можно получить из официального репозитория, например через реестр [Центра Docker](https://hub.docker.com/). Именно это происходит на внутреннем уровне при включении поддержки Docker в Visual Studio. Ваш Dockerfile будет использовать существующий образ `dotnet/core/aspnet`.

Ранее было показано, какие образы и репозитории Docker можно использовать в зависимости от выбранной платформы и операционной системы. Например, если вы выбрали ASP.NET Core (Windows или Linux), следует использовать образ `mcr.microsoft.com/dotnet/core/aspnet:3.1`. Таким образом, достаточно просто указать, какой базовый образ Docker будет использоваться для контейнера. Для этого добавьте `FROM mcr.microsoft.com/dotnet/core/aspnet:3.1` в свой Dockerfile. Visual Studio выполнит это автоматически, но в случае обновления версии вы обновляете это значение.

Использование официального репозитория образов .NET из Центра Docker с номером версии гарантирует, что на всех компьютерах (включая компьютеры для разработки, тестирования и работы) будут доступны одни и те же функции языка.

Ниже приведен пример Dockerfile для контейнера ASP.NET Core.

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1
ARG source
WORKDIR /app
EXPOSE 80
COPY ${source:-obj/Docker/publish} .
ENTRYPOINT ["dotnet", " MySingleContainerWebApp.dll "]
```

В этом случае образ основан на версии 3.1 официального образа Docker ASP.NET Core (мультиархитектурного, для Linux и Windows). Это параметр `FROM mcr.microsoft.com/dotnet/core/aspnet:3.1`. (Дополнительные сведения об этом базовом образе см. на странице [Образ Docker .NET Core](https://hub.docker.com/_/microsoft-dotnet-core/).) Кроме того, в Dockerfile необходимо указать Docker прослушивать порт TCP, который будет использоваться во время выполнения (в данном случае это порт 80, как задано в параметре EXPOSE).

В Dockerfile можно задать дополнительные параметры конфигурации, в зависимости от используемого языка и платформы. Например, параметр ENTRYPOINT со значением `["dotnet", "MySingleContainerWebApp.dll"]` указывает Docker запускать приложение .NET Core. Если для создания и запуска приложения .NET используется пакет SDK и .NET Core CLI (dotnet CLI), этот параметр будет другим. Параметр ENTRYPOINT, который находится в нижней строке, и другие параметры будут отличаться в зависимости от языка и платформы, выбранных для приложения.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Создание образов Docker для приложений .NET Core** \
  [https://docs.microsoft.com/dotnet/core/docker/building-net-docker-images](/aspnet/core/host-and-deploy/docker/building-net-docker-images)

- **Создание собственного образа**. В официальной документации Docker.\
  <https://docs.docker.com/engine/tutorials/dockerimages/>

- **Следите за образами контейнеров .NET** \
  <https://devblogs.microsoft.com/dotnet/staying-up-to-date-with-net-container-images/>

- **Совместное использование .NET и Docker — новости с DockerCon 2018** \
  <https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2018-update/>

### <a name="using-multi-arch-image-repositories"></a>Использование мультиархитектурных репозиториев

Один репозиторий может содержать варианты платформ, например образ Linux и образ Windows. Эта функция позволяет поставщикам, таким как Майкрософт, которые создают базовые образы, создать один репозиторий для охвата нескольких платформ (т. е. Windows и Linux). Например, репозиторий [dotnet/core](https://hub.docker.com/_/microsoft-dotnet-core/) в реестре Центра Docker обеспечивает поддержку Linux и Windows Nano Server при использовании одного и того же имени репозитория.

Можно указать тег, явно задающий платформу, как в следующих случаях:

- `mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim` \
  Цели: среда выполнения .NET Core 3.1, только на Linux

- `mcr.microsoft.com/dotnet/core/aspnet:3.1-nanoserver-1909` \
  Цели: среда выполнения .NET Core 3.1, только на Windows Nano Server

Появилась возможность указывать одно и то же имя образа, даже с одинаковым тегом, и новые мультиархитектурные образы (например, образ `aspnet`) будут использовать версию Windows или Linux в зависимости от развернутой базовой ОС Docker, как показано в следующем примере:

- `mcr.microsoft.com/dotnet/core/aspnet:3.1` \
  Мультиархитектурный: среда выполнения .NET Core 3.1 поддерживающая Linux и Windows Nano Server в зависимости от базовой ОС Docker

Таким образом, при запросе образа с узла Windows будет получен вариант для Windows, а при запросе образа с тем же именем с узла Linux будет получен вариант для Linux.

### <a name="multi-stage-builds-in-dockerfile"></a>Многоэтапная сборка в файле Dockerfile

Dockerfile похож на пакетный сценарий. Он похож на действия в ситуации, если бы вам необходимо было установить что-то на компьютере из командной строки.

Он начинается с базового образа, который задает начальный контекст; это как начальная файловая система, которая надстраивается над базовой ОС. Это не ОС в строгом смысле, но можно представить его как "ОС внутри контейнера".

Выполнение каждой командной строки создает новый слой в файловой системе с изменениями от предыдущего таким образом, чтобы при их объединении создавалась результирующая файловая система.

Поскольку каждый новый уровень "накладывается" на предыдущий и итоговый размер образа увеличивается с каждой командой, образы могут становиться очень большими, если они включают, например, пакет SDK для сборки и публикации приложения.

Здесь в дело вступает многоэтапная сборка (в Docker 17.05 и более поздних версий), творя настоящие чудеса.

Основная ее идея в том, что можно разделить процесс выполнения Dockerfile на этапы; каждый этап — исходный образ, за которым следуют команды, а последний этап определяет размер окончательного образа.

Короче говоря, многоэтапная сборка позволяет разделить создание образа на этапы и затем собрать окончательный образ, используя только соответствующие каталоги из промежуточных этапов. Общая стратегия использования этой функции такова:

1. Использовать базовый образ пакета SDK (его размер не имеет значения), где есть все необходимое для сборки и публикации приложения в папке.

2. Затем использовать небольшой базовый образ времени выполнения и скопировать папку публикации из предыдущего этапа для создания небольшого окончательного образа.

Возможно, лучший способ понять, как работает многоэтапный процесс, — это пройти в файле Dockerfile по каждой строке; давайте начнем с базового файла Dockerfile, созданного с помощью Visual Studio при добавлении поддержки Docker в проект, чтобы позже внести некоторые оптимизации.

Исходный файл Dockerfile может выглядеть следующим образом:

```Dockerfile
 1  FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS base
 2  WORKDIR /app
 3  EXPOSE 80
 4
 5  FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build
 6  WORKDIR /src
 7  COPY src/Services/Catalog/Catalog.API/Catalog.API.csproj …
 8  COPY src/BuildingBlocks/HealthChecks/src/Microsoft.AspNetCore.HealthChecks …
 9  COPY src/BuildingBlocks/HealthChecks/src/Microsoft.Extensions.HealthChecks …
10  COPY src/BuildingBlocks/EventBus/IntegrationEventLogEF/ …
11  COPY src/BuildingBlocks/EventBus/EventBus/EventBus.csproj …
12  COPY src/BuildingBlocks/EventBus/EventBusRabbitMQ/EventBusRabbitMQ.csproj …
13  COPY src/BuildingBlocks/EventBus/EventBusServiceBus/EventBusServiceBus.csproj …
14  COPY src/BuildingBlocks/WebHostCustomization/WebHost.Customization …
15  COPY src/BuildingBlocks/HealthChecks/src/Microsoft.Extensions …
16  COPY src/BuildingBlocks/HealthChecks/src/Microsoft.Extensions …
17  RUN dotnet restore src/Services/Catalog/Catalog.API/Catalog.API.csproj
18  COPY . .
19  WORKDIR /src/src/Services/Catalog/Catalog.API
20  RUN dotnet build Catalog.API.csproj -c Release -o /app
21
22  FROM build AS publish
23  RUN dotnet publish Catalog.API.csproj -c Release -o /app
24
25  FROM base AS final
26  WORKDIR /app
27  COPY --from=publish /app .
28  ENTRYPOINT ["dotnet", "Catalog.API.dll"]
```

И вот подробности, по одной строке:

- **Строка 1.** Начнем этап с небольшого базового образа времени выполнения, назвав его **base**.

- **Строка 2.** Создайте в образе каталог **/app**.

- **Строка 3.** Откройте порт **80**.

- **Строка 5.** Начнем новый этап с крупного образа для сборки и публикации. Назовем его **build**.

- **Строка 6.** Создайте в образе каталог **/src**.

- **Строка 7.** Скопируйте указанные файлы проектов **.csproj** до строки 16, чтобы иметь возможность восстановить пакеты позже.

- **Строка 17.** Восстановите пакеты для проекта **Catalog.API** и связанных проектов.

- **Строка 18.** Скопируйте **все дерево каталогов решения** (за исключением файлов и каталогов, включенных в файл **.dockerignore**) в каталог **/src** в образе.

- **Строка 19.** Укажите в качестве текущей папки проект **Catalog.API**.

- **Строка 20.** Скомпилируйте проект (и другие зависимости проекта) и поместите его в каталог проекта **/app** в образе.

- **Строка 22.** Начните новый этап, продолжая работу со сборкой. Назовем его **publish**.

- **Строка 23.** Опубликуйте проект (и его зависимости), поместив его в каталог проекта **/app** в образе.

- **Строка 25.** Начните новый этап, продолжая работу над образом **base**. Назовем его **final**.

- **Строка 26.** Измените текущий каталог на **/app**.

- **Строка 27.** Скопируйте каталог **/app** из этапа **publish** в текущий каталог.

- **Строка 28.** Определите команду, которая будет выполняться при запуске контейнера.

Теперь давайте рассмотрим некоторые оптимизации для повышения производительности всего процесса; в случае eShopOnContainers сборка полного решения в контейнерах Linux занимает около 22 минут или более.

Вы используете преимущества многоуровневого кэша Docker, которая не представляет особых сложностей: если базовый образ и команды — такие же, как в некоторых ранее выполненных случаях, можно просто использовать полученный слой без необходимости повторного выполнения команд, что экономит время.

Таким образом, давайте сосредоточимся на этапе **build**; строки 5–6 практически одинаковы, но строки 7–17 отличаются для каждой службы из eShopOnContainers, поэтому они должны выполняться каждый раз, но если изменить строки 7–16 на следующие:

```Dockerfile
COPY . .
```

то они будет практически аналогичны для каждой службы; строка копирует все решение и создаст слой большего размера, но при этом

1. процесс копирования будет выполняться только в первый раз (и при перестроении в случае изменения файла); для всех других служб будет использоваться кэш.

2. Так как более крупный образ находится на промежуточном этапе, он не влияет на размер окончательного образа.

Следующая значительная оптимизация касается команды `restore`, выполняемой в строке 17; она также отличается для каждой службы eShopOnContainers. Если вы измените эту строку так:

```Dockerfile
RUN dotnet restore
```

то она позволит восстановить пакеты для всего решения, что позволяет повторять ее только один раз вместо 15.

Тем не менее `dotnet restore` запускается, только если в папке есть лишь один файл проекта или решения, поэтому решения этой задачи немного сложнее. Если не вдаваться в подробности, все обстоит так:

1. Добавьте приведенные ниже строки в **.dockerignore**:

   - `*.sln` для игнорирования всех файлов решения в главном дереве папок

   - `!eShopOnContainers-ServicesAndWebApps.sln`, чтобы включить только этот файл решения.

2. Включите аргумент `/ignoreprojectextensions:.dcproj` в `dotnet restore`, чтобы он также игнорировал проект docker-compose и восстанавливал только пакеты для решения eShopOnContainers-ServicesAndWebApps.

Для окончательной оптимизации отметим, что строка 20 является избыточной, так как строка 23 также собирает приложение и следует, по сути, сразу после строки 20, поэтому можно убрать еще одну времязатратную команду.

Полученный файл будет таким:

```Dockerfile
 1  FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS base
 2  WORKDIR /app
 3  EXPOSE 80
 4
 5  FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS publish
 6  WORKDIR /src
 7  COPY . .
 8  RUN dotnet restore /ignoreprojectextensions:.dcproj
 9  WORKDIR /src/src/Services/Catalog/Catalog.API
10  RUN dotnet publish Catalog.API.csproj -c Release -0 /app
11
12  FROM base AS final
13  WORKDIR /app
14  COPY --from=publish /app
15  ENTRYPOINT ["dotnet", "Catalog.API.dll"]
```

### <a name="creating-your-base-image-from-scratch"></a>Создание базового образа с нуля

Вы можете создать собственный базовый образ Docker с нуля. Этот сценарий не рекомендуется для тех, кто только начинает работать с Docker, но если вы хотите задать определенные биты базового образа, это можно сделать.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Мультиархитектурные образы .NET Core**.\
  <https://github.com/dotnet/announcements/issues/14>

- **Создание базового образа**. Официальная документация Docker.\
  <https://docs.docker.com/develop/develop-images/baseimages/>

![Изображение для шага 3.](./media/docker-app-development-workflow/step-3-create-dockerfile-defined-images.png)

## <a name="step-3-create-your-custom-docker-images-and-embed-your-application-or-service-in-them"></a>Шаг 3. Создание пользовательских образов Docker и внедрение в них собственных приложений или служб

Для каждой службы в приложении необходимо создать связанный образ. Если приложение состоит из одной службы или веб-приложения, достаточно одного образа.

Обратите внимание, что образы Docker в Visual Studio создаются автоматически. Следующие действия потребуются только в рабочем процессе с использованием редактора/CLI и подробно описываются, чтобы показать, что происходит внутри.

Разработчик должен выполнять разработку и тестирование локально до тех пор, пока не завершит и отправит компонент или пока не перейдет в систему управления версиями (например, в GitHub). Это означает, что необходимо создавать образы Docker и разворачивать контейнеры на локальном узле Docker (на виртуальной машине Windows или Linux), а затем выполнять запуск, тестирование и отладку этих локальных контейнеров.

Чтобы создать пользовательский образ в локальной среде с помощью Docker CLI и Dockerfile, можно использовать команду docker build, как показано на рисунке 5-5.

![Снимок экрана, показывающий выходные данные команды docker build в консоли.](./media/docker-app-development-workflow/run-docker-build-command.png)

**Рис. 5-5**. Создание пользовательского образа Docker

При необходимости вместо непосредственного выполнения команды docker build из папки проекта можно сначала создать развертываемую папку с нужными библиотеками .NET и двоичными файлами, выполнив команду `dotnet publish`, а затем использовать команду `docker build`.

Это создаст образ Docker с именем `cesardl/netcore-webapi-microservice-docker:first`. В данном случае :first — это тег, представляющий конкретную версию. Этот шаг можно повторить для каждого пользовательского образа, который вам требуется создать для своего составного приложения Docker.

Если приложение состоит из нескольких контейнеров (т. е. это многоконтейнерное приложение), можно также использовать команду `docker-compose up --build`, чтобы собрать все связанные образы одной командой с помощью метаданных, представленных в связанном файле docker-compose.yml.

Вы можете найти существующие в локальном репозитории образы с помощью команды docker images, как показано на рисунке 5-6.

![Выходные данные команды docker images в консоли со списком существующих образов.](./media/docker-app-development-workflow/view-existing-images-with-docker-images.png)

**Рис. 5-6**. Просмотр существующих образов с помощью команды docker images

### <a name="creating-docker-images-with-visual-studio"></a>Создание образов Docker с помощью Visual Studio

При использовании Visual Studio для создания проекта с поддержкой Docker не требуется создавать образ явно. Этот образ создается автоматически, когда вы нажимаете клавиши **F5** или **Ctrl-F5** и запускаете приложение или службу, добавленную в Docker. Этот шаг выполняется в Visual Studio автоматически, и вы не увидите, как это происходит, но важно знать, что происходит внутри.

![Изображение для необязательного шага 4.](./media/docker-app-development-workflow/step-4-define-services-docker-compose-yml.png)

## <a name="step-4-define-your-services-in-docker-composeyml-when-building-a-multi-container-docker-application"></a>Шаг 4. Определение служб в файле docker-compose.yml при сборке многоконтейнерного приложения Docker

В файле [docker-compose.yml](https://docs.docker.com/compose/compose-file/) можно задать ряд связанных служб для развертывания в качестве составного приложения с помощью команд развертывания. Он также настраивает отношения зависимости и конфигурацию среды выполнения.

Чтобы использовать файл docker-compose.yml, его необходимо создать в основной или корневой папке решения, и его содержимое должно быть аналогично приведенному в следующем примере.

```yml
version: '3.4'

services:

  webmvc:
    image: eshop/web
    environment:
      - CatalogUrl=http://catalog-api
      - OrderingUrl=http://ordering-api
    ports:
      - "80:80"
    depends_on:
      - catalog-api
      - ordering-api

  catalog-api:
    image: eshop/catalog-api
    environment:
      - ConnectionString=Server=sqldata;Port=1433;Database=CatalogDB;…
    ports:
      - "81:80"
    depends_on:
      - sqldata

  ordering-api:
    image: eshop/ordering-api
    environment:
      - ConnectionString=Server=sqldata;Database=OrderingDb;…
    ports:
      - "82:80"
    extra_hosts:
      - "CESARDLBOOKVHD:10.0.75.1"
    depends_on:
      - sqldata

  sqldata:
    image: mssql-server-linux:latest
    environment:
      - SA_PASSWORD=Pass@word
      - ACCEPT_EULA=Y
    ports:
      - "5433:1433"
```

Данный файл docker-compose.yml представляет собой упрощенную и объединенную версию. Он содержит статические данные конфигурации для каждого контейнера (такие как имя пользовательского образа), которые требуются всегда, а также сведения о конфигурации, которые могут зависеть от среды развертывания, такие как строка подключения. В следующих разделах вы узнаете, как можно разбить конфигурацию в файле docker-compose.yml на несколько файлов docker-compose и переопределить значения в зависимости от среды и типа выполнения (отладка или выпуск).

В примере файла docker-compose.yml определяются четыре службы: служба `webmvc` (веб-приложение), две микрослужбы (`ordering-api` и `basket-api`) и один контейнер источника данных, `sqldata`, на основе SQL Server для Linux, работающего как контейнер. Каждая служба развертывается как контейнер, поэтому образ Docker требуется для каждой службы.

Файл docker-compose.yml задает не только используемые контейнеры, но и их индивидуальные конфигурации. Например, в определении контейнера `webmvc` в файле .yml задается следующее.

- Использует предварительно созданный образ `eshop/web:latest`. Однако вы также можете настроить сборку этого образа при выполнении команды docker-compose с дополнительной конфигурацией на основе раздела build: в файле docker-compose.

- Инициализируются две переменные среды (CatalogUrl и OrderingUrl).

- Предоставленный порт 80 в контейнере переадресуется на внешний порт 80 на хост-компьютере.

- Веб-приложение связывается со службами catalog и ordering с помощью параметра depends_on. В результате данная служба будет ожидать запуска этих служб.

Мы вернемся к файлу docker-compose.yml в следующем разделе, когда будем рассматривать реализацию микрослужб и многоконтейнерных приложений.

### <a name="working-with-docker-composeyml-in-visual-studio-2019"></a>Работа с файлом docker-compose.yml в Visual Studio 2019

Наряду с возможностью добавления Dockerfile в проект, как уже отмечалось, Visual Studio 2017 версии 15.8 и выше позволяет включить в решении поддержку оркестратора для Docker Compose.

При добавлении поддержки оркестратора контейнеров, как показано на рисунке 5-7, в первый раз Visual Studio создает файл Dockerfile для проекта и создает новый проект (раздел службы) в решении с несколькими глобальными файлами `docker-compose*.yml`, а затем добавляет проект для таких файлов. Затем можно открыть файлы docker-compose.yml и добавить в них дополнительные возможности.

Вам необходимо будет повторить эту операцию для каждого проекта, который вы хотите включить в файл docker-compose.yml.

На момент написания этой статьи Visual Studio поддерживает оркестраторы **Docker Compose** и **Kubernetes/Helm**.

![Снимок экрана: пункт "Поддержка оркестратора контейнеров" в контекстном меню проекта.](./media/docker-app-development-workflow/add-container-orchestrator-support-option.png)

**Рис. 5-7**. Добавление поддержки Docker в Visual Studio 2019 щелчком правой кнопки мыши на проекте ASP.NET Core

После добавления поддержки оркестратора в решение в Visual Studio вы также увидите новый узел в обозревателе решений (в файле проекта `docker-compose.dcproj`), содержащий добавленные файлы docker-compose.yml, как показано на рисунке 5-8.

![Снимок экрана: узел docker-compose в обозревателе решений.](./media/docker-app-development-workflow/docker-compose-tree-node.png)

**Рис. 5-8**. Узел дерева **docker-compose**, добавленный в обозреватель решений Visual Studio 2019

Можно развернуть многоконтейнерное приложение с единственным файлом docker-compose.yml с помощью команды `docker-compose up`. Однако Visual Studio добавляет группу этих файлов, чтобы вы могли переопределять значения в зависимости от среды (разработки или рабочей) и типа выполнения (выпуска или отладки). Эта возможность разъясняется в следующих разделах.

![Изображение для шага 5.](./media/docker-app-development-workflow/step-5-run-containers-compose-app.png)

## <a name="step-5-build-and-run-your-docker-application"></a>Шаг 5. Сборка и запуск приложения Docker

Если в приложении имеется только один контейнер, его можно запустить путем развертывания на узле Docker (на виртуальной машине или физическом сервере). Но если приложение содержит несколько служб, его можно развернуть как составное приложение с помощью одной команды CLI (`docker-compose up)`) или в Visual Studio, в котором внутри будет выполняться эта же команда. Давайте рассмотрим разные варианты.

### <a name="option-a-running-a-single-container-application"></a>Вариант А. Запуск приложения в одном контейнере

#### <a name="using-docker-cli"></a>Использование Docker CLI

Контейнер Docker можно запустить с помощью команды `docker run`, как показано на рисунке 5-9.

```console
docker run -t -d -p 80:5000 cesardl/netcore-webapi-microservice-docker:first
```

Приведенная выше команда создает новый экземпляр контейнера из указанного образа при каждом запуске. Можно использовать параметр `--name` для указания имени контейнера, а затем использовать `docker start {name}` (также поддерживаются идентификатор контейнера и автоматически присваиваемое имя) для запуска существующего экземпляра контейнера.

![Снимок экрана: запуск контейнера Docker с помощью команды docker run.](./media/docker-app-development-workflow/use-docker-run-command.png)

**Рис. 5-9**. Запуск контейнера Docker с помощью команды docker run

В этом случае команда привязывает внутренний порт 5000 контейнера к порту 80 хост-компьютера. Это означает, что узел выполняет прослушивание порта 80 и переадресацию в порт 5000 в контейнере.

Показанный хэш — это идентификатор контейнера; ему также присваивается случайное доступное для чтения имя, если параметр `--name` не используется.

#### <a name="using-visual-studio"></a>Использование Visual Studio

Если вы еще не добавили поддержку оркестратора контейнеров, запустите одноконтейнерное приложение в Visual Studio, нажав клавишу **Ctrl-F5**. Кроме того, клавиша **F5** позволяет отлаживать приложение внутри контейнера. Контейнер запускается локально с помощью команды docker run.

### <a name="option-b-running-a-multi-container-application"></a>Вариант Б. Запуск многоконтейнерного приложения

В большинстве корпоративных сценариев приложение Docker будет состоять из нескольких служб; это означает, что необходимо запускать многоконтейнерное приложение, как показано на рисунке 5-10.

![Виртуальная машина с несколькими контейнерами Docker](./media/docker-app-development-workflow/vm-with-docker-containers-deployed.png)

**Рис. 5-10**. Виртуальная машина с развернутыми контейнерами Docker

#### <a name="using-docker-cli"></a>Использование Docker CLI

Для запуска многоконтейнерного приложения с помощью Docker CLI используйте команду `docker-compose up`. Эта команда разворачивает многоконтейнерное приложение с помощью файла **docker-compose.yml**, существующего на уровне решения. На рисунке 5-11 показаны результаты выполнения этой команды из главного каталога решения, в котором находится файл docker-compose.yml.

![Вид экрана с результатом выполнения команды docker-compose up](./media/docker-app-development-workflow/results-docker-compose-up.png)

**Рис. 5-11**. Пример результата выполнения команды docker-compose up

После выполнения команды docker-compose up приложение и связанные с ним контейнеры развертываются в узле Docker, как показано на рисунке 5-10.

#### <a name="using-visual-studio"></a>Использование Visual Studio

Запуск многоконтейнерного приложения с помощью Visual Studio 2019 не может быть проще. Просто нажмите клавишу **Ctrl-F5** для запуска или **F5** для отладки, как обычно, настроив проект **docker-compose** как запускаемый.  Visual Studio обрабатывает все необходимые настройки, чтобы можно было создать точки останова обычным образом и отлаживать наконец ставшие независимыми процессы, запущенные на "удаленных серверах" с уже подключенным отладчиком. Вот так.

Как упоминалось ранее, каждый раз при добавлении поддержки решения Docker в проект в решении этот проект настраивается в глобальном (на уровне решения) файле docker-compose.yml, что позволяет запускать или отлаживать все решение сразу. Visual Studio будет запускать по одному контейнеру для каждого проекта с включенной поддержкой решения Docker и выполнять все внутренние шаги автоматически (dotnet publish, docker build и т. д.).

Если вы хотите оценить масштаб этой утомительной работы, взгляните на файл:

`{root solution folder}\obj\Docker\docker-compose.vs.debug.g.yml`

Здесь важно то, что, как показано на рисунке 5-12, в Visual Studio 2019 имеется дополнительная команда **Docker** для действия клавиши F5. Эта возможность позволяет запускать или отлаживать многоконтейнерное приложение путем запуска всех контейнеров, определенных в файлах docker-compose.yml на уровне решения. Возможность отладки многоконтейнерных решений означает, что можно установить несколько точек останова, чтобы все они были в разных проектах (контейнерах), и во время отладки из Visual Studio вы будете останавливаться в точках останова, заданных в разных проектах, и работать в разных контейнерах.

![Снимок экрана: панель инструментов отладки с запущенным проектом docker-compose.](./media/docker-app-development-workflow/debug-toolbar-docker-compose-project.png)

**Рис. 5-12**. Запуск многоконтейнерных приложений в Visual Studio 2019

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Развертывание контейнера ASP.NET на удаленном узле Docker** \
  <https://docs.microsoft.com/azure/vs-azure-tools-docker-hosting-web-apps-in-docker>

### <a name="a-note-about-testing-and-deploying-with-orchestrators"></a>Примечание о тестировании и развертывании с использованием оркестраторов

Команды docker-compose up и docker run (или запуск и отладка контейнеров в Visual Studio) подходят для тестирования контейнеров в вашей среде разработки. Но этот подход не следует использовать для развертывания в рабочей среде, где следует выбирать оркестраторы, например [Kubernetes](https://kubernetes.io/) или [Service Fabric](https://azure.microsoft.com/services/service-fabric/). При работе с Kubernetes необходимо использовать [модули](https://kubernetes.io/docs/concepts/workloads/pods/pod/) для организации контейнеров и [службы](https://kubernetes.io/docs/concepts/services-networking/service/) для их объединения в сеть. Можно также использовать [развертывания](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) для упорядочения создания и изменения модулей.

![Изображение для шага 6.](./media/docker-app-development-workflow/step-6-test-app-microservices.png)

## <a name="step-6-test-your-docker-application-using-your-local-docker-host"></a>Шаг 6. Тестирование приложения Docker с помощью локального узла Docker

Этот шаг будет зависеть от того, что делает ваше приложение. В случае простого веб-приложения .NET Core, развернутого в виде единственного контейнера или службы, можно получить доступ к этой службе, открыв на узле Docker браузер и перейдя в нем на этот сайт, как показано на рисунке 5-13. (Если конфигурация в Dockerfile сопоставляет контейнер с портом узла, отличным от 80, укажите этот порт узла в URL-адресе.)

![Снимок экрана: ответ с адреса localhost/API/values.](./media/docker-app-development-workflow/test-docker-app-locally-localhost.png)

**Рис. 5-13**. Пример локального тестирования приложения Docker с помощью localhost

Если localhost не указывает на IP-адрес узла Docker (при использовании Docker CE это должно происходить по умолчанию), то для перехода к службе используйте IP-адрес сетевой карты вашего компьютера.

Обратите внимание, что этот URL-адрес в браузере использует порт 80 для рассматриваемого примера конкретного контейнера. Однако внутренние запросы перенаправляются на порт 5000, поскольку именно так было выполнено развертывание с помощью команды docker run, как описано в предыдущем шаге.

Вы также можете тестировать приложение с помощью команды curl с терминала, как показано на рисунке 5-14. В случае установки Docker в Windows по умолчанию всегда будет использоваться IP-адрес узла Docker 10.0.75.1 помимо фактического IP-адреса вашего компьютера.

![Выходные данные команды curl, выполненной применительно к http://10.0.75.1/API/values, в консоли.](./media/docker-app-development-workflow/test-docker-app-locally-curl.png)

**Рис. 5-14**. Пример локального тестирования приложения Docker с помощью curl

### <a name="testing-and-debugging-containers-with-visual-studio-2019"></a>Тестирование и отладка контейнеров в Visual Studio 2019

При запуске и отладке контейнеров в Visual Studio 2019 вы можете отлаживать приложения .NET в основном так же, как при запуске без контейнеров.

### <a name="testing-and-debugging-without-visual-studio"></a>Тестирование и отладка без Visual Studio

Если при разработке используется редактор или CLI, отлаживать контейнеры будет значительно труднее, и вы, возможно, захотите выполнять отладку путем создания трассировок.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Отладка приложений в локальном контейнере Docker** \
  [https://docs.microsoft.com/visualstudio/containers/edit-and-refresh](/visualstudio/containers/edit-and-refresh)

- **Стив Ласкер (Steve Lasker). Сборка, отладка, развертывание приложений ASP.NET Core с помощью Docker.** Видео. \
  <https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T115>

## <a name="simplified-workflow-when-developing-containers-with-visual-studio"></a>Упрощенный рабочий процесс при разработке контейнеров в Visual Studio

В сущности, при использовании Visual Studio рабочий процесс гораздо проще, чем при использовании редактора или CLI. Большинство шагов, необходимых для Docker и связанных с Dockerfile и docker-compose.yml, выполняются скрыто от пользователя или значительно упрощаются благодаря Visual Studio, как показано на рисунке 5-15.

:::image type="complex" source="./media/docker-app-development-workflow/simplified-life-cycle-containerized-apps-docker-cli.png" alt-text="Схема, на которой показаны пять упрощенных шагов по созданию приложения.":::
Процесс разработки для приложений на основе Docker: 1) создайте код приложения; 2) напишите файлы Dockerfile; 3) создайте образы, определенные в файлах Dockerfile; 4) (необязательно) создайте службы в файле docker-compose.yml; 5) запустите контейнер или приложение docker-compose; 6) проведите тестирование приложений или микрослужб; 7) отправьте все в репозиторий и повторите.
:::image-end:::

**Рис. 5-15**. Упрощенный рабочий процесс при разработке в Visual Studio

Кроме того, вам достаточно будет выполнить шаг 2 (добавление поддержки Docker в проекты) только один раз. Таким образом, рабочий процесс аналогичен другим обычным задачам разработки, когда для разработки используется .NET. Вам нужно знать, что происходит на самом деле (процесс создания образа, какие базовые образы используются, развертывание контейнеров и т. п.), и в некоторых случаях также может потребоваться изменить файл Dockerfile или docker-compose.yml, чтобы настроить функциональность. Но благодаря Visual Studio большую часть работы можно выполнить гораздо проще, что существенно повышает эффективность работы.

### <a name="additional-resources"></a>Дополнительные ресурсы

- **Стив Ласкер (Steve Lasker). Разработка для Docker на .NET в Visual Studio 2017** \
  <https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T111>

## <a name="using-powershell-commands-in-a-dockerfile-to-set-up-windows-containers"></a>Использование команд PowerShell в DockerFile для настройки контейнеров Windows

[Контейнеры Windows](https://docs.microsoft.com/virtualization/windowscontainers/about/index) позволяют преобразовывать существующие приложения Windows в образы Docker и развертывать их с помощью тех же средств, что и остальную часть экосистемы Docker. Чтобы использовать контейнеры Windows, выполните команды PowerShell в Dockerfile, как показано в следующем примере:

```Dockerfile
FROM mcr.microsoft.com/windows/servercore
LABEL Description="IIS" Vendor="Microsoft" Version="10"
RUN powershell -Command Add-WindowsFeature Web-Server
CMD [ "ping", "localhost", "-t" ]
```

В этом случае мы используем базовый образ Windows Server Core (параметр FROM) и устанавливаем службы IIS с помощью команды PowerShell (параметр RUN). Аналогичным образом можно также использовать команды PowerShell для настройки дополнительных компонентов, таких как ASP.NET 4.x, .NET 4.6 и другого программного обеспечения Windows. Например, следующая команда в Dockerfile настраивает ASP.NET 4.5:

```Dockerfile
RUN powershell add-windowsfeature web-asp-net45
```

### <a name="additional-resources"></a>Дополнительные ресурсы

- **aspnet-docker/Dockerfile.** Примеры команд PowerShell, которые можно выполнять в файлах Dockerfile для включения компонентов Windows.\
  <https://github.com/Microsoft/aspnet-docker/blob/master/4.7.1-windowsservercore-ltsc2016/runtime/Dockerfile>

>[!div class="step-by-step"]
>[Назад](index.md)
>[Вперед](../multi-container-microservice-net-applications/index.md)
