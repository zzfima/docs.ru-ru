---
title: 'Распределенное управление данными: проблемы и решения'
description: Сведения о проблемах и решениях для распределенного управления данными в среде микрослужб.
ms.date: 09/20/2018
ms.openlocfilehash: c30de24591d5a73fd34087f34a69e9c7ed54cd35
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "71834447"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="58edf-103">Распределенное управление данными: проблемы и решения</span><span class="sxs-lookup"><span data-stu-id="58edf-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="58edf-104">Проблема \#1. Как определить границы каждой микрослужбы</span><span class="sxs-lookup"><span data-stu-id="58edf-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="58edf-105">Пожалуй, с проблемой определения границ микрослужб каждый разработчик сталкивается в первую очередь.</span><span class="sxs-lookup"><span data-stu-id="58edf-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="58edf-106">Каждая микрослужба должна быть частью вашего приложения, и каждая микрослужба должна быть автономной — здесь есть свои преимущества и свои недостатки.</span><span class="sxs-lookup"><span data-stu-id="58edf-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="58edf-107">Но как определить эти границы?</span><span class="sxs-lookup"><span data-stu-id="58edf-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="58edf-108">Во-первых, необходимо сосредоточиться на логических моделях предметных областей приложения и связанных данных.</span><span class="sxs-lookup"><span data-stu-id="58edf-108">First, you need to focus on the application's logical domain models and related data.</span></span> <span data-ttu-id="58edf-109">Попробуйте выделить группы данных и различные контексты в одном приложении.</span><span class="sxs-lookup"><span data-stu-id="58edf-109">Try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="58edf-110">Каждый контекст должен иметь свой бизнес-язык (свои бизнес-термины).</span><span class="sxs-lookup"><span data-stu-id="58edf-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="58edf-111">Контексты должны определяться и управляться независимо друг от друга.</span><span class="sxs-lookup"><span data-stu-id="58edf-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="58edf-112">Термины и объекты, используемые в этих контекстах, могут звучать похоже, но вы увидите, что в одном контексте концепция используется не так, как в другом, и даже может иметь другое название.</span><span class="sxs-lookup"><span data-stu-id="58edf-112">The terms and entities that are used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="58edf-113">Например, пользователь может называться пользователем в контексте идентификации или членства, клиентом — в контексте управления клиентами, покупателем — в контексте заказов и т. д.</span><span class="sxs-lookup"><span data-stu-id="58edf-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="58edf-114">Как вы определяете границы между контекстами приложения с отдельной предметной областью для каждого контекста, так же вы определяете границы каждой микрослужбы, ее модель предметной области и данные.</span><span class="sxs-lookup"><span data-stu-id="58edf-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="58edf-115">Всегда старайтесь свести к минимуму взаимозависимость между этими микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="58edf-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="58edf-116">Далее в главе [Определение границ модели предметной области для каждой микрослужбы](identify-microservice-domain-model-boundaries.md) будет подробно рассматриваться это разграничение и проектирование модели предметной области.</span><span class="sxs-lookup"><span data-stu-id="58edf-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="58edf-117">Проблема \#2. Как создавать запросы для извлечения данных из нескольких микрослужб</span><span class="sxs-lookup"><span data-stu-id="58edf-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="58edf-118">Вторая проблема — как применять запросы для извлечения данных из нескольких микрослужб без постоянного обращения удаленных клиентских приложений к микрослужбам.</span><span class="sxs-lookup"><span data-stu-id="58edf-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="58edf-119">Например, на одном экране в мобильном приложении может отображаться информация из микрослужб корзины, каталога и удостоверения пользователя.</span><span class="sxs-lookup"><span data-stu-id="58edf-119">An example could be a single screen from a mobile app that needs to show user information that's owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="58edf-120">Еще один пример — сложный отчет с большим количеством таблиц, расположенных в нескольких микрослужбах.</span><span class="sxs-lookup"><span data-stu-id="58edf-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="58edf-121">Правильное решение зависит от сложности запросов.</span><span class="sxs-lookup"><span data-stu-id="58edf-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="58edf-122">Но в любом случае вам потребуется способ агрегирования сведений, если вы хотите повысить эффективность обмена данными в системе.</span><span class="sxs-lookup"><span data-stu-id="58edf-122">But in any case, you'll need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="58edf-123">Ниже перечислены наиболее популярные решения.</span><span class="sxs-lookup"><span data-stu-id="58edf-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="58edf-124">**Шлюз API**.</span><span class="sxs-lookup"><span data-stu-id="58edf-124">**API Gateway.**</span></span> <span data-ttu-id="58edf-125">Для простого объединения данных из нескольких микрослужб с разными базами данных рекомендуется использовать микрослужбу агрегирования — шлюз API.</span><span class="sxs-lookup"><span data-stu-id="58edf-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="58edf-126">Будьте осторожны при применении этого шаблона, поскольку он может стать слабым местом вашей системы и нарушить принцип автономности микрослужб.</span><span class="sxs-lookup"><span data-stu-id="58edf-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="58edf-127">Чтобы смягчить негативные последствия, используйте несколько мелких шлюзов API для различных вертикальных срезов или областей системы.</span><span class="sxs-lookup"><span data-stu-id="58edf-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical "slice" or business area of the system.</span></span> <span data-ttu-id="58edf-128">Шаблон шлюза API более подробно описан в разделе [Использование шлюза API](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) ниже.</span><span class="sxs-lookup"><span data-stu-id="58edf-128">The API Gateway pattern is explained in more detail in the [API Gateway section](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) later.</span></span>

<span data-ttu-id="58edf-129">**CQRS с таблицами запросов/чтения**.</span><span class="sxs-lookup"><span data-stu-id="58edf-129">**CQRS with query/reads tables.**</span></span> <span data-ttu-id="58edf-130">Еще одно решение для объединения данных из нескольких микрослужб — [шаблон материализованного представления](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span><span class="sxs-lookup"><span data-stu-id="58edf-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="58edf-131">При таком подходе вы заранее создаете (готовите денормализованные данные до фактической отправки запросов) таблицу, доступную только для чтения, с данными, принадлежащими нескольким микрослужбам.</span><span class="sxs-lookup"><span data-stu-id="58edf-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that's owned by multiple microservices.</span></span> <span data-ttu-id="58edf-132">Таблица имеет формат, соответствующий потребностям клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="58edf-132">The table has a format suited to the client app's needs.</span></span>

<span data-ttu-id="58edf-133">Представьте себе экран мобильного приложения.</span><span class="sxs-lookup"><span data-stu-id="58edf-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="58edf-134">Если у вас одна база данных, вы можете собрать данные для этого экрана с помощью SQL-запроса, выполняющего сложное соединение с использованием нескольких таблиц.</span><span class="sxs-lookup"><span data-stu-id="58edf-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="58edf-135">Но если у вас несколько баз данных и каждая база данных принадлежит отдельной микрослужбе, невозможно отправить в них запрос и создать соединение SQL.</span><span class="sxs-lookup"><span data-stu-id="58edf-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="58edf-136">Такой сложный запрос становится проблемой.</span><span class="sxs-lookup"><span data-stu-id="58edf-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="58edf-137">Эту проблему можно решить с помощью подхода CQRS — создайте денормализованную таблицу в другой базе данных, которая используется только для запросов.</span><span class="sxs-lookup"><span data-stu-id="58edf-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that's used just for queries.</span></span> <span data-ttu-id="58edf-138">Таблица может предназначаться специально для данных, необходимых в этом сложном запросе, и между полями, необходимыми для экрана приложения, и столбцами в таблице запроса может существовать отношение один к одному.</span><span class="sxs-lookup"><span data-stu-id="58edf-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application's screen and the columns in the query table.</span></span> <span data-ttu-id="58edf-139">Такой метод также можно использовать для составления отчетов.</span><span class="sxs-lookup"><span data-stu-id="58edf-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="58edf-140">Этот подход позволяет не только решить изначальную проблему (как отправлять запросы в несколько микрослужб), но и значительно повысить производительность по сравнению с использованием сложных соединений, поскольку у вас уже есть все необходимые приложению данные в таблице запроса.</span><span class="sxs-lookup"><span data-stu-id="58edf-140">This approach not only solves the original problem (how to query and join across microservices), but it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="58edf-141">Конечно, если вы используете принцип разделения ответственности на команды и запросы (Command and Query Responsibility Segregation, CQRS) с таблицами запросов/чтения, придется проделать дополнительную работу и проследить за итоговой согласованностью.</span><span class="sxs-lookup"><span data-stu-id="58edf-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you'll need to embrace eventual consistency.</span></span> <span data-ttu-id="58edf-142">Тем не менее мы рекомендуем применять принцип CQRS с несколькими базами данных там, где существуют особые требования к производительности и масштабируемости в ситуации [совместной работы](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (или соперничества, это как посмотреть).</span><span class="sxs-lookup"><span data-stu-id="58edf-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) are where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="58edf-143">**"Холодные данные" в центральных базах данных**.</span><span class="sxs-lookup"><span data-stu-id="58edf-143">**"Cold data" in central databases.**</span></span> <span data-ttu-id="58edf-144">Для составления сложных отчетов и выполнения запросов, не требующих немедленного ответа, рекомендуется экспортировать "горячие данные" (данные о транзакциях из микрослужб) как "холодные данные" в большие базы данных, использующиеся только для отчетности.</span><span class="sxs-lookup"><span data-stu-id="58edf-144">For complex reports and queries that might not require real-time data, a common approach is to export your "hot data" (transactional data from the microservices) as "cold data" into large databases that are used only for reporting.</span></span> <span data-ttu-id="58edf-145">Система центральной базы данных может основываться на больших данных, например Hadoop, представлять собой хранилище данных, например на базе хранилища данных Azure SQL, или являться просто базой данных SQL, использующейся только для отчетов (если размер не имеет значения).</span><span class="sxs-lookup"><span data-stu-id="58edf-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database that's used just for reports (if size won't be an issue).</span></span>

<span data-ttu-id="58edf-146">Имейте в виду, что эта централизованная база данных будет использоваться только для запросов и отчетов, которым не требуются данные в режиме реального времени.</span><span class="sxs-lookup"><span data-stu-id="58edf-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="58edf-147">Исходные обновления и транзакции в качестве источника истины должны храниться в данных микрослужб.</span><span class="sxs-lookup"><span data-stu-id="58edf-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="58edf-148">Синхронизируйте данные при наступлении событий (как описано в следующих разделах) или через инструменты импорта и экспорта инфраструктуры другой базы данных.</span><span class="sxs-lookup"><span data-stu-id="58edf-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="58edf-149">Если вы используете управление событиями, процесс интеграции будет схож с методом распространения данных, описанным в разделе о таблицах запросов по принципу CQRS.</span><span class="sxs-lookup"><span data-stu-id="58edf-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="58edf-150">Но если в приложении требуется непрерывное агрегирование сведений из нескольких микрослужб для выполнения сложных запросов, это может быть признаком плохой структуры — микрослужбы должны быть максимально изолированы друг от друга.</span><span class="sxs-lookup"><span data-stu-id="58edf-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design -a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="58edf-151">(Мы не учитываем отчеты и аналитику, которые всегда должны использовать центральные базы данных с "холодными данными".) Если такая проблема возникает, возможно, следует объединить микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="58edf-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="58edf-152">Попробуйте найти баланс между автономностью развития и развертывания каждой микрослужбы и прочными зависимостями, слаженностью и агрегированием данных.</span><span class="sxs-lookup"><span data-stu-id="58edf-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="58edf-153">Проблема \#3. Как добиться согласованности нескольких микрослужб</span><span class="sxs-lookup"><span data-stu-id="58edf-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="58edf-154">Как мы уже говорили, данные микрослужбы принадлежат только ей, и получить их можно только через API микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="58edf-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="58edf-155">Поэтому встает вопрос, как реализовать целостные бизнес-процессы, сохраняя согласованность нескольких микрослужб.</span><span class="sxs-lookup"><span data-stu-id="58edf-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="58edf-156">Чтобы проанализировать эту проблему, рассмотрим пример из [примера приложения eShopOnContainers](https://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="58edf-156">To analyze this problem, let's look at an example from the [eShopOnContainers reference application](https://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="58edf-157">Микрослужба каталога хранит сведения обо всех товарах, включая их цены.</span><span class="sxs-lookup"><span data-stu-id="58edf-157">The Catalog microservice maintains information about all the products, including the product price.</span></span> <span data-ttu-id="58edf-158">Микрослужба корзины управляет временными данными о товарах, которые пользователи добавляют в корзину, включая стоимость элементов на момент их добавления в корзину.</span><span class="sxs-lookup"><span data-stu-id="58edf-158">The Basket microservice manages temporal data about product items that users are adding to their shopping baskets, which includes the price of the items at the time they were added to the basket.</span></span> <span data-ttu-id="58edf-159">При обновлении цены товара в каталоге эта цена также должна обновляться в активных корзинах, содержащих этот товар, кроме того, системе, наверное, следует предупреждать пользователей о том, что цена определенного элемента изменилась с тех пор, как они добавили его в свою корзину.</span><span class="sxs-lookup"><span data-stu-id="58edf-159">When a product's price is updated in the catalog, that price should also be updated in the active baskets that hold that same product, plus the system should probably warn the user saying that a particular item's price has changed since they added it to their basket.</span></span>

<span data-ttu-id="58edf-160">В гипотетической монолитной версии этого приложения при изменении цены в таблице "Товары" подсистема каталога может просто использовать транзакцию ACID, чтобы обновить текущую цену в таблице "Корзина".</span><span class="sxs-lookup"><span data-stu-id="58edf-160">In a hypothetical monolithic version of this application, when the price changes in the products table, the catalog subsystem could simply use an ACID transaction to update the current price in the Basket table.</span></span>

<span data-ttu-id="58edf-161">Однако в приложении на базе микрослужб таблицы "Товар" и "Корзина" находятся в соответствующих микрослужбах.</span><span class="sxs-lookup"><span data-stu-id="58edf-161">However, in a microservices-based application, the Product and Basket tables are owned by their respective microservices.</span></span> <span data-ttu-id="58edf-162">Микрослужбы никогда не должны включать таблицы или хранилища других микрослужб в свои транзакции, и в том числе в прямые запросы, как показано на рис. 4-9.</span><span class="sxs-lookup"><span data-stu-id="58edf-162">No microservice should ever include tables/storage owned by another microservice in its own transactions, not even in direct queries, as shown in Figure 4-9.</span></span>

![Схема, показывающая, что невозможно предоставить общий доступ к данным базы данных микрослужб.](./media/distributed-data-management/indepentent-microservice-databases.png)

<span data-ttu-id="58edf-164">**Рис. 4-9**.</span><span class="sxs-lookup"><span data-stu-id="58edf-164">**Figure 4-9**.</span></span> <span data-ttu-id="58edf-165">Микрослужба не может обратиться к таблице другой микрослужбы напрямую</span><span class="sxs-lookup"><span data-stu-id="58edf-165">A microservice can't directly access a table in another microservice</span></span>

<span data-ttu-id="58edf-166">Микрослужба каталога не должна напрямую изменять таблицу "Корзина", поскольку эта таблица принадлежит микрослужбе корзины.</span><span class="sxs-lookup"><span data-stu-id="58edf-166">The Catalog microservice shouldn't update the Basket table directly, because the Basket table is owned by the Basket microservice.</span></span> <span data-ttu-id="58edf-167">Чтобы обновить сведения в микрослужбе корзины, микрослужба каталога может использовать только итоговую согласованность, возможно на основе асинхронной связи, например событий интеграции (взаимодействие на основе сообщений и событий).</span><span class="sxs-lookup"><span data-stu-id="58edf-167">To make an update to the Basket microservice, the Catalog microservice should use eventual consistency probably based on asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="58edf-168">Вот как такая итоговая согласованность микрослужб выполняется в примере приложения [eShopOnContainers](https://aka.ms/eshoponcontainers).</span><span class="sxs-lookup"><span data-stu-id="58edf-168">This is how the [eShopOnContainers](https://aka.ms/eshoponcontainers) reference application performs this type of consistency across microservices.</span></span>

<span data-ttu-id="58edf-169">Как гласит [теорема CAP](https://en.wikipedia.org/wiki/CAP_theorem), вы должны выбирать между доступностью и согласованностью данных по принципу ACID.</span><span class="sxs-lookup"><span data-stu-id="58edf-169">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="58edf-170">В большинстве случаев при использовании микрослужб доступность и масштабируемость имеют приоритет над строгой согласованностью.</span><span class="sxs-lookup"><span data-stu-id="58edf-170">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="58edf-171">Критически важные приложения должны непрерывно работать, и разработчики могут решить проблему строгой согласованности, используя методы работы со слабой или итоговой согласованностью.</span><span class="sxs-lookup"><span data-stu-id="58edf-171">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="58edf-172">Такой подход используется в большинстве архитектур на базе микрослужб.</span><span class="sxs-lookup"><span data-stu-id="58edf-172">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="58edf-173">Кроме того, транзакции в стиле ACID или с двухфазной фиксацией не просто противоречат принципам микрослужб — большинство баз данных NoSQL (например, Azure Cosmos DB, MongoDB и т. д.) не поддерживают транзакции с двухфазной фиксацией, типичные для сценариев распространенных баз данных.</span><span class="sxs-lookup"><span data-stu-id="58edf-173">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions, typical in distributed databases scenarios.</span></span> <span data-ttu-id="58edf-174">Согласованность данных в разных службах и базах данных все же имеет большое значение.</span><span class="sxs-lookup"><span data-stu-id="58edf-174">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="58edf-175">Эта проблема также связана с вопросом распространения изменений в нескольких микрослужбах, когда некоторые данные должны быть избыточными — например, когда название или описание товара должно присутствовать в микрослужбе каталога и в микрослужбе корзины.</span><span class="sxs-lookup"><span data-stu-id="58edf-175">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product's name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="58edf-176">Хорошим решением этой проблемы может стать использование итоговой согласованности между микрослужбами, выраженной в управляемом событиями взаимодействии и системе публикации и подписки.</span><span class="sxs-lookup"><span data-stu-id="58edf-176">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="58edf-177">Эти темы обсуждаются в разделе [Асинхронное взаимодействие, управляемое событиями](asynchronous-message-based-communication.md#asynchronous-event-driven-communication).</span><span class="sxs-lookup"><span data-stu-id="58edf-177">These topics are covered in the section [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="58edf-178">Проблема \#4. Как реализовать взаимодействие через границы микрослужб</span><span class="sxs-lookup"><span data-stu-id="58edf-178">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="58edf-179">Взаимодействие через границы микрослужб является настоящей проблемой.</span><span class="sxs-lookup"><span data-stu-id="58edf-179">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="58edf-180">В этом контексте взаимодействие не подразумевает выбор протокола (HTTP и REST, AMQP, обмен сообщениями и так далее).</span><span class="sxs-lookup"><span data-stu-id="58edf-180">In this context, communication doesn't refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="58edf-181">Нужно подумать, какой стиль следует использовать и, особенно, насколько микрослужбы должны зависеть друг от друга.</span><span class="sxs-lookup"><span data-stu-id="58edf-181">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="58edf-182">В случае сбоя его последствия для системы будут определяться степенью этой взаимозависимости.</span><span class="sxs-lookup"><span data-stu-id="58edf-182">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="58edf-183">В распределенной системе, например в приложении на базе микрослужб, где существует множество элементов и службы расположены на множестве серверов или узлов, сбой неизбежен.</span><span class="sxs-lookup"><span data-stu-id="58edf-183">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="58edf-184">Частичный сбой или даже более масштабная проблема возникнут непременно, и необходимо учитывать этот факт при разработке микрослужб и взаимодействия между ними, не забывая о рисках, присущих распределенным системам такого типа.</span><span class="sxs-lookup"><span data-stu-id="58edf-184">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them considering the common risks in this type of distributed system.</span></span>

<span data-ttu-id="58edf-185">Чаще всего используются службы на базе HTTP (REST), поскольку они очень простые.</span><span class="sxs-lookup"><span data-stu-id="58edf-185">A popular approach is to implement HTTP (REST)-based microservices, due to their simplicity.</span></span> <span data-ttu-id="58edf-186">Использовать HTTP можно. Но как именно?</span><span class="sxs-lookup"><span data-stu-id="58edf-186">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="58edf-187">Если вы используете запросы и ответы HTTP только для взаимодействия между микрослужбами и клиентскими приложениями или шлюзами API, это нормально.</span><span class="sxs-lookup"><span data-stu-id="58edf-187">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that's fine.</span></span> <span data-ttu-id="58edf-188">Но если вы создаете длинные цепочки синхронных HTTP-вызовов для взаимодействия через границы микрослужб, как если бы микрослужбы были объектами в монолитном приложении, в конце концов в приложении возникнут проблемы.</span><span class="sxs-lookup"><span data-stu-id="58edf-188">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="58edf-189">Представьте, что клиентское приложение делает вызов HTTP API к отдельной микрослужбе, например микрослужбе заказов.</span><span class="sxs-lookup"><span data-stu-id="58edf-189">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="58edf-190">Если микрослужба заказов, в свою очередь, вызывает дополнительные микрослужбы по протоколу HTTP в рамках одного цикла запросов и ответов, вы создадите цепочку HTTP-вызовов.</span><span class="sxs-lookup"><span data-stu-id="58edf-190">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you're creating a chain of HTTP calls.</span></span> <span data-ttu-id="58edf-191">Поначалу это может казаться разумным.</span><span class="sxs-lookup"><span data-stu-id="58edf-191">It might sound reasonable initially.</span></span> <span data-ttu-id="58edf-192">Но при таком подходе следует учитывать несколько важных аспектов:</span><span class="sxs-lookup"><span data-stu-id="58edf-192">However, there are important points to consider when going down this path:</span></span>

- <span data-ttu-id="58edf-193">Блокировка и низкая производительность.</span><span class="sxs-lookup"><span data-stu-id="58edf-193">Blocking and low performance.</span></span> <span data-ttu-id="58edf-194">Поскольку HTTP-запросы синхронные по своей природе, изначальный запрос не получит ответ, пока все внутренние HTTP-вызовы не завершатся.</span><span class="sxs-lookup"><span data-stu-id="58edf-194">Due to the synchronous nature of HTTP, the original request doesn't get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="58edf-195">Представьте, что число этих вызовов значительно возрастет и при этом один из промежуточных HTTP-вызовов к микрослужбе будет заблокирован.</span><span class="sxs-lookup"><span data-stu-id="58edf-195">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="58edf-196">Это негативно отразится на производительности и масштабируемости приложения, ведь количество HTTP-запросов увеличится.</span><span class="sxs-lookup"><span data-stu-id="58edf-196">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

- <span data-ttu-id="58edf-197">Взаимозависимость микрослужб и HTTP.</span><span class="sxs-lookup"><span data-stu-id="58edf-197">Coupling microservices with HTTP.</span></span> <span data-ttu-id="58edf-198">Микрослужбы для бизнеса не следует объединять друг с другом.</span><span class="sxs-lookup"><span data-stu-id="58edf-198">Business microservices shouldn't be coupled with other business microservices.</span></span> <span data-ttu-id="58edf-199">В идеале они даже не должны "знать" о существовании других микрослужб.</span><span class="sxs-lookup"><span data-stu-id="58edf-199">Ideally, they shouldn't "know" about the existence of other microservices.</span></span> <span data-ttu-id="58edf-200">Если приложение использует взаимозависимые микрослужбы, как в примере, добиться автономности каждой микрослужбы будет практически невозможно.</span><span class="sxs-lookup"><span data-stu-id="58edf-200">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

- <span data-ttu-id="58edf-201">Сбой в одной микрослужбе.</span><span class="sxs-lookup"><span data-stu-id="58edf-201">Failure in any one microservice.</span></span> <span data-ttu-id="58edf-202">Если вы создали цепочку микрослужб, соединенную HTTP-вызовами, при сбое одной микрослужбы (а сбой неизбежен) вся цепочка перестанет работать.</span><span class="sxs-lookup"><span data-stu-id="58edf-202">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="58edf-203">Система на базе микрослужб должна максимально сохранять работоспособность в случае частичных сбоев.</span><span class="sxs-lookup"><span data-stu-id="58edf-203">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="58edf-204">Даже если вы применяете логику, которая использует повторные попытки с экспоненциальной задержкой или механизмы размыкания цепи, чем сложнее цепочки HTTP-вызовов, тем сложнее применить стратегию обработки сбоев на базе HTTP.</span><span class="sxs-lookup"><span data-stu-id="58edf-204">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is to implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="58edf-205">Если внутренние микрослужбы взаимодействуют с помощью цепочек HTTP-запросов, как описано выше, такое приложение можно назвать монолитным, но основанным на протоколе HTTP, а не на механизмах внутреннего взаимодействия процессов.</span><span class="sxs-lookup"><span data-stu-id="58edf-205">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intra-process communication mechanisms.</span></span>

<span data-ttu-id="58edf-206">Поэтому, чтобы повысить автономность и устойчивость микрослужб, следует как можно реже использовать цепочки запросов и ответов для взаимодействия между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="58edf-206">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="58edf-207">Рекомендуется использовать только асинхронное взаимодействие для связи между микрослужбами — асинхронное взаимодействие, управляемое сообщениями и событиями, или (асинхронные) HTTP-опросы независимо от изначального цикла HTTP-запросов и ответов.</span><span class="sxs-lookup"><span data-stu-id="58edf-207">It's recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using (asynchronous) HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="58edf-208">Более подробно асинхронное взаимодействие описывается в разделах [Асинхронная интеграция микрослужб в целях автономности](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) и [Асинхронное взаимодействие на базе сообщений](asynchronous-message-based-communication.md).</span><span class="sxs-lookup"><span data-stu-id="58edf-208">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice's autonomy](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) and [Asynchronous message-based communication](asynchronous-message-based-communication.md).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="58edf-209">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="58edf-209">Additional resources</span></span>

- <span data-ttu-id="58edf-210">**Теорема CAP** </span><span class="sxs-lookup"><span data-stu-id="58edf-210">**CAP theorem** </span></span>\
  <https://en.wikipedia.org/wiki/CAP_theorem>

- <span data-ttu-id="58edf-211">**Итоговая согласованность** </span><span class="sxs-lookup"><span data-stu-id="58edf-211">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="58edf-212">**Основные сведения о согласованности данных** </span><span class="sxs-lookup"><span data-stu-id="58edf-212">**Data Consistency Primer** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)>

- <span data-ttu-id="58edf-213">**Мартин Фоулер (Martin Fowler). CQRS (разделение обязанностей запросов и команд)**  </span><span class="sxs-lookup"><span data-stu-id="58edf-213">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)** </span></span>\
  <https://martinfowler.com/bliki/CQRS.html>

- <span data-ttu-id="58edf-214">**Материализованное представление** </span><span class="sxs-lookup"><span data-stu-id="58edf-214">**Materialized View** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/materialized-view>

- <span data-ttu-id="58edf-215">**Чарльз Роу (Charles Row). Кислота (ACID) и основание (BASE): изменение pH-показателя обработки транзакций в базах данных** </span><span class="sxs-lookup"><span data-stu-id="58edf-215">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing** </span></span>\
  <https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/>

- <span data-ttu-id="58edf-216">**Компенсирующие транзакции** </span><span class="sxs-lookup"><span data-stu-id="58edf-216">**Compensating Transaction** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction>

- <span data-ttu-id="58edf-217">**Уди Дахан (Udi Dahan). Объединение на основе служб** </span><span class="sxs-lookup"><span data-stu-id="58edf-217">**Udi Dahan. Service Oriented Composition** </span></span>\
  <http://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

>[!div class="step-by-step"]
><span data-ttu-id="58edf-218">[Назад](logical-versus-physical-architecture.md)
>[Вперед](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="58edf-218">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
