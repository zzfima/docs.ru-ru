---
title: Асинхронное взаимодействие на основе сообщений
description: Архитектура микрослужб .NET для контейнерных приложений .NET | Асинхронная связь на основе сообщений является основным понятием в архитектуре микрослужб, так как это лучший способ обеспечить независимость микрослужб друг от друга и при этом синхронизировать их.
ms.date: 09/20/2018
ms.openlocfilehash: c362bdaf41fee5ee20516b89b8bec12d6c0557cf
ms.sourcegitcommit: 4f4a32a5c16a75724920fa9627c59985c41e173c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/17/2019
ms.locfileid: "72522756"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="064a2-103">Асинхронное взаимодействие на основе сообщений</span><span class="sxs-lookup"><span data-stu-id="064a2-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="064a2-104">Асинхронный обмен сообщениями и взаимодействие, управляемое событиями, имеют важное значение при распространении изменений по многим микрослужбам и связанным с ними моделям доменов.</span><span class="sxs-lookup"><span data-stu-id="064a2-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="064a2-105">Как упоминалось ранее в обсуждении микрослужб и ограниченных контекстов (BC), модели (пользователь, клиент, продукт, учетная запись и т. д.) могут иметь разное значение для разных микрослужб или BC.</span><span class="sxs-lookup"><span data-stu-id="064a2-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="064a2-106">Это означает, что при внесении изменений необходимо найти способ согласовать эти изменения для разных моделей.</span><span class="sxs-lookup"><span data-stu-id="064a2-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="064a2-107">Для решения этой проблемы необходимо обеспечить итоговую согласованность и взаимодействие, управляемое событиями, на основе асинхронного обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="064a2-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="064a2-108">При использовании системы обмена сообщениями процессы взаимодействуют путем асинхронного обмена сообщениями.</span><span class="sxs-lookup"><span data-stu-id="064a2-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="064a2-109">Клиент отправляет команду или запрос в службу при помощи сообщения.</span><span class="sxs-lookup"><span data-stu-id="064a2-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="064a2-110">Если служба должна ответить, она отправляет ответное сообщение клиенту.</span><span class="sxs-lookup"><span data-stu-id="064a2-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="064a2-111">Так как это взаимодействие на основе сообщений, клиент знает, что ответ может поступить не сразу, а возможно, что ответа не будет вообще.</span><span class="sxs-lookup"><span data-stu-id="064a2-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="064a2-112">Сообщение состоит из заголовка (метаданные, например, идентификатор или данные для обеспечения безопасности) и текста.</span><span class="sxs-lookup"><span data-stu-id="064a2-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="064a2-113">Обычно сообщения отправляются с использованием асинхронного протокола, например AMQP.</span><span class="sxs-lookup"><span data-stu-id="064a2-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="064a2-114">Предпочтительной инфраструктурой для такого типа обмена данными в сообществе микрослужб является упрощенный брокер сообщений, который отличается от больших брокеров и оркестраторов, используемых в SOA.</span><span class="sxs-lookup"><span data-stu-id="064a2-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="064a2-115">В случае упрощенного брокера сообщений задача инфраструктуры обычно сводится к выполнению функций брокера обмена сообщениями с использованием простой реализации, например RabbitMQ или масштабируемой служебной шины в облаке, такой как служебная шина Azure.</span><span class="sxs-lookup"><span data-stu-id="064a2-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="064a2-116">При таком сценарии основная обработка данных выполняется в конечных точках, там, где создаются и используются сообщения, т. е. микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="064a2-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="064a2-117">Есть еще правило, которого следует придерживаться, насколько это возможно. Между внутренними службами следует использовать только асинхронный обмен сообщениями, а синхронное взаимодействие (например, HTTP) использовать только для клиентских приложений, работающих со службами интерфейса (шлюзами API и микрослужбами первого уровня).</span><span class="sxs-lookup"><span data-stu-id="064a2-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="064a2-118">Существует два типа асинхронного обмена сообщениями: взаимодействие на основе сообщений с одним получателем и взаимодействие с несколькими получателями.</span><span class="sxs-lookup"><span data-stu-id="064a2-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="064a2-119">В следующих разделах содержатся дополнительные сведения об этих типах обмена.</span><span class="sxs-lookup"><span data-stu-id="064a2-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="064a2-120">Взаимодействие на основе сообщений с одним получателем</span><span class="sxs-lookup"><span data-stu-id="064a2-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="064a2-121">Асинхронное взаимодействие на основе сообщений с одним получателем — это передача данных от одного узла другому, когда единственный получатель считывает сообщение из канала и сообщение обрабатывается только один раз.</span><span class="sxs-lookup"><span data-stu-id="064a2-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="064a2-122">Однако существуют особые случаи.</span><span class="sxs-lookup"><span data-stu-id="064a2-122">However, there are special situations.</span></span> <span data-ttu-id="064a2-123">Например, в облачной системе, когда предпринимаются попытки автоматического восстановления после сбоя, одно и то же сообщение может быть отправлено многократно.</span><span class="sxs-lookup"><span data-stu-id="064a2-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="064a2-124">Чтобы быть устойчивым к сетевым и другим сбоям, клиент должен иметь возможность повторить отправку сообщения, а сервер должен обеспечить идемпотентность операции, чтобы обработать каждое конкретное сообщение только один раз.</span><span class="sxs-lookup"><span data-stu-id="064a2-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="064a2-125">Взаимодействие на основе сообщений с одним получателем особенно хорошо подходит в случаях отправки асинхронных команд из одной микрослужбы другую. На рис. 4-18 иллюстрируется этот метод.</span><span class="sxs-lookup"><span data-stu-id="064a2-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="064a2-126">После того как вы начнете взаимодействие на основе сообщений (с использованием команд или событий), вам не следует использовать этот тип взаимодействия вместе с синхронным обменом по протоколу HTTP.</span><span class="sxs-lookup"><span data-stu-id="064a2-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![Одна микрослужба, получающая асинхронное сообщение](./media/asynchronous-message-based-communication/single-receiver-message-based-communication.png)

<span data-ttu-id="064a2-128">**Рис. 4-18**.</span><span class="sxs-lookup"><span data-stu-id="064a2-128">**Figure 4-18**.</span></span> <span data-ttu-id="064a2-129">Одна микрослужба, получающая асинхронное сообщение</span><span class="sxs-lookup"><span data-stu-id="064a2-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="064a2-130">Обратите внимание, что когда команды поступают из клиентских приложений, они могут быть реализованы в виде синхронных команд HTTP.</span><span class="sxs-lookup"><span data-stu-id="064a2-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="064a2-131">Команды на основе сообщений следует использовать в случае необходимости обеспечения высокой масштабируемости или тогда, когда уже запущен бизнес-процесс на основе сообщений.</span><span class="sxs-lookup"><span data-stu-id="064a2-131">You should use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="064a2-132">Взаимодействие на основе сообщений с несколькими получателями</span><span class="sxs-lookup"><span data-stu-id="064a2-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="064a2-133">Существует более гибкий подход. Это механизм публикации или подписки, позволяющий сделать сообщения от отправителя доступными дополнительным микрослужбам-подписчикам или внешним приложениям.</span><span class="sxs-lookup"><span data-stu-id="064a2-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="064a2-134">Он позволяет реализовать [принцип "открыт — закрыт"](https://en.wikipedia.org/wiki/Open/closed_principle) в службе отправки.</span><span class="sxs-lookup"><span data-stu-id="064a2-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="064a2-135">Таким образом, в будущем могут быть добавлены дополнительные подписчики без изменения службы отправителя.</span><span class="sxs-lookup"><span data-stu-id="064a2-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="064a2-136">При взаимодействии на основе публикаций и подписок вы, возможно, будете использовать интерфейс шины событий при публикации событий для всех подписчиков.</span><span class="sxs-lookup"><span data-stu-id="064a2-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="064a2-137">Асинхронное взаимодействие, управляемое событиями</span><span class="sxs-lookup"><span data-stu-id="064a2-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="064a2-138">При использовании асинхронного взаимодействия, управляемого событиями, одна микрослужба публикует событие интеграции, когда что-то происходит внутри ее домена, а другая микрослужба должна узнать об этом. Пример такого события — изменение цены в микрослужбе каталога продукции.</span><span class="sxs-lookup"><span data-stu-id="064a2-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="064a2-139">Дополнительные микрослужбы подписываются на события, что позволяет им получать данные о них асинхронно.</span><span class="sxs-lookup"><span data-stu-id="064a2-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="064a2-140">В этом случае получатели могут обновить свои собственные сущности домена, что может вызвать появление новых событий интеграции, которые будут опубликованы.</span><span class="sxs-lookup"><span data-stu-id="064a2-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="064a2-141">Эта система публикаций и подписок обычно реализуется с помощью шины событий.</span><span class="sxs-lookup"><span data-stu-id="064a2-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="064a2-142">Шина событий может быть разработана как абстракция или интерфейс с API, необходимым для подписки и отмены подписки на события и для публикации событий.</span><span class="sxs-lookup"><span data-stu-id="064a2-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="064a2-143">Шина событий может иметь одну или несколько реализаций на основе любого межпроцессорного брокера или брокера обмена сообщениями как очередь сообщений или служебная шина, поддерживающая асинхронное взаимодействие и модель публикаций и подписок.</span><span class="sxs-lookup"><span data-stu-id="064a2-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="064a2-144">Если система использует итоговую согласованность, управляемую событиями интеграции, рекомендуется разъяснить этот подход конечным пользователям.</span><span class="sxs-lookup"><span data-stu-id="064a2-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made completely clear to the end user.</span></span> <span data-ttu-id="064a2-145">Не следует использовать в системе подход, который имитирует события интеграции, как, например, в системе SignalR или системах опроса клиентов.</span><span class="sxs-lookup"><span data-stu-id="064a2-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="064a2-146">Конечный пользователь и владелец компании должны открыто принимать использование в системе принципа итоговой согласованности и понимать, что в большинстве случаев у бизнеса не возникает проблем с этим подходом до тех пор, пока он является открытым.</span><span class="sxs-lookup"><span data-stu-id="064a2-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="064a2-147">Это важно, поскольку пользователи ожидают увидеть некоторые результаты сразу, а с итоговой согласованностью их может не быть.</span><span class="sxs-lookup"><span data-stu-id="064a2-147">This is important because users might expect to see some results immediately and this might not happen with eventual consistency.</span></span>

<span data-ttu-id="064a2-148">Как отмечалось ранее в разделе [Распределенное управление данными. Проблемы и решения](distributed-data-management.md), события интеграции можно использовать для реализации бизнес-задач, охватывающих многие микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="064a2-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="064a2-149">Таким образом, вы получите итоговую согласованность между этими службами.</span><span class="sxs-lookup"><span data-stu-id="064a2-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="064a2-150">Согласованная по принципу итоговой согласованности транзакция состоит из коллекции распределенных действий.</span><span class="sxs-lookup"><span data-stu-id="064a2-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="064a2-151">В каждом действии соответствующая микрослужба обновляет сущность домена и публикует другое событие интеграции, которое вызывает следующее действие в рамках той же конечной задачи.</span><span class="sxs-lookup"><span data-stu-id="064a2-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="064a2-152">Важно то, что вы можете передать сообщение сразу нескольким микрослужбам, которые подписаны на это событие.</span><span class="sxs-lookup"><span data-stu-id="064a2-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="064a2-153">Чтобы сделать это, вы можете использовать систему обмена сообщениями о публикациях и подписках на основе взаимодействия, управляемого событиями, как показано на рис. 4-19.</span><span class="sxs-lookup"><span data-stu-id="064a2-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="064a2-154">Этот механизм публикаций и подписок используется не только в архитектуре микрослужб.</span><span class="sxs-lookup"><span data-stu-id="064a2-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="064a2-155">Он похож на способ, которым взаимодействуют [ограниченные контексты](https://martinfowler.com/bliki/BoundedContext.html) в DDD, или на способ распространения обновлений от баз данных записи к базам данных чтения в архитектурах типа [разделение команд и запросов (CQRS)](https://martinfowler.com/bliki/CQRS.html).</span><span class="sxs-lookup"><span data-stu-id="064a2-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="064a2-156">Цель — получить итоговую согласованность между различными источниками данных в распределенной системе.</span><span class="sxs-lookup"><span data-stu-id="064a2-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![Схема, демонстрирующая асинхронное взаимодействие, управляемое событиями.](./media/asynchronous-message-based-communication/asynchronous-event-driven-communication.png)

<span data-ttu-id="064a2-158">**Рис. 4-19**.</span><span class="sxs-lookup"><span data-stu-id="064a2-158">**Figure 4-19**.</span></span> <span data-ttu-id="064a2-159">Асинхронное взаимодействие, управляемое сообщением о событиях</span><span class="sxs-lookup"><span data-stu-id="064a2-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="064a2-160">В асинхронном взаимодействии на основе событий одна микрослужба публикует события в шине событий, и многие микрослужбы могут подписаться на него, чтобы получать уведомления и реагировать.</span><span class="sxs-lookup"><span data-stu-id="064a2-160">In asynchronous event-driven communication one microservice publishes events to an event bus and many microservices can subscribe to it, to get notified and act on it.</span></span> <span data-ttu-id="064a2-161">Протокол, используемый для взаимодействия на основе сообщений, управляемого событиями, зависит от вашей реализации.</span><span class="sxs-lookup"><span data-stu-id="064a2-161">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="064a2-162">Протокол [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) позволяет добиться надежного взаимодействия с использованием очередей.</span><span class="sxs-lookup"><span data-stu-id="064a2-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="064a2-163">При использовании шины событий может возникнуть необходимость использования уровня абстракции (например, интерфейса шины событий) на основе соответствующей реализации в классах с кодом, использующим API из брокера сообщений, например [RabbitMQ](https://www.rabbitmq.com/) или служебной шины, такой как [служебная шина Azure с разделами](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="064a2-163">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="064a2-164">Кроме того, можно использовать служебную шину более высокого уровня, например NServiceBus, MassTransit или Brighter, чтобы связать вашу шину событий и систему публикаций и подписок.</span><span class="sxs-lookup"><span data-stu-id="064a2-164">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="064a2-165">Примечание о технологии обмена сообщениями для производственных систем</span><span class="sxs-lookup"><span data-stu-id="064a2-165">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="064a2-166">Технологии обмена сообщениями, с помощью которых можно реализовать абстрактную шину событий, находятся на разных уровнях.</span><span class="sxs-lookup"><span data-stu-id="064a2-166">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="064a2-167">Например, такие продукты, как RabbitMQ (транспорт брокера обмена сообщениями) и служебная шина Azure находятся на более низком уровне, чем другие продукты, такие как NServiceBus, MassTransit и Brighter, которые могут работать, используя RabbitMQ и служебную шину Azure.</span><span class="sxs-lookup"><span data-stu-id="064a2-167">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="064a2-168">Выбор зависит от того, насколько много сложных функций уровня приложения и готовых к использованию возможностей масштабирования необходимо для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="064a2-168">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="064a2-169">Для реализации шины событий, предназначенной только для демонстрации принципа работы и используемой в среде разработки, как было показано на примере eShopOnContainers, будет достаточно простой реализации на основе системы RabbitMQ, работающей в контейнере Docker.</span><span class="sxs-lookup"><span data-stu-id="064a2-169">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="064a2-170">Для построения критически важных и производственных систем, требующих широких возможностей масштабирования, следует использовать служебную шину Azure.</span><span class="sxs-lookup"><span data-stu-id="064a2-170">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="064a2-171">Для обеспечения высокого уровня абстракции и функций, облегчающих разработку распределенных приложений, рекомендуется использовать другие коммерческие служебные шины и служебные шины с открытым кодом, такие как NServiceBus, MassTransit и Brighter.</span><span class="sxs-lookup"><span data-stu-id="064a2-171">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="064a2-172">Кроме того, вы можете создавать свои собственные функции служебной шины на основе низкоуровневых технологий, таких как RabbitMQ и Docker.</span><span class="sxs-lookup"><span data-stu-id="064a2-172">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="064a2-173">Однако эта черная работа может оказаться слишком дорогим занятием при разработке корпоративного приложения.</span><span class="sxs-lookup"><span data-stu-id="064a2-173">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="064a2-174">Гибкая публикация в шине событий</span><span class="sxs-lookup"><span data-stu-id="064a2-174">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="064a2-175">Главной сложностью при реализации архитектуры, управляемой событиями, предназначенной для работы с несколькими микрослужбами, является обеспечение атомарного обновления состояния в исходной микрослужбе с одновременной гибкой публикацией соответствующего события интеграции в служебной шине, выполняемое с помощью транзакций.</span><span class="sxs-lookup"><span data-stu-id="064a2-175">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="064a2-176">Далее описано несколько способов достижения этого. Возможны и другие подходы.</span><span class="sxs-lookup"><span data-stu-id="064a2-176">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="064a2-177">Использование очереди транзакций (на основе DTC), подобной MSMQ.</span><span class="sxs-lookup"><span data-stu-id="064a2-177">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="064a2-178">(Этот способ применялся в системах более ранних версий.)</span><span class="sxs-lookup"><span data-stu-id="064a2-178">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="064a2-179">[Интеллектуальный анализ данных журнала транзакций](https://www.scoop.it/t/sql-server-transaction-log-mining).</span><span class="sxs-lookup"><span data-stu-id="064a2-179">Using [transaction log mining](https://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

- <span data-ttu-id="064a2-180">Использование полной модели [источников событий](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span><span class="sxs-lookup"><span data-stu-id="064a2-180">Using full [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="064a2-181">Использование [модели исходящих сообщений](http://www.kamilgrzybek.com/design/the-outbox-pattern/), таблицы базы данных транзакций как очереди сообщений, которая служит основой для компонента генерации событий, создающего и публикующего события.</span><span class="sxs-lookup"><span data-stu-id="064a2-181">Using the [Outbox pattern](http://www.kamilgrzybek.com/design/the-outbox-pattern/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="064a2-182">При использовании асинхронного взаимодействия следует дополнительно рассмотреть вопросы идемпотентности и дедупликации сообщений.</span><span class="sxs-lookup"><span data-stu-id="064a2-182">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="064a2-183">Эти вопросы рассматриваются в разделе [Реализация взаимодействия между микрослужбами на основе событий (события интеграции)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) далее в этом руководстве.</span><span class="sxs-lookup"><span data-stu-id="064a2-183">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="064a2-184">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="064a2-184">Additional resources</span></span>

- <span data-ttu-id="064a2-185">**Обмен сообщениями на основе событий** </span><span class="sxs-lookup"><span data-stu-id="064a2-185">**Event Driven Messaging** </span></span>\
  <https://soapatterns.org/design_patterns/event_driven_messaging>

- <span data-ttu-id="064a2-186">**Канал публикации или подписки** </span><span class="sxs-lookup"><span data-stu-id="064a2-186">**Publish/Subscribe Channel** </span></span>\
  <https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html>

- <span data-ttu-id="064a2-187">**Уди Дахан (Udi Dahan). Пояснения к CQRS** </span><span class="sxs-lookup"><span data-stu-id="064a2-187">**Udi Dahan. Clarified CQRS** </span></span>\
  <http://udidahan.com/2009/12/09/clarified-cqrs/>

- <span data-ttu-id="064a2-188">**Архитектура с разделением команд и запросов (CQRS)**  </span><span class="sxs-lookup"><span data-stu-id="064a2-188">**Command and Query Responsibility Segregation (CQRS)** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/cqrs>

- <span data-ttu-id="064a2-189">**Взаимодействие между ограниченными контекстами** </span><span class="sxs-lookup"><span data-stu-id="064a2-189">**Communicating Between Bounded Contexts** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)>

- <span data-ttu-id="064a2-190">**Итоговая согласованность** </span><span class="sxs-lookup"><span data-stu-id="064a2-190">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="064a2-191">**Джимми Богард (Jimmy Bogard). Рефакторинг для обеспечения отказоустойчивости: оценка взаимозависимости** </span><span class="sxs-lookup"><span data-stu-id="064a2-191">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** </span></span>\
  <https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/>

> [!div class="step-by-step"]
> <span data-ttu-id="064a2-192">[Назад](communication-in-microservice-architecture.md)
> [Вперед](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="064a2-192">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>
