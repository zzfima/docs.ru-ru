---
title: Сравнение шаблона шлюза API с прямым взаимодействием клиента и микрослужбы
description: Общие сведения о различиях использования шаблона шлюза API и прямого взаимодействия клиента и микрослужбы.
ms.date: 01/07/2019
ms.openlocfilehash: 47e9a383c1fcb6c9fec38cb376b60a4ab839077d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401559"
---
# <a name="the-api-gateway-pattern-versus-the-direct-client-to-microservice-communication"></a><span data-ttu-id="b37b4-103">Сравнение шаблона шлюза API с прямым взаимодействием клиента и микрослужбы</span><span class="sxs-lookup"><span data-stu-id="b37b4-103">The API gateway pattern versus the Direct client-to-microservice communication</span></span>

<span data-ttu-id="b37b4-104">В архитектуре микрослужб каждая микрослужба обычно предоставляет набор специализированных конечных точек.</span><span class="sxs-lookup"><span data-stu-id="b37b4-104">In a microservices architecture, each microservice exposes a set of (typically) fine-grained endpoints.</span></span> <span data-ttu-id="b37b4-105">Этот факт может повлиять на взаимодействие между клиентом и микрослужбой, как описано в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="b37b4-105">This fact can impact the client-to-microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="b37b4-106">Прямое взаимодействие между клиентом и микрослужбой</span><span class="sxs-lookup"><span data-stu-id="b37b4-106">Direct client-to-microservice communication</span></span>

<span data-ttu-id="b37b4-107">Возможный подход — использование архитектуры с прямым взаимодействием между клиентом и микрослужбой.</span><span class="sxs-lookup"><span data-stu-id="b37b4-107">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="b37b4-108">При таком подходе клиентские приложения могут отправлять запросы к некоторым микрослужбам напрямую, как показано на рис. 4-12.</span><span class="sxs-lookup"><span data-stu-id="b37b4-108">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![На схеме представлена архитектура с взаимодействием клиента и микрослужбы.](./media/direct-client-to-microservice-communication.png)

<span data-ttu-id="b37b4-110">**Рис. 4-12**.</span><span class="sxs-lookup"><span data-stu-id="b37b4-110">**Figure 4-12**.</span></span> <span data-ttu-id="b37b4-111">Использование архитектуры с прямым взаимодействием клиента и микрослужбы</span><span class="sxs-lookup"><span data-stu-id="b37b4-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="b37b4-112">При таком подходе у каждой микрослужбы есть общедоступная конечная точка, иногда с отдельным портом TCP для каждой микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="b37b4-112">In this approach, each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="b37b4-113">Например, определенная служба может иметь следующий URL-адрес в Azure:</span><span class="sxs-lookup"><span data-stu-id="b37b4-113">An example of a URL for a particular service could be the following URL in Azure:</span></span>

`http://eshoponcontainers.westus.cloudapp.azure.com:88/`

<span data-ttu-id="b37b4-114">В рабочей среде на основе кластера этот URL-адрес будет указывать на подсистему балансировки нагрузки кластера, которая, в свою очередь, распределяет запросы между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="b37b4-114">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="b37b4-115">В производственной среде можно использовать контроллер доставки приложений, например [шлюз приложения Azure](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) между вашими микрослужбами и Интернетом.</span><span class="sxs-lookup"><span data-stu-id="b37b4-115">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="b37b4-116">Он выступает как прозрачный уровень, который не только выполняет балансировку нагрузки, но и защищает службы благодаря завершению SSL-запросов.</span><span class="sxs-lookup"><span data-stu-id="b37b4-116">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="b37b4-117">Это уменьшает нагрузку на узлах за счет разгрузки завершения SSL-запросов и других задач, активно использующих ЦП, в шлюз приложений Azure.</span><span class="sxs-lookup"><span data-stu-id="b37b4-117">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="b37b4-118">В любом случае подсистема балансировки нагрузки и контроллер доставки приложений прозрачны с точки зрения логической архитектуры приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-118">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="b37b4-119">Архитектура прямого взаимодействия клиента и микрослужбы достаточно хорошо подходит для небольших приложений на основе микрослужб, особенно если клиентское приложение представляет собой веб-приложение на стороне сервера, например приложение MVC ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="b37b4-119">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="b37b4-120">Однако при создании больших и сложных приложений на основе микрослужб (например, при обработке десятков типов микрослужб) и особенно в том случае, если клиентские приложения представляют собой удаленные мобильные приложения или одностраничные веб-приложения, этот подход приводит к появлению нескольких проблем.</span><span class="sxs-lookup"><span data-stu-id="b37b4-120">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="b37b4-121">При разработке крупного приложения на основе микрослужб ответьте на следующие вопросы:</span><span class="sxs-lookup"><span data-stu-id="b37b4-121">Consider the following questions when developing a large application based on microservices:</span></span>

- <span data-ttu-id="b37b4-122">*Как клиентские приложения могут свести к минимуму число запросов к серверной части и уменьшить частоту обмена данными с несколькими микрослужбами?*</span><span class="sxs-lookup"><span data-stu-id="b37b4-122">*How can client apps minimize the number of requests to the back end and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="b37b4-123">Взаимодействие с несколькими микрослужбами для создания одного окна пользовательского интерфейса увеличивает число круговых путей через Интернет.</span><span class="sxs-lookup"><span data-stu-id="b37b4-123">Interacting with multiple microservices to build a single UI screen increases the number of round trips across the Internet.</span></span> <span data-ttu-id="b37b4-124">Это увеличивает задержку и сложности на стороне пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="b37b4-124">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="b37b4-125">В идеальном случае ответы должны эффективно вычисляться на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="b37b4-125">Ideally, responses should be efficiently aggregated in the server side.</span></span> <span data-ttu-id="b37b4-126">Это сокращает задержки, так как можно возвращать несколько фрагментов данных в параллельном режиме, и в некоторых пользовательских интерфейсах данные можно отобразить сразу же после их появления.</span><span class="sxs-lookup"><span data-stu-id="b37b4-126">This reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it's ready.</span></span>

- <span data-ttu-id="b37b4-127">*Как вы можете обрабатывать сквозную функциональность, например проверку подлинности, преобразование данных и динамическую диспетчеризацию запросов?*</span><span class="sxs-lookup"><span data-stu-id="b37b4-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="b37b4-128">Реализация вопросов безопасности и сквозной функциональности, например реализация безопасности и проверки подлинности на каждой микрослужбе, может потребовать значительных усилий.</span><span class="sxs-lookup"><span data-stu-id="b37b4-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="b37b4-129">Один из возможных подходов состоит в том, чтобы разместить эти службы на узле Docker или во внутреннем кластере, закрыв прямой доступ к ним извне, и реализовать сквозную функциональность централизованно, например в шлюзе API.</span><span class="sxs-lookup"><span data-stu-id="b37b4-129">A possible approach is to have those services within the Docker host or internal cluster to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

- <span data-ttu-id="b37b4-130">*Как клиентские приложения взаимодействуют со службами, использующими не поддерживаемые в Интернете протоколы?*</span><span class="sxs-lookup"><span data-stu-id="b37b4-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="b37b4-131">Протоколы, используемые на стороне сервера (например, AMQP или двоичные протоколы), обычно не поддерживаются в клиентских приложениях.</span><span class="sxs-lookup"><span data-stu-id="b37b4-131">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="b37b4-132">Поэтому запросы необходимо выполнять через такие протоколы, как HTTP или HTTPS, а затем преобразовывать в другие протоколы.</span><span class="sxs-lookup"><span data-stu-id="b37b4-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="b37b4-133">Подход *посредник* может помочь в этой ситуации.</span><span class="sxs-lookup"><span data-stu-id="b37b4-133">A *man-in-the-middle* approach can help in this situation.</span></span>

- <span data-ttu-id="b37b4-134">*Как создать интерфейс, специально предназначенный для мобильных приложений?*</span><span class="sxs-lookup"><span data-stu-id="b37b4-134">*How can you shape a facade especially made for mobile apps?*</span></span>

<span data-ttu-id="b37b4-135">API нескольких микрослужб может быть не слишком хорошо приспособлено для удовлетворения потребностей различных клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="b37b4-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="b37b4-136">Например, потребности мобильного приложения могут отличаться от потребностей веб-приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="b37b4-137">Для мобильных приложений может потребоваться дополнительная оптимизация, чтобы повысить эффективность данных ответов.</span><span class="sxs-lookup"><span data-stu-id="b37b4-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="b37b4-138">Это можно сделать, агрегировав данные из нескольких микрослужб и возвращая один набор данных. Также иногда можно исключить из ответа все данные, которые не требуются мобильному приложению.</span><span class="sxs-lookup"><span data-stu-id="b37b4-138">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that isn't needed by the mobile app.</span></span> <span data-ttu-id="b37b4-139">И, конечно же, эти данные можно сжать.</span><span class="sxs-lookup"><span data-stu-id="b37b4-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="b37b4-140">Опять же, можно предусмотреть удобный интерфейс или API между микрослужбами и мобильным приложением для этого сценария.</span><span class="sxs-lookup"><span data-stu-id="b37b4-140">Again, a facade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="why-consider-api-gateways-instead-of-direct-client-to-microservice-communication"></a><span data-ttu-id="b37b4-141">Преимущества шлюза API над прямым взаимодействием клиента и микрослужбы</span><span class="sxs-lookup"><span data-stu-id="b37b4-141">Why consider API Gateways instead of direct client-to-microservice communication</span></span>

<span data-ttu-id="b37b4-142">В архитектуре микрослужб клиентские приложения обычно используют функциональные возможности нескольких микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-142">In a microservices architecture, the client apps usually need to consume functionality from more than one microservice.</span></span> <span data-ttu-id="b37b4-143">Если такое взаимодействие выполняется напрямую, клиенту нужно обрабатывать несколько вызовов к конечным точкам микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-143">If that consumption is performed directly, the client needs to handle multiple calls to microservice endpoints.</span></span> <span data-ttu-id="b37b4-144">Чем же это закончится, если развитие приложения будет сопровождаться добавлением новых микрослужб или обновлением существующих?</span><span class="sxs-lookup"><span data-stu-id="b37b4-144">What happens when the application evolves and new microservices are introduced or existing microservices are updated?</span></span> <span data-ttu-id="b37b4-145">Если приложение использует много микрослужб, взаимодействие с большим количеством конечных точек становится для клиентского приложения сущим кошмаром.</span><span class="sxs-lookup"><span data-stu-id="b37b4-145">If your application has many microservices, handling so many endpoints from the client apps can be a nightmare.</span></span> <span data-ttu-id="b37b4-146">Так как клиентское приложение тесно связано с внутренними конечными точками, любые изменения микрослужб могут существенно повлиять на клиентские приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-146">Since the client app would be coupled to those internal endpoints, evolving the microservices in the future can cause high impact for the client apps.</span></span>

<span data-ttu-id="b37b4-147">Это означает, что промежуточный слой или уровень для косвенного обращения (шлюз) будет очень полезен в приложениях на основе микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-147">Therefore, having an intermediate level or tier of indirection (Gateway) can be very convenient for microservice-based applications.</span></span> <span data-ttu-id="b37b4-148">Если у вас нет шлюзов API, клиентские приложения должны отправлять запросы непосредственно к микрослужбам, что может вызывать описанные ниже проблемы.</span><span class="sxs-lookup"><span data-stu-id="b37b4-148">If you don't have API Gateways, the client apps must send requests directly to the microservices and that raises problems, such as the following issues:</span></span>

- <span data-ttu-id="b37b4-149">**Взаимозависимость**. Без шлюза API клиентские приложения тесно связаны с внутренними микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="b37b4-149">**Coupling**: Without the API Gateway pattern, the client apps are coupled to the internal microservices.</span></span> <span data-ttu-id="b37b4-150">Клиентскому приложению нужно знать, как обрабатываются в микрослужбах разные функции приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-150">The client apps need to know how the multiple areas of the application are decomposed in microservices.</span></span> <span data-ttu-id="b37b4-151">По мере развития и рефакторинга внутренних микрослужб все действия с ними очень плохо влияют на процесс обслуживания, так как приводят к критическим изменениям клиентских приложений, которые обращаются напрямую к внутренним микрослужбам.</span><span class="sxs-lookup"><span data-stu-id="b37b4-151">When evolving and refactoring the internal microservices, those actions impact maintenance pretty badly because they cause breaking changes to the client apps due to the direct reference to the internal microservices from the client apps.</span></span> <span data-ttu-id="b37b4-152">Клиентские приложения приходится часто обновлять, что усложняет процесс развития решения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-152">Client apps need to be updated frequently, making the solution harder to evolve.</span></span>

- <span data-ttu-id="b37b4-153">**Большое количество круговых путей**. Для одной страницы (экрана) в клиентском приложении может потребоваться несколько вызовов к разным службам.</span><span class="sxs-lookup"><span data-stu-id="b37b4-153">**Too many round trips**: A single page/screen in the client app might require several calls to multiple services.</span></span> <span data-ttu-id="b37b4-154">Это приводит к созданию нескольких круговых путей по сети между клиентом и сервером, что значительно увеличивает задержку.</span><span class="sxs-lookup"><span data-stu-id="b37b4-154">That can result in multiple network round trips between the client and the server, adding significant latency.</span></span> <span data-ttu-id="b37b4-155">Объединения на промежуточном уровне позволяют повысить производительность и улучшить взаимодействие с пользователем для клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-155">Aggregation handled in an intermediate level could improve the performance and user experience for the client app.</span></span>

- <span data-ttu-id="b37b4-156">**Проблемы безопасности**. Без шлюза все микрослужбы будут доступны извне, что значительно увеличивает уязвимую зону, если не скрыть внутренние микрослужбы, не используемые клиентскими приложениями напрямую.</span><span class="sxs-lookup"><span data-stu-id="b37b4-156">**Security issues**: Without a gateway, all the microservices must be exposed to the "external world", making the attack surface larger than if you hide internal microservices that aren't directly used by the client apps.</span></span> <span data-ttu-id="b37b4-157">Чем меньше уязвимая зона, тем надежнее будет ваше приложение.</span><span class="sxs-lookup"><span data-stu-id="b37b4-157">The smaller the attack surface is, the more secure your application can be.</span></span>

- <span data-ttu-id="b37b4-158">**Проблемы сквозной функциональности**. Каждая общедоступная микрослужба вынуждена самостоятельно обрабатывать такие задачи, как авторизация, шифрование SSL и т. д. Во многих случаях эти задачи можно вынести на общий уровень, что позволяет упростить внутренние микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="b37b4-158">**Cross-cutting concerns**: Each publicly published microservice must handle concerns such as authorization, SSL, etc. In many situations, those concerns could be handled in a single tier so the internal microservices are simplified.</span></span>

## <a name="what-is-the-api-gateway-pattern"></a><span data-ttu-id="b37b4-159">Что представляет собой шаблон шлюза API?</span><span class="sxs-lookup"><span data-stu-id="b37b4-159">What is the API Gateway pattern?</span></span>

<span data-ttu-id="b37b4-160">При проектировании и разработке крупных или сложных приложений на основе микрослужб с несколькими клиентскими приложениями рекомендуется использовать [шлюз API](https://microservices.io/patterns/apigateway.html).</span><span class="sxs-lookup"><span data-stu-id="b37b4-160">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="b37b4-161">Это служба, предоставляющая единую точку входа для определенных групп микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-161">This is a service that provides a single-entry point for certain groups of microservices.</span></span> <span data-ttu-id="b37b4-162">Она похожа на шаблон [фасада](https://en.wikipedia.org/wiki/Facade_pattern) из объектно-ориентированного проектирования, но в этом случае включается в распределенную систему.</span><span class="sxs-lookup"><span data-stu-id="b37b4-162">It's similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object-oriented design, but in this case, it's part of a distributed system.</span></span> <span data-ttu-id="b37b4-163">Шаблон шлюза API также иногда называют "серверной частью для клиентской части" [(BFF)](https://samnewman.io/patterns/architectural/bff/), так как она создается с учетом потребностей клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-163">The API Gateway pattern is also sometimes known as the "backend for frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="b37b4-164">Таким образом, шлюз API располагается между клиентскими приложениями и микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="b37b4-164">Therefore, the API gateway sits between the client apps and the microservices.</span></span> <span data-ttu-id="b37b4-165">Он выполняет функцию обратного прокси, передавая запросы от клиентов к службам.</span><span class="sxs-lookup"><span data-stu-id="b37b4-165">It acts as a reverse proxy, routing requests from clients to services.</span></span> <span data-ttu-id="b37b4-166">Также он может предоставлять дополнительные сквозные функции, например аутентификацию, завершение SSL-подключения и кэширование.</span><span class="sxs-lookup"><span data-stu-id="b37b4-166">It can also provide additional cross-cutting features such as authentication, SSL termination, and cache.</span></span>

<span data-ttu-id="b37b4-167">На рисунке 4-13 показано, как пользовательский шлюз API можно использовать в упрощенной архитектуре на основе микрослужб, которая включает всего несколько микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-167">Figure 4-13 shows how a custom API Gateway can fit into a simplified microservice-based architecture with just a few microservices.</span></span>

![Схема со шлюзом API, реализованным в виде пользовательской службы.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/custom-service-api-gateway.png)

<span data-ttu-id="b37b4-169">**Рис. 4-13**.</span><span class="sxs-lookup"><span data-stu-id="b37b4-169">**Figure 4-13**.</span></span> <span data-ttu-id="b37b4-170">Использование шлюза API, реализованного в виде пользовательской службы</span><span class="sxs-lookup"><span data-stu-id="b37b4-170">Using an API Gateway implemented as a custom service</span></span>

<span data-ttu-id="b37b4-171">Приложения подключаются к одной конечной точке — шлюзу API, который настроен для пересылки запросов в отдельные микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="b37b4-171">Apps connect to a single endpoint, the API Gateway, that's configured to forward requests to individual microservices.</span></span> <span data-ttu-id="b37b4-172">В этом примере шлюз API будет реализован в виде пользовательской службы ASP.NET Core WebHost, запущенной в виде контейнера.</span><span class="sxs-lookup"><span data-stu-id="b37b4-172">In this example, the API Gateway would be implemented as a custom ASP.NET Core WebHost service running as a container.</span></span>

<span data-ttu-id="b37b4-173">Важно отметить, что на этой схеме вы использовали бы одну пользовательскую службу шлюза API, взаимодействующую с несколькими и различными клиентскими приложениями.</span><span class="sxs-lookup"><span data-stu-id="b37b4-173">It's important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="b37b4-174">Этот факт может привести к заметному риску, так как служба шлюза API будет расти и развиваться на основе множества различных требований от клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="b37b4-174">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="b37b4-175">Со временем служба шлюза API окажется перегруженной из-за различных требований и по сути окажется похожей на монолитное приложение или монолитную службу.</span><span class="sxs-lookup"><span data-stu-id="b37b4-175">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="b37b4-176">Поэтому настоятельно рекомендуется разделять шлюз API между различными службами или между более мелкими шлюзами API, например по одному шлюзу для каждого типа форм-фактора клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-176">That's why it's very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per client app form-factor type, for instance.</span></span>

<span data-ttu-id="b37b4-177">Следует соблюдать осторожность при реализации шаблона шлюза API.</span><span class="sxs-lookup"><span data-stu-id="b37b4-177">You need to be careful when implementing the API Gateway pattern.</span></span> <span data-ttu-id="b37b4-178">Обычно не рекомендуется иметь один шлюз API, который агрегирует все внутренние микрослужбы вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-178">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="b37b4-179">Такой шлюз выступает в качестве монолитного агрегатора или оркестратора и нарушает автономность микрослужб, связывая все микрослужбы друг с другом.</span><span class="sxs-lookup"><span data-stu-id="b37b4-179">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span>

<span data-ttu-id="b37b4-180">Поэтому шлюзы API следует разделять по границам бизнес-процессов и клиентским приложениям и не использовать в качестве единого агрегатора для всех внутренних микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-180">Therefore, the API Gateways should be segregated based on business boundaries and the client apps and not act as a single aggregator for all the internal microservices.</span></span>

<span data-ttu-id="b37b4-181">При разделении уровня шлюза API на несколько шлюзов API, если приложение включает несколько клиентских приложений, это разделение можно использовать в качестве основы для описания типов шлюзов API, то есть разработать индивидуальный фасад для каждого клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-181">When splitting the API Gateway tier into multiple API Gateways, if your application has multiple client apps, that can be a primary pivot when identifying the multiple API Gateways types, so that you can have a different facade for the needs of each client app.</span></span> <span data-ttu-id="b37b4-182">Такую схему иногда называют "Серверная часть для клиентской части" ([BFF](https://samnewman.io/patterns/architectural/bff/)). Каждый шлюз API может предоставлять различные API с учетом каждого типа клиентского приложения (а возможно, и форм-фактора), на основе реализации кода адаптера, который вызывает несколько внутренних микрослужб, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="b37b4-182">This case is a pattern named "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) where each API Gateway can provide a different API tailored for each client app type, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices, as shown in the following image:</span></span>

![Схема с несколькими пользовательскими шлюзами API.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/multiple-custom-api-gateways.png)

<span data-ttu-id="b37b4-184">**Рис. 4-13.1.**</span><span class="sxs-lookup"><span data-stu-id="b37b4-184">**Figure 4-13.1**.</span></span> <span data-ttu-id="b37b4-185">Использование нескольких пользовательских шлюзов API</span><span class="sxs-lookup"><span data-stu-id="b37b4-185">Using multiple custom API Gateways</span></span>

<span data-ttu-id="b37b4-186">На рис. 4-13.1 показаны шлюзы API, разделенные по типу клиента: для мобильных клиентов и для веб-клиентов.</span><span class="sxs-lookup"><span data-stu-id="b37b4-186">Figure 4-13.1 shows API Gateways that are segregated by client type; one for mobile clients and one for web clients.</span></span> <span data-ttu-id="b37b4-187">Традиционное веб-приложение подключается к микрослужбе MVC, использующей шлюз веб-API.</span><span class="sxs-lookup"><span data-stu-id="b37b4-187">A traditional web app connects to an MVC microservice that uses the web API Gateway.</span></span> <span data-ttu-id="b37b4-188">В примере показана упрощенная архитектура с несколькими детально настроенными шлюзами API.</span><span class="sxs-lookup"><span data-stu-id="b37b4-188">The example depicts a simplified architecture with multiple fine-grained API Gateways.</span></span> <span data-ttu-id="b37b4-189">В этом примере границы для разделения шлюзов API строго основаны на шаблоне "Серверная часть для клиентской части" ([BFF](https://samnewman.io/patterns/architectural/bff/)), то есть шлюзы реализуют только те API, которые нужны конкретному клиентскому приложению.</span><span class="sxs-lookup"><span data-stu-id="b37b4-189">In this case, the boundaries identified for each API Gateway are based purely on the "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) pattern, hence based just on the API needed per client app.</span></span> <span data-ttu-id="b37b4-190">Но в более крупных приложениях следует пойти немного дальше и использовать границы бизнес-процессов в качестве второго фактора разделения шлюзов API.</span><span class="sxs-lookup"><span data-stu-id="b37b4-190">But in larger applications you should also go further and create additional API Gateways based on business boundaries as a second design pivot.</span></span>

## <a name="main-features-in-the-api-gateway-pattern"></a><span data-ttu-id="b37b4-191">Основные возможности шаблона шлюза API</span><span class="sxs-lookup"><span data-stu-id="b37b4-191">Main features in the API Gateway pattern</span></span>

<span data-ttu-id="b37b4-192">Шлюз API может предоставлять множество функций.</span><span class="sxs-lookup"><span data-stu-id="b37b4-192">An API Gateway can offer multiple features.</span></span> <span data-ttu-id="b37b4-193">В зависимости от конкретного продукта, его возможности могут быть простыми или достаточно широкими, но в любом шлюзе API основными следует считать следующие шаблоны разработки:</span><span class="sxs-lookup"><span data-stu-id="b37b4-193">Depending on the product it might offer richer or simpler features, however, the most important and foundational features for any API Gateway are the following design patterns:</span></span>

<span data-ttu-id="b37b4-194">**Обратный прокси-сервер или маршрутизация шлюза**.</span><span class="sxs-lookup"><span data-stu-id="b37b4-194">**Reverse proxy or gateway routing.**</span></span> <span data-ttu-id="b37b4-195">Шлюз API предоставляет обратный прокси-сервер для маршрутизации или перенаправления запросов (маршрутизация уровня 7, обычно это HTTP-запросы) к конечным точкам внутренних микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-195">The API Gateway offers a reverse proxy to redirect or route requests (layer 7 routing, usually HTTP requests) to the endpoints of the internal microservices.</span></span> <span data-ttu-id="b37b4-196">Шлюз предоставляет единую конечную точку (URL-адрес) для клиентских приложений, а внутри сопоставляет запросы от них с конкретными группами внутренних микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-196">The gateway provides a single endpoint or URL for the client apps and then internally maps the requests to a group of internal microservices.</span></span> <span data-ttu-id="b37b4-197">Эта возможность маршрутизации помогает отделить клиентские приложения от микрослужб, но она не менее удобна при обновлении монолитного API. Между этим монолитным API и клиентскими приложениями размещается шлюз API, что позволяет добавлять новые API в формате микрослужб и продолжать использовать монолитный API вплоть до его разделения на множество микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-197">This routing feature helps to decouple the client apps from the microservices but it's also pretty convenient when modernizing a monolithic API by sitting the API Gateway in between the monolithic API and the client apps, then you can add new APIs as new microservices while still using the legacy monolithic API until it's split into many microservices in the future.</span></span> <span data-ttu-id="b37b4-198">Благодаря шлюзу API для клиентских приложений неважно, как реализованы конкретные API-интерфейсы: в виде внутренних микрослужб или монолитных API. И что более важно, в процессе развития, рефакторинга и разделения монолитного API на микрослужбы шлюз API защищает клиентские приложения от любых изменений URI.</span><span class="sxs-lookup"><span data-stu-id="b37b4-198">Because of the API Gateway, the client apps won't notice if the APIs being used are implemented as internal microservices or a monolithic API and more importantly, when evolving and refactoring the monolithic API into microservices, thanks to the API Gateway routing, client apps won't be impacted with any URI change.</span></span>

<span data-ttu-id="b37b4-199">Дополнительные сведения см. в разделе [о шаблоне маршрутизации шлюза](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing).</span><span class="sxs-lookup"><span data-stu-id="b37b4-199">For more information, see [Gateway routing pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing).</span></span>

<span data-ttu-id="b37b4-200">**Агрегирование запросов**.</span><span class="sxs-lookup"><span data-stu-id="b37b4-200">**Requests aggregation.**</span></span> <span data-ttu-id="b37b4-201">Шаблон шлюза можно дополнить агрегированием нескольких клиентских запросов (обычно HTTP-запросов), направленных к разным внутренним микрослужбам, в один клиентский запрос.</span><span class="sxs-lookup"><span data-stu-id="b37b4-201">As part of the gateway pattern you can aggregate multiple client requests (usually HTTP requests) targeting multiple internal microservices into a single client request.</span></span> <span data-ttu-id="b37b4-202">Этот шаблон особенно удобен, когда клиенту для отображения страницы или экрана нужны данные из нескольких микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-202">This pattern is especially convenient when a client page/screen needs information from several microservices.</span></span> <span data-ttu-id="b37b4-203">При таком подходе клиентское приложение отправляет на шлюз API один запрос, а шлюз преобразует его в несколько запросов к внутренним микрослужбам, затем объединяет полученные результаты и отправляет в клиентское приложение.</span><span class="sxs-lookup"><span data-stu-id="b37b4-203">With this approach, the client app sends a single request to the API Gateway that dispatches several requests to the internal microservices and then aggregates the results and sends everything back to the client app.</span></span> <span data-ttu-id="b37b4-204">Основное преимущество и цель этого шаблона разработки заключается в уменьшении объема данных, передаваемых между клиентскими приложениями и внутренними API. Это особенно важно для удаленных приложений, размещаемых за пределами центра обработки данных, где расположены микрослужбы, например для мобильных приложений или запросов от приложений SPA, созданных на Javascript в браузерах на удаленном клиентском компьютере.</span><span class="sxs-lookup"><span data-stu-id="b37b4-204">The main benefit and goal of this design pattern is to reduce chattiness between the client apps and the backend API, which is especially important for remote apps out of the datacenter where the microservices live, like mobile apps or requests coming from SPA apps that come from Javascript in client remote browsers.</span></span> <span data-ttu-id="b37b4-205">Для обычных веб-приложений, которые выполняют запросы в серверной среде (например, веб-приложение ASP.NET Core MVC), этот шаблон менее полезен, так как сетевая задержка и так намного меньше, чем у удаленных клиентских приложений.</span><span class="sxs-lookup"><span data-stu-id="b37b4-205">For regular web apps performing the requests in the server environment (like an ASP.NET Core MVC web app), this pattern is not so important as the latency is very much smaller than for remote client apps.</span></span>

<span data-ttu-id="b37b4-206">В зависимости от того, какой продукт вы используете в качестве шлюза API, он может поддерживать или не поддерживать агрегирование.</span><span class="sxs-lookup"><span data-stu-id="b37b4-206">Depending on the API Gateway product you use, it might be able to perform this aggregation.</span></span> <span data-ttu-id="b37b4-207">Но во многих случаях более гибким подходом будет создание микрослужб агрегирования в пределах шлюза API, и тогда ее нужно выполнять в отдельном коде (то есть в коде C#).</span><span class="sxs-lookup"><span data-stu-id="b37b4-207">However, in many cases it's more flexible to create aggregation microservices under the scope of the API Gateway, so you define the aggregation in code (that is, C# code):</span></span>

<span data-ttu-id="b37b4-208">Дополнительные сведения см. в разделе [о шаблоне агрегирования на шлюзе](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation).</span><span class="sxs-lookup"><span data-stu-id="b37b4-208">For more information, see [Gateway aggregation pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation).</span></span>

<span data-ttu-id="b37b4-209">**Проблемы сквозной функциональности или разгрузка шлюза**.</span><span class="sxs-lookup"><span data-stu-id="b37b4-209">**Cross-cutting concerns or gateway offloading.**</span></span> <span data-ttu-id="b37b4-210">В зависимости от функций, предоставляемых конкретной реализацией шлюза API, вы можете перенести некоторые функции из отдельных микрослужб на шлюз, что упростит реализацию каждой микрослужбы за счет объединения сквозных функций на отдельном уровне.</span><span class="sxs-lookup"><span data-stu-id="b37b4-210">Depending on the features offered by each API Gateway product, you can offload functionality from individual microservices to the gateway, which simplifies the implementation of each microservice by consolidating cross-cutting concerns into one tier.</span></span> <span data-ttu-id="b37b4-211">Это особенно удобно для специализированных функций, которые иногда сложно правильно реализовать в каждой внутренней микрослужбе. К этой категории относятся следующие функции:</span><span class="sxs-lookup"><span data-stu-id="b37b4-211">This is especially convenient for specialized features that can be complex to implement properly in every internal microservice, such as the following functionality:</span></span>

- <span data-ttu-id="b37b4-212">Аутентификация и авторизация</span><span class="sxs-lookup"><span data-stu-id="b37b4-212">Authentication and authorization</span></span>
- <span data-ttu-id="b37b4-213">интеграция средства обнаружения служб;</span><span class="sxs-lookup"><span data-stu-id="b37b4-213">Service discovery integration</span></span>
- <span data-ttu-id="b37b4-214">Кэширование откликов</span><span class="sxs-lookup"><span data-stu-id="b37b4-214">Response caching</span></span>
- <span data-ttu-id="b37b4-215">политики повторных попыток, размыкатель цепи и качество обслуживания;</span><span class="sxs-lookup"><span data-stu-id="b37b4-215">Retry policies, circuit breaker, and QoS</span></span>
- <span data-ttu-id="b37b4-216">ограничение скорости и регулирование;</span><span class="sxs-lookup"><span data-stu-id="b37b4-216">Rate limiting and throttling</span></span>
- <span data-ttu-id="b37b4-217">балансировка нагрузки;</span><span class="sxs-lookup"><span data-stu-id="b37b4-217">Load balancing</span></span>
- <span data-ttu-id="b37b4-218">ведение журнала, трассировка, корреляция;</span><span class="sxs-lookup"><span data-stu-id="b37b4-218">Logging, tracing, correlation</span></span>
- <span data-ttu-id="b37b4-219">преобразования заголовков, строк запроса и утверждений;</span><span class="sxs-lookup"><span data-stu-id="b37b4-219">Headers, query strings, and claims transformation</span></span>
- <span data-ttu-id="b37b4-220">список разрешенных IP-адресов.</span><span class="sxs-lookup"><span data-stu-id="b37b4-220">IP whitelisting</span></span>

<span data-ttu-id="b37b4-221">Дополнительные сведения см. в разделе [о шаблоне разгрузки шлюза](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading).</span><span class="sxs-lookup"><span data-stu-id="b37b4-221">For more information, see [Gateway offloading pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading).</span></span>

## <a name="using-products-with-api-gateway-features"></a><span data-ttu-id="b37b4-222">Использование продуктов с функциями шлюза API</span><span class="sxs-lookup"><span data-stu-id="b37b4-222">Using products with API Gateway features</span></span>

<span data-ttu-id="b37b4-223">В зависимости от конкретной реализации шлюз API может поддерживать еще множество сквозных функций.</span><span class="sxs-lookup"><span data-stu-id="b37b4-223">There can be many more cross-cutting concerns offered by the API Gateways products depending on each implementation.</span></span> <span data-ttu-id="b37b4-224">Здесь рассматриваются следующие темы:</span><span class="sxs-lookup"><span data-stu-id="b37b4-224">We'll explore here:</span></span>

- [<span data-ttu-id="b37b4-225">Управление API Azure</span><span class="sxs-lookup"><span data-stu-id="b37b4-225">Azure API Management</span></span>](https://azure.microsoft.com/services/api-management/)
- [<span data-ttu-id="b37b4-226">Ocelot</span><span class="sxs-lookup"><span data-stu-id="b37b4-226">Ocelot</span></span>](https://github.com/ThreeMammals/Ocelot)

### <a name="azure-api-management"></a><span data-ttu-id="b37b4-227">Управление API Azure</span><span class="sxs-lookup"><span data-stu-id="b37b4-227">Azure API Management</span></span>

<span data-ttu-id="b37b4-228">Служба [управления API Azure](https://azure.microsoft.com/services/api-management/) (как показано на рис. 4-14) не только позволяет удовлетворить потребности шлюза API, но и предоставляет дополнительные функции, например сбор аналитических данных от интерфейсов API.</span><span class="sxs-lookup"><span data-stu-id="b37b4-228">[Azure API Management](https://azure.microsoft.com/services/api-management/) (as shown in Figure 4-14) not only solves your API Gateway needs but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="b37b4-229">Если вы используете решение для управления API, шлюз API является только компонентом в рамках полного решения по управлению API.</span><span class="sxs-lookup"><span data-stu-id="b37b4-229">If you're using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![На схеме показано, как использовать Управление API Azure в качестве шлюза API.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/api-gateway-azure-api-management.png)

<span data-ttu-id="b37b4-231">**Рис. 4-14**.</span><span class="sxs-lookup"><span data-stu-id="b37b4-231">**Figure 4-14**.</span></span> <span data-ttu-id="b37b4-232">Использование управления API Azure для шлюза API</span><span class="sxs-lookup"><span data-stu-id="b37b4-232">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="b37b4-233">Служба управления API Azure удовлетворяет ваши потребности в отношении шлюза API и управления, такие как ведение журнала, обеспечение безопасности, контроль использования и т. д. В этом случае при использовании такого продукта, как управление API Azure, наличие одного шлюза API не так рискованно, так как такие виды шлюзов API "тоньше". Это означает, что вы не сможете реализовать пользовательский код C#, который сможет развиваться в сторону монолитного компонента.</span><span class="sxs-lookup"><span data-stu-id="b37b4-233">Azure API Management solves both your API Gateway and Management needs like logging, security, metering, etc. In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span>

<span data-ttu-id="b37b4-234">Такой шлюз API обычно выступает в роли обратного прокси-сервера для приема данных, позволяя отделить API от внутренних микрослужб и реализовать авторизацию для всех опубликованных API на этом едином уровне.</span><span class="sxs-lookup"><span data-stu-id="b37b4-234">The API Gateway products usually act like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="b37b4-235">Аналитические сведения, доступные из системы управления API, помогут вам понять, как используются ваши API и насколько эффективно они работают.</span><span class="sxs-lookup"><span data-stu-id="b37b4-235">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="b37b4-236">Для этого вы можете просматривать отчеты практически в режиме реального времени и выявлять тенденции, которые могут повлиять на ваш бизнес.</span><span class="sxs-lookup"><span data-stu-id="b37b4-236">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="b37b4-237">Кроме того, вы можете вести журналы запросов и ответов как для интерактивного, так и для автономного анализа.</span><span class="sxs-lookup"><span data-stu-id="b37b4-237">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="b37b4-238">С помощью управления API Azure вы можете защитить свои интерфейсы API с помощью ключей, маркеров и фильтрации IP-адресов.</span><span class="sxs-lookup"><span data-stu-id="b37b4-238">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="b37b4-239">Эти возможности позволяют обеспечить гибкие и точные квоты и ограничения скорости, изменить форму и поведение ваших API с помощью политик и улучшить производительность с помощью кэширования ответов.</span><span class="sxs-lookup"><span data-stu-id="b37b4-239">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="b37b4-240">В этом руководстве и в примере приложения (eShopOnContainers) архитектура ограничивается простой реализацией пользовательской контейнерной архитектуры, чтобы сосредоточиться только на контейнерах без использования продуктов PaaS, таких как управление API Azure.</span><span class="sxs-lookup"><span data-stu-id="b37b4-240">In this guide and the reference sample application (eShopOnContainers), the architecture is limited to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="b37b4-241">Но для крупных приложений на основе микрослужб, развернутых в Microsoft Azure, мы рекомендуем применить в рабочей среде шлюз API на основе управления API Azure.</span><span class="sxs-lookup"><span data-stu-id="b37b4-241">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to evaluate Azure API Management as the base for your API Gateways in production.</span></span>

### <a name="ocelot"></a><span data-ttu-id="b37b4-242">Ocelot</span><span class="sxs-lookup"><span data-stu-id="b37b4-242">Ocelot</span></span>

<span data-ttu-id="b37b4-243">[Ocelot](https://github.com/ThreeMammals/Ocelot) — это упрощенный шлюз API, рекомендуемый для более простых случаев.</span><span class="sxs-lookup"><span data-stu-id="b37b4-243">[Ocelot](https://github.com/ThreeMammals/Ocelot) is a lightweight API Gateway, recommended for simpler approaches.</span></span> <span data-ttu-id="b37b4-244">Шлюз API Ocelot с открытым исходным кодом на основе .NET Core специально разработан для архитектуры микрослужб, в которой нужны единые точки входа в систему.</span><span class="sxs-lookup"><span data-stu-id="b37b4-244">Ocelot is an Open Source .NET Core based API Gateway especially made for microservices architecture that need unified points of entry into their system.</span></span> <span data-ttu-id="b37b4-245">Он не требует много ресурсов, работает быстро, легко масштабируется и поддерживает, среди прочего, маршрутизацию и аутентификацию.</span><span class="sxs-lookup"><span data-stu-id="b37b4-245">It's lightweight, fast, scalable and provides routing and authentication among many other features.</span></span>

<span data-ttu-id="b37b4-246">Ocelot используется в [примере приложения eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers) в первую очередь потому, что этот простой шлюз API на основе .NET Core можно развернуть в той же среде развертывания приложений, где размещаются микрослужбы и контейнеры, такие как узел Docker, Kubernetes и т. д. Так как этот шлюз основан на .NET Core, он одинаково хорошо работает на платформах Windows или Linux.</span><span class="sxs-lookup"><span data-stu-id="b37b4-246">The main reason to choose Ocelot for the [eShopOnContainers reference application](https://github.com/dotnet-architecture/eShopOnContainers) is because Ocelot is a .NET Core lightweight API Gateway that you can deploy into the same application deployment environment where you're deploying your microservices/containers, such as a Docker Host, Kubernetes, etc. And since it's based on .NET Core, it's cross-platform allowing you to deploy on Linux or Windows.</span></span>

<span data-ttu-id="b37b4-247">На схеме выше представлен пользовательский шлюз API, выполняемый в контейнерах. Ocelot можно точно так же запустить в контейнере для приложения на основе микрослужб.</span><span class="sxs-lookup"><span data-stu-id="b37b4-247">The previous diagrams showing custom API Gateways running in containers are precisely how you can also run Ocelot in a container and microservice-based application.</span></span>

<span data-ttu-id="b37b4-248">Кроме него, существует много других продуктов с функциональностью шлюза API, например Apigee, Kong, MuleSoft, WSO2. Также есть много продуктов, например Linkerd и Istio, реализующих функции управления входящими данными.</span><span class="sxs-lookup"><span data-stu-id="b37b4-248">In addition, there are many other products in the market offering API Gateways features, such as Apigee, Kong, MuleSoft, WSO2, and other products like Linkerd and Istio for service mesh ingress controller features.</span></span>

<span data-ttu-id="b37b4-249">После разделов с описанием базовой архитектуры и шаблонов мы переходим к описанию реализации шлюза API на примере [Ocelot](https://github.com/ThreeMammals/Ocelot).</span><span class="sxs-lookup"><span data-stu-id="b37b4-249">After the initial architecture and patterns explanation sections, the next sections explain how to implement API Gateways with [Ocelot](https://github.com/ThreeMammals/Ocelot).</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="b37b4-250">Недостатки шаблона шлюза API</span><span class="sxs-lookup"><span data-stu-id="b37b4-250">Drawbacks of the API Gateway pattern</span></span>

- <span data-ttu-id="b37b4-251">Наиболее важный недостаток заключается в том, что при реализации шлюза API вы связываете этот уровень с внутренними микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="b37b4-251">The most important drawback is that when you implement an API Gateway, you're coupling that tier with the internal microservices.</span></span> <span data-ttu-id="b37b4-252">Такое связывание может привести к серьезным проблемам для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="b37b4-252">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="b37b4-253">Клеменс Вастер (Clemens Vaster), архитектор команды по разработке служебной шины Azure, называет эту потенциальную трудность "новой служебной шиной предприятия (ESB)" в выступлении [Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k) (Обмен сообщениями и микрослужбы) на GOTO 2016.</span><span class="sxs-lookup"><span data-stu-id="b37b4-253">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as "the new ESB" in the "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

- <span data-ttu-id="b37b4-254">Использование шлюза API микрослужб создает возможную дополнительную единую точку отказа.</span><span class="sxs-lookup"><span data-stu-id="b37b4-254">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

- <span data-ttu-id="b37b4-255">Шлюз API может привести к увеличению времени ответа из-за дополнительного сетевого вызова.</span><span class="sxs-lookup"><span data-stu-id="b37b4-255">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="b37b4-256">Однако этот дополнительный вызов обычно оказывает меньшее влияние, чем целый клиентский интерфейс, который постоянно взаимодействует с внутренними микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="b37b4-256">However, this extra call usually has less impact than having a client interface that's too chatty directly calling the internal microservices.</span></span>

- <span data-ttu-id="b37b4-257">При отсутствии должного масштабирования шлюз API может стать узким местом.</span><span class="sxs-lookup"><span data-stu-id="b37b4-257">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

- <span data-ttu-id="b37b4-258">Шлюз API требует дополнительных затрат на разработку и последующее обслуживание, если он включает пользовательскую логику и агрегирование данных.</span><span class="sxs-lookup"><span data-stu-id="b37b4-258">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="b37b4-259">Чтобы предоставить конечные точки каждой микрослужбы, разработчикам необходимо обновить шлюз API.</span><span class="sxs-lookup"><span data-stu-id="b37b4-259">Developers must update the API Gateway in order to expose each microservice's endpoints.</span></span> <span data-ttu-id="b37b4-260">Кроме того, изменения в реализации внутренних микрослужб могут вызвать изменения кода на уровне API шлюза.</span><span class="sxs-lookup"><span data-stu-id="b37b4-260">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="b37b4-261">Тем не менее, если в шлюзе API просто применяется безопасность, ведение журналов и управление версиями (как при использовании управления API Azure), эти затраты на разработку могут отсутствовать.</span><span class="sxs-lookup"><span data-stu-id="b37b4-261">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

- <span data-ttu-id="b37b4-262">Если шлюз API разрабатывается одной командой, это может быть узким местом разработки.</span><span class="sxs-lookup"><span data-stu-id="b37b4-262">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="b37b4-263">Это еще одна причина, по которой лучше использовать несколько специализированных шлюзов API, которые реализуют различные потребности клиента.</span><span class="sxs-lookup"><span data-stu-id="b37b4-263">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="b37b4-264">Также можно внутренне разделить шлюз API на несколько областей или уровней, которые принадлежат другим командам, работающим над внутренними микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="b37b4-264">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="b37b4-265">Дополнительные ресурсы</span><span class="sxs-lookup"><span data-stu-id="b37b4-265">Additional resources</span></span>

- <span data-ttu-id="b37b4-266">**Крис Ричардсон (Chris Richardson). Шаблон: шлюз API, серверная часть для внешнего интерфейса** </span><span class="sxs-lookup"><span data-stu-id="b37b4-266">**Chris Richardson. Pattern: API Gateway / Backend for Front-End** </span></span>\
  <https://microservices.io/patterns/apigateway.html>

- <span data-ttu-id="b37b4-267">**Шаблон шлюза API** </span><span class="sxs-lookup"><span data-stu-id="b37b4-267">**API Gateway pattern** </span></span>\
  <https://docs.microsoft.com/azure/architecture/microservices/gateway>

- <span data-ttu-id="b37b4-268">**Шаблон агрегирования и компоновки** </span><span class="sxs-lookup"><span data-stu-id="b37b4-268">**Aggregation and composition pattern** </span></span>\
  <https://microservices.io/patterns/data/api-composition.html>

- <span data-ttu-id="b37b4-269">**Управление API Azure** </span><span class="sxs-lookup"><span data-stu-id="b37b4-269">**Azure API Management** </span></span>\
  <https://azure.microsoft.com/services/api-management/>

- <span data-ttu-id="b37b4-270">**Уди Дахан (Udi Dahan). Объединение на основе служб** </span><span class="sxs-lookup"><span data-stu-id="b37b4-270">**Udi Dahan. Service Oriented Composition** </span></span>\
  <http://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

- <span data-ttu-id="b37b4-271">**Клеменс Вастерс (Clemens Vasters). Messaging and Microservices (Обмен сообщениями и микрослужбы) на GOTO 2016 (видео)**  </span><span class="sxs-lookup"><span data-stu-id="b37b4-271">**Clemens Vasters. Messaging and Microservices at GOTO 2016 (video)** </span></span>\
  <https://www.youtube.com/watch?v=rXi5CLjIQ9k>

- <span data-ttu-id="b37b4-272">**API Gateway in a Nutshell** (Краткие сведения о шлюзе API) — серия руководств по шлюзу API ASP.NET Core </span><span class="sxs-lookup"><span data-stu-id="b37b4-272">**API Gateway in a Nutshell** (ASP.net Core API Gateway Tutorial Series) </span></span>\
  <https://www.pogsdotnet.com/2018/08/api-gateway-in-nutshell.html>

>[!div class="step-by-step"]
><span data-ttu-id="b37b4-273">[Назад](identify-microservice-domain-model-boundaries.md)
>[Вперед](communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="b37b4-273">[Previous](identify-microservice-domain-model-boundaries.md)
[Next](communication-in-microservice-architecture.md)</span></span>
