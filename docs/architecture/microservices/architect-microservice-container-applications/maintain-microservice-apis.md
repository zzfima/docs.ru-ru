---
title: Создание, развитие и управление версиями API-интерфейсов и контрактов микрослужб
description: Создание API микрослужбы и контрактов с учетом развития и управления версиями из-за изменения потребностей.
ms.date: 09/20/2018
ms.openlocfilehash: 1972d02d8bf7935c71bfd383707ae19ea2baded9
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "68672901"
---
# <a name="creating-evolving-and-versioning-microservice-apis-and-contracts"></a>Создание, развитие и управление версиями API-интерфейсов и контрактов микрослужб

API микрослужбы представляет собой контракт между службой и ее клиентами. Вы сможете развивать микрослужбу независимо только в том случае, если не нарушаете ее контракт API; вот почему контракт так важен. Если изменить контракт, это повлияет на клиентские приложения или на шлюз API.

Характер определения API зависит от того, какой протокол используется. Например, при использовании обмена сообщениями (такого как [AMQP](https://www.amqp.org/)) API состоит из типов сообщений. При использовании HTTP и службы RESTful API состоит из URL-адресов и форматов JSON запросов и ответов.

Тем не менее, даже если вы внимательно относитесь к первоначальному контракту, со временем API службы потребуется изменить. Когда это происходит, и особенно в том случае, если ваш API является общим API, используемым несколькими клиентскими приложениями, как правило, вы не можете заставить всех клиентов обновиться до вашего нового контракта API. Обычно требуется последовательное развертывание новых версий службы таким образом, чтобы и старая, и новая версии контракта службы работали одновременно. Следовательно, важно иметь стратегию для управления версиями вашей службы.

Если изменения API невелики, например, вы добавили в API атрибуты или параметры, то клиенты, использующие старый API, должны переключиться на новую версию службы и работать с ней. Вы могли бы предоставить значения по умолчанию для каких-либо отсутствующих, но необходимых атрибутов, а клиенты могли бы игнорировать любые лишние атрибуты ответа.

Однако иногда требуется внести в API службы важные и несовместимые изменения. Поскольку вы не сможете обеспечить принудительное немедленное обновление клиентских приложений или служб до новой версии, служба должна некоторое время поддерживать старые версии API. Если используется механизм на основе HTTP, такой как REST, один из подходов заключается во внедрении номера версии API в URL-адрес или в заголовок HTTP. Затем можно либо одновременно реализовать обе версии службы в одном и том же экземпляре службы, либо развернуть разные экземпляры, каждый из которых обрабатывает версию API. Для разделения разных версий реализации по независимым обработчикам рекомендуется использовать [шаблон Mediator](https://en.wikipedia.org/wiki/Mediator_pattern) (например, [библиотеку MediatR](https://github.com/jbogard/MediatR)).

Наконец, при использовании архитектуры REST лучшим решением для управления версиями служб и разрешения развиваемых API является использование [гиперсредств](https://www.infoq.com/articles/mark-baker-hypermedia).

## <a name="additional-resources"></a>Дополнительные ресурсы

- **Скотт Ханселман (Scott Hanselman). Упрощение управления версиями веб-API ASP.NET Core с поддержкой REST** \
  <https://www.hanselman.com/blog/ASPNETCoreRESTfulWebAPIVersioningMadeEasy.aspx>

- **Управление версиями веб-API с поддержкой REST** \
  <https://docs.microsoft.com/azure/architecture/best-practices/api-design#versioning-a-restful-web-api>

- **Рой Филдинг (Roy Fielding). Управление версиями, гипермедиа и REST** \
  <https://www.infoq.com/articles/roy-fielding-on-versioning>

>[!div class="step-by-step"]
>[Назад](asynchronous-message-based-communication.md)
>[Вперед](microservices-addressability-service-registry.md)
