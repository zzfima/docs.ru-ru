---
title: Работа с данными в приложениях ASP.NET Core
description: Разработка современных веб-приложений с помощью ASP.NET Core и Azure | Работа с данными в приложениях ASP.NET Core
author: ardalis
ms.author: wiwagn
ms.date: 01/30/2019
ms.openlocfilehash: fa30deb16be323f059aa0ec12df08793598a6da2
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/24/2020
ms.locfileid: "76738358"
---
# <a name="working-with-data-in-aspnet-core-apps"></a>Работа с данными в приложениях ASP.NET Core

> "Данные — это самый ценный ресурс, который намного переживет сами системы".
>
> Тим Бернерс-Ли (Tim Berners-Lee)

Доступ к данным является одной из важнейших составляющих практически любой программы. ASP.NET Core поддерживает широкий спектр способов доступа к данным, включая Entity Framework Core (и Entity Framework 6), и может работать с любыми платформами доступа к данным .NET. Выбор используемой платформы доступа к данным зависит от потребностей приложения. Абстрагируя выбор такой платформы от проектов ядра приложения и пользовательского интерфейса, а также инкапсулируя детали реализации в инфраструктуре, можно создавать слабо связанное приложение с расширенными возможностями для тестирования.

## <a name="entity-framework-core-for-relational-databases"></a>Entity Framework Core (для реляционных баз данных)

Если вы создаете новое приложение ASP.NET Core для работы с реляционными данными, рекомендуется выбирать Entity Framework Core (EF Core) для доступа к данным. EF Core является объектно-реляционным модулем сопоставления (O/RM), который позволяет разработчикам .NET обеспечивать двустороннюю сохраняемость объектов во взаимодействии с источником данных. Это устраняет необходимость в большей части кода для доступа к данным, который разработчикам обычно приходится писать. Как и ASP.NET Core, платформа EF Core была переработана, чтобы обеспечить поддержку модульных кроссплатформенных приложений. Она добавляется в приложение в виде пакета NuGet, настраивается в классе Startup и используется для обработки запросов посредством внедрения зависимостей в тот момент, когда это необходимо.

Чтобы использовать EF Core с базой данных SQL Server, выполните следующую команду dotnet CLI:

```dotnetcli
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
```

Чтобы добавить поддержку источника данных в памяти для тестирования, выполните следующую команду:

```dotnetcli
dotnet add package Microsoft.EntityFrameworkCore.InMemory
```

### <a name="the-dbcontext"></a>DbContext

Для работы с EF Core вам потребуется подкласс <xref:Microsoft.EntityFrameworkCore.DbContext>. Этот класс содержит свойства, представляющие коллекцию сущностей, с которыми будет работать ваше приложение. Пример приложения eShopOnWeb содержит CatalogContext с коллекциями товаров, брендов и типов:

```csharp
public class CatalogContext : DbContext
{
    public CatalogContext(DbContextOptions<CatalogContext> options) : base(options)
    {

    }

    public DbSet<CatalogItem> CatalogItems { get; set; }

    public DbSet<CatalogBrand> CatalogBrands { get; set; }

    public DbSet<CatalogType> CatalogTypes { get; set; }
}
```

Ваш класс DbContext должен иметь конструктор, который принимает DbContextOptions и передает этот аргумент в базовый класс DbContext. Обратите внимание, что если в вашем приложении используется только один класс DbContext, вы можете передавать экземпляр DbContextOptions, однако при наличии нескольких таких классов вам нужно использовать универсальный тип DbContextOptions\<T>, передавая ваш тип DbContext в качестве универсального параметра.

### <a name="configuring-ef-core"></a>Настройка EF Core

В приложении ASP.NET Core настройка EF Core обычно осуществляется в методе ConfigureServices. EF Core использует DbContextOptionsBuilder, который поддерживает несколько полезных методов расширения, позволяющих оптимизировать его конфигурацию. Чтобы настроить метод CatalogContext для использования базы данных SQL Server со строкой подключения, определенной в конфигурации, необходимо добавить следующий код в ConfigureServices:

```csharp
services.AddDbContext<CatalogContext>(options => options.UseSqlServer (Configuration.GetConnectionString("DefaultConnection")));
```

Чтобы использовать выполняющуюся в памяти базу данных:

```csharp
services.AddDbContext<CatalogContext>(options =>
    options.UseInMemoryDatabase());
```

После установки EF Core, создания дочернего типа DbContext и его настройки в методе ConfigureServices вы можете использовать EF Core. Вы можете запросить экземпляр вашего типа DbContext в любой службе, где он необходим, и начать работу с хранимыми сущностями с помощью LINQ так, как если бы они были обычными коллекциями. EF Core автоматически преобразует выражения LINQ в запросы SQL для хранения и извлечения данных.

Чтобы просмотреть выполнение запросов EF Core, настройте ведение журналов как минимум на уровне информационных сообщений, как показано на рис. 8-1.

![Ведение журналов запросов EF Core на консоль](./media/image8-1.png)

**Рис. 8-1**. Ведение журналов запросов EF Core на консоль

### <a name="fetching-and-storing-data"></a>Получение и сохранение данных

Чтобы извлечь данные из EF Core, необходимо обратиться к соответствующему свойству и использовать LINQ для фильтрации результатов. Также можно использовать LINQ для выполнения проекции (преобразования результата из одного типа в другой). В следующем примере извлекается CatalogBrands с упорядочением по имени, затем осуществляется фильтровка по свойству Enabled, после чего выполняется проекция в тип SelectListItem:

```csharp
var brandItems = await _context.CatalogBrands
    .Where(b => b.Enabled)
    .OrderBy(b => b.Name)
    .Select(b => new SelectListItem {
        Value = b.Id, Text = b.Name })
    .ToListAsync();
```

В приведенном выше примере важно добавить вызов ToListAsync, чтобы выполнить запрос немедленно. В противном случае инструкция назначит IQueryable\<SelectListItem> для brandItems, и выполнение не будет начато, пока не будет выполнено перечисление. Возврат результатов IQueryable из методов имеет свои преимущества и недостатки. Такой подход позволяет осуществлять дальнейшие изменения запроса, который будет создавать EF Core, но также может привести к ошибке, которая проявится только во время выполнения при добавлении операций в запрос, который EF Core не сможет преобразовать. Как правило, более безопасный подход подразумевает передачу любых фильтров в метод, осуществляющий доступ к данным, с последующим возвратом размещаемой в памяти коллекции (например, List\<T>) в виде результата.

EF Core отслеживает изменения сущностей, которые получаются из хранилища сохраняемости. Чтобы сохранить изменения в отслеживаемой сущности, достаточно вызвать метод SaveChanges для DbContext и убедиться, что это тот же экземпляр DbContext, который использовался при получении сущности. Добавление и удаление сущностей осуществляется непосредственно с помощью свойства DbSet, опять таки, посредством вызова метода SaveChanges для выполнения команд базы данных. В следующем примере показано добавление, обновление и удаление сущностей из хранилища сохраняемости.

```csharp
// create
var newBrand = new CatalogBrand() { Brand = "Acme" };
_context.Add(newBrand);
await _context.SaveChangesAsync();

// read and update
var existingBrand = _context.CatalogBrands.Find(1);
existingBrand.Brand = "Updated Brand";
await _context.SaveChangesAsync();

// read and delete (alternate Find syntax)
var brandToDelete = _context.Find<CatalogBrand>(2);
_context.CatalogBrands.Remove(brandToDelete);
await _context.SaveChangesAsync();
```

EF Core поддерживает как синхронные, так и асинхронные методы получения и сохранения. В веб-приложениях рекомендуется использовать шаблон async/await для асинхронных методов. В этом случае потоки веб-сервера не блокируются на время ожидания завершения операций доступа к данным.

### <a name="fetching-related-data"></a>Получение связанных данных

При получении сущностей EF Core заполняет все свойства, которые хранятся в базе данных непосредственно с этой сущностью. Свойства навигации, например списки связанных сущностей, не заполняются и могут получать значения null. Таким образом гарантируется, что EF Core не будет извлекать объем данных больше необходимого, что особенно важно для веб-приложений, которые должны быстро обрабатывать запросы и возвращать ответы эффективным способом. Чтобы включить отношение с сущностью, используя _безотложную загрузку_, необходимо указать свойство, используя метод расширения Include для запроса, как показано ниже:

```csharp
// .Include requires using Microsoft.EntityFrameworkCore
var brandsWithItems = await _context.CatalogBrands
    .Include(b => b.Items)
    .ToListAsync();
```

Можно включить несколько отношений, а также вложенные отношения с помощью ThenInclude. EF Core выполнит один запрос для извлечения результирующего набора сущностей. Кроме того, вы можете включить свойства навигации, передав строку с разделением "." в метод расширения `.Include()` следующим образом:

```csharp
    .Include(“Items.Products”)
```

Помимо инкапсуляции логики фильтрации, эта спецификация может указывать форму возвращаемых данных, включая свойства, которые следует заполнить. Пример приложения eShopOnWeb содержит несколько спецификаций, которые демонстрируют сведения об инкапсулирующей безотложной загрузке в спецификации. Вы видите, как спецификация используется в рамках запроса:

```csharp
// Includes all expression-based includes
query = specification.Includes.Aggregate(query,
            (current, include) => current.Include(include));

// Include any string-based include statements
query = specification.IncludeStrings.Aggregate(query,
            (current, include) => current.Include(include));
```

Также для загрузки связанных данных можно использовать _явную загрузку_. Явная загрузка позволяет загружать дополнительные данные в уже извлеченную сущность. Поскольку для этого требуется дополнительный запрос к базе данных, такой подход не рекомендуется для веб-приложений, в которых необходимо свести к минимуму число обращений к базе данных в рамках одного запроса.

_Отложенная загрузка_ позволяет автоматически загружать данные в тот момент, когда на них ссылается приложение. В EF Core добавлена поддержка отложенной загрузки в версии 2.1. Отложенная загрузка не включена по умолчанию и требует установки `Microsoft.EntityFrameworkCore.Proxies`. Как и явная загрузка, отложенная загрузка обычно отключена для веб-приложений, так как ее использование приведет к дополнительным запросам к базе данных в пределах каждого веб-запроса. К сожалению, издержки, связанные с отложенной загрузкой, часто незаметны во время разработки, когда задержка маленькая и для тестирования используются небольшие наборы данных. Но в рабочей среде с большим количеством пользователей, данных и задержек запросы к базе данных могут приводить к снижению производительности для веб-приложений, где активно используется отложенная загрузка.

[Предотвращение отложенной загрузки сущностей в веб-приложениях](https://ardalis.com/avoid-lazy-loading-entities-in-asp-net-applications)

### <a name="encapsulating-data"></a>Инкапсуляция данных

EF Core поддерживает несколько функций, которые позволяют модели правильно инкапсулировать свое состояние. Распространенной проблемой моделей предметной области является то, что они предоставляют свойства навигации коллекции как общедоступные типы списка. Это позволяет любому участнику совместной работы управлять содержимым этих типов в коллекции. В результате могут обходиться важные бизнес-правила, связанные с коллекцией, из-за чего объект может оказаться в недопустимом состоянии. Решение заключается в предоставлении доступа только для чтения к связанным коллекциям и явном предоставлении методов, которые определяют возможные способы работы клиентов с этими коллекциями, как в этом примере:

```csharp
public class Basket : BaseEntity
{
    public string BuyerId { get; set; }
    private readonly List<BasketItem> _items = new List<BasketItem>();
    public IReadOnlyCollection<BasketItem> Items => _items.AsReadOnly();

    public void AddItem(int catalogItemId, decimal unitPrice, int quantity = 1)
    {
        if (!Items.Any(i => i.CatalogItemId == catalogItemId))
        {
            _items.Add(new BasketItem()
            {
                CatalogItemId = catalogItemId,
                Quantity = quantity,
                UnitPrice = unitPrice
            });
            return;
        }
        var existingItem = Items.FirstOrDefault(i => i.CatalogItemId == catalogItemId);
        existingItem.Quantity += quantity;
    }
}
```

Обратите внимание, что этот тип сущности не предоставляет открытое свойство `List` или `ICollection`, но вместо этого предоставляет тип `IReadOnlyCollection`, который создает оболочку для базового типа списка. При использовании этого шаблона можно указать для Entity Framework Core использовать резервное поле следующим образом:

```csharp
private void ConfigureBasket(EntityTypeBuilder<Basket> builder)
{
    var navigation = builder.Metadata.FindNavigation(nameof(Basket.Items));

    navigation.SetPropertyAccessMode(PropertyAccessMode.Field);
}
```

Еще один способ улучшить модель предметной области — использовать объекты значений для типов, которым не хватает удостоверений и которые различаются только по своим свойствам. Использование таких типов в качестве свойств сущностей может помочь сохранить логику, присущую объекту значения, и избежать повторяющуюся логику между несколькими сущностями, использующими одну концепцию. В Entity Framework Core можно сохранить объекты значений в той же таблице, что и сущность-владелец, настроив тип в качестве принадлежащей сущности следующим образом:

```csharp
private void ConfigureOrder(EntityTypeBuilder<Order> builder)
{
    builder.OwnsOne(o => o.ShipToAddress);
}
```

В этом примере свойство `ShipToAddress` принадлежит типу `Address`. `Address` является объектом значения с несколькими свойствами, такими как `Street` и `City`. EF Core сопоставляет объект `Order` со своей таблицей, по одному столбцу на свойство `Address`, вставляя перед именем каждого столбца имя свойства. В этом примере таблица `Order` должна включать такие столбцы, как `ShipToAddress_Street` и `ShipToAddress_City`.

[В EF Core 2.2 добавлена поддержка коллекций принадлежащих сущностей](https://docs.microsoft.com/ef/core/what-is-new/ef-core-2.2#collections-of-owned-entities)

### <a name="resilient-connections"></a>Устойчивые подключения

Внешние ресурсы, например базы данных SQL, время от времени могут быть недоступны. Если ресурс временно недоступен, приложение может использовать логику повторных попыток, чтобы избежать возникновения исключения. Такой подход часто называют _устойчивостью подключений_. Вы можете реализовать собственную логику [повторных попыток с экспоненциальной выдержкой](https://docs.microsoft.com/azure/architecture/patterns/retry), при которой приложение пытается повторить операцию с экспоненциально растущим временем ожидания, пока не будет достигнуто максимальное число повторных попыток. Этот метод учитывает тот факт, что облачные ресурсы могут быть периодически недоступны в течение нескольких секунд по различным причинам, в результате чего некоторые запросы могут завершаться сбоем.

Для баз данных Azure SQL платформа Entity Framework Core уже предоставляет логику устойчивости и повторного выполнения при подключении к внутренним базам данных. Но вам необходимо применить стратегию выполнения Entity Framework к каждому подключению DbContext, если вы хотите иметь устойчивое подключение к EF Core.

Например, следующий код на уровне подключения к EF Core обеспечивает устойчивое SQL-подключение, которое устанавливается повторно при сбое.

```csharp
// Startup.cs from any ASP.NET Core Web API
public class Startup
{
    public IServiceProvider ConfigureServices(IServiceCollection services)
    {
        //...
        services.AddDbContext<OrderingContext>(options =>
        {
            options.UseSqlServer(Configuration["ConnectionString"],
            sqlServerOptionsAction: sqlOptions =>
        {
            sqlOptions.EnableRetryOnFailure(
            maxRetryCount: 5,
            maxRetryDelay: TimeSpan.FromSeconds(30),
            errorNumbersToAdd: null);
        });
    });
}
//...
```

#### <a name="execution-strategies-and-explicit-transactions-using-begintransaction-and-multiple-dbcontexts"></a>Стратегии выполнения и явные транзакции с использованием BeginTransaction и нескольких DbContext

Если в подключениях к EF Core включены повторные попытки, каждая операция, выполняемая с помощью EF Core, будет предпринимать повторные попытки. Каждый запрос и каждый вызов к SaveChanges будет повторяться снова как единица в случае сбоя.

Но если код запускает транзакцию с помощью BeginTransaction, вы сами определяете группу операций, которые должны рассматриваться как единица, — все содержимое транзакции можно будет откатить в случае сбоя. Если вы попытаетесь выполнить эту транзакцию при использовании стратегии выполнения EF (политика повтора) и включаете несколько вызовов SaveChanges из нескольких DbContext в транзакции, отобразится следующее исключение.

"System.InvalidOperationException: The configured execution strategy 'SqlServerRetryingExecutionStrategy' does not support user initiated transactions" (System.InvalidOperationException: настроенная стратегия выполнения SqlServerRetryingExecutionStrategy не поддерживает запуск транзакций пользователем). Используйте стратегию выполнения, возвращенную 'DbContext.Database.CreateExecutionStrategy()', чтобы выполнить все операции в транзакции как повторяемую единицу.

Необходимо вручную вызвать стратегию выполнения EF с делегатом, который представляет все, что должно быть выполнено. В случае временного сбоя стратегия выполнения будет снова вызывать делегат. В следующем примере кода показано, как реализовать этот подход:

```csharp
// Use of an EF Core resiliency strategy when using multiple DbContexts
// within an explicit transaction
// See:
// https://docs.microsoft.com/ef/core/miscellaneous/connection-resiliency
var strategy = _catalogContext.Database.CreateExecutionStrategy();
await strategy.ExecuteAsync(async () =>
{
    // Achieving atomicity between original Catalog database operation and the
    // IntegrationEventLog thanks to a local transaction
    using (var transaction = _catalogContext.Database.BeginTransaction())
    {
        _catalogContext.CatalogItems.Update(catalogItem);
        await _catalogContext.SaveChangesAsync();

        // Save to EventLog only if product price changed
        if (raiseProductPriceChangedEvent)
        await _integrationEventLogService.SaveEventAsync(priceChangedEvent);
        transaction.Commit();
    }
});
```

Первый DbContext — это \_catalogContext, а второй DbContext находится в объекте \_integrationEventLogService. Наконец, действие фиксации выполняется в нескольких DbContext с помощью стратегии выполнения EF.

> ### <a name="references--entity-framework-core"></a>Ссылки — получение Entity Framework Core
>
> - **Документация по EF Core**  
>   <https://docs.microsoft.com/ef/>
> - **EF Core. Связанные данные**  
>   <https://docs.microsoft.com/ef/core/querying/related-data>
> - **Предотвращение отложенной загрузки сущностей в приложениях ASPNET**  
>   <https://ardalis.com/avoid-lazy-loading-entities-in-asp-net-applications>

## <a name="ef-core-or-micro-orm"></a>EF Core или микро-ORM?

EF Core хорошо подходит для управления сохраняемостью и по большей части инкапсулирует детали базы данных, освобождая от труда разработчиков приложения, однако это средство не является единственным вариантом. Популярным альтернативным решением с открытым исходным кодом является [Dapper](https://github.com/StackExchange/Dapper), который также называется микро-ORM. Микро-ORM — это упрощенное средство сопоставления объектов со структурами данных, обладающее сокращенным набором функции. Основной задачей Dapper является оптимизация производительности при проектировании, а не полная инкапсуляция базовых запросов, которые используются для извлечения и обновления данных. Поскольку это средство не абстрагирует SQL от разработчика, Dapper является более низкоуровневым инструментом, позволяя разработчикам создавать точные запросы, которые они хотят использовать для конкретных операций доступа к данным.

EF Core может предложить две существенных функциональных возможности, которые отличают эту платформу Dapper, но при этом приводят к снижению производительности. Первая из них — это преобразование выражений LINQ в SQL. Эти преобразования кэшируются, однако даже в этом случае при их первом выполнении производительность снижается. Вторая возможность — отслеживание изменений сущностей, что позволяет создавать эффективные операторы обновления. Такое поведение можно отключить для конкретных запросов с помощью расширения AsNotTracking. EF Core также создает эффективные SQL-запросы, которые крайне эффективны и в любом случае приемлемы с точки зрения производительности. Однако если вам требуется детальный контроль над тем, какой в точности запрос выполняется, вы также можете передать настраиваемый SQL (или выполнить хранимую процедуру) с помощью EF Core. В такой ситуации Dapper по-прежнему, хотя и незначительно, превосходит EF Core в отношении производительности. Джули Лерман (Julie Lerman) приводит некоторые данные по производительности в статье MSDN [Dapper, Entity Framework и гибридные приложения](https://docs.microsoft.com/archive/msdn-magazine/2016/may/data-points-dapper-entity-framework-and-hybrid-apps) за май 2016 г. Дополнительные данные по тестированию производительности для различных методов доступа к данным можно найти на [сайте Dapper](https://github.com/StackExchange/Dapper).

Чтобы ознакомиться с различиями в синтаксисе между Dapper и EF Core, рассмотрите следующие две версии одного и того же метода, извлекающего список элементов:

```csharp
// EF Core
private readonly CatalogContext _context;
public async Task<IEnumerable<CatalogType>> GetCatalogTypes()
{
    return await _context.CatalogTypes.ToListAsync();
}

// Dapper
private readonly SqlConnection _conn;
public async Task<IEnumerable<CatalogType>> GetCatalogTypesWithDapper()
{
    return await _conn.QueryAsync<CatalogType>("SELECT * FROM CatalogType");
}
```

Для построения более сложных графов объектов с помощью Dapper вам потребуется написать связанные запросы самостоятельно (в отличие от EF Core, где для этого используется Include). Поддержка такого поведения обеспечивается различным синтаксисом, в том числе с помощью функции множественного сопоставления, которая позволяет сопоставлять отдельные строки с несколькими сопоставленными объектами. Например, для класса Post со свойством Owner типа User следующий SQL-код будет возвращать все необходимые данные:

```sql
select * from #Posts p
left join #Users u on u.Id = p.OwnerId
Order by p.Id
```

Каждая возвращаемая строка будет включать данные User и Post. Поскольку данные User должны быть присоединены к данным Post посредством свойства Owner, используется следующая функция:

```csharp
(post, user) => { post.Owner = user; return post; }
```

Полный код, возвращающий коллекцию элементов Post, свойства Owner которых будут заполнены соответствующими данными User, будет выглядеть следующим образом:

```csharp
var sql = @"select * from #Posts p
left join #Users u on u.Id = p.OwnerId
Order by p.Id";
var data = connection.Query<Post, User, Post>(sql,
(post, user) => { post.Owner = user; return post;});
```

Dapper обеспечивает более низкий уровень инкапсуляции, в связи с чем разработчики должны знать больше о том, как хранятся их данные, как эффективно выполнять запросы к ним, а также о том, как писать дополнительный код для их получения. Если модель изменяется вместо создания новой миграции (еще одна функция EF Core) и (или) обновления данных сопоставления в одном месте в DbContext, необходимо обновить каждый затрагиваемый запрос. Для таких запросов отсутствуют гарантии времени компиляции, поэтому они могут завершиться нарушением во время выполнения в ответ на изменения в модели или базе данных, что значительно усложняет своевременное выявление ошибок. Тем не менее эти недостатки Dapper компенсирует крайне высокой производительностью.

Для большинства приложений и большинства компонентов практически любых приложений EF Core предлагает приемлемый уровень производительности. Таким образом, преимущества в удобстве для разработчика в большинстве случаев перевешивают возможное снижение производительности. Для запросов, эффективность которых может быть повышена за счет кэширования, фактический запрос выполняется крайне редко, в связи с чем эти относительно небольшие различия в производительности обработки запросов теряют значимость.

## <a name="sql-or-nosql"></a>SQL или NoSQL

Реляционные базы данных, такие как SQL Server, традиционно занимают львиную долю рынка решений для хранения постоянных данных, однако они также не являются единственным решением. Такие базы данных NoSQL, как [MongoDB](https://www.mongodb.com/what-is-mongodb), предлагают другой подход к хранению объектов. Вместо сопоставления объектов с таблицами и строками выполняется сериализация всего графа объектов с сохранением результата. Преимущества такого подхода, как минимум на начальной стадии, заключаются в простоте и производительности. Безусловно, проще хранить один сериализованный объект с ключом, чем разбивать его на множество таблиц, связанных различными отношениями, и обновлять строки, которые могли быть изменены с момента последнего получения объекта из базы данных. Аналогичным образом, получение и десериализация одного объекта из основанного на ключах хранилища, как правило, выполняется значительно быстрее и проще, чем сложные объединения или множественные запросы к базе данных, необходимые для полного воссоздания объекта на основе реляционной базы данных. Отсутствие блокировок, транзакций или фиксированной схемы также обеспечивает высокую степень пригодности баз данных NoSQL для масштабирования на множестве компьютеров для поддержки очень крупных баз данных.

С другой стороны, базы данных NoSQL имеют свои недостатки. Для обеспечения согласованности и предотвращения дублирования данных в реляционных базах данных применяется нормализация. Это позволяет уменьшить общий размер базы данных и гарантировать немедленную доступность обновлений общих данных на уровне всей базы данных. В реляционной базе данных таблица Address может ссылаться на таблицу Country по идентификатору. Таким образом, при изменении названия страны или региона записи адресов будут использовать обновленные данные и не потребуют отдельного обновления. Тем не менее в базе данных NoSQL таблица Address и связанная с ней таблица Country могут быть сериализованы в составе множества хранимых объектов. В таких случаях при изменении названия страны или региона потребуется обновить все такие объекты, а не одну строку. Реляционные базы данных также гарантируют реляционную целостность посредством применения правил, например внешних ключей. Базы данных NoSQL, как правило, не реализуют такие ограничения для данных.

Также с базами данных NoSQL связаны трудности при управлении версиями. При изменении свойств объекта может быть невозможна десериализация объекта на основе хранимых предыдущих версий. Таким образом, все существующие объекты, у которых есть сериализованная (предыдущая) версия, должны быть обновлены в соответствии с новой схемой. В таком поведении нет принципиальных отличий от реляционных баз данных, в которых изменение схемы иногда требует обновления скриптов или сопоставления обновлений. Тем не менее для баз данных NoSQL число изменяемых записей зачастую намного больше из-за большего объема дублированных данных.

В базах данных NoSQL может храниться несколько версий объектов, что в некоторых реляционных базах данных обычно не поддерживается. Тем не менее в этом случае в коде приложения необходимо учитывать существование предыдущих версий объектов, в результате чего сложность возрастает.

В базах данных NoSQL, как правило, не применяется концепция [ACID](https://en.wikipedia.org/wiki/ACID) (атомарность, согласованность, изолированность, устойчивость), в связи с чем они превосходят реляционные базы данных в отношении производительности и масштабируемости. Они хорошо подходят для очень больших наборов данных и объектов, которые неэффективно хранить в нормализованных табличных структурах. При этом нет никаких ограничений на использование преимуществ как реляционных баз, так и баз данных NoSQL, в рамках одного приложения в тех случаях, где это необходимо.

## <a name="azure-cosmos-db"></a>Azure Cosmos DB

Azure Cosmos DB — это полностью управляемая служба баз данных NoSQL, которая предлагает облачное хранилище данных без схемы. Cosmos DB обеспечивает высокую прогнозируемую производительность, высокую доступность, эластичную масштабируемость и возможность глобального распределения. Несмотря на то, что это база данных NoSQL, разработчики могут использовать все хорошо знакомые возможности SQL-запросов к данным JSON. Все ресурсы в Azure Cosmos DB хранятся в виде документов JSON. Ресурсы управляются в виде _элементов_ (документы, содержащие метаданные) и _веб-каналов_, которые представляют собой коллекции элементов. На рис. 8-2 показаны связи между разными ресурсами Azure Cosmos DB.

![Иерархические связи между ресурсами в Azure Cosmos DB (база данных JSON NoSQL)](./media/image8-2.png)

**Рис. 8-2.** Организация ресурсов Azure Cosmos DB.

Язык запросов Azure Cosmos DB — это простой, но мощный интерфейс для создания запросов документов JSON. Этот язык поддерживает подмножество грамматических конструкций SQL ANSI и реализует углубленную интеграцию объектов, массивов, возможностей конструирования объектов и вызова функций JavaScript.

**Ссылки. Azure Cosmos DB**

- Обзор Azure Cosmos DB  
  <https://docs.microsoft.com/azure/cosmos-db/introduction>

## <a name="other-persistence-options"></a>Другие варианты сохраняемости

В дополнение к реляционным и NoSQL вариантам хранения, в приложениях ASP.NET Core можно использовать облачное масштабируемое хранилище Azure для хранения данных и файлов в различных форматах. Хранилище Azure обеспечивает высокую степень масштабируемости, позволяя начать с хранения небольших объемов данных и при необходимости увеличить объем хранилища до сотен терабайт. Хранилище Azure поддерживает четыре вида данных:

- Хранилище BLOB-объектов для хранения неструктурированных текстовых или двоичных данных, которое также называется хранилищем объектов.

- Хранилище таблиц для структурированных наборов данных, доступных по ключам строк.

- Хранилище очередей для надежного обмена сообщениями на основе очередей.

- Хранилище файлов для совместного доступа к файлам между виртуальными машинами Azure и локальными приложениями.

**Ссылки — хранилище Azure**

- Общие сведения о службе хранилища Azure  
  <https://docs.microsoft.com/azure/storage/storage-introduction>

## <a name="caching"></a>Кэширование

В веб-приложениях каждый веб-запрос должен быть выполнен в максимально короткое время. Одним из способов добиться этого является ограничение числа внешних вызовов, которые сервер должен выполнить для обработки запроса. Процесс кэширования предусматривает сохранение копии данных на сервере (или в другом хранилище данных, запросы к которому выполняются более эффективно по сравнению с источником данных). Веб-приложения, в особенности традиционные многостраничные веб-приложения, для каждого запроса должны осуществлять полное построение пользовательского интерфейса. При этом часто требуется многократно выполнять одни и те же запросы к базе данных от одного пользовательского запроса к другому. В большинстве случаев эти данные редко изменяются, поэтому не имеет практического смысла постоянно запрашивать их из базы данных. ASP.NET Core поддерживает кэширование ответов для кэширования страниц целиком, а также кэширование данных, благодаря которому обеспечивается более детальная реализация кэширования.

При реализации кэширования важно учитывать необходимость разделения задач. Рекомендуется избегать кэширования логики в логике доступа к данным или в пользовательском интерфейсе. Вместо этого следует инкапсулировать кэширование в собственных классах и использовать конфигурацию для управления ее поведением. Такой подход соответствует принципам открытости/закрытости и единственной обязанности, позволяя управлять использованием кэширования в приложении по мере его расширения.

### <a name="aspnet-core-response-caching"></a>Кэширование ответов в ASP.NET Core

ASP.NET Core поддерживает два уровня кэширования ответов. На первом уровне на сервере ничего не кэшируется, однако добавляются заголовки HTTP с инструкциями по кэшированию ответов для клиентов и прокси-серверов. Это реализуется путем добавления атрибута ResponseCache к отдельным контроллерам или действиям:

```csharp
[ResponseCache(Duration = 60)]
public IActionResult Contact()
{
    ViewData["Message"] = "Your contact page.";
    return View();
}
```

В предыдущем примере к ответу будет добавлен следующий заголовок, предписывающий клиентам кэшировать результат до 60 секунд.

Cache-Control: public,max-age=60

Чтобы добавить в приложение кэширование в памяти на стороне сервера, необходимо сослаться на пакет NuGet Microsoft.AspNetCore.ResponseCaching и добавить ПО промежуточного слоя для кэширования ответов. ПО промежуточного слоя настраивается в методах ConfigureServices и Configure в классе Startup:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddResponseCaching();
}

public void Configure(IApplicationBuilder app)
{
    app.UseResponseCaching();
}
```

ПО промежуточного слоя для кэширования ответов будет автоматически кэшировать ответы на основе набора условий, которые при необходимости можно настроить. По умолчанию кэшируются только ответы 200 (OK) на запросы, выполненные с помощью методов GET или HEAD. Кроме того, запросы должны иметь ответ Cache-Control: открытый заголовок и не могут включать заголовки для Authorization или Set-Cookie. См. [полный перечень условий кэширования, применяемых ПО промежуточного уровня для кэширования ответов](/aspnet/core/performance/caching/middleware#conditions-for-caching).

### <a name="data-caching"></a>Кэширование данных

Вместо кэширования полных веб-ответов или в дополнение к нему вы можете кэшировать результаты отдельных запросов данных. Для этого вы можете использовать кэширование в памяти на веб-сервере или [распределенный кэш](/aspnet/core/performance/caching/distributed). В этом разделе демонстрируется, как реализовать кэширование в памяти.

Поддержка кэширования в памяти (или распределенного кэша) добавляется в ConfigureServices:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMemoryCache();
    services.AddMvc();
}
```

Также не забудьте добавить пакет Microsoft.Extensions.Caching.Memory NuGet.

После добавления службы вы выполняете запрос IMemoryCache посредством внедрения зависимостей каждый раз, когда вам требуется доступ к кэшу. В этом примере служба CachedCatalogService использует конструктивный шаблон прокси-сервера (или декоратора), предоставляя альтернативную реализацию ICatalogService, которая управляет доступом к базовой реализации CatalogService или дополняет ее поведение.

```csharp
public class CachedCatalogService : ICatalogService
{
    private readonly IMemoryCache _cache;
    private readonly CatalogService _catalogService;
    private static readonly string _brandsKey = "brands";
    private static readonly string _typesKey = "types";
    private static readonly TimeSpan _defaultCacheDuration = TimeSpan.FromSeconds(30);
    public CachedCatalogService(IMemoryCache cache,
    CatalogService catalogService)
    {
        _cache = cache;
        _catalogService = catalogService;
    }

    public async Task<IEnumerable<SelectListItem>> GetBrands()
    {
        return await _cache.GetOrCreateAsync(_brandsKey, async entry =>
        {
            entry.SlidingExpiration = _defaultCacheDuration;
            return await _catalogService.GetBrands();
        });
    }

    public async Task<Catalog> GetCatalogItems(int pageIndex, int itemsPage, int? brandID, int? typeId)
    {
        string cacheKey = $"items-{pageIndex}-{itemsPage}-{brandID}-{typeId}";
        return await _cache.GetOrCreateAsync(cacheKey, async entry =>
        {
            entry.SlidingExpiration = _defaultCacheDuration;
            return await _catalogService.GetCatalogItems(pageIndex, itemsPage, brandID, typeId);
        });
    }

    public async Task<IEnumerable<SelectListItem>> GetTypes()
    {
        return await _cache.GetOrCreateAsync(_typesKey, async entry =>
        {
            entry.SlidingExpiration = _defaultCacheDuration;
            return await _catalogService.GetTypes();
        });
    }
}
```

Чтобы настроить приложение для использования кэшированной версии службы и при этом разрешить службе получать экземпляр CatalogService, который требуется в ее конструкторе, вам необходимо добавить следующий код в ConfigureServices:

```csharp
services.AddMemoryCache();
services.AddScoped<ICatalogService, CachedCatalogService>();
services.AddScoped<CatalogService>();
```

После этого вызовы базы данных для получения данных каталога будут выполняться только один раз в минуту, а не при каждом запросе. В зависимости от объема трафика на сайте это может в значительной степени повлиять на число запросов к базе данных и среднее время загрузки домашней страницы, которое на данный момент зависит от всех трех запросов, предоставляемых этой службой.

При использовании кэширования возникает проблема _устаревших данных_, то есть данных, которые были изменены в источнике, но для которых в кэше хранится устаревшая версия. Самый простой способ устранить эту проблему заключается в сокращении продолжительности кэширования, поскольку в приложениях с высоким уровнем загрузки увеличение продолжительности кэширования данных дает минимальные преимущества. Рассмотрим страницу, которая выполняет 1 запрос к базе данных, который повторяется 10 раз в секунду. Если эта страница будет кэшироваться 1 раз в минуту, число запросов к базе данных за минуту уменьшится с 600 до 1, то есть на 99,8 %. Если вместо этого задать продолжительность кэширования равной 1 часу, число запросов сократится на 99,997 %, однако при этом значительно увеличится вероятность и потенциальный "возраст" устаревших данных.

Другой подход заключается в упреждающем удалении записей кэша при обновлении данных, которые они содержат. Любую отдельную запись можно удалить по ее ключу:

```csharp
_cache.Remove(cacheKey);
```

Если в вашем приложении предоставляются функции обновления кэшируемых записей, вы можете удалять соответствующие записи кэша в коде, который выполняет обновления. В некоторых случаях от конкретного набора данных может зависеть множество различных записей. В таких ситуациях рекомендуется создать зависимости между записями кэша с помощью CancellationChangeToken. Используя CancellationChangeToken, вы можете одновременно завершить срок действия нескольких записей, аннулировав маркер.

```csharp
// configure CancellationToken and add entry to cache
var cts = new CancellationTokenSource();
_cache.Set("cts", cts);
_cache.Set(cacheKey,
itemToCache,
new CancellationChangeToken(cts.Token));

// elsewhere, expire the cache by cancelling the token\
_cache.Get<CancellationTokenSource>("cts").Cancel();
```

Кэширование может значительно повысить производительность веб-страниц, которые постоянно запрашивают одни и те же значения из базы данных. Обязательно измеряйте производительность доступа к данным и страниц перед применением кэширования и используйте кэширование только при необходимости. Кэширование потребляет ресурсы памяти веб-сервера и увеличивает сложность приложения, поэтому очень важно не внедрять оптимизацию с помощью этой методики преждевременно.

>[!div class="step-by-step"]
>[Назад](develop-asp-net-core-mvc-apps.md)
>[Вперед](test-asp-net-core-mvc-apps.md)
