---
title: Разработка приложений MVC ASP.NET Core
description: Разработка современных веб-приложений с помощью ASP.NET Core и Azure | Разработка приложений MVC ASP.NET Core
author: ardalis
ms.author: wiwagn
ms.date: 12/04/2019
ms.openlocfilehash: a18b4dfc60c7d3971136f73f333b7225735710b3
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "77503944"
---
# <a name="develop-aspnet-core-mvc-apps"></a>Разработка приложений MVC ASP.NET Core

> "Неважно, если что-то не получается вначале. Главное, чтобы это получилось в конце".  
> _— Эндрю Хант (Andrew Hunt) и Дэвид Томас (David Thomas)_

ASP.NET Core является кроссплатформенной средой с открытым исходным кодом для создания современных приложений, оптимизированных для работы в облаке. Приложения ASP.NET Core отличаются простотой и модульностью, а также реализуют встроенную поддержку внедрения зависимостей, что позволяет расширить возможности тестирования и сопровождения. В сочетании с моделью MVC, которая поддерживает создание современных веб-API в дополнение к приложениям на основе представлений, ASP.NET Core представляет собой эффективную платформу для разработки веб-приложений корпоративного уровня.

## <a name="mvc-and-razor-pages"></a>MVC и Razor Pages

ASP.NET Core MVC предлагает множество функций, которые могут быть полезны для создания веб-API и приложений. Термин MVC означает "модель — представление — контроллер", шаблон пользовательского интерфейса, который разбивает обязанности по ответу на запросы пользователей на несколько частей. В дополнение к использованию этого шаблона вы также можете реализовать функции в приложениях ASP.NET Core как Razor Pages. Razor Pages встроены в ASP.NET Core MVC и используют те же функции для маршрутизации, привязки модели и т. д. Но вместо отдельных папок и файлов для контроллеров, представлений и т. д. и использования маршрутизации на основе атрибутов, Razor Pages помещаются в одну папку ("/Pages"), выстраивают маршрут на основе своего относительного расположения в этой папке и обрабатывают запросы с помощью обработчиков, а не действий контроллера.

При создании нового приложения ASP.NET Core необходимо мысленно составить план приложения, которое вы хотите создать. В Visual Studio вы выбираете из нескольких шаблонов. Три наиболее распространенных шаблона проекта: веб-API, веб-приложение и веб-приложение (модель — представление — контроллер). Хотя вы принимаете это решение только при создании проекта, вы можете впоследствии передумать. В проекте веб-API используются стандартные контроллеры шаблона "модель — представление — контроллер", просто по умолчанию там нет представлений. Аналогичным образом шаблон веб-приложения по умолчанию использует Razor Pages, поэтому там тоже нет папки с представлениями. Вы можете добавить папку с представлениями в эти проекты позже для поддержки поведения на основе представлений. Проекты веб-API и "модель — представление — контроллер" не включают папку страниц по умолчанию, но ее можно добавить позже для поддержки поведения на основе Razor Pages. Эти три шаблона поддерживают три различных типа взаимодействия с пользователем по умолчанию: данные (веб-API), на базе страниц и на базе представлений. Но вы можете комбинировать все эти взаимодействия в одном проекте.

### <a name="why-razor-pages"></a>Почему Razor Pages?

Razor Pages — это подход по умолчанию для новых веб-приложений в Visual Studio. Razor Pages предлагает более простой способ создания функций приложения на основе страниц, например, формы в не одностраничных приложениях. При использовании контроллеров и представлений у приложений обычно были очень большие контроллеры, которые работали со множеством различных зависимостей и моделей представлений и возвращали множество различных представлений. Это приводило к массе сложностей, и контроллеры часто не могли эффективно следовать принципу единой ответственности или принципам открытости/закрытости. Razor Pages решает эту проблему за счет инкапсуляции логики на стороне сервера для данной логической "страницы" в веб-приложение с разметкой Razor. Страница Razor без логики на стороне сервера может просто состоять из файла Razor (например, Index.cshtml). Но большинство нетривиальных страниц Razor Pages будет иметь соответствующий класс модели страницы, которая по соглашению называется так же, как файл Razor с расширением .cs (например, Index.cshtml.cs).

Модель страницы Razor сочетает в себе обязанности контроллера MVC и viewmodel. Вместо обработки запросов с помощью методов действий контроллера выполняются обработчики модели страницы, такие как OnGet(), подготавливая к просмотру соответствующую страницу по умолчанию. Razor Pages упрощает процесс создания отдельных страниц в приложения ASP.NET Core, предоставляя при этом все архитектурные компоненты ASP.NET Core MVC. Это неплохой выбор по умолчанию для новых функциональных возможностей на основе страниц.

### <a name="when-to-use-mvc"></a>Когда использовать MVC

При создании веб-API шаблон MVC подходит больше, чем Razor Pages. Если проект будет предоставлять только конечные точки веб-API, в идеале следует начать с шаблона проекта веб-API. В противном случае вы можете легко добавить контроллеры и связанные конечные точки API для любого приложения ASP.NET Core. Шаблон MVC на основе представления следует использовать в том случае, если вы переносите имеющееся приложение ASP.NET MVC 5 или более ранней версии в ASP.NET Core MVC и хотите затратить минимум усилий. После завершения первоначальной миграции вы можете оценить, нужно ли использовать Razor Pages для новых функций или для миграции в целом.

Независимо от выбранного подхода (Razor Pages или представления MVC) ваше приложение будет иметь схожую производительность и будет включать поддержку внедрения зависимостей, фильтров, привязки, проверки модели и т. д.

## <a name="mapping-requests-to-responses"></a>Сопоставление запросов с ответами

Суть приложений ASP.NET Core заключается в сопоставлении входящих запросов с исходящими ответами. На низком уровне это реализуется за счет ПО промежуточного слоя, и простые приложения и микрослужбы ASP.NET Core могут полностью состоять из пользовательского ПО промежуточного слоя. При использовании модели MVC ASP.NET Core вы можете работать на более высоком уровне на основе _маршрутов_, _контроллеров_ и _действий_. Каждый входящий запрос сравнивается с таблицей маршрутизации приложения. При обнаружении подходящего маршрута для обработки запроса вызывается связанный метод действия, который принадлежит контроллеру. Если подходящий маршрут не обнаружен, вызывается обработчик ошибок (в этом случае он возвращает результат NotFound).

Приложения MVC ASP.NET Core могут использовать обычные маршруты, маршруты с атрибутами или оба вида маршрутов. Обычные маршруты определяются в коде путем указания _соглашений_ о маршрутизации с использованием показанного в следующем примере синтаксиса:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
});
```

В этом примере в таблицу маршрутизации добавлен маршрут "default". Он определяет шаблон маршрута с заполнителями _controller_, _action_ и _id_. Для заполнителей контроллера и действия задаются значения по умолчанию ("Home" и "Index" соответственно). Заполнитель идентификатора является необязательным (для этого к нему применяется знак "?"). В определенных здесь соглашениях указывается, что первая часть запроса должна соответствовать имени контроллера, вторая часть — действию, а третья (если требуется) представляет параметр идентификатора. Обычные маршруты, как правило, определяются в одном месте приложения, например в методе Configure класса Startup.

Маршруты с атрибутами применяются напрямую к контроллерам и действиям, а не задаются глобально. Это делает их более доступными для обнаружения в рамках конкретного метода, однако при этом сведения о маршрутизации могут храниться в разных местах в приложении. С помощью маршрутов с атрибутами можно с легкостью задавать несколько маршрутов для конкретного действия, а также комбинировать маршруты между контроллерами и действиями. Пример:

```csharp
[Route("Home")]
public class HomeController : Controller
{
    [Route("")] // Combines to define the route template "Home"
    [Route("Index")] // Combines to define route template "Home/Index"
    [Route("/")] // Does not combine, defines the route template ""
    public IActionResult Index() {}
}
```

Маршруты можно задать с использованием [HttpGet] и схожих атрибутов, что позволяет отказаться от добавления отдельных атрибутов [Route]. Маршруты с атрибутами также могут использовать маркеры, что позволяет сократить объем использования имен контроллера или действия, как показано ниже:

```csharp
[Route("[controller]")]
public class ProductsController : Controller
{
    [Route("")] // Matches 'Products'
    [Route("Index")] // Matches 'Products/Index'
    public IActionResult Index() {}
}
```

Razor Pages не использует маршрутизацию с помощью атрибутов. Вы можете указать дополнительные сведения о шаблоне маршрута для страницы Razor в директиве `@page`:

```csharp
@page "{id:int}"
```

В предыдущем примере рассматриваемая страница будет сопоставлять маршрут с целочисленным параметром `id`. Например, страница *Products.cshtml*, расположенная в корне `/Pages`, будет иметь следующий маршрут:

```csharp
"/Products/123"
```

После того как нужный запрос сопоставлен с маршрутом, но до вызова метода действия, модель MVC ASP.NET Core выполняет [привязку](/aspnet/core/mvc/models/model-binding) и [проверку](/aspnet/core/mvc/models/validation) модели по запросу. Привязка модели необходима для преобразования входящих данных HTTP в типы .NET, которые задаются в виде параметров вызываемого метода действия. Например, если метод действия требует целочисленный параметр идентификатора, привязка модели попытается получить этот параметр из значения, предоставленного в рамках запроса. Для этого привязка модели будет искать значения в опубликованной форме, в самом маршруте, а также в строке запроса. Найденное предполагаемое значение идентификатора преобразуется в целочисленный формат, после чего передается в метод действия.

После привязки модели, но перед вызовом метода действия выполняется проверка модели. При проверке используются необязательные атрибуты типа модели, что позволяет убедиться, что предоставленный объект модели соответствует определенным требованиям к данным. Некоторые значения могут задаваться как обязательные или иметь ограниченную длину, диапазон и т. д. Если заданы атрибуты проверки, но модель не соответствует их требованиям, свойству ModelState.IsValid присваивается значение false, и готовится набор правил проверки, завершившихся с ошибкой, которые будут отправлены клиенту, выполнившему запрос.

Если вы используете проверку модели, необходимо всегда проверять допустимость модели, прежде чем выполнять какие-либо изменяющие состояние команды. Это позволит предотвратить повреждение приложения из-за недопустимых данных. Чтобы не добавлять соответствующий код в каждое действие, можно использовать [фильтр](/aspnet/core/mvc/controllers/filters). Фильтры MVC ASP.NET Core предназначены для перехвата групп запросов с той целью, чтобы применить к ним общие политики или сквозную функциональность. Фильтры могут применяться к отдельным действиям, ко всему контроллеру или глобально на уровне приложения.

Для веб-API модель MVC ASP.NET Core поддерживает [_согласование содержимого_](/aspnet/core/mvc/models/formatting), что позволяет указывать в запросах требуемый формат ответа. На основании представленных в запросе заголовков действия, возвращающие данные, будут использовать для ответа XML, JSON или другой поддерживаемый формат. Эта возможность позволяет использовать один и тот же API нескольким клиентам с разными требованиями к формату.

Проекты веб-API могут использовать атрибут `[ApiController]`, который может применяться к отдельным контроллерам, базовому классу контроллера или ко всей сборке. Этот атрибут добавляет автоматическую проверку модели, и действие с недопустимой моделью вернет ошибку BadRequest с подробными сведениями об ошибках проверки. Атрибут также требует, чтобы все действия имели маршрут атрибута, а не использовали маршрут на основе соглашения, и возвращает более подробные сведения ProblemDetails в ответ на ошибки.

> ### <a name="references--mapping-requests-to-responses"></a>Ссылки — сопоставление запросов с ответами
>
> - **Маршрутизация к действиям контроллера**
 > <https://docs.microsoft.com/aspnet/core/mvc/controllers/routing>
> - **Привязка модели**
 > <https://docs.microsoft.com/aspnet/core/mvc/models/model-binding>
> - **Проверка модели**
 > <https://docs.microsoft.com/aspnet/core/mvc/models/validation>
> - **Фильтры**
 > <https://docs.microsoft.com/aspnet/core/mvc/controllers/filters>
> - **Атрибут ApiController**
 > <https://docs.microsoft.com/aspnet/core/web-api/>

## <a name="working-with-dependencies"></a>Работа с зависимостями

ASP.NET Core реализует встроенную поддержку и использование методики [внедрения зависимостей](/aspnet/core/fundamentals/dependency-injection). Методика внедрения зависимостей позволяет обеспечить слабую связанность между разными частями приложения. Такая реализация является желательной, поскольку упрощает изоляцию частей приложения, что делает их тестирование или замену более эффективными. Кроме того, в этом случае снижается вероятность того, что изменения в одной части приложения будут иметь непредвиденное влияние на какую-либо другую часть. Внедрение зависимостей осуществляется на основе принципа инверсии зависимостей и часто является основным фактором, определяющим соблюдение принципа открытости/закрытости. При оценке того, как ваше приложение работает с зависимостями, следует учитывать риск возникновения проблем со [статическим сцеплением](https://deviq.com/static-cling/) кода и помнить о том, что [ключевое слово new является "клеем" для вашего приложения](https://ardalis.com/new-is-glue).

Статическое сцепление происходит тогда, когда классы вызывают статические методы или обращаются к статическим свойствам, в результате чего в инфраструктуре возникают побочные эффекты или зависимости. Например, если вы используете метод, который вызывает статический метод, осуществляющий запись в базу данных, ваш метод будет тесно связан с базой. В таком случае любой сбой в вызове базы данных приведет к нарушению работы вашего метода. Тестирование этих методов представляет собой серьезную проблему, поскольку для проведения таких тестов требуется, чтобы коммерческие библиотеки макетирования имитировали статические вызовы. Иначе подобную проверку можно провести только при наличии тестовой базы данных. Статические вызовы, которые не имеют зависимостей от инфраструктуры, особенно полностью не поддерживающие отслеживание состояния, можно вызывать без опаски, поскольку они не влияют на степень связанности или возможности тестирования (помимо связанности самого кода со статическим вызовом).

Многие разработчики осознают риски статического сцепления и глобального состояния, однако по-прежнему допускают связанность кода с конкретными реализациями из-за прямого создания экземпляров. Об этом напоминает принцип, что ключевое слово new является "клеем" для вашего приложения. Однако это ни в коем случае не значит, что от слова `new` следует полностью отказаться. Как и в случае с вызовами статических методов, создание новых экземпляров типов, не имеющих внешних зависимостей, как правило, не приводит к тесной привязке кода к деталям реализации и не усложняет тестирование. Однако каждый раз, когда создается экземпляр класса, следует задуматься о том, имеет ли смысл жесткая привязка этого экземпляра к конкретному месту или эффективнее будет реализовать запрос этого экземпляра в качестве зависимости.

### <a name="declare-your-dependencies"></a>Объявление зависимостей

В основе ASP.NET Core лежит принцип объявления методами и классами собственных зависимостей посредством их запроса в виде аргументов. Настройка приложений ASP.NET обычно выполняется в классе Startup, конфигурация которого обеспечивает поддержку внедрения зависимостей в нескольких точках. Если у вашего класса Startup есть конструктор, с его помощью могут запрашиваться зависимости. Например, это может выглядеть так:

```csharp
public class Startup
{
    public Startup(IHostingEnvironment env)
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(env.ContentRootPath)
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
            .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true);
    }
}
```

Класс Startup интересен тем, что для него не определены явные требования к типу. Он не наследуется от конкретного базового класса Startup и не реализует какой-либо конкретный интерфейс. Он может иметь конструктор, для которого вы можете задать любое число параметров, однако при необходимости от конструктора можно отказаться. При запуске веб-узла, который вы настроили для своего приложения, вызывается указанный вами класс Startup, в результате чего все требуемые классом Startup зависимости заполняются посредством внедрения зависимостей. Естественно, если запросить параметры, которые не были настроены в контейнере служб, используемом ASP.NET Core, будет возвращено исключение. Тем не менее, если вы работаете с известными контейнеру зависимостями, вы можете запрашивать все, что угодно.

Ваше приложение ASP.NET Core будет поддерживать внедрение зависимостей с самого начала с момента создания экземпляра Startup. Этим поддержка для класса Startup не ограничивается. Вы также можете запрашивать зависимости в методе Configure:

```csharp
public void Configure(IApplicationBuilder app,
    IHostingEnvironment env,
    ILoggerFactory loggerFactory)
{

}
```

Исключением является метод ConfigureServices, который принимает всего один параметр типа IServiceCollection. В этом методе поддержка внедрения зависимостей не требуется, поскольку, с одной стороны, он отвечает за добавление объектов в контейнер служб, а с другой — имеет доступ ко всем настроенным в данный момент службам посредством параметра IServiceCollection. Таким образом, вы можете работать с зависимостями, определенными в коллекции служб ASP.NET Core, в любой части класса Startup, запрашивая необходимую службу в виде параметра или используя параметр IServiceCollection метода ConfigureServices.

> [!NOTE]
> Если вам необходимо гарантировать доступность определенных служб для класса Startup, вы можете настроить их с помощью IWebHostBuilder и его метода ConfigureServices в вызове CreateDefaultBuilder.

Класс Startup выступает в качестве модели, определяющей требуемую структуру для других частей вашего приложения ASP.NET Core, включая контроллеры, ПО промежуточного слоя, фильтры и ваши собственные службы. В каждом случае необходимо соблюдать [принцип явных зависимостей](https://deviq.com/explicit-dependencies-principle/) и запрашивать зависимости, а не создавать их. Для этих целей в приложении следует использовать внедрение зависимостей. Обращайте внимание на то, где и как осуществляется прямое создание экземпляров реализаций, особенно для служб и объектов, которые работают с инфраструктурой или имеют побочные эффекты. Отдавайте предпочтение работе с абстракциями, которые определены в ядре приложения и передаются в качестве аргументов, и не увлекайтесь жестким определением ссылок на конкретные типы реализации.

## <a name="structuring-the-application"></a>Структурирование приложения

Монолитные приложения обычно имеют одну точку входа. Для веб-приложения ASP.NET Core точкой входа служит веб-проект ASP.NET Core. Тем не менее это не означает, что решение обязательно должно состоять из одного проекта. В соответствии с принципом разделения задач рекомендуется разбивать приложение на слои. После этого следует рассмотреть возможность разделения проектов по папкам, что позволит достичь более эффективной инкапсуляции. Оптимальным способом достичь этих целей в приложении ASP.NET Core является использование варианта чистой архитектуры, которая обсуждается в главе 5. При таком подходе решение приложения должно состоять из отдельных библиотек для пользовательского интерфейса, инфраструктуры и ядра приложения.

В дополнение к этим проектам также включаются отдельные тестовые проекты (тестирование обсуждается в главе 9).

Объектная модель и интерфейсы приложения должны располагаться в проекте ядра приложения. Этот проект будет иметь минимально возможное количество зависимостей, и на него будут ссылаться другие проекты решения. Необходимые бизнес-сущности определяются в проекте ядра приложения, как и службы, которые не зависят напрямую от инфраструктуры.

Детали реализации, в том числе способ реализации сохраняемости или отправки уведомлений пользователю, определяются в проекте инфраструктуры. Этот проект будет ссылаться на зависящие от реализации пакеты, например Entity Framework Core, однако не должен предоставлять детали таких реализаций за пределы проекта. Службы и репозитории инфраструктуры должны реализовывать интерфейсы, которые определены в проекте ядра приложения, а ее реализации сохраняемости обеспечивают извлечение и хранение сущностей, определенных в ядре приложения.

Проект пользовательского интерфейса ASP.NET Core отвечает за выполнение задач уровня пользовательского интерфейса, но не должен включать детали бизнес-логики или инфраструктуры. Фактически, в идеальном случае он не должен иметь зависимостей от проекта инфраструктуры, что позволяет исключить случайное появление зависимостей между этими двумя проектами. Для этого может использоваться сторонний контейнер внедрения зависимостей, например Autofac, который позволяет определять правила внедрения зависимостей в классах модуля в каждом проекте.

Другой подход к ослаблению связанности приложения с деталями реализации заключается в вызове из приложения микрослужб, которые могут быть развернуты в отдельных контейнерах Docker. Таким образом обеспечивается дополнительное разделение задач и ослабление связанности по сравнению с внедрением зависимостей между двумя проектами, однако такой подход связан с определенными сложностями.

### <a name="feature-organization"></a>Организация компонентов

По умолчанию структура папок приложения ASP.NET Core включает контроллеры, представления и зачастую модели представлений. Код на стороне клиента, обеспечивающий поддержку таких структур на стороне сервера, как правило, хранится отдельно в папке wwwroot. Тем не менее в крупных приложениях при такой организации могут возникать проблемы, поскольку для работы с конкретным компонентом может потребоваться переход между этими папками. С увеличением числа файлов и вложенных папок в каждой папке сложности только возрастают, в связи с чем приходится тратить дополнительное время на просмотр в обозревателе решений. Одним из решений этой проблемы может стать упорядочение кода приложения по _компонентам_, а не по типу файлов. Такой стиль организации обычно называется папками или [срезами компонентов](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc) (см. также статью [Вертикальные срезы](https://deviq.com/vertical-slices/)).

Для этой цели в модели MVC ASP.NET Core поддерживаются области. С помощью областей можно создавать отдельные наборы папок контролеров и представлений (а также связанных с ними моделей) в каждой папке области. На рис. 7-1 показан пример структуры папок, в которой используются области.

![Пример организации области](./media/image7-1.png)

**Рис. 7-1**. Пример организации области

При работе с областями необходимо использовать атрибуты, чтобы декорировать контроллеры с указанием имени области, которой они принадлежат:

```csharp
[Area("Catalog")]
public class HomeController
{}
```

Также необходимо добавить поддержку областей для маршрутов:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(name: "areaRoute", pattern: "{area:exists}/{controller=Home}/{action=Index}/{id?}");
    endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
});
```

Помимо встроенной поддержки областей, вы можете использовать собственную структуру папок и соглашения вместо атрибутов и настраиваемых маршрутов. В этом случае у вас будут папки компонентов, не содержащие отдельных папок для представлений, контроллеров и т. д., благодаря чему иерархия будет иметь меньше уровней, что позволит упростить поиск всех файлов для конкретного компонента в одном месте.

В ASP.NET Core это поведение реализуется с использованием встроенных типов соглашений. При необходимости эти соглашения можно изменить или заменить. Например, вы можете определить соглашение, по которому имя компонента для указанного контроллера будет получаться автоматически на основе его пространства имен (оно обычно связано с папкой, в которой располагается контроллер):

```csharp
public class FeatureConvention : IControllerModelConvention
{
    public void Apply(ControllerModel controller)
    {
        controller.Properties.Add("feature",
        GetFeatureName(controller.ControllerType));
    }

    private string GetFeatureName(TypeInfo controllerType)
    {
        string[] tokens = controllerType.FullName.Split('.');
        if (!tokens.Any(t => t == "Features")) return "";
        string featureName = tokens
        .SkipWhile(t => !t.Equals("features",
        StringComparison.CurrentCultureIgnoreCase))
        .Skip(1)
        .Take(1)
        .FirstOrDefault();
        return featureName;
    }
}
```

Затем это соглашение указывается в качестве варианта при добавлении поддержки модели MVC для приложения в ConfigureServices:

```csharp
services.AddMvc(o => o.Conventions.Add(new FeatureConvention()));
```

Модель MVC ASP.NET Core также использует соглашение для поиска представлений. Вы можете переопределить его с использованием настраиваемого соглашения, чтобы задать поиск представлений в папках компонентов (будет использоваться имя компонента, предоставленное ранее с помощью FeatureConvention). Узнать больше об этом подходе и скачать рабочий пример можно в статье MSDN Magazine, посвященной [срезам компонентов для модели MVC ASP.NET Core](https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc).

### <a name="cross-cutting-concerns"></a>Сквозная функциональность

По мере расширения приложения все большую важность приобретает вопрос вынесения сквозной функциональности, что позволяет исключить дублирование и обеспечить согласованность. В качестве примеров сквозной функциональности в приложениях ASP.NET Core можно привести задачи проверки подлинности, правила проверки моделей, кэширование вывода и обработку ошибок. [Фильтры](/aspnet/core/mvc/controllers/filters) в ASP.NET Core MVC позволяют выполнять код до или после определенных стадий в конвейере обработки запросов. Например, фильтр можно выполнять до и после привязки модели, выполнения действия или получения результата действия. Кроме того, с помощью фильтра авторизации можно управлять доступом к оставшейся части конвейера. На рис. 7-2 показан поток выполнения запроса через настроенные фильтры.

![Запрос обрабатывается посредством фильтров авторизации, фильтров ресурсов, привязки модели, фильтров действий, выполнения действия и преобразования результата действия, фильтров исключений, фильтров результатов и выполнения результатов. На обратном пути запрос обрабатывается только фильтрами результатов и фильтрами ресурсов, прежде чем стать ответом, отправляемым клиенту.](./media/image7-2.png)

**Рис. 7-2**. Выполнение запроса через фильтры и конвейер запросов.

Фильтры обычно реализуются в виде атрибутов, поэтому их можно применять к контроллерам или действиям (или даже глобально). При добавлении таким способом фильтры, задаваемые на уровне действия, переопределяют (или используют в качестве основы) фильтры уровня контроллера, которые, в свою очередь, переопределяют глобальные фильтры. Например, атрибут \[Route\] может использоваться для создания маршрутов между контроллерами и действиями. Аналогичным образом можно настроить авторизацию на уровне контроллера и затем переопределить ее для отдельных действий, как показано в следующем примере:

```csharp
[Authorize]
public class AccountController : Controller

{
    [AllowAnonymous] // overrides the Authorize attribute
    public async Task<IActionResult> Login() {}
    public async Task<IActionResult> ForgotPassword() {}
}
```

Первый метод, Login, использует фильтр AllowAnonymous (атрибут) для переопределения фильтра Authorize, заданного на уровне контроллера. Действие ForgotPassword (и любое другое действие в классе без атрибута AllowAnonymous) потребует запрос с проверкой подлинности.

С помощью фильтров можно исключить дублирование, выражаемое общими политиками обработки ошибок для API. Например, типовая политика API предусматривает возврат ответа NotFound для запросов, ссылающихся на несуществующие ключи, а также ответа BadRequest в случае сбоя при проверке модели. Действие этих двух политик демонстрируется в следующем примере:

```csharp
[HttpPut("{id}")]
public async Task<IActionResult> Put(int id, [FromBody]Author author)
{
    if ((await _authorRepository.ListAsync()).All(a => a.Id != id))
    {
        return NotFound(id);
    }
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }
    author.Id = id;
    await _authorRepository.UpdateAsync(author);
    return Ok();
}
```

Не перегружайте свои методы действия подобным условным кодом. Вместо этого следует вынести политики в фильтры, которые будут применяться по необходимости. В этом примере проверку модели, которая должна выполняться каждый раз при отправке команды в API, можно заменить следующим атрибутом:

```csharp
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(context.ModelState);
        }
    }
}
```

Вы можете добавить `ValidateModelAttribute` в проект как зависимость NuGet, включив пакет [Ardalis.ValidateModel](https://www.nuget.org/packages/Ardalis.ValidateModel). Для интерфейсов API можно использовать атрибут `ApiController` для обеспечения такого поведения без отдельного фильтра `ValidateModel`.

Аналогичным образом с помощью фильтра можно проверить факт существования записи и вернуть ошибку 404 до выполнения действия. Это позволит исключить необходимость выполнять такие проверки в самом действии. После вынесения общих соглашений и организации решения таким образом, чтобы отделить код инфраструктуры и бизнес-логики от пользовательского интерфейса, метод действия MVC будет иметь минимальный размер:

```csharp
[HttpPut("{id}")]
[ValidateAuthorExists]
public async Task<IActionResult> Put(int id, [FromBody]Author author)
{
    await _authorRepository.UpdateAsync(author);
    return Ok();
}
```

Узнать больше о реализации фильтров и скачать рабочий пример можно в статье MSDN Magazine, посвященной [применению фильтров MVC для ASP.NET Core в реальном мире](https://docs.microsoft.com/archive/msdn-magazine/2016/august/asp-net-core-real-world-asp-net-core-mvc-filters).

> ### <a name="references--structuring-applications"></a>Ссылки — структурирование приложений
>
> - **Области**  
>   <https://docs.microsoft.com/aspnet/core/mvc/controllers/areas>
> - **MSDN Magazine — срезы функций для ASP.NET Core MVC**  
>   <https://docs.microsoft.com/archive/msdn-magazine/2016/september/asp-net-core-feature-slices-for-asp-net-core-mvc>
> - **Фильтры**  
>   <https://docs.microsoft.com/aspnet/core/mvc/controllers/filters>
> - **Журнал MSDN Magazine — фильтры MVC ASP.NET Core в реальном мире**  
>   <https://docs.microsoft.com/archive/msdn-magazine/2016/august/asp-net-core-real-world-asp-net-core-mvc-filters>

## <a name="security"></a>Безопасность

Обеспечение безопасности веб-приложений — это серьезная проблема, требующая решения множества задач. На базовом уровне обеспечение безопасности подразумевает знание источника запроса и предоставление этому запросу доступа только к необходимым ресурсам. Процесс проверки подлинности предусматривает сравнение предоставленных в запросе учетных данных с теми, которые находятся в хранилище доверенных данных. Это позволяет определить, является ли источник запроса известной сущностью. Процесс авторизации предусматривает ограничение доступа к определенным ресурсам на основе удостоверения пользователя. Еще одна задача заключается в защите от перехвата запросов третьими лицами. Для этого в приложении как минимум [должен использоваться протокол SSL](/aspnet/core/security/enforcing-ssl).

### <a name="authentication"></a>Проверка подлинности

Удостоверение ASP.NET Core — это система членства, с помощью которой обеспечивается поддержка функций входа в ваше приложение. Благодаря этому поддерживаются учетные записи локальных пользователей, а также внешние поставщики служб входа, включая учетные записи Майкрософт, Twitter, Facebook, Google и многие другие. В дополнение к удостоверению ASP.NET Core в приложении может использоваться проверка подлинности Windows или сторонний поставщик служб проверки подлинности, например [Identity Server](https://github.com/IdentityServer/IdentityServer4).

Удостоверение ASP.NET Core включается в шаблоны новых проектов в том случае, если выбран параметр "Учетные записи отдельных пользователей". Этот шаблон включает поддержку регистрации, входа, внешних имен входа, забытых паролей и других дополнительных функций.

![Выберите "Учетные записи отдельных пользователей" для использования предварительно настроенных идентификаторов](./media/image7-3.png)

**Рис. 7-3**. Выбор "Учетные записи отдельных пользователей" для использования предварительно настроенных идентификаторов.

Поддержка удостоверения реализуется в классе Startup в методах ConfigureServices и Configure:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // Add framework services.
    services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
    services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();
    services.AddMvc();
}

public void Configure(IApplicationBuilder app)
{
    app.UseStaticFiles();
    app.UseIdentity();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllerRoute(name: "default", pattern: "{controller=Home}/{action=Index}/{id?}");
    });
}
```

В методе Configure UseIdentity обязательно должно указываться раньше, чем UseMvc. При настройке удостоверения в ConfigureServices вы можете обратить внимание на вызов AddDefaultTokenProviders. Этот вызов не связан с маркерами, которые могут использоваться для защиты веб-соединений. Он относится к поставщикам, создающим запросы, которые могут направляться пользователям в сообщениях электронной почты или SMS для подтверждения их личности.

Дополнительные сведения о [настройке двухфакторной проверки подлинности](/aspnet/core/security/authentication/2fa) и [использовании внешних поставщиков служб входа](/aspnet/core/security/authentication/social/) см. в официальной документации по ASP.NET Core.

### <a name="authorization"></a>Авторизация

Простейшая форма авторизации предусматривает запрет на доступ анонимных пользователей. Чтобы реализовать это, достаточно применить атрибут \[Authorize\] к определенным контроллерам и действиям. При использовании ролей этот атрибут можно расширить, ограничив доступ для пользователей с определенными ролями, как показано ниже:

```csharp
[Authorize(Roles = "HRManager,Finance")]
public class SalaryController : Controller
{

}
```

В этом случае доступ к контроллеру SalaryController будут иметь пользователи, которым назначены роли HRManager или Finance (или одновременно обе эти роли). Если пользователь должен иметь одновременно несколько ролей, этот атрибут можно применить несколько раз, в каждом случае указывая нужную роль.

Если наборы ролей указываются в виде строк в различных контроллерах и действиях, это может привести к нежелательному дублированию. Вместо применения отдельных ролей с помощью атрибута \[Authorize\] можно настроить политики авторизации, которые будут инкапсулировать правила авторизации:

```csharp
[Authorize(Policy = "CanViewPrivateReport")]
public IActionResult ExecutiveSalaryReport()
{
    return View();
}
```

Такой подход к применению политик позволяет разделить виды действий, доступ к которым ограничивается на основе ролей или применяемых правил. Впоследствии при создании новой роли, которой требуется доступ к определенным ресурсам, достаточно просто обновить политику вместо того, чтобы обновлять все списки ролей для каждого атрибута \[Authorize\].

#### <a name="claims"></a>Утверждения

Утверждения — это пары имен и значений, которые представляют свойства прошедшего проверку подлинности пользователя. Например, в виде утверждения могут храниться номера сотрудников. Утверждения могут использоваться в рамках политик авторизации. Например, вы можете создать политику EmployeeOnly, которая требует наличия утверждения с названием EmployeeNumber, как показано ниже:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddAuthorization(options =>
    {
        options.AddPolicy("EmployeeOnly", policy => policy.RequireClaim("EmployeeNumber"));
    });
}
```

Эту политику можно использовать совместно с атрибутом \[Authorize\] для защиты любых контроллеров и действий, как описывается выше.

#### <a name="securing-web-apis"></a>Защита веб-API

В большинстве веб-API должна применяться система проверки подлинности на основе маркеров. Проверка подлинности на основе маркеров реализуется без сохранения сведений о состоянии и предусматривает возможность масштабирования. В системе на основе маркеров клиент сначала должен пройти проверку подлинности с использованием соответствующего поставщика. В случае успешного прохождения проверки клиент получает маркер, который представляет собой зашифрованную значащую строку символов. Впоследствии при отправке запроса к API клиент добавляет этот маркер в заголовок запроса. Перед выполнением запроса сервер проверяет маркер, указанный в его заголовке. Этот процесс показан на рис. 7-4.

![Проверка подлинности на основе маркеров](./media/image7-4.png)

**Рис. 7-4.** Проверка подлинности на основе маркеров для веб-API.

Вы можете создать собственную службу проверки подлинности, интегрировать ее с Azure AD и OAuth или реализовать службу с помощью средства с открытым исходным кодом, например [IdentityServer](https://github.com/IdentityServer).

#### <a name="custom-security"></a>Настраиваемая безопасность

Будьте особенно осторожны при самостоятельной реализации криптографии, членства пользователей или системы создания токенов. Есть много платных и бесплатных инструментов, которые почти наверняка гарантируют более высокий уровень безопасности, чем пользовательские реализации.

> ### <a name="references--security"></a>Ссылки — безопасность
>
> - **Обзор документации по безопасности**  
>   https://docs.microsoft.com/aspnet/core/security/
> - **Принудительное применение протокола SSL в приложениях ASP.NET Core**  
>   <https://docs.microsoft.com/aspnet/core/security/enforcing-ssl>
> - **Общие сведения об Identity**  
>   <https://docs.microsoft.com/aspnet/core/security/authentication/identity>
> - **Общие сведения об авторизации**  
>   <https://docs.microsoft.com/aspnet/core/security/authorization/introduction>
> - **Проверка подлинности и авторизация для приложений API в службах приложений Azure**  
>   <https://docs.microsoft.com/azure/app-service-api/app-service-api-authentication>
> - **Сервер удостоверений**  
>   <https://github.com/IdentityServer>

## <a name="client-communication"></a>Взаимодействие с клиентом

Помимо обслуживания страниц и ответа на запросы данных через веб-API, приложения ASP.NET Core могут напрямую взаимодействовать с подключенными клиентами. Для исходящего обмена данными в этом случае могут использоваться самые разные транспортные технологии, однако самое широкое распространение получила технология WebSockets. Библиотека ASP.NET Core SignalR упрощает реализацию функций взаимодействия между клиентом и сервером в реальном времени в вашем приложении. SignalR поддерживает широкий спектр транспортных технологий, в том числе WebSockets, и абстрагирует многие детали реализации, освобождая от этого труда разработчика.

Взаимодействие с клиентом в реальном времени с использованием WebSockets или других технологий применяется в самых разных сценариях. Ниже приведены некоторые примеры таких ситуаций.

- Приложения комнаты чата в реальном времени

- Приложения мониторинга

- Обновления хода выполнения заданий

- Уведомления

- Приложения интерактивных форм

При реализации взаимодействия с клиентом в приложениях обычно используются два компонента:

- Диспетчер подключений на стороне сервера (SignalR Hub, WebSocketManager WebSocketHandler)

- Библиотека на стороне клиента

В качестве клиентов могут выступать не только браузеры, но также мобильные, консольные и другие встроенные приложения, которые поддерживают SignalR/WebSockets. Следующая простая программа, входящая в пример приложения WebSocketManager, выводит на консоль все содержимое, передаваемое в приложение чата:

```csharp
public class Program
{
    private static Connection _connection;
    public static void Main(string[] args)
    {
        StartConnectionAsync();
        _connection.On("receiveMessage", (arguments) =>
        {
            Console.WriteLine($"{arguments[0]} said: {arguments[1]}");
        });
        Console.ReadLine();
        StopConnectionAsync();
    }

    public static async Task StartConnectionAsync()
    {
        _connection = new Connection();
        await _connection.StartConnectionAsync("ws://localhost:65110/chat");
    }

    public static async Task StopConnectionAsync()
    {
        await _connection.StopConnectionAsync();
    }
}
```

Рассмотрите способы обеспечения взаимодействия с клиентом напрямую из приложений и оцените, насколько возможность взаимодействия в реальном времени позволит улучшить ваше приложение.

> ### <a name="references--client-communication"></a>Ссылки — взаимодействие с клиентом
>
> - **Библиотека ASP.NET Core SignalR**  
>   <https://github.com/dotnet/aspnetcore/tree/master/src/SignalR>
> - **WebSocket Manager**  
>   https://github.com/radu-matei/websocket-manager

## <a name="domain-driven-design--should-you-apply-it"></a>Следует ли применять проблемно-ориентированное проектирование?

Проблемно-ориентированное проектирование предусматривает гибкий подход к разработке программного обеспечения с учетом особенностей _области бизнеса_. При таком подходе особое внимание уделяется взаимодействию с экспертами в конкретных областях бизнеса, которые предоставляют разработчикам информацию о работе систем в реальном мире. Например, при разработке системы биржевых торгов вам может потребоваться консультация со стороны эксперта в этой области. Проблемно-ориентированное проектирование рассчитано на решение сложных бизнес-проблем и зачастую не подходит для небольших простых приложений, поскольку затраты на понимание и моделирование предметной области попросту не могут окупиться.

При разработке программного обеспечения с соблюдением принципов проблемно-ориентированного проектирования ваша команда (включая нетехнических специалистов и участников) должна использовать _единый язык_ для общего понимания предметной области. Это значит, что необходимо использовать единую терминологию для описания моделируемых концепций реального мира, их программных эквивалентов и любых структур, которые могут применяться для сохранения концепций (например, таблиц баз данных). Таким образом, описываемые на едином языке концепции должны стать основой для вашей _модели предметной области_.

Модель предметной области состоит из объектов, которые взаимодействуют друг с другом, моделируя поведения системы. Эти объекты можно разделить на следующие категории:

- [Сущности](https://deviq.com/entity/), которые представляют объекты с потоком удостоверений. Для сущностей обычно применяется сохраняемость по ключу, по которому они могут быть впоследствии извлечены.

- [Агрегаты](https://deviq.com/aggregate-pattern/), представляющие группы объектов, которые должны сохраняться как единое целое.

- [Объекты значений](https://deviq.com/value-object/), представляющие концепции, которые могут сравниваться на основании суммы значений их свойств. Например, диапазон дат определяется датами начала и окончания.

- [События предметной области](https://martinfowler.com/eaaDev/DomainEvent.html), которые представляют происходящие в системе события, интересующие другие части системы.

Модель предметной области должна инкапсулировать комплексное поведение в рамках модели. В частности, сущности должны представлять собой не просто коллекции свойств. Модель предметной области, которая не определяет поведение и представляет лишь состояние системы, будет [слабой](https://deviq.com/anemic-model/), что при проблемно-ориентированном проектировании крайне нежелательно.

Помимо этих типов моделей, при проблемно-ориентированном проектировании применяются другие шаблоны:

- [Репозиторий](https://deviq.com/repository-pattern/) обеспечивает абстрагирование сведений о сохраняемости.

- [Фабрика](https://en.wikipedia.org/wiki/Factory_method_pattern) служит для инкапсуляции создания сложных объектов.

- События домена позволяют отделить зависимое поведение от инициирующих его действий и событий.

- [Службы](http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/) инкапсулируют сложное поведение и (или) детали реализации инфраструктуры.

- [Команда](https://en.wikipedia.org/wiki/Command_pattern) обеспечивает разделение выдачи и выполнения команд.

- [Спецификация](https://deviq.com/specification-pattern/) инкапсулирует детали запроса.

При проблемно-ориентированном проектировании также рекомендуется применять ранее описываемую чистую архитектуру, благодаря которой обеспечиваются слабая связанность, инкапсуляция и простота проверки кода с использованием модульных тестов.

### <a name="when-should-you-apply-ddd"></a>В каких случаях следует применять проблемно-ориентированное проектирование

Проблемно-ориентированное проектирование оптимально подходит для крупных приложений, разработка которых связана с решением как серьезных технических трудностей, так и сложных бизнес-задач. В таких сценариях при разработке приложения требуются знания экспертов в предметной области. При этом требуется значительный объем работы над поведением в самой модели предметной области, что позволяет представить бизнес-правила и взаимодействия в дополнение к возможностям хранения и извлечения текущего состояния различных записей с применением хранилищ данных.

### <a name="when-shouldnt-you-apply-ddd"></a>В каких случаях не следует применять проблемно-ориентированное проектирование

Проблемно-ориентированное проектирование предусматривает инвестиции в моделирование, разработку архитектуры и взаимодействия, которые могут быть необоснованно велики для небольших приложений или решений, предназначенных только для создания, чтения, обновления и удаления данных. Если вы выбрали этот вариант, но при этом обнаружили слабость модели предметной области (то есть отсутствие поведения), возможно, следует пересмотреть выбранный подход. Возможно, в таком случае для вашего приложения не требуется применять проблемно-ориентированное проектирование либо вам может потребоваться помощь в рефакторинге приложения с тем, чтобы инкапсулировать бизнес-логику в модели предметной области, а не в базе данных или пользовательском интерфейсе.

Возможен гибридный подход, при котором проблемно-ориентированное проектирование применяется только в отношении транзакционных или более сложных частей приложения, а не для реализации простых функций создания, чтения, обновления и удаления данных. Например, если вы запрашиваете данные для вывода отчета или визуализации данных в панели мониторинга, вам не нужны ограничения агрегата. В этом случае вполне подойдет использование более простой модели чтения.

> ### <a name="references--domain-driven-design"></a>Ссылки — проблемно-ориентированное проектирование
>
> - **Проблемно-ориентированное проектирование простыми словами (ответ с веб-сайта StackOverflow)**  
>   <https://stackoverflow.com/questions/1222392/can-someone-explain-domain-driven-design-ddd-in-plain-english-please/1222488#1222488>

## <a name="deployment"></a>Развертывание

Независимо от того, где будет размещено ваше приложение ASP.NET Core, процесс его развертывания будет состоять из нескольких шагов. В первую очередь выполняется публикация приложения, например с помощью команды `dotnet publish` интерфейса командной строки. На этом этапе приложение компилируется, а все необходимые для его работы файлы помещаются в указанную папку. При развертывании из Visual Studio эти действия выполняются автоматически. В папке публикации содержатся EXE- и DLL-файлы приложения, а также его зависимости. Автономное приложение также будет включать версию среды выполнения .NET. Приложения ASP.NET Core также включают файлы конфигурации, статические ресурсы клиента и представления MVC.

Приложения ASP.NET Core являются консольными приложениями и должны запускаться при загрузке или перезагрузке сервера в случае сбоя приложения (или сервера). Для автоматизации этого процесса может использоваться диспетчер процессов. Чаще всего для ASP.NET Core используются такие диспетчеры запросов, как Nginx и Apache в Linux, а также IIS или Windows Service в Windows.

В дополнение к диспетчеру процессов ASP.NET Core приложения могут использовать обратный прокси-сервер. Обратный прокси-сервер получает HTTP-запросы из Интернета и пересылает их в Kestrel после определенной предварительной обработки. Обратные прокси-серверы обеспечивают слой безопасности для приложения. Кроме того, Kestrel не поддерживает размещение нескольких приложений на одном порту и по одному IP-адресу, поэтому такие сценарии нельзя использовать заголовки узла и другие подобные технологии.

![Kestrel для Интернета](./media/image7-5.png)

**Рис. 7-5**. ASP.NET, размещенный в Kestrel за обратным прокси-сервером

Кроме того, обратный прокси-сервер может применяться для защиты нескольких приложений с использованием протокола SSL/HTTPS. В этом случае настраивать SSL необходимо только на обратном прокси-сервере. Взаимодействие между обратным прокси-сервером и Kestrel может осуществляться по протоколу HTTP, как показано на рис. 7-6.

![Приложение ASP.NET, размещенное позади обратного прокси-сервера, защищенного с помощью протокола HTTPS](./media/image7-6.png)

**Рис. 7-6.** Приложение ASP.NET, размещенное позади обратного прокси-сервера, защищенного с помощью протокола HTTPS

Также набирает популярность подход с размещением приложений ASP.NET Core в контейнере Docker, который, в свою очередь, может размещаться локально или развертываться в облачной среде Azure. Контейнер Docker может содержать код приложения и выполняться на сервере Kestrel (в этом случае необходимо развертывание позади обратного прокси-сервера, как показано выше).

Если вы размещаете приложение в Azure, можно использовать шлюз приложений Microsoft Azure в качестве выделенного виртуального устройства для предоставления определенных служб. Шлюз приложений не только выступает в качестве обратного прокси-сервера для отдельных приложений, но и реализует следующие возможности:

- Балансировка нагрузки HTTP

- Разгрузка SSL (SSL только для Интернета)

- Сквозное шифрование SSL

- Распределенная маршрутизация (консолидация до 20 сайтов на одном шлюзе приложений)

- Брандмауэр веб-приложения

- Поддержка WebSocket

- Расширенная диагностика

_Дополнительные сведения о вариантах развертывания Azure см. [в главе 10](development-process-for-azure.md)._

> ### <a name="references--deployment"></a>Ссылки — развертывание
>
> - **Общие сведения о размещении и развертывании**  
>   <https://docs.microsoft.com/aspnet/core/publishing/>
> - **Условия использования Kestrel с обратным прокси-сервером**  
>   <https://docs.microsoft.com/aspnet/core/fundamentals/servers/kestrel#when-to-use-kestrel-with-a-reverse-proxy>
> - **Размещение приложений ASP.NET Core в контейнерах Docker**  
>   <https://docs.microsoft.com/aspnet/core/publishing/docker>
> - **Общие сведения о шлюзе приложений Azure**  
>   <https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction>

>[!div class="step-by-step"]
>[Назад](common-client-side-web-technologies.md)
>[Вперед](work-with-data-in-asp-net-core-apps.md)
