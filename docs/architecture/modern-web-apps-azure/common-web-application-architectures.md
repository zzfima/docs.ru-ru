---
title: Общие архитектуры веб-приложений
description: Разработка современных веб-приложений с помощью ASP.NET Core и Azure | Общие архитектуры веб-приложений
author: ardalis
ms.author: wiwagn
ms.date: 01/30/2019
ms.openlocfilehash: 6a4e971c1cb19a12710ad7893378a49758b4016e
ms.sourcegitcommit: 68a4b28242da50e1d25aab597c632767713a6f81
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/06/2019
ms.locfileid: "74884245"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="ffbec-103">Общие архитектуры веб-приложений</span><span class="sxs-lookup"><span data-stu-id="ffbec-103">Common web application architectures</span></span>

> <span data-ttu-id="ffbec-104">"Если вы считаете хорошую архитектуру слишком дорогой, попробуйте использовать плохую".</span><span class="sxs-lookup"><span data-stu-id="ffbec-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="ffbec-105">_— Брайан Фут (Brian Foote) и Джозеф Йодер (Joseph Yoder)_</span><span class="sxs-lookup"><span data-stu-id="ffbec-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="ffbec-106">Большинство традиционных приложений .NET развертывается в виде одного элемента, соответствующего исполняемому файлу, или одного веб-приложения, выполняющегося в домене приложений служб IIS.</span><span class="sxs-lookup"><span data-stu-id="ffbec-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="ffbec-107">Это простейшая модель развертывания, которая оптимально подходит для множества внутренних и небольших общедоступных приложений.</span><span class="sxs-lookup"><span data-stu-id="ffbec-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="ffbec-108">Тем не менее даже в такой простой модели развертывания большинство бизнес-приложений использует преимущества логического разделения на слои.</span><span class="sxs-lookup"><span data-stu-id="ffbec-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="ffbec-109">Что собой представляет монолитное приложение?</span><span class="sxs-lookup"><span data-stu-id="ffbec-109">What is a monolithic application?</span></span>

<span data-ttu-id="ffbec-110">Монолитное приложение полностью замкнуто в контексте поведения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="ffbec-111">Во время работы оно может взаимодействовать с другими службами или хранилищами данных, однако основа его поведения реализуется в собственном процессе, а все приложение обычно развертывается как один элемент.</span><span class="sxs-lookup"><span data-stu-id="ffbec-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="ffbec-112">Для горизонтального масштабирования такое приложение обычно целиком дублируется на нескольких серверах или виртуальных машинах.</span><span class="sxs-lookup"><span data-stu-id="ffbec-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="ffbec-113">Комплексные приложения</span><span class="sxs-lookup"><span data-stu-id="ffbec-113">All-in-one applications</span></span>

<span data-ttu-id="ffbec-114">Архитектура приложения содержит как минимум один проект.</span><span class="sxs-lookup"><span data-stu-id="ffbec-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="ffbec-115">В таком случае вся логика приложения заключена в одном проекте, компилируется в одну сборку и развертывается как один элемент.</span><span class="sxs-lookup"><span data-stu-id="ffbec-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="ffbec-116">Любой создаваемый в Visual Studio или из командной строки проект ASP.NET Core изначально будет представлять собой комплексный монолитный проект.</span><span class="sxs-lookup"><span data-stu-id="ffbec-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="ffbec-117">В нем будет заключено все поведение приложения, включая презентацию данных, бизнес-логику и логику доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="ffbec-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="ffbec-118">На рис. 5-1 показана файловая структура приложения, состоящего из одного проекта.</span><span class="sxs-lookup"><span data-stu-id="ffbec-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![Приложение ASP.NET Core, состоящее из одного проекта](./media/image5-1.png)

<span data-ttu-id="ffbec-120">**Рис. 5-1**.</span><span class="sxs-lookup"><span data-stu-id="ffbec-120">**Figure 5-1.**</span></span> <span data-ttu-id="ffbec-121">Приложение ASP.NET Core, состоящее из одного проекта.</span><span class="sxs-lookup"><span data-stu-id="ffbec-121">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="ffbec-122">В сценарии с одним проектом разделение задач реализуется с помощью папок.</span><span class="sxs-lookup"><span data-stu-id="ffbec-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="ffbec-123">Используемый по умолчанию шаблон включает отдельные папки для обязанностей шаблона MVC (модели, представления и контроллеры), а также дополнительные папки для данных и служб.</span><span class="sxs-lookup"><span data-stu-id="ffbec-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="ffbec-124">При такой организации детали презентации данных в максимально возможной степени размещаются в папке представлений (Views), а детали реализации доступа к данным должны быть ограничены классами, содержащимися в папке данных (Data).</span><span class="sxs-lookup"><span data-stu-id="ffbec-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="ffbec-125">Бизнес-логика при этом размещается в службах и классах, находящихся в папке моделей (Models).</span><span class="sxs-lookup"><span data-stu-id="ffbec-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="ffbec-126">Несмотря на свою простоту, монолитное решение с одним проектом имеет определенные недостатки.</span><span class="sxs-lookup"><span data-stu-id="ffbec-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="ffbec-127">По мере увеличения размера и сложности проекта будет расти число файлов и папок.</span><span class="sxs-lookup"><span data-stu-id="ffbec-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="ffbec-128">Задачи, связанные с пользовательским интерфейсом (модели, представления, контроллеры), размещаются в разных папках, которые не упорядочены по алфавиту.</span><span class="sxs-lookup"><span data-stu-id="ffbec-128">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="ffbec-129">С добавлением в отдельные папки конструкций уровня пользовательского интерфейса, например фильтров или связывателей модели, ситуация только ухудшается.</span><span class="sxs-lookup"><span data-stu-id="ffbec-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="ffbec-130">Бизнес-логика теряется в папках моделей (Models) и служб (Services), в результате чего невозможно четко определить, какие классы в каких папках должны зависеть от других классов.</span><span class="sxs-lookup"><span data-stu-id="ffbec-130">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="ffbec-131">Подобная неэффективная организация на уровне проекта часто приводит к получению [плохо структурированного кода](https://deviq.com/spaghetti-code/).</span><span class="sxs-lookup"><span data-stu-id="ffbec-131">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="ffbec-132">Для решения подобных проблем приложения часто организуются в виде решений, состоящих из множества проектов, где каждый проект размещается в отдельном _слое_ приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-132">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="ffbec-133">Что представляют собой слои?</span><span class="sxs-lookup"><span data-stu-id="ffbec-133">What are layers?</span></span>

<span data-ttu-id="ffbec-134">По мере увеличения сложности приложения для эффективного управления им может применяться разбиение по обязанностям и задачам.</span><span class="sxs-lookup"><span data-stu-id="ffbec-134">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="ffbec-135">Такой подход соответствует принципу разделения задач и помогает сохранить организацию расширяющейся базы кода, благодаря чему разработчики могут легко найти, где именно были реализованы конкретные функциональные возможности.</span><span class="sxs-lookup"><span data-stu-id="ffbec-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="ffbec-136">Многослойная архитектура имеет также целый ряд других преимуществ.</span><span class="sxs-lookup"><span data-stu-id="ffbec-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="ffbec-137">Благодаря упорядочению кода с помощью слоев общие низкоуровневые функции могут многократно использоваться по всему приложению.</span><span class="sxs-lookup"><span data-stu-id="ffbec-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="ffbec-138">Это крайне важно, поскольку такой подход требует меньшего объема кода и, за счет стандартизации приложения на уровне одной реализации, соответствует принципу ["Не повторяйся"](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).</span><span class="sxs-lookup"><span data-stu-id="ffbec-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="ffbec-139">В приложениях с многослойной архитектурой могут устанавливаться ограничения на взаимодействие между слоями.</span><span class="sxs-lookup"><span data-stu-id="ffbec-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="ffbec-140">Таким образом удается реализовать инкапсуляцию.</span><span class="sxs-lookup"><span data-stu-id="ffbec-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="ffbec-141">При изменении или замене слоя будут затронуты только те слои, которые работают непосредственно с ним.</span><span class="sxs-lookup"><span data-stu-id="ffbec-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="ffbec-142">Ограничивая зависимости слоев друг от друга, можно уменьшить последствия внесения изменений, в результате чего единичное изменение не будет влиять на все приложение.</span><span class="sxs-lookup"><span data-stu-id="ffbec-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="ffbec-143">Применение слоев (и инкапсуляция) позволяет заметно упростить замену функциональных возможностей в рамках приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="ffbec-144">Например, приложение может изначально использовать собственную базу данных SQL Server для сохраняемости, а впоследствии перейти на стратегию сохранения состояния на основе облака или веб-API.</span><span class="sxs-lookup"><span data-stu-id="ffbec-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="ffbec-145">Если в приложении надлежащим образом инкапсулирована реализация сохраняемости на логическом слое, этот слой SQL Server может быть заменен новым, где будет реализовываться тот же открытый интерфейс.</span><span class="sxs-lookup"><span data-stu-id="ffbec-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="ffbec-146">Помимо возможности замены реализаций в связи с последующими изменениями, применение слоев в приложении также позволяет менять реализации в целях тестирования.</span><span class="sxs-lookup"><span data-stu-id="ffbec-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="ffbec-147">Вместо написания тестов, которые применяются к слоям реальных данных или пользовательского интерфейса приложения, во время тестирования они заменяются фиктивными реализациями, которые демонстрируют известную реакцию на запросы.</span><span class="sxs-lookup"><span data-stu-id="ffbec-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="ffbec-148">Как правило, это значительно упрощает написание и ускоряет выполнение тестов по сравнению с тестированием в реальной инфраструктуре приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-148">This typically makes tests much easier to write and much faster to run when compared to running tests against the application's real infrastructure.</span></span>

<span data-ttu-id="ffbec-149">Разделение на логические слои широко распространено и помогает упорядочить код приложений предприятия. Сделать это можно несколькими способами.</span><span class="sxs-lookup"><span data-stu-id="ffbec-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="ffbec-150">_Слои_ обеспечивают логический уровень разделения в приложении.</span><span class="sxs-lookup"><span data-stu-id="ffbec-150">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="ffbec-151">Если логика приложения физически распределена между несколькими серверами или процессами, такие раздельные физические целевые объекты развертывания называются _уровнями_.</span><span class="sxs-lookup"><span data-stu-id="ffbec-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="ffbec-152">Таким образом, не только возможно, но и широко распространено развертывание N-слойных приложений на одном уровне.</span><span class="sxs-lookup"><span data-stu-id="ffbec-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="ffbec-153">Традиционные приложения с N-слойной архитектурой</span><span class="sxs-lookup"><span data-stu-id="ffbec-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="ffbec-154">Общепринятая организация логики приложения по слоям показана на рис. 5-2.</span><span class="sxs-lookup"><span data-stu-id="ffbec-154">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![Слои типового приложения](./media/image5-2.png)

<span data-ttu-id="ffbec-156">**Рис. 5-2.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-156">**Figure 5-2.**</span></span> <span data-ttu-id="ffbec-157">Слои типового приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-157">Typical application layers.</span></span>

<span data-ttu-id="ffbec-158">Как правило, в приложении определяются слои пользовательского интерфейса, бизнес-логики и доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="ffbec-158">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="ffbec-159">В рамках такой архитектуры пользователи выполняют запросы через слой пользовательского интерфейса, который взаимодействует только со слоем бизнес-логики.</span><span class="sxs-lookup"><span data-stu-id="ffbec-159">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="ffbec-160">Слой бизнес-логики, в свою очередь, может вызывать слой доступа к данным для обработки запросов.</span><span class="sxs-lookup"><span data-stu-id="ffbec-160">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="ffbec-161">Слой пользовательского интерфейса не должен выполнять запросы напрямую к слою доступа к данным и какими-либо другими способами напрямую взаимодействовать с функциями сохраняемости.</span><span class="sxs-lookup"><span data-stu-id="ffbec-161">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="ffbec-162">Аналогичным образом, слой бизнес-логики должен взаимодействовать с функциями сохраняемости только через слой доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="ffbec-162">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="ffbec-163">Таким образом, для каждого слоя четко определена своя обязанность.</span><span class="sxs-lookup"><span data-stu-id="ffbec-163">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="ffbec-164">Одним из недостатков традиционного многослойного подхода является то, что обработка зависимостей во время компиляции осуществляется сверху вниз.</span><span class="sxs-lookup"><span data-stu-id="ffbec-164">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="ffbec-165">Это значит, что слой пользовательского интерфейса зависит от слоя бизнес-логики, который, в свою очередь, зависит от слоя доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="ffbec-165">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="ffbec-166">Это значит, что слой бизнес-логики, который обычно содержит ключевые функции приложения, зависит от деталей реализации доступа к данным (и зачастую от наличия самой базы данных).</span><span class="sxs-lookup"><span data-stu-id="ffbec-166">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="ffbec-167">Тестирование бизнес-логики в такой архитектуре зачастую затруднено и требует наличия тестовой базы данных.</span><span class="sxs-lookup"><span data-stu-id="ffbec-167">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="ffbec-168">Для решения этой проблемы может применяться принцип инверсии зависимостей, как описывается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="ffbec-168">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="ffbec-169">На рис. 5-3 показан пример решения, в котором приложение разделено на три проекта (или слоя) в соответствии с определенными обязанностями.</span><span class="sxs-lookup"><span data-stu-id="ffbec-169">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![Простое монолитное приложение, состоящее из трех проектов](./media/image5-3.png)

<span data-ttu-id="ffbec-171">**Рис. 5-3.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-171">**Figure 5-3.**</span></span> <span data-ttu-id="ffbec-172">Простое монолитное приложение, состоящее из трех проектов.</span><span class="sxs-lookup"><span data-stu-id="ffbec-172">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="ffbec-173">Несмотря на то, что в целях упорядочения в этом приложении используется несколько проектов, оно по-прежнему развертывается как единый элемент, и его клиенты взаимодействуют с ним как с одним веб-приложением.</span><span class="sxs-lookup"><span data-stu-id="ffbec-173">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="ffbec-174">Это позволяет реализовать крайне простой процесс развертывания.</span><span class="sxs-lookup"><span data-stu-id="ffbec-174">This allows for very simple deployment process.</span></span> <span data-ttu-id="ffbec-175">На рис. 5-4 показано, как такое приложение можно разместить с использованием Azure.</span><span class="sxs-lookup"><span data-stu-id="ffbec-175">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![Простое развертывание веб-приложения Azure](./media/image5-4.png)

<span data-ttu-id="ffbec-177">**Рис. 5-4.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-177">**Figure 5-4.**</span></span> <span data-ttu-id="ffbec-178">Простое развертывание веб-приложения Azure</span><span class="sxs-lookup"><span data-stu-id="ffbec-178">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="ffbec-179">По мере развития приложения могут потребоваться более сложные и надежные решения для развертывания.</span><span class="sxs-lookup"><span data-stu-id="ffbec-179">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="ffbec-180">На рис. 5-5 показан пример более сложного плана развертывания, который поддерживает дополнительные возможности.</span><span class="sxs-lookup"><span data-stu-id="ffbec-180">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![Развертывание веб-приложения в службе приложений Azure](./media/image5-5.png)

<span data-ttu-id="ffbec-182">**Рис. 5-5.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-182">**Figure 5-5.**</span></span> <span data-ttu-id="ffbec-183">Развертывание веб-приложения в службе приложений Azure</span><span class="sxs-lookup"><span data-stu-id="ffbec-183">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="ffbec-184">Разбиение этого проекта на несколько проектов на основе обязанностей позволяет повысить удобство поддержки приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-184">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="ffbec-185">Такой элемент поддерживает вертикальное и горизонтальное масштабирование, что позволяет использовать преимущества облачного масштабирования по запросу.</span><span class="sxs-lookup"><span data-stu-id="ffbec-185">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="ffbec-186">Под вертикальным масштабированием понимается увеличение числа ЦП, объема памяти, места на диске и других ресурсов на серверах, где размещается приложение.</span><span class="sxs-lookup"><span data-stu-id="ffbec-186">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="ffbec-187">Горизонтальное масштабирование заключается в добавлении дополнительных экземпляров таких физических серверов, виртуальных машин или контейнеров.</span><span class="sxs-lookup"><span data-stu-id="ffbec-187">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="ffbec-188">Если приложение размещается на нескольких экземплярах, для распределения запросов между экземплярами приложения используется система балансировки нагрузки.</span><span class="sxs-lookup"><span data-stu-id="ffbec-188">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="ffbec-189">Самый простой подход к масштабированию веб-приложения в Azure заключается в ручной настройке масштабирования в плане службы приложений для приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-189">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="ffbec-190">На рис. 5-6 показан экран панели мониторинга Azure, предназначенный для настройки числа экземпляров, обслуживающих приложение.</span><span class="sxs-lookup"><span data-stu-id="ffbec-190">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![Масштабирование плана службы приложений в Azure](./media/image5-6.png)

<span data-ttu-id="ffbec-192">**Рис. 5-6**.</span><span class="sxs-lookup"><span data-stu-id="ffbec-192">**Figure 5-6.**</span></span> <span data-ttu-id="ffbec-193">Масштабирование плана службы приложений в Azure.</span><span class="sxs-lookup"><span data-stu-id="ffbec-193">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="ffbec-194">Чистая архитектура</span><span class="sxs-lookup"><span data-stu-id="ffbec-194">Clean architecture</span></span>

<span data-ttu-id="ffbec-195">Приложения, использующие принципы инверсии зависимостей и проблемно-ориентированного проектирования, имеют схожую архитектуру.</span><span class="sxs-lookup"><span data-stu-id="ffbec-195">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="ffbec-196">На протяжении многих лет она носила самые разные названия.</span><span class="sxs-lookup"><span data-stu-id="ffbec-196">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="ffbec-197">Сначала это была шестигранная архитектура, на смену которой пришла архитектура портов и адаптеров.</span><span class="sxs-lookup"><span data-stu-id="ffbec-197">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="ffbec-198">На современном этапе она называется [многослойной](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) или [чистой](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) архитектурой.</span><span class="sxs-lookup"><span data-stu-id="ffbec-198">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="ffbec-199">В этой электронной книге используется термин "чистая архитектура".</span><span class="sxs-lookup"><span data-stu-id="ffbec-199">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="ffbec-200">Термин "чистая архитектура" может применяться к приложениям, независимо от того, соблюдались ли при их создании принципы проблемно-ориентированного проектирования.</span><span class="sxs-lookup"><span data-stu-id="ffbec-200">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="ffbec-201">Если да, то такое сочетание носит название чистой проблемно-ориентированной архитектуры.</span><span class="sxs-lookup"><span data-stu-id="ffbec-201">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="ffbec-202">В рамках чистой архитектуры центральным элементом приложения являются его бизнес-логика и модель.</span><span class="sxs-lookup"><span data-stu-id="ffbec-202">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="ffbec-203">В этом случае бизнес-логика не зависит от доступа к данным или другим инфраструктурам, то есть стандартная зависимость инвертируется: инфраструктура и детали реализации зависят от ядра приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-203">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="ffbec-204">Это достигается путем определения абстракций или интерфейсов в ядре приложения, которые реализуются типами, определенными в слое инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="ffbec-204">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="ffbec-205">Такую архитектуру обычно рисуют в виде серии окружностей с общим центром, которая внешне напоминает срез луковицы.</span><span class="sxs-lookup"><span data-stu-id="ffbec-205">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="ffbec-206">На рис. 5-7 показан пример такого стиля представления архитектуры.</span><span class="sxs-lookup"><span data-stu-id="ffbec-206">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![Чистая архитектура (многослойное представление)](./media/image5-7.png)

<span data-ttu-id="ffbec-208">**Рис. 5-7.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-208">**Figure 5-7.**</span></span> <span data-ttu-id="ffbec-209">Чистая архитектура (многослойное представление)</span><span class="sxs-lookup"><span data-stu-id="ffbec-209">Clean Architecture; onion view</span></span>

<span data-ttu-id="ffbec-210">На этой схеме зависимости направлены из самой внутренней окружности.</span><span class="sxs-lookup"><span data-stu-id="ffbec-210">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="ffbec-211">Ядро приложения называется так потому, что находится в самом центре этой схемы.</span><span class="sxs-lookup"><span data-stu-id="ffbec-211">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="ffbec-212">Как видно на схеме, ядро приложения не имеет зависимостей от других слоев приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-212">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="ffbec-213">Сущности и интерфейсы приложения находятся в самом центре.</span><span class="sxs-lookup"><span data-stu-id="ffbec-213">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="ffbec-214">Сразу после них, но все еще в пределах ядра приложения, расположены доменные службы, которые обычно реализуют интерфейсы, определенные во внутренней окружности.</span><span class="sxs-lookup"><span data-stu-id="ffbec-214">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="ffbec-215">За пределами ядра приложения располагаются слои пользовательского интерфейса и инфраструктуры, которые зависят от ядра приложения, но не друг от друга (обязательно).</span><span class="sxs-lookup"><span data-stu-id="ffbec-215">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="ffbec-216">На рис. 5-8 показана более привычная горизонтальная схема слоев, которая лучше отражает зависимости между слоем пользовательского интерфейса и другими слоями.</span><span class="sxs-lookup"><span data-stu-id="ffbec-216">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![Чистая архитектура (горизонтальное представление слоев)](./media/image5-8.png)

<span data-ttu-id="ffbec-218">**Рис. 5-8.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-218">**Figure 5-8.**</span></span> <span data-ttu-id="ffbec-219">Чистая архитектура (горизонтальное представление слоев)</span><span class="sxs-lookup"><span data-stu-id="ffbec-219">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="ffbec-220">Обратите внимание, что сплошные стрелки соответствуют зависимостям времени компиляции, а пунктирные — зависимостям, которые существуют только во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-220">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="ffbec-221">В рамках чистой архитектуры слой пользовательского интерфейса работает с интерфейсами, которые определены в ядре приложения во время компиляции, и в идеальном случае не должен знать ничего о типах реализации, определенных в слое инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="ffbec-221">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="ffbec-222">Тем не менее во время выполнения эти типы реализации необходимы для выполнения приложения, поэтому они должны существовать и быть привязаны к интерфейсам ядра приложения посредством внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ffbec-222">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="ffbec-223">На рис. 5-9 показано более подробное представление архитектуры приложения ASP.NET Core, построенного с соблюдением этих рекомендаций.</span><span class="sxs-lookup"><span data-stu-id="ffbec-223">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Схема чистой архитектуры ASP.NET Core](./media/image5-9.png)

<span data-ttu-id="ffbec-225">**Рис. 5-9.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-225">**Figure 5-9.**</span></span> <span data-ttu-id="ffbec-226">Схема чистой архитектуры ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="ffbec-226">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="ffbec-227">Поскольку ядро приложения не зависит от инфраструктуры, для этого слоя легко писать автоматические модульные тесты.</span><span class="sxs-lookup"><span data-stu-id="ffbec-227">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="ffbec-228">На рис. 5-10 и 5-11 показано, как эти тесты вписываются в такую архитектуру.</span><span class="sxs-lookup"><span data-stu-id="ffbec-228">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![Модульное тестирование ядра](./media/image5-10.png)

<span data-ttu-id="ffbec-230">**Рис. 5-10.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-230">**Figure 5-10.**</span></span> <span data-ttu-id="ffbec-231">Изолированное модульное тестирование ядра приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-231">Unit testing Application Core in isolation.</span></span>

![Интеграционное тестирование](./media/image5-11.png)

<span data-ttu-id="ffbec-233">**Рис. 5-11.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-233">**Figure 5-11.**</span></span> <span data-ttu-id="ffbec-234">Интеграционное тестирование реализаций инфраструктуры с внешними зависимостями.</span><span class="sxs-lookup"><span data-stu-id="ffbec-234">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="ffbec-235">Поскольку слой пользовательского интерфейса не имеет прямых зависимостей от типов, определенных в проекте инфраструктуры, будет так же просто менять реализации в целях тестирования или в случае изменения требований к приложению.</span><span class="sxs-lookup"><span data-stu-id="ffbec-235">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="ffbec-236">ASP.NET Core предлагает встроенную поддержку внедрения зависимостей, в связи с чем такая архитектура представляет собой оптимальный подход к структурированию нетривиальных монолитных приложений.</span><span class="sxs-lookup"><span data-stu-id="ffbec-236">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="ffbec-237">Для монолитных приложений проекты ядра приложения, инфраструктуры и пользовательского интерфейса выполняются как единое приложение.</span><span class="sxs-lookup"><span data-stu-id="ffbec-237">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="ffbec-238">Во время выполнения архитектура приложения будет выглядеть так, как показано на рис. 5-12.</span><span class="sxs-lookup"><span data-stu-id="ffbec-238">The runtime application architecture might look something like Figure 5-12.</span></span>

![Архитектура ASP.NET Core 2](./media/image5-12.png)

<span data-ttu-id="ffbec-240">**Рис. 5-12.**</span><span class="sxs-lookup"><span data-stu-id="ffbec-240">**Figure 5-12.**</span></span> <span data-ttu-id="ffbec-241">Пример архитектуры приложения ASP.NET Core во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-241">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="ffbec-242">Упорядочение кода в рамках чистой архитектуры</span><span class="sxs-lookup"><span data-stu-id="ffbec-242">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="ffbec-243">В решении с чистой архитектурой для каждого проекта четко определены обязанности.</span><span class="sxs-lookup"><span data-stu-id="ffbec-243">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="ffbec-244">Фактически, каждому проекту будут принадлежать определенные типы, а в проектах будут представлены соответствующие этим типам папки.</span><span class="sxs-lookup"><span data-stu-id="ffbec-244">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="ffbec-245">Ядро приложения содержит бизнес-модель, которая включает в себя сущности, службы и интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="ffbec-245">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="ffbec-246">Такие интерфейсы включают абстракции для операций, которые будут выполняться с использованием архитектуры, включая операции доступа к данным или файловой системе, сетевые вызовы и т. д. В некоторых случаях службы или интерфейсы, определенные в этом слое, должны работать с типами, не являющимися типами сущностей, которые не имеют зависимостей от пользовательского интерфейса или инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="ffbec-246">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="ffbec-247">Они могут определяться как простые объекты передачи данных.</span><span class="sxs-lookup"><span data-stu-id="ffbec-247">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

### <a name="application-core-types"></a><span data-ttu-id="ffbec-248">Типы ядра приложения</span><span class="sxs-lookup"><span data-stu-id="ffbec-248">Application Core types</span></span>

- <span data-ttu-id="ffbec-249">Сущности (сохраняемые классы бизнес-модели)</span><span class="sxs-lookup"><span data-stu-id="ffbec-249">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="ffbec-250">интерфейсов,</span><span class="sxs-lookup"><span data-stu-id="ffbec-250">Interfaces</span></span>
- <span data-ttu-id="ffbec-251">Службы</span><span class="sxs-lookup"><span data-stu-id="ffbec-251">Services</span></span>
- <span data-ttu-id="ffbec-252">Объекты передачи данных</span><span class="sxs-lookup"><span data-stu-id="ffbec-252">DTOs</span></span>

<span data-ttu-id="ffbec-253">Как правило, проект инфраструктуры включает реализацию доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="ffbec-253">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="ffbec-254">В типовом веб-приложении ASP.NET Core эта реализация включает Entity Framework (EF) DbContext, любые определенные объекты `Migration` EF Core, а также классы реализации доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="ffbec-254">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="ffbec-255">Наиболее распространенный подход к абстрагированию кода реализации доступа к данным заключается в использовании [конструктивного шаблона репозитория](https://deviq.com/repository-pattern/).</span><span class="sxs-lookup"><span data-stu-id="ffbec-255">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="ffbec-256">Помимо реализации доступа к данным, проект инфраструктуры должен также включать реализации служб, которые должны взаимодействовать с инфраструктурными задачами.</span><span class="sxs-lookup"><span data-stu-id="ffbec-256">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="ffbec-257">Эти службы должны реализовывать интерфейсы, определенные в ядре приложения. Таким образом, инфраструктура должна содержать ссылку на проект ядра приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-257">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

### <a name="infrastructure-types"></a><span data-ttu-id="ffbec-258">Типы инфраструктуры</span><span class="sxs-lookup"><span data-stu-id="ffbec-258">Infrastructure types</span></span>

- <span data-ttu-id="ffbec-259">Типы EF Core (`DbContext`, `Migration`)</span><span class="sxs-lookup"><span data-stu-id="ffbec-259">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="ffbec-260">Типы реализации доступа к данным (репозитории)</span><span class="sxs-lookup"><span data-stu-id="ffbec-260">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="ffbec-261">Службы, связанные с инфраструктурой (например, `FileLogger` или `SmtpNotifier`)</span><span class="sxs-lookup"><span data-stu-id="ffbec-261">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

<span data-ttu-id="ffbec-262">Слой пользовательского интерфейса в приложении MVC ASP.NET Core выступает в качестве точки входа для приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-262">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="ffbec-263">Этот проект должен ссылаться на слой ядра приложения, а его типы должны взаимодействовать с инфраструктурой строго через интерфейсы, определенные в ядре приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-263">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="ffbec-264">В слое пользовательского интерфейса не должны разрешаться прямое создание экземпляров для типов слоя инфраструктуры, а также их статические вызовы.</span><span class="sxs-lookup"><span data-stu-id="ffbec-264">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

### <a name="ui-layer-types"></a><span data-ttu-id="ffbec-265">Типы слоев пользовательского интерфейса</span><span class="sxs-lookup"><span data-stu-id="ffbec-265">UI layer types</span></span>

- <span data-ttu-id="ffbec-266">Контроллеры</span><span class="sxs-lookup"><span data-stu-id="ffbec-266">Controllers</span></span>
- <span data-ttu-id="ffbec-267">Фильтры</span><span class="sxs-lookup"><span data-stu-id="ffbec-267">Filters</span></span>
- <span data-ttu-id="ffbec-268">Представления</span><span class="sxs-lookup"><span data-stu-id="ffbec-268">Views</span></span>
- <span data-ttu-id="ffbec-269">Модели представлений</span><span class="sxs-lookup"><span data-stu-id="ffbec-269">ViewModels</span></span>
- <span data-ttu-id="ffbec-270">Запуск</span><span class="sxs-lookup"><span data-stu-id="ffbec-270">Startup</span></span>

<span data-ttu-id="ffbec-271">Класс Startup отвечает за настройку приложений и запись типов реализации в интерфейсы, обеспечивая корректную работу внедрения зависимостей во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-271">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="ffbec-272">Чтобы привязать внедрение зависимостей в ConfigureServices в файле Startup.cs проекта пользовательского интерфейса, в этом проекте может потребоваться ссылка на проект инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="ffbec-272">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="ffbec-273">Эту зависимость можно исключить. Проще всего это сделать с помощью настраиваемого контейнера внедрения зависимостей.</span><span class="sxs-lookup"><span data-stu-id="ffbec-273">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="ffbec-274">В рамках этого примера применяется простейший подход, при котором разрешаются ссылки из проекта пользовательского интерфейса на проект инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="ffbec-274">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="ffbec-275">Монолитные приложения и контейнеры</span><span class="sxs-lookup"><span data-stu-id="ffbec-275">Monolithic applications and containers</span></span>

<span data-ttu-id="ffbec-276">Вы можете создать одно монолитное веб-приложение или службу и развернуть их как контейнер.</span><span class="sxs-lookup"><span data-stu-id="ffbec-276">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="ffbec-277">В рамках приложения монолитность может не соблюдаться, однако будет реализована организация на основе нескольких библиотек, компонентов или слоев.</span><span class="sxs-lookup"><span data-stu-id="ffbec-277">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="ffbec-278">Внешне оно будет представлять собой единый контейнер — единый процесс, единое веб-приложение или единую службу.</span><span class="sxs-lookup"><span data-stu-id="ffbec-278">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="ffbec-279">Для управления этой моделью вы развертываете один контейнер, представляющий собой приложение.</span><span class="sxs-lookup"><span data-stu-id="ffbec-279">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="ffbec-280">Для увеличения масштаба просто добавьте дополнительные копии с подсистемой балансировки нагрузки спереди.</span><span class="sxs-lookup"><span data-stu-id="ffbec-280">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="ffbec-281">Управлять одним развертыванием в одном контейнере или виртуальной машине гораздо проще.</span><span class="sxs-lookup"><span data-stu-id="ffbec-281">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![Рис. 5-13.](./media/image5-13.png)

<span data-ttu-id="ffbec-283">Вы можете включить в один контейнер несколько компонентов, библиотек или внутренних слоев, как показано на рис. 5-13.</span><span class="sxs-lookup"><span data-stu-id="ffbec-283">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="ffbec-284">Такой монолитный шаблон может конфликтовать с принципом контейнера: "_контейнер выполняет одно дело и в одном процессе_".</span><span class="sxs-lookup"><span data-stu-id="ffbec-284">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="ffbec-285">Недостаток этого подхода становится очевидным, когда приложение разрастается и его необходимо масштабировать.</span><span class="sxs-lookup"><span data-stu-id="ffbec-285">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="ffbec-286">Если масштабируется приложение целиком, все получится.</span><span class="sxs-lookup"><span data-stu-id="ffbec-286">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="ffbec-287">Но в большинстве случаев необходимо масштабировать всего несколько частей приложения, пока другие компоненты работают нормально.</span><span class="sxs-lookup"><span data-stu-id="ffbec-287">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="ffbec-288">В примере приложения для электронной торговли, вероятнее всего, потребуется масштабирование компонента со сведениями о товарах.</span><span class="sxs-lookup"><span data-stu-id="ffbec-288">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="ffbec-289">Клиенты чаще просматривают товары, чем приобретают их.</span><span class="sxs-lookup"><span data-stu-id="ffbec-289">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="ffbec-290">Клиенты чаще складывают товары в корзину, чем оплачивают их.</span><span class="sxs-lookup"><span data-stu-id="ffbec-290">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="ffbec-291">Не так много клиентов пишут комментарии или просматривают историю покупок.</span><span class="sxs-lookup"><span data-stu-id="ffbec-291">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="ffbec-292">И у вас скорее всего может быть лишь несколько сотрудников в одном регионе, которые управляют содержимым и маркетинговыми кампаниями.</span><span class="sxs-lookup"><span data-stu-id="ffbec-292">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="ffbec-293">При масштабировании монолитных решений весь код развертывается многократно.</span><span class="sxs-lookup"><span data-stu-id="ffbec-293">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="ffbec-294">Помимо того, что необходимо масштабировать все компоненты, изменения в одном компоненте требуют полного повторного тестирования всего приложения и полного повторного развертывания всех его экземпляров.</span><span class="sxs-lookup"><span data-stu-id="ffbec-294">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="ffbec-295">Монолитный подход нашел широкое распространение и используется многими организациями при разработке архитектуры.</span><span class="sxs-lookup"><span data-stu-id="ffbec-295">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="ffbec-296">Во многих случаях это позволяет добиться желаемых результатов, однако иногда организация сталкивается с достигнутыми ограничениями.</span><span class="sxs-lookup"><span data-stu-id="ffbec-296">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="ffbec-297">Во многих организациях приложения строились по такой модели, поскольку несколько лет назад с помощью существующих инструментов и инфраструктуры слишком сложно было создавать архитектуры, ориентированные на службы (SOA), и проблем не возникало, пока приложение не начинало разрастаться.</span><span class="sxs-lookup"><span data-stu-id="ffbec-297">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="ffbec-298">Если ваша организация столкнулась с ограничениями монолитного подхода, следующим логичным шагом может стать разбиение приложения для более эффективного использования контейнеров и микрослужб.</span><span class="sxs-lookup"><span data-stu-id="ffbec-298">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![Рис. 5-14](./media/image5-14.png)

<span data-ttu-id="ffbec-300">Монолитные приложения в Microsoft Azure можно развертывать с использованием выделенных виртуальных машин для каждого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="ffbec-300">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="ffbec-301">С помощью [масштабируемых наборов виртуальных машин Azure](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) можно легко масштабировать виртуальные машины.</span><span class="sxs-lookup"><span data-stu-id="ffbec-301">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="ffbec-302">[Службы приложений Azure](https://azure.microsoft.com/services/app-service/) также могут выполнять монолитные приложения и легко масштабировать экземпляры, и вам не придется управлять виртуальными машинами.</span><span class="sxs-lookup"><span data-stu-id="ffbec-302">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="ffbec-303">Службы приложений Azure также могут выполнять отдельные экземпляры контейнеров Docker, упрощая развертывание.</span><span class="sxs-lookup"><span data-stu-id="ffbec-303">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="ffbec-304">С помощью Docker вы можете развернуть одну виртуальную машину на узле Docker и выполнять на ней несколько экземпляров.</span><span class="sxs-lookup"><span data-stu-id="ffbec-304">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="ffbec-305">Для управления масштабированием можно использовать систему балансировки Azure, как показано на рис. 5-14.</span><span class="sxs-lookup"><span data-stu-id="ffbec-305">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="ffbec-306">Развертыванием на различных узлах можно управлять с помощью традиционных методов развертывания.</span><span class="sxs-lookup"><span data-stu-id="ffbec-306">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="ffbec-307">Узлами Docker можно управлять с помощью вводимых вручную команд вида **docker run** или автоматизированно, например с помощью конвейеров непрерывной поставки (CD).</span><span class="sxs-lookup"><span data-stu-id="ffbec-307">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="ffbec-308">Развертывание монолитного приложения в контейнере</span><span class="sxs-lookup"><span data-stu-id="ffbec-308">Monolithic application deployed as a container</span></span>

<span data-ttu-id="ffbec-309">Использование контейнеров для управления развертываниями монолитных приложений имеет свои преимущества.</span><span class="sxs-lookup"><span data-stu-id="ffbec-309">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="ffbec-310">Масштабировать экземпляры контейнера гораздо быстрее и проще, чем развертывать дополнительные виртуальные машины.</span><span class="sxs-lookup"><span data-stu-id="ffbec-310">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="ffbec-311">Даже при использовании масштабируемых наборов виртуальных машин применяется основанный на экземплярах подход.</span><span class="sxs-lookup"><span data-stu-id="ffbec-311">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="ffbec-312">При развертывании в виде экземпляров приложения управление конфигурацией приложения осуществляется в составе виртуальной машины.</span><span class="sxs-lookup"><span data-stu-id="ffbec-312">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="ffbec-313">Развертывание обновлений в виде образов Docker выполняется гораздо быстрее и эффективнее с точки зрения использования сети.</span><span class="sxs-lookup"><span data-stu-id="ffbec-313">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="ffbec-314">Образы Docker обычно запускаются за считанные секунды, что позволяет ускорить выпуск.</span><span class="sxs-lookup"><span data-stu-id="ffbec-314">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="ffbec-315">Остановить образ Docker можно с помощью команды `docker stop`, и обычно это происходит моментально.</span><span class="sxs-lookup"><span data-stu-id="ffbec-315">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="ffbec-316">Поскольку контейнеры по своей природе являются неизменяемыми, вам не придется беспокоиться о возможности повреждения виртуальной машины, когда скрипты обновления не учитывают некоторые оставшиеся на диске конфигурации или файлы.</span><span class="sxs-lookup"><span data-stu-id="ffbec-316">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="ffbec-317">Контейнеры Docker можно использовать для монолитного развертывания простых веб-приложений.</span><span class="sxs-lookup"><span data-stu-id="ffbec-317">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="ffbec-318">Это позволяет оптимизировать процессы непрерывной интеграции и непрерывного развертывания, а также добиться успешного развертывания в рабочей среде.</span><span class="sxs-lookup"><span data-stu-id="ffbec-318">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="ffbec-319">Вам больше не придется гадать, почему решение, работающее на вашем компьютере, не работает в рабочей среде.</span><span class="sxs-lookup"><span data-stu-id="ffbec-319">No more “It works in my machine, why does it not work in production?”</span></span>

<span data-ttu-id="ffbec-320">Архитектура на основе микрослужб имеет много преимуществ, но обратной стороной является повышение сложности.</span><span class="sxs-lookup"><span data-stu-id="ffbec-320">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="ffbec-321">В некоторых случаях затраты перевешивают преимущества, и лучше прибегнуть к монолитному развертыванию приложения в одном контейнере или буквально нескольких.</span><span class="sxs-lookup"><span data-stu-id="ffbec-321">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="ffbec-322">Монолитное приложение может быть непросто разделить на отдельные микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="ffbec-322">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="ffbec-323">Микрослужбы должны работать независимо друг от друга для повышения отказоустойчивости приложения.</span><span class="sxs-lookup"><span data-stu-id="ffbec-323">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="ffbec-324">Если приложение невозможно разложить на независимые функциональные составляющие, то его разделение лишь увеличит сложность.</span><span class="sxs-lookup"><span data-stu-id="ffbec-324">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="ffbec-325">Приложению пока может не требоваться независимое масштабирование компонентов.</span><span class="sxs-lookup"><span data-stu-id="ffbec-325">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="ffbec-326">Многие приложения, когда им требуется использовать более одного экземпляра, относительно легко клонируют весь экземпляр.</span><span class="sxs-lookup"><span data-stu-id="ffbec-326">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="ffbec-327">Дополнительный труд по разделению приложений на отдельные службы предоставляет минимум преимуществ, тогда как масштабирование полноценных экземпляров приложения — это простое и экономичное решение.</span><span class="sxs-lookup"><span data-stu-id="ffbec-327">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="ffbec-328">На ранних этапах развертывания приложения может отсутствовать ясное представление о том, где пролегают границы между функциональными областями.</span><span class="sxs-lookup"><span data-stu-id="ffbec-328">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="ffbec-329">В процессе разработки продукта, обладающего минимальным необходимым набором возможностей, его естественное разделение на части может быть не очевидным.</span><span class="sxs-lookup"><span data-stu-id="ffbec-329">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="ffbec-330">Некоторые из этих условий могут быть временными.</span><span class="sxs-lookup"><span data-stu-id="ffbec-330">Some of these conditions might be temporary.</span></span> <span data-ttu-id="ffbec-331">Вы можете сначала создать монолитное приложение, а в дальнейшем отделить некоторые компоненты для разработки и развертывания в качестве микрослужб.</span><span class="sxs-lookup"><span data-stu-id="ffbec-331">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="ffbec-332">Другие условия могут быть неотъемлемыми особенностями приложения. Это означает, что приложение в принципе невозможно разделить на несколько микрослужб.</span><span class="sxs-lookup"><span data-stu-id="ffbec-332">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="ffbec-333">Разделение приложения на множество отдельных процессов также приводит к накладным расходам.</span><span class="sxs-lookup"><span data-stu-id="ffbec-333">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="ffbec-334">При разделении компонента на несколько процессов повышается сложность.</span><span class="sxs-lookup"><span data-stu-id="ffbec-334">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="ffbec-335">Усложняются протоколы обмена данными.</span><span class="sxs-lookup"><span data-stu-id="ffbec-335">The communication protocols become more complex.</span></span> <span data-ttu-id="ffbec-336">Вместо вызовов методов необходимо использовать асинхронное взаимодействие между службами.</span><span class="sxs-lookup"><span data-stu-id="ffbec-336">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="ffbec-337">При переходе на архитектуру микрослужб необходимо добавить множество стандартных блоков, реализованных в версии приложения eShopOnContainers на основе микрослужб: обработку шины событий, отказоустойчивость и повторную отправку сообщений, итоговую согласованность и многое другое.</span><span class="sxs-lookup"><span data-stu-id="ffbec-337">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="ffbec-338">Гораздо более простой [пример приложения eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb) поддерживает использование одного монолитного контейнера.</span><span class="sxs-lookup"><span data-stu-id="ffbec-338">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="ffbec-339">Приложение включает одно веб-приложение с традиционными представлениями MVC, веб-API и Razor Pages.</span><span class="sxs-lookup"><span data-stu-id="ffbec-339">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="ffbec-340">Это приложение может запускаться из корня решения с помощью команд `docker-compose build` и `docker-compose up`.</span><span class="sxs-lookup"><span data-stu-id="ffbec-340">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="ffbec-341">Эта команда настраивает контейнер для веб-экземпляра с помощью `Dockerfile` из корневого каталога веб-проекта и выполняет контейнер в указанном порте.</span><span class="sxs-lookup"><span data-stu-id="ffbec-341">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="ffbec-342">Вы можете скачать исходный код этого приложения из GitHub и запустить его в локальной системе.</span><span class="sxs-lookup"><span data-stu-id="ffbec-342">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="ffbec-343">Даже такое монолитное приложение выигрывает от развертывания в контейнерной среде.</span><span class="sxs-lookup"><span data-stu-id="ffbec-343">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="ffbec-344">Во-первых, контейнерное развертывание означает, что каждый экземпляр приложения выполняется в одной и той же среде.</span><span class="sxs-lookup"><span data-stu-id="ffbec-344">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="ffbec-345">Это относится и к среде разработки, в которой проводятся начальные этапы тестирования и разработки.</span><span class="sxs-lookup"><span data-stu-id="ffbec-345">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="ffbec-346">Команда разработчиков может запускать приложение в контейнерной среде, которая аналогична рабочей.</span><span class="sxs-lookup"><span data-stu-id="ffbec-346">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="ffbec-347">Кроме того, контейнерные приложения обеспечивают более экономичное горизонтальное масштабирование.</span><span class="sxs-lookup"><span data-stu-id="ffbec-347">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="ffbec-348">Контейнерная среда позволяет эффективнее организовывать совместное использование ресурсов, чем традиционные среды виртуальных машин.</span><span class="sxs-lookup"><span data-stu-id="ffbec-348">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="ffbec-349">Наконец, помещая приложение в контейнеры, вы разделяете бизнес-логику и сервер хранилища.</span><span class="sxs-lookup"><span data-stu-id="ffbec-349">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="ffbec-350">По мере масштабирования приложения все контейнеры будут использовать один физический носитель данных.</span><span class="sxs-lookup"><span data-stu-id="ffbec-350">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="ffbec-351">В качестве хранилища, как правило, используется сервер высокой доступности с базой данных SQL Server.</span><span class="sxs-lookup"><span data-stu-id="ffbec-351">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="ffbec-352">Поддержка Docker</span><span class="sxs-lookup"><span data-stu-id="ffbec-352">Docker support</span></span>

<span data-ttu-id="ffbec-353">Проект `eShopOnWeb` работает в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="ffbec-353">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="ffbec-354">Поэтому его можно запускать как в контейнерах Linux, так и в контейнерах Windows.</span><span class="sxs-lookup"><span data-stu-id="ffbec-354">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="ffbec-355">Обратите внимание на то, что для развертывания Docker необходимо использовать тот же тип узла для SQL Server.</span><span class="sxs-lookup"><span data-stu-id="ffbec-355">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="ffbec-356">Контейнеры на основе Linux требуют меньше ресурсов и более предпочтительны.</span><span class="sxs-lookup"><span data-stu-id="ffbec-356">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="ffbec-357">Вы можете использовать Visual Studio 2017, чтобы добавить поддержку Docker в существующее приложение, щелкнув проект в **обозревателе решений** правой кнопкой мыши и выбрав **Добавить** > **Поддержка Docker**.</span><span class="sxs-lookup"><span data-stu-id="ffbec-357">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="ffbec-358">Таким образом вы добавите необходимые файлы и внесете изменения в проект для их использования.</span><span class="sxs-lookup"><span data-stu-id="ffbec-358">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="ffbec-359">В текущем примере `eShopOnWeb` эти файлы уже есть.</span><span class="sxs-lookup"><span data-stu-id="ffbec-359">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="ffbec-360">Файл `docker-compose.yml` на уровне решения содержит сведения о том, какие образы необходимо создать и какие контейнеры запустить.</span><span class="sxs-lookup"><span data-stu-id="ffbec-360">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="ffbec-361">Этот файл позволяет использовать команду `docker-compose` для запуска нескольких приложений одновременно.</span><span class="sxs-lookup"><span data-stu-id="ffbec-361">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="ffbec-362">В этом случае он запускает только веб-проект.</span><span class="sxs-lookup"><span data-stu-id="ffbec-362">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="ffbec-363">Вы также можете с его помощью настроить зависимости, например отдельный контейнер базы данных.</span><span class="sxs-lookup"><span data-stu-id="ffbec-363">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="ffbec-364">Файл `docker-compose.yml` ссылается на `Dockerfile` в проекте `Web`.</span><span class="sxs-lookup"><span data-stu-id="ffbec-364">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="ffbec-365">С помощью `Dockerfile` можно указать, какой базовый контейнер будет использоваться и как приложение будет настроено на нем.</span><span class="sxs-lookup"><span data-stu-id="ffbec-365">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="ffbec-366">`Dockerfile` `Web`:</span><span class="sxs-lookup"><span data-stu-id="ffbec-366">The `Web`' `Dockerfile`:</span></span>

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:2.2 AS build
WORKDIR /app

COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/core/aspnet:2.2 AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

# Optional: Set this here if not setting it from docker-compose.yml
# ENV ASPNETCORE_ENVIRONMENT Development

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="ffbec-367">Устранение неполадок с Docker</span><span class="sxs-lookup"><span data-stu-id="ffbec-367">Troubleshooting Docker problems</span></span>

<span data-ttu-id="ffbec-368">После запуска контейнерное приложение продолжает работать, пока его не остановят.</span><span class="sxs-lookup"><span data-stu-id="ffbec-368">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="ffbec-369">Используйте команду `docker ps`, чтобы посмотреть, какие контейнеры выполняются.</span><span class="sxs-lookup"><span data-stu-id="ffbec-369">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="ffbec-370">Вы можете остановить выполняющийся контейнер с помощью команды `docker stop` и идентификатора контейнера.</span><span class="sxs-lookup"><span data-stu-id="ffbec-370">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="ffbec-371">Обратите внимание, что запущенные контейнеры Docker могут быть привязаны к портам, которые в противном случае вы могли бы использовать в среде разработки.</span><span class="sxs-lookup"><span data-stu-id="ffbec-371">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="ffbec-372">При попытке запустить или выполнить отладку приложения через порт, связанный с контейнером Docker, возникнет ошибка с сообщением о том, что сервер не может выполнить привязку к этому порту.</span><span class="sxs-lookup"><span data-stu-id="ffbec-372">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="ffbec-373">Проблемы будет решена, если вы остановите контейнер.</span><span class="sxs-lookup"><span data-stu-id="ffbec-373">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="ffbec-374">Если вы хотите добавить поддержку Docker в приложение с помощью Visual Studio, убедитесь, что Docker Desktop при этом запущен.</span><span class="sxs-lookup"><span data-stu-id="ffbec-374">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="ffbec-375">Если при запуске мастера средство Docker Desktop не выполняется, мастер будет работать неправильно.</span><span class="sxs-lookup"><span data-stu-id="ffbec-375">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="ffbec-376">Кроме того, мастер проверяет выбранные контейнеры, чтобы правильно реализовать поддержку Docker.</span><span class="sxs-lookup"><span data-stu-id="ffbec-376">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="ffbec-377">Чтобы добавить поддержку контейнеров Windows, при запуске мастера должно выполняться средство Docker Desktop с настроенными контейнерами Windows.</span><span class="sxs-lookup"><span data-stu-id="ffbec-377">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="ffbec-378">Чтобы добавить поддержку контейнеров Linux, при запуске мастера должно выполняться средство Docker с настроенными контейнерами Linux.</span><span class="sxs-lookup"><span data-stu-id="ffbec-378">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="ffbec-379">Ссылки — общие архитектуры веб-приложений</span><span class="sxs-lookup"><span data-stu-id="ffbec-379">References – Common web architectures</span></span>

- <span data-ttu-id="ffbec-380">**Чистая архитектура**</span><span class="sxs-lookup"><span data-stu-id="ffbec-380">**The Clean Architecture**</span></span>  
  <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
- <span data-ttu-id="ffbec-381">**Многослойная архитектура**</span><span class="sxs-lookup"><span data-stu-id="ffbec-381">**The Onion Architecture**</span></span>  
  <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
- <span data-ttu-id="ffbec-382">**Шаблон репозитория**</span><span class="sxs-lookup"><span data-stu-id="ffbec-382">**The Repository Pattern**</span></span>  
  <https://deviq.com/repository-pattern/>
- <span data-ttu-id="ffbec-383">**Пример решения с чистой архитектурой**</span><span class="sxs-lookup"><span data-stu-id="ffbec-383">**Clean Architecture Solution Sample**</span></span>  
  <https://github.com/ardalis/cleanarchitecture>
- <span data-ttu-id="ffbec-384">**Электронная книга по разработке архитектуры микрослужб**</span><span class="sxs-lookup"><span data-stu-id="ffbec-384">**Architecting Microservices e-book**</span></span>  
  <https://aka.ms/MicroservicesEbook>
- <span data-ttu-id="ffbec-385">**DDD (предметно-ориентированное проектирование)**</span><span class="sxs-lookup"><span data-stu-id="ffbec-385">**DDD (Domain-Driven Design)**</span></span>  
  <https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/>

>[!div class="step-by-step"]
><span data-ttu-id="ffbec-386">[Назад](architectural-principles.md)
>[Вперед](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="ffbec-386">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
