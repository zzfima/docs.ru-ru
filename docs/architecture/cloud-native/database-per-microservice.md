---
title: База данных на микрослужбу
description: Сравните объем хранилища данных в монолитных и облачных приложениях.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: e472309d3dc815070fc2d2c220bf4fe00b8c29ae
ms.sourcegitcommit: 13e79efdbd589cad6b1de634f5d6b1262b12ab01
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/28/2020
ms.locfileid: "76795065"
---
# <a name="database-per-microservice"></a><span data-ttu-id="6d93b-103">База данных на микрослужбу</span><span class="sxs-lookup"><span data-stu-id="6d93b-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="6d93b-104">Как мы видели в этой книге, подход с использованием собственного облака изменяет способ проектирования, развертывания и управления приложениями.</span><span class="sxs-lookup"><span data-stu-id="6d93b-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="6d93b-105">Он также изменяет способ управления и хранения данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="6d93b-106">На рис. 5-1 различают различия.</span><span class="sxs-lookup"><span data-stu-id="6d93b-106">Figure 5-1 contrasts the differences.</span></span>

![Хранение данных в собственных приложениях в облаке](./media/distributed-data.png)

<span data-ttu-id="6d93b-108">**Рис. 5-1**.</span><span class="sxs-lookup"><span data-stu-id="6d93b-108">**Figure 5-1**.</span></span> <span data-ttu-id="6d93b-109">Управление данными в собственных облачных приложениях</span><span class="sxs-lookup"><span data-stu-id="6d93b-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="6d93b-110">Опытные разработчики легко распознают архитектуру на левой стороне рис. 5-1.</span><span class="sxs-lookup"><span data-stu-id="6d93b-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="6d93b-111">В этом *монолитном приложении*компоненты бизнес-службы объединяются в общий уровень служб, совместно используя данные из одной реляционной базы данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="6d93b-112">Во многих случаях единая база данных обеспечивает простоту управления данными.</span><span class="sxs-lookup"><span data-stu-id="6d93b-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="6d93b-113">Запрос данных по нескольким таблицам прост.</span><span class="sxs-lookup"><span data-stu-id="6d93b-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="6d93b-114">Изменения в данных обновляются вместе или во всех операциях отката.</span><span class="sxs-lookup"><span data-stu-id="6d93b-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="6d93b-115">[Транзакции ACID](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) гарантируют строгую и немедленную согласованность.</span><span class="sxs-lookup"><span data-stu-id="6d93b-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="6d93b-116">Разработка для собственного облака, мы принимаем другой подход.</span><span class="sxs-lookup"><span data-stu-id="6d93b-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="6d93b-117">На правой стороне рис. 5-1 Обратите внимание на то, как бизнес-функции разделяются на небольшие независимые микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="6d93b-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="6d93b-118">Каждая микрослужба включает в себя определенную бизнес-возможность и собственные данные.</span><span class="sxs-lookup"><span data-stu-id="6d93b-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="6d93b-119">Монолитная база данных разбивается на распределенную модель данных с несколькими меньшими базами данных, каждая из которых соответствует микрослужбе.</span><span class="sxs-lookup"><span data-stu-id="6d93b-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="6d93b-120">После того, как этот тест очищен, мы создаем проект, который предоставляет *базу данных для каждой микрослужбы*.</span><span class="sxs-lookup"><span data-stu-id="6d93b-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="6d93b-121">Почему?</span><span class="sxs-lookup"><span data-stu-id="6d93b-121">Why?</span></span>

<span data-ttu-id="6d93b-122">Эта база данных на микрослужбах предоставляет множество преимуществ, особенно для систем, которые должны быстро развиваться и поддерживать крупномасштабное масштабирование.</span><span class="sxs-lookup"><span data-stu-id="6d93b-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="6d93b-123">С этой моделью...</span><span class="sxs-lookup"><span data-stu-id="6d93b-123">With this model...</span></span>

- <span data-ttu-id="6d93b-124">Данные домена инкапсулируются в службе</span><span class="sxs-lookup"><span data-stu-id="6d93b-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="6d93b-125">Схема данных может развиваться без непосредственного воздействия на другие службы</span><span class="sxs-lookup"><span data-stu-id="6d93b-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="6d93b-126">Каждое хранилище данных может масштабироваться независимо друг от друга</span><span class="sxs-lookup"><span data-stu-id="6d93b-126">Each data store can independently scale</span></span>
- <span data-ttu-id="6d93b-127">Сбой хранилища данных в одной службе не влияет на другие службы напрямую.</span><span class="sxs-lookup"><span data-stu-id="6d93b-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="6d93b-128">Разделение данных также позволяет каждой микрослужбе реализовать тип хранилища данных, оптимально оптимизированный для его рабочей нагрузки, потребностей в хранении и шаблонов чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="6d93b-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="6d93b-129">Варианты включают в себя реляционные, документы, значения ключа и даже хранилища данных на основе графов.</span><span class="sxs-lookup"><span data-stu-id="6d93b-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="6d93b-130">На рисунке 5-2 представлен принцип polyglot persistence в собственной облачной системе.</span><span class="sxs-lookup"><span data-stu-id="6d93b-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Сохраняемость данных Polyglot](./media/polyglot-data-persistence.png)

<span data-ttu-id="6d93b-132">**Рис. 5-2**.</span><span class="sxs-lookup"><span data-stu-id="6d93b-132">**Figure 5-2**.</span></span> <span data-ttu-id="6d93b-133">Сохраняемость данных Polyglot</span><span class="sxs-lookup"><span data-stu-id="6d93b-133">Polyglot data persistence</span></span>

<span data-ttu-id="6d93b-134">Обратите внимание, что на предыдущем рисунке каждая микрослужба поддерживает различные типы хранилищ данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="6d93b-135">Микрослужба каталога продукции использует реляционную базу данных для обеспечения функциональной реляционной структуры базовых данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="6d93b-136">Микрослужба корзины для покупок использует распределенный кэш, который поддерживает простое хранилище данных "ключ — значение".</span><span class="sxs-lookup"><span data-stu-id="6d93b-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="6d93b-137">Микрослужба заказа использует базу данных документов NoSql для операций записи, а также строго денормализованное хранилище ключей и значений для поддержки больших объемов операций чтения.</span><span class="sxs-lookup"><span data-stu-id="6d93b-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="6d93b-138">В то время как реляционные базы данных остаются актуальными для микрослужб со сложными данными, NoSQL базы данных значительно популярность.</span><span class="sxs-lookup"><span data-stu-id="6d93b-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="6d93b-139">Они обеспечивают широкие возможности масштабирования и обеспечения высокого уровня доступности.</span><span class="sxs-lookup"><span data-stu-id="6d93b-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="6d93b-140">Их природа без схем позволяет разработчикам переходить от архитектуры типизированных классов данных и моделей ORM, которые делают изменения затратными и ресурсоемкими.</span><span class="sxs-lookup"><span data-stu-id="6d93b-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="6d93b-141">Далее в этой главе мы рассмотрим базы данных NoSQL.</span><span class="sxs-lookup"><span data-stu-id="6d93b-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="6d93b-142">Инкапсуляция данных в отдельные микрослужбы может повысить гибкость, производительность и масштабируемость, а также предоставляет множество проблем.</span><span class="sxs-lookup"><span data-stu-id="6d93b-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="6d93b-143">В следующем разделе рассматриваются эти проблемы, а также шаблоны и методики, которые помогут преодолеть их.</span><span class="sxs-lookup"><span data-stu-id="6d93b-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="6d93b-144">Запросы между службами</span><span class="sxs-lookup"><span data-stu-id="6d93b-144">Cross-service queries</span></span>

<span data-ttu-id="6d93b-145">Хотя микрослужбы независимы и сосредоточены на конкретных функциональных возможностях, таких как Инвентаризация, Доставка или упорядочение, для них часто требуется интеграция с другими микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="6d93b-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="6d93b-146">Часто интеграция состоит в том, что одна микрослужба *запрашивает* другие данные.</span><span class="sxs-lookup"><span data-stu-id="6d93b-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="6d93b-147">На рис. 5-3 показан сценарий.</span><span class="sxs-lookup"><span data-stu-id="6d93b-147">Figure 5-3 shows the scenario.</span></span>

![Запросы между микрослужбами](./media/cross-service-query.png)

<span data-ttu-id="6d93b-149">**Рис. 5-3**.</span><span class="sxs-lookup"><span data-stu-id="6d93b-149">**Figure 5-3**.</span></span> <span data-ttu-id="6d93b-150">Запросы между микрослужбами</span><span class="sxs-lookup"><span data-stu-id="6d93b-150">Querying across microservices</span></span>

<span data-ttu-id="6d93b-151">На предыдущем рисунке показана микрослужба корзины покупок, которая добавляет элемент в корзину для покупок пользователя.</span><span class="sxs-lookup"><span data-stu-id="6d93b-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="6d93b-152">Хотя хранилище данных для этой микрослужбы содержит данные элементов корзины и строк, оно не поддерживает данные о продуктах и ценах.</span><span class="sxs-lookup"><span data-stu-id="6d93b-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="6d93b-153">Вместо этого эти элементы данных принадлежат микрослужбам каталога и ценообразования.</span><span class="sxs-lookup"><span data-stu-id="6d93b-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="6d93b-154">Это представляет проблему.</span><span class="sxs-lookup"><span data-stu-id="6d93b-154">This presents a problem.</span></span> <span data-ttu-id="6d93b-155">Как микрослужба корзины покупок добавляет продукт к корзине покупок пользователя, если в базе данных нет данных о продукте или ценах?</span><span class="sxs-lookup"><span data-stu-id="6d93b-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="6d93b-156">Один из вариантов, описанных в главе 4, — [прямой вызов HTTP](service-to-service-communication.md#queries) из корзины покупок в микрослужбы каталога и ценообразования.</span><span class="sxs-lookup"><span data-stu-id="6d93b-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="6d93b-157">Однако в главе 4 мы говорили о синхронных HTTP- *вызовах* , объединяющих микрослужбы, уменьшая их автономность и снижая преимущества архитектуры.</span><span class="sxs-lookup"><span data-stu-id="6d93b-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="6d93b-158">Также можно реализовать шаблон "запрос-ответ" с отдельными входящими и исходящими очередями для каждой службы.</span><span class="sxs-lookup"><span data-stu-id="6d93b-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="6d93b-159">Однако этот шаблон сложен и требует коммуникации для корреляции сообщений запросов и ответов.</span><span class="sxs-lookup"><span data-stu-id="6d93b-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="6d93b-160">Во время разделения вызовов микрослужб внутреннего сервера вызывающая служба по-прежнему может синхронно ожидать завершения вызова.</span><span class="sxs-lookup"><span data-stu-id="6d93b-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="6d93b-161">Перегрузка сети, временные сбои или перегруженная микрослужба, что может привести к длительному выполнению и даже неудачным операциям.</span><span class="sxs-lookup"><span data-stu-id="6d93b-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="6d93b-162">Вместо этого широко принятым шаблоном для удаления зависимостей между службами является [Материализованный шаблон представления](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), показанный на рис. 5-4.</span><span class="sxs-lookup"><span data-stu-id="6d93b-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Шаблон материализованных представлений](./media/materialized-view-pattern.png)

<span data-ttu-id="6d93b-164">**Рис. 5-4**.</span><span class="sxs-lookup"><span data-stu-id="6d93b-164">**Figure 5-4**.</span></span> <span data-ttu-id="6d93b-165">Шаблон материализованных представлений</span><span class="sxs-lookup"><span data-stu-id="6d93b-165">Materialized View Pattern</span></span>

<span data-ttu-id="6d93b-166">С помощью этого шаблона вы поместите локальную таблицу данных (которая называется *моделью чтения*) в службу корзины покупок.</span><span class="sxs-lookup"><span data-stu-id="6d93b-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="6d93b-167">Эта таблица содержит денормализованную копию данных, необходимых для микрослужб продукта и ценообразования.</span><span class="sxs-lookup"><span data-stu-id="6d93b-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="6d93b-168">Копирование данных непосредственно в микрослужбу корзины покупок устраняет необходимость в дорогостоящих вызовах между службами.</span><span class="sxs-lookup"><span data-stu-id="6d93b-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="6d93b-169">С данными, локальными для службы, вы повышаете время отклика и надежность службы.</span><span class="sxs-lookup"><span data-stu-id="6d93b-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="6d93b-170">Кроме того, наличие собственной копии данных делает службу корзины покупок более устойчивой.</span><span class="sxs-lookup"><span data-stu-id="6d93b-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="6d93b-171">Если служба каталога должна стать недоступной, она не повлияет непосредственно на службу корзины покупок.</span><span class="sxs-lookup"><span data-stu-id="6d93b-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="6d93b-172">Корзина для покупок может продолжать работать с данными из собственного магазина.</span><span class="sxs-lookup"><span data-stu-id="6d93b-172">The shopping basket can continue operating with the data from its own store.</span></span> 

<span data-ttu-id="6d93b-173">Перехватывать этот подход заключается в том, что теперь в системе есть дублирующиеся данные.</span><span class="sxs-lookup"><span data-stu-id="6d93b-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="6d93b-174">Однако *стратегические* дублирование данных в собственных системах в облаке — это установленный подход, который не считается антишаблоном или плохим подходом.</span><span class="sxs-lookup"><span data-stu-id="6d93b-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="6d93b-175">Помните, что *одна и только одна служба* могут владеть набором данных и обладать полномочиями на нее.</span><span class="sxs-lookup"><span data-stu-id="6d93b-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="6d93b-176">При обновлении системы записи необходимо синхронизировать модели чтения.</span><span class="sxs-lookup"><span data-stu-id="6d93b-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="6d93b-177">Обычно синхронизация реализуется посредством асинхронного обмена сообщениями с [шаблоном публикации или подписки](service-to-service-communication.md#events), как показано на рисунке 5,4.</span><span class="sxs-lookup"><span data-stu-id="6d93b-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="6d93b-178">Распределенные транзакции</span><span class="sxs-lookup"><span data-stu-id="6d93b-178">Distributed transactions</span></span>

<span data-ttu-id="6d93b-179">При запросе данных между микрослужбами сложно реализовать транзакцию в нескольких микрослужбах еще более сложно.</span><span class="sxs-lookup"><span data-stu-id="6d93b-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="6d93b-180">Встроенная задача поддержания согласованности данных между независимыми источниками данных в разных микрослужбах не может быть неполной.</span><span class="sxs-lookup"><span data-stu-id="6d93b-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="6d93b-181">Отсутствие распределенных транзакций в собственных приложениях в облаке означает необходимость программного управления распределенными транзакциями.</span><span class="sxs-lookup"><span data-stu-id="6d93b-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="6d93b-182">Вы перейдете из мира *непосредственно к согласованности* в *конечном итоге*.</span><span class="sxs-lookup"><span data-stu-id="6d93b-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="6d93b-183">На рис. 5-5 показана проблема.</span><span class="sxs-lookup"><span data-stu-id="6d93b-183">Figure 5-5 shows the problem.</span></span>

![Транзакция в шаблоне Saga](./media/saga-transaction-operation.png)

<span data-ttu-id="6d93b-185">**Рис. 5-5**.</span><span class="sxs-lookup"><span data-stu-id="6d93b-185">**Figure 5-5**.</span></span> <span data-ttu-id="6d93b-186">Реализация транзакции по микрослужбам</span><span class="sxs-lookup"><span data-stu-id="6d93b-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="6d93b-187">На предыдущем рисунке пять независимых микрослужб участвуют в распределенной транзакции, которая создает заказ.</span><span class="sxs-lookup"><span data-stu-id="6d93b-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="6d93b-188">Каждая микрослужба поддерживает собственное хранилище данных и реализует локальную транзакцию для своего магазина.</span><span class="sxs-lookup"><span data-stu-id="6d93b-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="6d93b-189">Чтобы создать заказ, локальная транзакция для *каждой* отдельной микрослужбы должна быть выполнена, либо *все* должно завершиться и откатить операцию.</span><span class="sxs-lookup"><span data-stu-id="6d93b-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="6d93b-190">Хотя встроенная поддержка транзакций доступна в каждой микрослужбе, нет поддержки распределенной транзакции, охватывающей все пять служб для обеспечения согласованности данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="6d93b-191">Вместо этого распределенная транзакция должна создаваться *программно*.</span><span class="sxs-lookup"><span data-stu-id="6d93b-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="6d93b-192">Распространенный шаблон для добавления распределенной поддержки транзакций — шаблон Saga.</span><span class="sxs-lookup"><span data-stu-id="6d93b-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="6d93b-193">Он реализуется с помощью группирования локальных транзакций вместе программно и последовательно вызывает каждый из них.</span><span class="sxs-lookup"><span data-stu-id="6d93b-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="6d93b-194">Если какая-либо из локальных транзакций завершается ошибкой, Saga прерывает операцию и вызывает набор [компенсирующих транзакций](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span><span class="sxs-lookup"><span data-stu-id="6d93b-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="6d93b-195">Компенсирующие транзакции отменяют изменения, внесенные предыдущими локальными транзакциями, и восстанавливают согласованность данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="6d93b-196">На рис. 5-6 показана неудачная транзакция с шаблоном Saga.</span><span class="sxs-lookup"><span data-stu-id="6d93b-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Откат в шаблоне Saga](./media/saga-rollback-operation.png)

<span data-ttu-id="6d93b-198">**Рис. 5-6**.</span><span class="sxs-lookup"><span data-stu-id="6d93b-198">**Figure 5-6**.</span></span> <span data-ttu-id="6d93b-199">Откат транзакции</span><span class="sxs-lookup"><span data-stu-id="6d93b-199">Rolling back a transaction</span></span>

<span data-ttu-id="6d93b-200">На предыдущем рисунке операция *обновления инвентаризации* завершилась сбоем в микрослужбе инвентаризации.</span><span class="sxs-lookup"><span data-stu-id="6d93b-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="6d93b-201">Saga вызывает набор компенсирующих транзакций (красным цветом) для корректировки количества запасов, отмены платежа и заказа, а также возврата данных для каждой микрослужбы обратно в согласованное состояние.</span><span class="sxs-lookup"><span data-stu-id="6d93b-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="6d93b-202">Шаблоны Saga обычно организуются как ряд связанных событий или организованы в виде набора связанных команд.</span><span class="sxs-lookup"><span data-stu-id="6d93b-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="6d93b-203">В главе 4 мы обсуждали шаблон агрегатора служб, который будет основой для управляемой реализации Saga.</span><span class="sxs-lookup"><span data-stu-id="6d93b-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="6d93b-204">Мы также обсуждали события, связанные с служебной шиной Azure и таблицами службы "Сетка событий Azure", которые будут основой для реализации организуются Saga.</span><span class="sxs-lookup"><span data-stu-id="6d93b-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="6d93b-205">Данные большого объема</span><span class="sxs-lookup"><span data-stu-id="6d93b-205">High volume data</span></span>

<span data-ttu-id="6d93b-206">Крупные облачные приложения часто поддерживают требования к данным большого объема.</span><span class="sxs-lookup"><span data-stu-id="6d93b-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="6d93b-207">В этих сценариях традиционные методы хранения данных могут вызвать узкие места.</span><span class="sxs-lookup"><span data-stu-id="6d93b-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="6d93b-208">Для сложных систем, которые развертываются в крупном масштабе, как разделение команд и запросов (CQRS), так и источников событий могут повысить производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="6d93b-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="6d93b-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="6d93b-209">CQRS</span></span>

<span data-ttu-id="6d93b-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)— это шаблон архитектуры, позволяющий максимально повысить производительность, масштабируемость и безопасность.</span><span class="sxs-lookup"><span data-stu-id="6d93b-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="6d93b-211">Шаблон разделяет операции, считывающие данные из операций, которые записывают данные.</span><span class="sxs-lookup"><span data-stu-id="6d93b-211">The pattern separates operations that read data from those operations that write data.</span></span> 

<span data-ttu-id="6d93b-212">В обычных сценариях одна и та же модель сущностей и объект репозитория данных используются для *операций чтения и* записи.</span><span class="sxs-lookup"><span data-stu-id="6d93b-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="6d93b-213">Однако сценарий с данными большого объема может воспользоваться преимуществами отдельных моделей и таблиц данных для операций чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="6d93b-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="6d93b-214">Чтобы повысить производительность, операция чтения может выполнить запрос к очень денормализованному представлению данных, чтобы избежать дорогостоящих повторяющихся соединений таблиц и блокировок таблиц.</span><span class="sxs-lookup"><span data-stu-id="6d93b-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="6d93b-215">Операция *записи* , называемая *командой*, обновится с использованием полностью нормализованного представления данных, которое обеспечит согласованность.</span><span class="sxs-lookup"><span data-stu-id="6d93b-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="6d93b-216">Затем необходимо реализовать механизм, обеспечивающий синхронизацию обоих представлений. Как правило, при изменении таблицы записи она публикует событие, которое реплицирует изменения в таблицу чтения.</span><span class="sxs-lookup"><span data-stu-id="6d93b-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="6d93b-217">На рис. 5-7 показана реализация шаблона CQRS.</span><span class="sxs-lookup"><span data-stu-id="6d93b-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![разделение команд и запросов](./media/cqrs-implementation.png)

<span data-ttu-id="6d93b-219">**Рис. 5-7**.</span><span class="sxs-lookup"><span data-stu-id="6d93b-219">**Figure 5-7**.</span></span> <span data-ttu-id="6d93b-220">Реализация CQRS</span><span class="sxs-lookup"><span data-stu-id="6d93b-220">CQRS implementation</span></span>

<span data-ttu-id="6d93b-221">На предыдущем рисунке реализуются отдельные модели команд и запросов.</span><span class="sxs-lookup"><span data-stu-id="6d93b-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="6d93b-222">Каждая операция записи данных сохраняется в хранилище записи и затем распространяется в хранилище для чтения.</span><span class="sxs-lookup"><span data-stu-id="6d93b-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="6d93b-223">Обратите особое внимание на то, как процесс распространения данных работает по принципу [окончательной согласованности](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span><span class="sxs-lookup"><span data-stu-id="6d93b-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="6d93b-224">Модель чтения в конечном итоге синхронизируется с моделью записи, но в процессе может возникнуть некоторое запаздывание.</span><span class="sxs-lookup"><span data-stu-id="6d93b-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="6d93b-225">В следующем разделе рассматривается окончательная согласованность.</span><span class="sxs-lookup"><span data-stu-id="6d93b-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="6d93b-226">Это разделение обеспечивает независимое масштабирование операций чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="6d93b-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="6d93b-227">Операции чтения используют схему, оптимизированную для запросов, в то время как операции записи используют схему, оптимизированную для обновлений.</span><span class="sxs-lookup"><span data-stu-id="6d93b-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="6d93b-228">Запросы на чтение относятся к денормализованным данным, а к модели записи можно применить сложную бизнес-логику.</span><span class="sxs-lookup"><span data-stu-id="6d93b-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="6d93b-229">Кроме того, при операциях записи может быть обеспечена более строгая безопасность, чем при чтении.</span><span class="sxs-lookup"><span data-stu-id="6d93b-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="6d93b-230">Реализация CQRS может улучшить производительность приложений для облачных служб.</span><span class="sxs-lookup"><span data-stu-id="6d93b-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="6d93b-231">Однако это приводит к более сложной структуре.</span><span class="sxs-lookup"><span data-stu-id="6d93b-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="6d93b-232">Применяйте этот принцип внимательно и стратегически к разделам собственного облачного приложения, которые повышают его преимущества.</span><span class="sxs-lookup"><span data-stu-id="6d93b-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="6d93b-233">Дополнительные сведения о CQRS см. в статье [о микрослужбах .NET книги Майкрософт: архитектура для контейнерных приложений .NET](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span><span class="sxs-lookup"><span data-stu-id="6d93b-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="6d93b-234">Источники событий</span><span class="sxs-lookup"><span data-stu-id="6d93b-234">Event sourcing</span></span>

<span data-ttu-id="6d93b-235">Другой подход к оптимизации сценариев с данными большого объема включает в себя [источники событий](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span><span class="sxs-lookup"><span data-stu-id="6d93b-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="6d93b-236">Как правило, система хранит текущее состояние сущности данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="6d93b-237">Если пользователь изменяет свой номер телефона, например, запись клиента обновляется с учетом нового номера.</span><span class="sxs-lookup"><span data-stu-id="6d93b-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="6d93b-238">Мы всегда знакомы с текущим состоянием сущности данных, но каждое обновление перезаписывает предыдущее состояние.</span><span class="sxs-lookup"><span data-stu-id="6d93b-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span> 

<span data-ttu-id="6d93b-239">В большинстве случаев эта модель работает нормально.</span><span class="sxs-lookup"><span data-stu-id="6d93b-239">In most cases, this model works fine.</span></span> <span data-ttu-id="6d93b-240">Однако в системах большого объема издержки от транзакционной блокировки и частых операций обновления могут повлиять на производительность базы данных, скорость реагирования и ограничить масштабируемость.</span><span class="sxs-lookup"><span data-stu-id="6d93b-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="6d93b-241">Источник событий использует другой подход к сбору данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="6d93b-242">Каждая операция, влияющая на данные, сохраняется в хранилище событий.</span><span class="sxs-lookup"><span data-stu-id="6d93b-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="6d93b-243">Вместо обновления состояния записи данных мы добавляем каждое изменение в последовательный список прошлых событий, как в бухгалтерскую книгу.</span><span class="sxs-lookup"><span data-stu-id="6d93b-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="6d93b-244">Хранилище событий преобразуется в систему записи данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="6d93b-245">Он используется для распространения различных материализованных представлений в ограниченном контексте микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="6d93b-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="6d93b-246">На рисунке 5,8 показан шаблон.</span><span class="sxs-lookup"><span data-stu-id="6d93b-246">Figure 5.8 shows the pattern.</span></span>

![Источники событий](./media/event-sourcing.png)

<span data-ttu-id="6d93b-248">**Рис. 5-8**.</span><span class="sxs-lookup"><span data-stu-id="6d93b-248">**Figure 5-8**.</span></span> <span data-ttu-id="6d93b-249">Источники событий</span><span class="sxs-lookup"><span data-stu-id="6d93b-249">Event Sourcing</span></span>

<span data-ttu-id="6d93b-250">На предыдущем рисунке обратите внимание, как каждая запись (синий цвет) для пользовательской корзины добавляется в базовое хранилище событий.</span><span class="sxs-lookup"><span data-stu-id="6d93b-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="6d93b-251">В смежном материализованным представлении система проецирует текущее состояние за счет воспроизведения всех событий, связанных с каждой корзиной для покупок.</span><span class="sxs-lookup"><span data-stu-id="6d93b-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="6d93b-252">Это представление (или чтение модели) затем предоставляется обратно в пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="6d93b-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="6d93b-253">События также могут быть интегрированы с внешними системами и приложениями или запрошены для определения текущего состояния сущности.</span><span class="sxs-lookup"><span data-stu-id="6d93b-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="6d93b-254">При таком подходе вы сохраняете историю.</span><span class="sxs-lookup"><span data-stu-id="6d93b-254">With this approach, you maintain history.</span></span> <span data-ttu-id="6d93b-255">Вы понимаете не только текущее состояние сущности, но и то, как вы достигли этого состояния.</span><span class="sxs-lookup"><span data-stu-id="6d93b-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="6d93b-256">Механическое обговорит, что источники событий упрощают модель записи.</span><span class="sxs-lookup"><span data-stu-id="6d93b-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="6d93b-257">Нет обновлений или удалений.</span><span class="sxs-lookup"><span data-stu-id="6d93b-257">There are no updates or deletes.</span></span> <span data-ttu-id="6d93b-258">Добавление каждой записи данных в качестве неизменяемого события снижает конфликты конфликтов, блокировки и параллелизма, связанные с реляционными базами данных.</span><span class="sxs-lookup"><span data-stu-id="6d93b-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="6d93b-259">Создание моделей чтения с помощью шаблона материализованных представлений позволяет отделить представление от модели записи и выбрать лучшее хранилище данных для оптимизации потребностей пользовательского интерфейса приложения.</span><span class="sxs-lookup"><span data-stu-id="6d93b-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="6d93b-260">Для этого шаблона рассмотрим хранилище данных, которое напрямую поддерживает источники событий.</span><span class="sxs-lookup"><span data-stu-id="6d93b-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="6d93b-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB и RavenDB являются хорошими кандидатами.</span><span class="sxs-lookup"><span data-stu-id="6d93b-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="6d93b-262">Как и в случае с любыми шаблонами и технологиями, реализуйте стратегические и при необходимости.</span><span class="sxs-lookup"><span data-stu-id="6d93b-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="6d93b-263">В то время как источники событий могут повысить производительность и масштабируемость, это достигается за счет сложности и обученной кривой.</span><span class="sxs-lookup"><span data-stu-id="6d93b-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="6d93b-264">[Назад](service-mesh-communication-infrastructure.md)
>[Вперед](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="6d93b-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
