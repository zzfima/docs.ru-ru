---
title: Монолитные приложения
description: Сведения об основных понятиях для контейнеризации монолитных приложений.
ms.date: 02/15/2019
ms.openlocfilehash: 8664153ee2e9d1d253164e43ac13105f6dbf476c
ms.sourcegitcommit: 559259da2738a7b33a46c0130e51d336091c2097
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2019
ms.locfileid: "72771037"
---
# <a name="monolithic-applications"></a>Монолитные приложения

В этом сценарии вы можете создать отдельное монолитное веб-приложение или службу и развернуть их как контейнер. Это приложение может не иметь монолитную внутреннюю структуру и состоять из нескольких библиотек, компонентов или даже уровней (прикладной уровень, уровень домена, уровень доступа к данным и т. д.). Внешне оно будет представлять собой единый контейнер — единый процесс, единое веб-приложение или единую службу.

Для управления этой моделью вы развертываете один контейнер, представляющий собой приложение. Для масштабирования просто добавьте дополнительные копии, расположив перед ними подсистему балансировки нагрузки. Управлять одним развертыванием в одном контейнере или виртуальной машине гораздо проще.

Такой монолитный шаблон может конфликтовать с принципом контейнера: "контейнер выполняет одну задачу и в одном процессе". Вы можете включить в один контейнер несколько компонентов, библиотек или внутренних слоев, как показано на рис. 4-1.

![Схема, показывающая монолитное приложение, которое масштабируется путем клонирования приложения.](./media/monolithic-applications/monolithic-application-architecture-example.png)

**Рис. 4-1.** Пример архитектуры монолитного приложения

Все функции монолитного приложения или основная их часть сосредоточены в одном процессе или контейнере, который разбивается на внутренние слои или библиотеки. Недостаток этого подхода становится очевидным, когда приложение разрастается и его необходимо масштабировать. Если масштабируется приложение целиком, все получится. Но в большинстве случаев необходимо масштабировать лишь некоторые части приложения, пока другие компоненты работают нормально.

В примере приложения для электронной торговли, вероятнее всего, потребуется масштабирование компонента со сведениями о товарах. Клиенты чаще просматривают товары, чем приобретают их. Клиенты чаще складывают товары в корзину, чем оплачивают их. Не так много клиентов пишут комментарии или просматривают историю покупок. И у вас, скорее всего, может быть лишь несколько сотрудников в одном регионе, которые управляют содержимым и маркетинговыми кампаниями. При масштабировании монолитных решений весь код развертывается многократно.

Помимо того, что необходимо масштабировать все компоненты, изменения в одном компоненте требуют полного повторного тестирования всего приложения и полного повторного развертывания всех его экземпляров.

Монолитный подход нашел широкое распространение и используется многими организациями при разработке архитектуры. Во многих случаях это позволяет добиться желаемых результатов, но иногда организация сталкивается с ограничениями. Во многих организациях приложения строились по такой модели, так как несколько лет назад с помощью существующих инструментов и инфраструктуры слишком сложно было создавать архитектуры SOA, и проблем не возникало, пока приложение не начинало разрастаться.

С точки зрения инфраструктуры, каждый сервер может выполнять множество приложений в одном узле и применять допустимое соотношение эффективности использования ресурсов, как показано на рисунке 4-2.

![Схема, показывающая один узел с несколькими приложениями в отдельных контейнерах.](./media/monolithic-applications/host-with-multiple-apps-containers.png)

**Рис. 4-2.** Узел, выполняющий несколько приложений/контейнеров

Наконец, с точки зрения доступности монолитные приложения нужно развертывать целиком. Это означает, что если требуется выполнить *остановку и запуск*, в течение периода развертывания будут затронуты все функциональные возможности и все пользователи. В некоторых случаях использование Azure и контейнеров позволяет свести эти ситуации к минимуму, а также снизить вероятность простоя приложения, как показано на рисунке 4-3.

Монолитные приложения можно развернуть в Azure с помощью выделенных виртуальных машин для каждого экземпляра. С помощью [масштабируемых наборов виртуальных машин Azure](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) можно легко масштабировать виртуальные машины.

[Службы приложений Azure](https://azure.microsoft.com/services/app-service/) также позволяют выполнять монолитные приложения и легко масштабировать экземпляры без управления виртуальными машинами. Службы приложений Azure также могут выполнять отдельные экземпляры контейнеров Docker, упрощая развертывание.

Вы можете развернуть несколько виртуальных машин в качестве узлов Docker и запустить любое количество контейнеров на виртуальную машину. Затем с помощью Azure Load Balancer вы можете управлять масштабированием, как показано на рисунке 4-3.

![Схема, показывающая монолитное приложение, масштабируемое на разные узлы.](./media/monolithic-applications/multiple-hosts-from-single-docker-container.png)

**Рис. 4-3**. Масштабирование одного приложения Docker с использованием нескольких узлов

Развертыванием самих узлов можно управлять с помощью традиционных методов развертывания.

Вы можете управлять контейнерами Docker из командной строки с помощью таких команд, как `docker run` и `docker-compose up`, а также автоматизировать эту процедуру с помощью конвейеров непрерывной поставки (CD) и, например, выполнить развертывание на узлах Docker из Azure DevOps Services.

## <a name="monolithic-application-deployed-as-a-container"></a>Развертывание монолитного приложения в контейнере

Использование контейнеров для управления монолитными развертываниями имеет свои преимущества. Масштабировать экземпляры контейнера гораздо быстрее и проще, чем развертывать дополнительные виртуальные машины.

Развертывание обновлений в виде образов Docker выполняется гораздо быстрее и эффективнее с точки зрения использования сети. Контейнеры Docker обычно запускаются за считаные секунды, что ускоряет выпуск. Демонтировать контейнер Docker можно с помощью команды `docker stop`, и обычно для этого требуется меньше секунды.

Так как контейнеры по своей природе являются неизменяемыми, вам не придется беспокоиться о возможности повреждения виртуальной машины, когда сценарии обновления не учитывают некоторые оставшиеся на диске конфигурации или файлы.

Docker имеет много плюсов для монолитных приложений, и мы лишь слегка затрагиваем эту тему. Более обширные возможности при управлении контейнерами открываются благодаря развертыванию с помощью оркестраторов контейнеров, которые управляют различными экземплярами и жизненным циклом каждого экземпляра контейнера. Когда вы разбиваете монолитное приложение на подсистемы, которые затем можно масштабировать, разрабатывать и развертывать по отдельности, вы переходите на уровень микрослужб.

Дополнительные сведения о том, как выполнить процедуру "lift-and-shift" для монолитных приложений с использованием контейнеров и модернизировать приложения, см. в дополнительном руководстве Майкрософт [Модернизация существующих приложений .NET с помощью облака Azure и контейнеров Windows](../../modernize-with-azure-containers/index.md), которое можно скачать в формате PDF по адресу <https://aka.ms/LiftAndShiftWithContainersEbook>.

## <a name="publish-a-single-docker-container-app-to-azure-app-service"></a>Публикация отдельного приложения на основе контейнера Docker в службе приложений Azure

Когда вы хотите быстро проверить контейнер, развернутый в Azure, или когда приложение основано на одном контейнере, вы можете воспользоваться удобной функцией предоставления масштабируемых служб на основе одного контейнера в службах приложений Azure.

Она интуитивно понятна и прекрасно интегрируется с Git, что ускоряет работу, так как вы можете взять свой код, выполнить его сборку в Visual Studio и развернуть его прямо в Azure. В обычном случае (без Docker), если вам требовались другие возможности, платформы или зависимости, не поддерживаемые в службах приложений, вам потребовалось бы подождать, пока команда разработчиков Azure не обновит эти зависимости в службе приложений, либо переключиться на другие службы, например Service Fabric, облачные службы или даже обычные виртуальные машины, где вы можете полнее контролировать процесс и установить необходимый компонент или необходимую платформу для своего приложения.

Как показано на рис. 4-4, при использовании Visual Studio 2017 поддержка контейнеров в службе приложений Azure позволяет включать в среду приложения любые компоненты. Если вы добавили зависимость в приложение, то поскольку оно выполняется в контейнере, вы можете включить такие зависимости в Dockerfile или образ Docker.

![Снимок экрана: диалоговое окно создания Службы приложений, в котором отображается Реестр контейнеров](./media/monolithic-applications/publish-azure-app-service-container.png)

**Рис. 4-4**. Публикация контейнера в службе приложений из приложений/контейнеров Visual Studio

На рис. 4-4 также указано, что поток публикации отправляет образ через реестр контейнеров. Это может быть Реестр контейнеров Azure (реестр, близкий к вашим развертываниям в Azure и защищенный группами и учетными записями в Azure Active Directory) или другой реестр Docker, например Docker Hub или локальные реестры.

>[!div class="step-by-step"]
>[Назад](common-container-design-principles.md)
>[Вперед](state-and-data-in-docker-applications.md)
