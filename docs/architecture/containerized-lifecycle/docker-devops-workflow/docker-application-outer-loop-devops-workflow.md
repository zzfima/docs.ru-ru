---
title: Действия в рабочем процессе внешнего цикла DevOps для приложения Docker
description: Сведения об этапах, относящихся к "внешнему циклу" рабочего процесса DevOps
ms.date: 02/15/2019
ms.openlocfilehash: 7c465ab380770441005f7365f53bc585236c31bd
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/07/2019
ms.locfileid: "73738358"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="0f04b-103">Действия в рабочем процессе внешнего цикла DevOps для приложения Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="0f04b-104">На рис. 5-1 приводится комплексное описание этапов, относящихся к рабочему процессу внешнего цикла DevOps.</span><span class="sxs-lookup"><span data-stu-id="0f04b-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="0f04b-105">Здесь представлен "внешний цикл" DevOps.</span><span class="sxs-lookup"><span data-stu-id="0f04b-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="0f04b-106">После отправки кода в репозиторий начинает работу конвейер непрерывной интеграции, а затем конвейер непрерывного развертывания, на котором осуществляется развертывание приложения.</span><span class="sxs-lookup"><span data-stu-id="0f04b-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="0f04b-107">Собранные метрики развернутых приложений передаются в рабочую нагрузку разработки, где реализуется "внутренний цикл". Таким образом, команда разработчиков получает актуальные данные, на основе которых может реагировать на потребности пользователей и бизнеса.</span><span class="sxs-lookup"><span data-stu-id="0f04b-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![Схема, на которой показано шесть шагов внешнего цикла DevOps.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="0f04b-109">**Рис. 5-1**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-109">**Figure 5-1**.</span></span> <span data-ttu-id="0f04b-110">Рабочий процесс внешнего цикла DevOps для приложений Docker с использованием средств Майкрософт</span><span class="sxs-lookup"><span data-stu-id="0f04b-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="0f04b-111">Далее рассмотрим каждый из этих этапов более подробно.</span><span class="sxs-lookup"><span data-stu-id="0f04b-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="0f04b-112">Шаг 1. Рабочий процесс внутреннего цикла разработки</span><span class="sxs-lookup"><span data-stu-id="0f04b-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="0f04b-113">Этот этап подробно описывается в главе 4. Напомним, что внешний цикл начинается именно здесь, в момент, когда разработчик отправляет код в систему управления версиями (например, Git), запуская конвейер непрерывной интеграции.</span><span class="sxs-lookup"><span data-stu-id="0f04b-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="0f04b-114">Шаг 2. Интеграция с системой управления версиями и управление ею с использованием Azure DevOps Services и Git</span><span class="sxs-lookup"><span data-stu-id="0f04b-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="0f04b-115">На этом этапе используется система управления версиями, которая собирает консолидированную версию всего кода на основе отправляемых различными разработчиками команды данных.</span><span class="sxs-lookup"><span data-stu-id="0f04b-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="0f04b-116">Работа с системами управления версиями хорошо знакома практически каждому разработчику. Тем не менее при создании приложений Docker в рамках жизненного цикла DevOps важно помнить, что не нужно отправлять образы Docker вместе с приложением с компьютера разработчика напрямую в глобальный реестр Docker (например, в реестр контейнеров Azure или Docker Hub).</span><span class="sxs-lookup"><span data-stu-id="0f04b-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="0f04b-117">Напротив, выпускаемые и развертываемые в рабочих средах образы Docker должны создаваться исключительно на основе исходного кода, который интегрируется с глобальным конвейером сборки или непрерывной интеграции на базе вашего репозитория исходного кода (например, Git).</span><span class="sxs-lookup"><span data-stu-id="0f04b-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="0f04b-118">Создаваемые разработчиками локальные образы должны использоваться ими только для тестирования на собственных компьютерах.</span><span class="sxs-lookup"><span data-stu-id="0f04b-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="0f04b-119">Именно поэтому активацию контейнера DevOps важно осуществлять из кода системы управления версиями.</span><span class="sxs-lookup"><span data-stu-id="0f04b-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="0f04b-120">Azure DevOps Services и Team Foundation Server поддерживают Git и систему управления версиями Team Foundation.</span><span class="sxs-lookup"><span data-stu-id="0f04b-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="0f04b-121">Выберите подходящую систему, чтобы использовать все преимущества комплексного решения на основе технологий Майкрософт.</span><span class="sxs-lookup"><span data-stu-id="0f04b-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="0f04b-122">Тем не менее вы можете использовать для управления кодом сторонние репозитории (например, GitHub, локальные репозитории Git или Subversion) и по-прежнему сможете подключаться к ним и получать код, который будет выступать в качестве отправной точки для конвейера непрерывной интеграции DevOps.</span><span class="sxs-lookup"><span data-stu-id="0f04b-122">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="0f04b-123">Шаг 3. Сборка, непрерывная интеграция, интеграция и тестирование с использованием Azure DevOps Services и Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="0f04b-124">Технологии непрерывной интеграции стали общепринятым стандартом для современных процессов тестирования и доставки программного обеспечения.</span><span class="sxs-lookup"><span data-stu-id="0f04b-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="0f04b-125">Решение Docker обеспечивает четкое разделение задач между командой разработчиков и операционной командой.</span><span class="sxs-lookup"><span data-stu-id="0f04b-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="0f04b-126">Неизменность образов Docker позволяет гарантировать успешное многократное развертывание компонентов, которые разрабатываются, тестируются в рамках процесса непрерывной интеграции и выполняются в рабочей среде.</span><span class="sxs-lookup"><span data-stu-id="0f04b-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="0f04b-127">Подсистема Docker развертывается на ноутбуках разработчиков, а инфраструктура тестирования обеспечивает возможность переноса контейнеров между средами.</span><span class="sxs-lookup"><span data-stu-id="0f04b-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="0f04b-128">На этом этапе после отправки правильного кода в систему управления версиями вам необходимо выполнить *построение службы* на основе этого кода и выполнить глобальные процедуры сборки и тестирования.</span><span class="sxs-lookup"><span data-stu-id="0f04b-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="0f04b-129">Внутренний рабочий процесс этого этапа (непрерывная интеграция, сборка, тестирование) включает в себя построение конвейера непрерывной интеграции, состоящего из репозитория кода (Git и т. д.), сервера сборки (Azure DevOps Services), подсистемы Docker и реестра Docker.</span><span class="sxs-lookup"><span data-stu-id="0f04b-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="0f04b-130">Вы можете использовать Azure DevOps Services в качестве основы для построения приложений, организации конвейера непрерывной сборки и публикации "артефактов" сборки в "репозитории артефактов" (см. описание следующего этапа).</span><span class="sxs-lookup"><span data-stu-id="0f04b-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="0f04b-131">При использовании технологии Docker для развертывания в качестве "конечных артефактов" развертываются образы Docker, в которые встроены ваши приложения или службы.</span><span class="sxs-lookup"><span data-stu-id="0f04b-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="0f04b-132">Эти образы отправляются или публикуются в *реестр Docker* (закрытый репозиторий, аналогичный присутствующим в реестре контейнеров Azure, или открытый, как реестр Docker Hub, который широко применяется для размещения официальных базовых образов).</span><span class="sxs-lookup"><span data-stu-id="0f04b-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="0f04b-133">Ниже описываются основные принципы этого процесса: Контейнер непрерывной интеграции активируется в момент фиксации кода в репозитории системы управления версиями, например в Git.</span><span class="sxs-lookup"><span data-stu-id="0f04b-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="0f04b-134">В результате фиксации службы Azure DevOps Services запускают задание сборки в контейнере Docker и после его успешного выполнения отправляют образ Docker в реестр Docker, как показано на рис. 5-2.</span><span class="sxs-lookup"><span data-stu-id="0f04b-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="0f04b-135">Это первая часть внешнего цикла, которая включает в себя этапы с 1 по 3: написание, выполнение, отладка и проверка кода; отправка кода в репозиторий; сборка и тестирование в рамках процесса непрерывной интеграции.</span><span class="sxs-lookup"><span data-stu-id="0f04b-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![Схема, на которой показаны три шага рабочего процесса непрерывной интеграции.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="0f04b-137">**Рис. 5-2**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-137">**Figure 5-2**.</span></span> <span data-ttu-id="0f04b-138">Этапы процесса непрерывной интеграции</span><span class="sxs-lookup"><span data-stu-id="0f04b-138">The steps involved in CI</span></span>

<span data-ttu-id="0f04b-139">Далее описываются основные этапы рабочего процесса непрерывной интеграции с использованием Docker и Azure DevOps Services:</span><span class="sxs-lookup"><span data-stu-id="0f04b-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="0f04b-140">Разработчик отправляет код для фиксации в репозиторий системы управления версиями (Git, Azure DevOps Services, GitHub и т. д.).</span><span class="sxs-lookup"><span data-stu-id="0f04b-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="0f04b-141">Если вы используете Azure DevOps Services или Git, вам будут доступны встроенные технологии непрерывной интеграции, для использования которых достаточно установить соответствующий флажок в Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="0f04b-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="0f04b-142">При работе со сторонней системой управления версиями (например, GitHub), `webhook` будет отправлять в Azure DevOps Services уведомления об обновлениях либо передавать их в Git или GitHub.</span><span class="sxs-lookup"><span data-stu-id="0f04b-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="0f04b-143">Службы Azure DevOps Services извлекают из репозитория системы управления версиями данные, в том числе файл Dockerfile с описанием образа, а также код приложения и тестов.</span><span class="sxs-lookup"><span data-stu-id="0f04b-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="0f04b-144">Службы Azure DevOps Services выполняют построение образа Docker и присваивают ему номер сборки.</span><span class="sxs-lookup"><span data-stu-id="0f04b-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="0f04b-145">Службы Azure DevOps создают экземпляр контейнера Docker в подготовленном узле Docker и проводят соответствующие тесты.</span><span class="sxs-lookup"><span data-stu-id="0f04b-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="0f04b-146">В случае успешного завершения тестов образу присваивается значащее имя, указывающее на то, что эта сборка утверждена (например, "/1.0.0" или другое соответствующее имя), после чего он отправляется в реестр Docker (Docker Hub, реестр контейнеров Azure, DTR и т. д.).</span><span class="sxs-lookup"><span data-stu-id="0f04b-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="0f04b-147">Реализация конвейера непрерывной интеграции с использованием Azure DevOps Services и расширения Docker для Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="0f04b-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="0f04b-148">В Visual Studio Azure DevOps Services содержатся шаблоны сборки и выпуска, которые можно использовать в конвейере непрерывной интеграции или непрерывного развертывания, используемом для сборки образов Docker, отправки образов Docker в прошедший проверку подлинности реестр Docker, запуска образов Docker или выполнения других операций, предлагаемых интерфейсом командной строки Docker.</span><span class="sxs-lookup"><span data-stu-id="0f04b-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="0f04b-149">Также эти службы добавляют задачу Docker Compose, с помощью которой можно выполнять сборку, отправку и запуск многоконтейнерных приложений Docker, а также другие операции, предлагаемые интерфейсом командной строки Docker Compose, как показано на рис. 5-3.</span><span class="sxs-lookup"><span data-stu-id="0f04b-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Снимок экрана: конвейер непрерывной интеграции Docker в Azure DevOps.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="0f04b-151">**Рис. 5-3**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-151">**Figure 5-3**.</span></span> <span data-ttu-id="0f04b-152">Конвейер непрерывной интеграции Docker в Azure DevOps Services, включающий шаблоны сборки и выпуска, а также связанные с ними задачи.</span><span class="sxs-lookup"><span data-stu-id="0f04b-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="0f04b-153">Эти шаблоны и задачи можно использовать для построения артефактов непрерывной интеграции и непрерывного развертывания для сборки, тестирования и развертывания в Azure Service Fabric, службе Azure Kubernetes и аналогичных предложениях.</span><span class="sxs-lookup"><span data-stu-id="0f04b-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="0f04b-154">Используя эти задачи Visual Studio Team Services, узел или виртуальную машину сборки Linux-Docker, подготовленные в Azure, а также предпочтительный реестр Docker (реестр контейнеров Azure, Docker Hub, закрытый доверенный реестр Docker DTR или любой другой реестр Docker), вы можете обеспечить максимально согласованное построение конвейера непрерывной интеграции Docker.</span><span class="sxs-lookup"><span data-stu-id="0f04b-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="0f04b-155">***Требования:***</span><span class="sxs-lookup"><span data-stu-id="0f04b-155">***Requirements:***</span></span>

- <span data-ttu-id="0f04b-156">Службы Azure DevOps Services либо (для локальной установки) Team Foundation Server 2015 с обновлением 3 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="0f04b-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="0f04b-157">Агент Azure DevOps Services, содержащий двоичные файлы Docker.</span><span class="sxs-lookup"><span data-stu-id="0f04b-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="0f04b-158">Простой способ создать один из таких агентов заключается в использовании Docker для запуска контейнера на основе образа Docker агента Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="0f04b-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!ИНФОРМАЦИЯ]<span data-ttu-id="0f04b-159"> Дополнительные сведения о построении контейнера непрерывной интеграции Docker для Azure DevOps Services и соответствующие пошаговые руководства см. на следующих веб-сайтах:</span><span class="sxs-lookup"><span data-stu-id="0f04b-159"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="0f04b-160">Запуск агента Visual Studio Team Services (теперь Azure DevOps Services) в качестве контейнера Docker: </span><span class="sxs-lookup"><span data-stu-id="0f04b-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="0f04b-161">Сборка образов Docker .NET Core Linux с использованием Azure DevOps Services: </span><span class="sxs-lookup"><span data-stu-id="0f04b-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/>
>
> - <span data-ttu-id="0f04b-162">Построение машины сборки Visual Studio Team Service на основе Linux с поддержкой Docker: </span><span class="sxs-lookup"><span data-stu-id="0f04b-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="0f04b-163">Интеграция, тестирование и проверка многоконтейнерных приложений Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="0f04b-164">Большинство приложений Docker состоит не из одного, а из нескольких контейнеров.</span><span class="sxs-lookup"><span data-stu-id="0f04b-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="0f04b-165">В качестве примера можно привести ориентированные на работу с микрослужбами приложения, в которых обычно используется один контейнер для каждой микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="0f04b-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="0f04b-166">Тем не менее, даже если ваше приложение Docker не рассчитано на работу с микрослужбами, в нем скорее всего будет использоваться несколько контейнеров или служб.</span><span class="sxs-lookup"><span data-stu-id="0f04b-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="0f04b-167">Таким образом, после построения контейнеров приложения на конвейере непрерывной интеграции вам также необходимо выполнить развертывание, интеграцию и тестирование приложения в целом со всеми его контейнерами в узле интеграции Docker или даже в кластере тестирования, в котором будут распространяться ваши контейнеры.</span><span class="sxs-lookup"><span data-stu-id="0f04b-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="0f04b-168">Если вам требуется один узел, используйте команды Docker, например docker-compose, для развертывания связанных контейнеров с целью протестировать и проверить среду Docker на отдельной виртуальной машине.</span><span class="sxs-lookup"><span data-stu-id="0f04b-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="0f04b-169">Если же вы работаете с кластером оркестратора, таким как DC/OS, Kubernetes или Docker Swarm, для развертывания контейнеров необходимо использовать другой механизм или оркестратор, в зависимости от выбранного кластера или планировщика.</span><span class="sxs-lookup"><span data-stu-id="0f04b-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="0f04b-170">Ниже описывается несколько типов тестов, которые можно выполнять в отношении контейнеров Docker:</span><span class="sxs-lookup"><span data-stu-id="0f04b-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="0f04b-171">Модульные тесты для контейнеров Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="0f04b-172">Тестирование групп взаимосвязанных приложений или микрослужб</span><span class="sxs-lookup"><span data-stu-id="0f04b-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="0f04b-173">Тестирование в рабочей среде и ранних выпусках</span><span class="sxs-lookup"><span data-stu-id="0f04b-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="0f04b-174">Важно помнить, что интеграционные и функциональные тесты следует выполнять за пределами контейнеров.</span><span class="sxs-lookup"><span data-stu-id="0f04b-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="0f04b-175">Тесты не включаются в состав развертываемых контейнеров, поскольку контейнеры основываются на статических образах, которые должны в точности соответствовать тем, которые будут развернуты в рабочей среде.</span><span class="sxs-lookup"><span data-stu-id="0f04b-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="0f04b-176">При тестировании в более сложных сценариях, например с участием нескольких кластеров (кластер тестирования, промежуточный и рабочий кластеры), целесообразно публиковать образы в реестре, что позволяет выполнять тестирование в нескольких кластерах.</span><span class="sxs-lookup"><span data-stu-id="0f04b-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="0f04b-177">Отправка образа пользовательского приложения Docker в глобальный реестр Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="0f04b-178">После тестирования и проверки образов Docker можно присвоить им теги и опубликовать их в реестре Docker.</span><span class="sxs-lookup"><span data-stu-id="0f04b-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="0f04b-179">Реестр Docker — это критически важный компонент жизненного цикла приложения Docker, который представляет собой централизованное место для хранения пользовательских тестов (так называемые утвержденные образы), которые будут развертываться в средах для контроля качества и рабочих средах.</span><span class="sxs-lookup"><span data-stu-id="0f04b-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="0f04b-180">Как и репозиторий системы управления версиями (Git и т. д.), в котором хранится проверенный код приложения, реестр Docker является вашим надежным источником для двоичных приложений и компонентов, которые будут развертываться в средах для контроля качества и рабочих средах.</span><span class="sxs-lookup"><span data-stu-id="0f04b-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="0f04b-181">Как правило, пользовательские образы хранятся либо в закрытом репозитории (в реестре контейнеров Azure или в локальном реестре, например в доверенном реестре Docker), либо в открытом облачном реестре с ограниченным доступом (например, Docker Hub). Обратите внимание, что в последнем случае, если вы не работаете с открытым исходным кодом, вы должны доверять системе безопасности поставщика.</span><span class="sxs-lookup"><span data-stu-id="0f04b-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="0f04b-182">В любом случае используемый метод будет аналогичен команде `docker push` и построен на ее основе, как показано на рис. 5-4.</span><span class="sxs-lookup"><span data-stu-id="0f04b-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Схема, на которой показана отправка пользовательских образов в реестр контейнеров.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="0f04b-184">**Рис. 5-4**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-184">**Figure 5-4**.</span></span> <span data-ttu-id="0f04b-185">Публикация пользовательских образов в реестре Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="0f04b-186">На этапе 3 при построении интеграции и тестирования (непрерывная интеграция) вы можете публиковать полученные образы Docker в закрытом или общедоступном реестре.</span><span class="sxs-lookup"><span data-stu-id="0f04b-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="0f04b-187">На рынке представлены реестры Docker, предлагаемые целым рядом поставщиков облачных решений, в том числе реестр контейнеров Azure, Amazon Web Services Container Registry, Google Container Registry, Quay Registry и другие.</span><span class="sxs-lookup"><span data-stu-id="0f04b-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="0f04b-188">С помощью задач Docker вы можете отправлять набор образов служб с несколькими тегами, определяемый в файле `docker-compose.yml`, в прошедший проверку подлинности реестр Docker (например, в реестр контейнеров Azure), как показано на рис. 5-5.</span><span class="sxs-lookup"><span data-stu-id="0f04b-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Снимок экрана: этап публикации образов в реестре.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="0f04b-190">**Рис. 5-5**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-190">**Figure 5-5**.</span></span> <span data-ttu-id="0f04b-191">Использование служб Azure DevOps Services для публикации пользовательских образов в реестр Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!ИНФОРМАЦИЯ]<span data-ttu-id="0f04b-192"> Дополнительные сведения о реестре контейнеров Azure см. в статье <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="0f04b-192"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="0f04b-193">Шаг 4. Непрерывное развертывание и развертывание</span><span class="sxs-lookup"><span data-stu-id="0f04b-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="0f04b-194">Неизменность образов Docker позволяет гарантировать успешное многократное развертывание компонентов, которые разрабатываются, тестируются в рамках процесса непрерывной интеграции и выполняются в рабочей среде.</span><span class="sxs-lookup"><span data-stu-id="0f04b-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="0f04b-195">После публикации образов приложений Docker в реестре Docker (закрытом или общедоступном) вы можете развертывать их в разных средах (например, в промежуточной, рабочей среде, среде контроля качества и т. д.) с конвейера непрерывного развертывания с использованием задач конвейера Azure DevOps Services или служб Release Management для Azure DevOps Services.</span><span class="sxs-lookup"><span data-stu-id="0f04b-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="0f04b-196">Выбор подхода зависит от того, какое приложение Docker вы развертываете.</span><span class="sxs-lookup"><span data-stu-id="0f04b-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="0f04b-197">Развертывание простого (с точки зрения состава и развертывания), например монолитного, приложения, состоящего из небольшого количества контейнеров и служб, на нескольких серверах или виртуальных машинах будет отличаться от развертывания более сложных приложений, например ориентированных на микрослужбы с возможностями гипермасштабирования.</span><span class="sxs-lookup"><span data-stu-id="0f04b-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="0f04b-198">Эти сценарии рассматриваются в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="0f04b-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="0f04b-199">Развертывание составных приложений Docker в нескольких средах Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="0f04b-200">Для начала рассмотрим более простой сценарий, подразумевающий развертывание на простых узлах Docker (виртуальные машины или серверы) в одной или нескольких средах (промежуточная, рабочая среда или среда контроля качества).</span><span class="sxs-lookup"><span data-stu-id="0f04b-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="0f04b-201">В этом сценарии вы можете использовать команду docker-compose (из задач развертывания Azure DevOps Services) внутри конвейера непрерывного развертывания для развертывания приложений Docker и связанных с ними наборов контейнеров и служб, как показано на рис. 5-6.</span><span class="sxs-lookup"><span data-stu-id="0f04b-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Схема, на которой показано развертывание в трех средах в рамках непрерывного развертывания.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="0f04b-203">**Рис. 5-6**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-203">**Figure 5-6**.</span></span> <span data-ttu-id="0f04b-204">Развертывание контейнеров приложений в реестре сред простого узла Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="0f04b-205">На рис. 5-7 показаны принципы подключения непрерывной интеграции сборки к средам контроля качества и тестирования через Azure DevOps Services посредством выбора задачи Docker Compose в диалоговом окне "Добавить задачу".</span><span class="sxs-lookup"><span data-stu-id="0f04b-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="0f04b-206">Тем не менее при развертывании в промежуточной или рабочей среде обычно используются возможности служб Release Management, позволяющие работать с несколькими средами (промежуточная, рабочая среда или среда контроля качества).</span><span class="sxs-lookup"><span data-stu-id="0f04b-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="0f04b-207">При развертывании на отдельных узлах Docker используется задача Docker Compose служб Azure DevOps Services (внутри этой задачи вызывается команда `docker-compose up`).</span><span class="sxs-lookup"><span data-stu-id="0f04b-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="0f04b-208">При развертывании службы Azure Kubernetes (AKS) используется задача развертывания Docker, как описывается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="0f04b-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Снимок экрана: диалоговое окно добавления задачи Docker Compose.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="0f04b-210">**Рис. 5-7**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-210">**Figure 5-7**.</span></span> <span data-ttu-id="0f04b-211">Добавление задачи Docker Compose на конвейер служб Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="0f04b-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="0f04b-212">При создании выпуска в Azure DevOps Services используется набор входных артефактов.</span><span class="sxs-lookup"><span data-stu-id="0f04b-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="0f04b-213">Эти артефакты должны быть неизменными на протяжении всего жизненного цикла выпуска во всех средах.</span><span class="sxs-lookup"><span data-stu-id="0f04b-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="0f04b-214">При работе с контейнерами входные артефакты определяют развертываемые образы в реестре.</span><span class="sxs-lookup"><span data-stu-id="0f04b-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="0f04b-215">В зависимости от способа идентификации этих образов они необязательно будут оставаться неизменными на протяжении всего жизненного цикла выпуска. Самым очевидным примером этого является использование ссылки на `myimage:latest` из файла `docker-compose`.</span><span class="sxs-lookup"><span data-stu-id="0f04b-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="0f04b-216">С помощью шаблонов Azure DevOps Services вы можете создавать артефакты сборки, содержащие дайджесты конкретного образа реестра, которые гарантированно будут уникальным способом определять один и тот же двоичный файл образа.</span><span class="sxs-lookup"><span data-stu-id="0f04b-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="0f04b-217">Именно они будут использоваться в качестве входных данных для выпуска.</span><span class="sxs-lookup"><span data-stu-id="0f04b-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="0f04b-218">Управление выпусками в средах Docker с использованием служб Release Management для Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="0f04b-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="0f04b-219">С помощью шаблонов Azure DevOps Services вы можете создать новый образ, опубликовать его в реестре Docker, запустить его на узлах под управлением Linux или Windows, а также развернуть несколько контейнеров в качестве единого приложения с помощью таких команд, как `docker-compose`. Для решения всех этих задач используются возможности служб Release Management для Azure DevOps Services, обеспечивающие работу с несколькими средами (см. рис. 5-8).</span><span class="sxs-lookup"><span data-stu-id="0f04b-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Снимок экрана, на котором показана конфигурация выпусков Docker Compose.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="0f04b-221">**Рис. 5-8**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-221">**Figure 5-8**.</span></span> <span data-ttu-id="0f04b-222">Настройка задач Docker Compose в Azure DevOps Services с помощью служб Release Management для Azure DevOps Services</span><span class="sxs-lookup"><span data-stu-id="0f04b-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="0f04b-223">Не забывайте, что сценарий, который показан на рис. 5-6 и реализован на рис. 5-8, является простым (развертывание одного контейнера или экземпляра на каждый образ на отдельных виртуальных машинах или узлах Docker). Как правило, такой сценарий возможен только на этапах разработки или тестирования.</span><span class="sxs-lookup"><span data-stu-id="0f04b-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="0f04b-224">В большинстве рабочих корпоративных сред вам потребуется обеспечить высокий уровень доступности и простоту масштабирования посредством балансировки нагрузки между несколькими узлами, серверами и виртуальными машинами, а также возможности интеллектуальной отработки отказа для автоматического переноса служб или контейнеров с отказавшего сервера или узла на другой сервер или другую виртуальную машину.</span><span class="sxs-lookup"><span data-stu-id="0f04b-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="0f04b-225">В таком случае вам потребуются более сложные технологии, например кластеры контейнеров, оркестраторы и планировщики.</span><span class="sxs-lookup"><span data-stu-id="0f04b-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="0f04b-226">Таким образом, при развертывании в таких кластерах вы будете следовать более сложным сценариям, которые описываются в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="0f04b-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="0f04b-227">Развертывание приложений Docker в кластерах Docker</span><span class="sxs-lookup"><span data-stu-id="0f04b-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="0f04b-228">По своей природе распределенные приложения требуют распределенных вычислительных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="0f04b-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="0f04b-229">Чтобы обеспечить возможности масштабирования для рабочей среды, вам необходимо использовать кластеры, которые обеспечивают высокий уровень доступности и масштабируемости за счет применения пула ресурсов.</span><span class="sxs-lookup"><span data-stu-id="0f04b-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="0f04b-230">Вы можете развернуть контейнеры в таких кластерах вручную с помощью средства командной строки или веб-интерфейса пользователя, однако делать это рекомендуется только при точечных развертываниях, предназначенных для тестирования, либо управления масштабированием или мониторингом.</span><span class="sxs-lookup"><span data-stu-id="0f04b-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="0f04b-231">С точки зрения непрерывного развертывания и, в частности, служб Azure DevOps Services, вы можете использовать специализированные задачи развертывания из служб Release Management для Azure DevOps Services, которые позволяют развертывать контейнерные приложения в распределенных кластерах в службе контейнеров, как показано на рис. 5-9.</span><span class="sxs-lookup"><span data-stu-id="0f04b-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![Схема, на которой показано развертывание в оркестраторах в рамках непрерывного развертывания.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="0f04b-233">**Рис. 5-9**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-233">**Figure 5-9**.</span></span> <span data-ttu-id="0f04b-234">Развертывание распределенных приложений в службе контейнеров</span><span class="sxs-lookup"><span data-stu-id="0f04b-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="0f04b-235">Изначально для развертывания в определенных кластерах или оркестраторах вам необходимо было использовать особые скрипты и механизмы развертывания для каждого оркестратора (например, Kubernetes и Service Fabric используют разные механизмы развертывания) вместо единой удобной задачи `docker-compose`, которая основывается на файле определения `docker-compose.yml`.</span><span class="sxs-lookup"><span data-stu-id="0f04b-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="0f04b-236">Тем не менее благодаря задаче Docker Deploy в Azure DevOps Services (см. рис. 5-10) вы также можете выполнять развертывание в поддерживаемых оркестраторах с использованием знакомого файла `docker-compose.yml`. Это связано с тем, что данное средство автоматически выполняет преобразование из файла `docker-compose.yml` в формат, используемый оркестратором.</span><span class="sxs-lookup"><span data-stu-id="0f04b-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that “translation” for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Снимок экрана, на котором показана задача развертывания в Kubernetes.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="0f04b-238">**Рис. 5-10**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-238">**Figure 5-10**.</span></span> <span data-ttu-id="0f04b-239">Добавление в среду задачи развертывания в Kubernetes</span><span class="sxs-lookup"><span data-stu-id="0f04b-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="0f04b-240">На рис. 5-11 показаны возможности для редактирования задачи развертывания в Kubernetes и разделы, которые доступны для настройки.</span><span class="sxs-lookup"><span data-stu-id="0f04b-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="0f04b-241">Эта задача будет извлекать в кластер готовые к работе пользовательские образы Docker в виде контейнеров.</span><span class="sxs-lookup"><span data-stu-id="0f04b-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Снимок экрана, на котором показана конфигурация задачи развертывания в Kubernetes.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="0f04b-243">**Рис. 5-11**.</span><span class="sxs-lookup"><span data-stu-id="0f04b-243">**Figure 5-11**.</span></span> <span data-ttu-id="0f04b-244">Определение задачи Docker Deploy для развертывания в ACS DC/OS</span><span class="sxs-lookup"><span data-stu-id="0f04b-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [!ИНФОРМАЦИЯ]<span data-ttu-id="0f04b-245"> Дополнительные сведения о контейнере непрерывного развертывания для Azure DevOps Services и Docker см. на странице <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="0f04b-245"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="0f04b-246">Шаг 5. Запуск и управление</span><span class="sxs-lookup"><span data-stu-id="0f04b-246">Step 5: Run and manage</span></span>

<span data-ttu-id="0f04b-247">Поскольку запуск приложений в рабочей корпоративной среде и управление ими сами по себе являются весьма объемной темой, в связи с характером операций, выполняемых сотрудниками на этом уровне (ИТ-операции), а также из-за большого объема информации по этой теме ей будет посвящена вся следующая глава.</span><span class="sxs-lookup"><span data-stu-id="0f04b-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="0f04b-248">Шаг 6. Мониторинг и диагностика</span><span class="sxs-lookup"><span data-stu-id="0f04b-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="0f04b-249">Эта тема также рассматривается в следующей главе в контексте ИТ-операций, выполняемых в рабочих системах. Тем не менее важно отметить, что полученные на этом этапе аналитические сведения должны передаваться команде разработчиков, которая сможет использовать их в качестве основы для постоянного улучшения приложения.</span><span class="sxs-lookup"><span data-stu-id="0f04b-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="0f04b-250">С этой точки зрения такие задачи операции также относятся к DevOps, хотя и выполняются в основном ИТ-отделом.</span><span class="sxs-lookup"><span data-stu-id="0f04b-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="0f04b-251">Функции мониторинга и диагностики полностью относятся к сфере DevOps только в том случае, если они выполняются командой разработчиков по отношению к средам тестирования или бета-версиям сред.</span><span class="sxs-lookup"><span data-stu-id="0f04b-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="0f04b-252">Для этих целей осуществляются нагрузочное тестирование или мониторинг в бета-версиях сред или средах контроля качества, на которых тестировщики проверяют новые решения.</span><span class="sxs-lookup"><span data-stu-id="0f04b-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="0f04b-253">[Назад](index.md)
>[Вперед](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="0f04b-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
