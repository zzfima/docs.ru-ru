---
title: Создание типов смешения с помощью методов интерфейса по умолчанию
description: Используя элементы интерфейса по умолчанию, можно расширить интерфейсы дополнительными реализациями по умолчанию для средств реализации.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: fb8fc1f432bdf909bae4f54bb76d10d7619f71a3
ms.sourcegitcommit: fbb8a593a511ce667992502a3ce6d8f65c594edf
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/16/2019
ms.locfileid: "74140843"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a>Учебник. Функциональные возможности смешения при создании классов с помощью методов интерфейса по умолчанию

Начиная с C# 8.0 в .NET Core 3.0 можно определить реализацию при объявлении члена интерфейса. Эта функция предоставляет новые возможности, позволяющие определить реализации по умолчанию для компонентов, объявленных в интерфейсах. Классы могут выбирать, когда следует переопределять функциональность, когда следует использовать функциональную возможность по умолчанию и когда не следует объявлять поддержку отдельных функций.

В этом руководстве вы узнаете, как:

> [!div class="checklist"]
>
> * Создать интерфейсы с реализациями, описывающими отдельные функции.
> * Создать классы, которые используют реализации по умолчанию.
> * Создать классы, которые переопределяют некоторые или все реализации по умолчанию.

## <a name="prerequisites"></a>Предварительные требования

Вам нужно настроить свой компьютер для выполнения .NET Core, включая компилятор C# 8.0. Компилятор C# 8.0 доступен, начиная с [Visual Studio 2019, 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), или [в пакете SDK для .NET Core 3.0](https://dotnet.microsoft.com/download/dotnet-core) или более поздней версии.

## <a name="limitations-of-extension-methods"></a>Ограничения методов расширения

Одним из способов реализации поведения, проявляемого в рамках интерфейса, является определение [методов расширения](../programming-guide/classes-and-structs/extension-methods.md), которые обеспечивают поведение по умолчанию. Интерфейсы объявляют минимальный набор элементов, предоставляя большую контактную зону для любого класса, реализующего этот интерфейс. Например, методы расширения в <xref:System.Linq.Enumerable> обеспечивают реализацию любой последовательности в качестве источника запроса LINQ.

Методы расширения разрешаются с использованием объявленного типа переменной во время компиляции. Реализующие интерфейс классы могут обеспечить лучшую реализацию для любого метода расширения. Объявления переменных должны соответствовать реализующему типу, чтобы позволить компилятору выбрать эту реализацию. Если тип во время компиляции соответствует интерфейсу, метод вызывает разрешение для метода расширения. Другая проблема с методами расширения заключается в том, что эти методы доступны везде, где доступен класс, содержащий методы расширения. Классы не могут объявлять, должны они или не должны предоставлять функции, объявленные в методах расширения.

Начиная с C# 8.0, можно объявить реализации по умолчанию как методы интерфейса. Так каждый класс автоматически использует реализацию по умолчанию. Классы, обеспечивающие лучшую реализацию, могут переопределить определение метода интерфейса с помощью более эффективного алгоритма. В каком-то смысле этот прием напоминает то, как можно использовать [метод расширения](../programming-guide/classes-and-structs/extension-methods.md).

В этой статье вы узнаете, как реализации интерфейса по умолчанию позволяют поддерживать новые сценарии.

## <a name="design-the-application"></a>Разработка приложения

Рассмотрим приложение для системы домашней автоматики. Возможно, у вас есть много типов разного освещения и индикаторов, которые можно использовать во всем доме. Каждый источник освещения должен поддерживать интерфейсы API, позволяющие включать и выключать эти источники, а также передавать данные о текущем состоянии. Некоторые источники освещения и индикаторы могут поддерживать другие функции, такие как:

- включение освещения, а затем его отключение по таймеру;
- мигание освещения в течение определенного периода времени.

Некоторые из этих расширенных возможностей можно эмулировать на устройствах, поддерживающих минимальный набор. Это соответствует реализации по умолчанию. Для устройств со встроенными дополнительными возможностями программное обеспечение устройства будет использовать собственные возможности. Для других источников освещения они могут реализовать интерфейс и использовать реализацию по умолчанию.

Элементы интерфейса по умолчанию являются лучшим решением для этого сценария, чем методы расширения. Авторы классов могут управлять выбором интерфейсов для реализации. Выбранные ими интерфейсы доступны как методы. Кроме того, так как методы стандартного интерфейса являются виртуальными по умолчанию, диспетчеризация методов всегда выбирает реализацию в классе. 

Давайте создадим код для демонстрации этих различий.

## <a name="create-interfaces"></a>Создание интерфейсов

Сначала можно создать интерфейс, который определяет поведение для всех источников освещения.

[!code-csharp[Declare base interface](~/samples/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

Основное средство тестирования верхнего освещения может реализовать этот интерфейс, как показано в следующем коде.

[!code-csharp[First overhead light](~/samples/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

В этом учебнике код не поддерживает устройства Интернета вещей, но эмулирует такие действия, записывая сообщения в консоль. Вы можете исследовать код без автоматизации дома.

Теперь определим интерфейс, автоматически отключающий освещение по истечении времени ожидания.

[!code-csharp[pure Timer interface](~/samples/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

Можно добавить базовую реализацию к верхнему освещению, но лучшим решением является изменение этого определения интерфейса для предоставления реализации по умолчанию типа `virtual`.

[!code-csharp[Timer interface](~/samples/csharp/tutorials/mixins-with-interfaces/ITimerLight.cs?name=SnippetTimerLightFinal)]

После добавления этого изменения класс `OverheadLight` может реализовать функцию таймера, объявляя поддержку интерфейса.

```csharp
public class OverheadLight : ITimerLight { }
```

Другой тип освещения может поддерживать более сложный протокол. Он может предоставить собственную реализацию для `TurnOnFor`, как показано в следующем коде.

[!code-csharp[Override the timer function](~/samples/csharp/tutorials/mixins-with-interfaces/HalogenLight.cs?name=SnippetHalogenLight)]

В отличие от переопределения виртуальных методов классов, объявление `TurnOnFor` в классе `HalogenLight` не использует ключевое слово `override`. 

## <a name="mix-and-match-capabilities"></a>Смешение и сопоставление возможностей

Преимущества методов интерфейса по умолчанию становятся понятнее, когда вы добавляете расширенные возможности. Использование интерфейса позволяет смешивать и сопоставлять возможности. Это также позволяет каждому автору класса выбирать между реализацией по умолчанию и пользовательской реализацией. Давайте добавим интерфейс с реализацией по умолчанию для мигающего освещения.

[!code-csharp[Define the blinking light interface](~/samples/csharp/tutorials/mixins-with-interfaces/IBlinkingLight.cs?name=SnippetBlinkingLight)]

Реализация по умолчанию позволяет освещению мигать. С помощью реализации по умолчанию к верхнему освещению можно добавить возможности таймера и мигания.

[!code-csharp[Use the default blink function](~/samples/csharp/tutorials/mixins-with-interfaces/OverheadLight.cs?name=SnippetOverheadLight)]

Новый тип освещения `LEDLight` поддерживает функцию таймера и функцию мигания напрямую. Такой стиль освещения реализует интерфейсы `ITimerLight` и `IBlinkingLight`, а также переопределяет метод `Blink`.

[!code-csharp[Override the blink function](~/samples/csharp/tutorials/mixins-with-interfaces/LEDLight.cs?name=SnippetLEDLight)]

`ExtraFancyLight` может напрямую поддерживать функции мигания и таймера.

[!code-csharp[Override the blink and timer function](~/samples/csharp/tutorials/mixins-with-interfaces/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

Ранее созданный класс `HalogenLight` не поддерживает мигание. Поэтому не добавляйте `IBlinkingLight` в список его поддерживаемых интерфейсов.

## <a name="detect-the-light-types-using-pattern-matching"></a>Определение типов освещения с помощью сопоставления шаблонов

Теперь давайте напишем тестовый код. С помощью функции [сопоставления шаблонов](../pattern-matching.md) в C# можно определить возможности освещения путем проверки поддерживаемых им интерфейсов.  Следующий метод выполняет поддерживаемые возможности для каждого источника освещения.

[!code-csharp[Test a light's capabilities](~/samples/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetTestLightFunctions)]

Следующий код в методе `Main` последовательно создает каждый тип освещения и тестирует его.

[!code-csharp[Test a light's capabilities](~/samples/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a>Как компилятор определяет наилучшую реализацию

В этом сценарии показан базовый интерфейс без каких-либо реализаций. Добавление метода в интерфейс `ILight` вводит новые сложности. Языковые правила, управляющие методами интерфейса по умолчанию, снижают влияние на конкретные классы, которые реализуют несколько производных интерфейсов. Попробуем улучшить исходный интерфейс с помощью нового метода, чтобы продемонстрировать, как это изменит использование интерфейса. Каждый световой индикатор может сообщать о своем состоянии питания в виде перечисленного значения.

[!code-csharp[Enumeration for power status](~/samples/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetPowerStatus)]

Реализация по умолчанию предполагает питание от сети.

[!code-csharp[Report a default power status](~/samples/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetILightInterface)]

Эти изменения компилируются правильно, несмотря на то что `ExtraFancyLight` объявляет поддержку интерфейса `ILight` и производных интерфейсов `ITimerLight` и `IBlinkingLight`. В интерфейсе `ILight` объявлена только одна "ближайшая" реализация. Любой класс, который объявляет переопределение, стает "ближайшей" реализацией. Вы видели примеры с предыдущими классами, которые переопределили элементы других производных интерфейсов.

Старайтесь не переопределять один и тот же метод в нескольких производных интерфейсах. При этом создается неоднозначный вызов метода каждый раз, когда класс реализует оба производных интерфейса. Компилятор не может выбрать один лучший метод, поэтому выдает ошибку. Например, если и `IBlinkingLight`, и `ITimerLight` реализовали переопределение `PowerStatus`, то для `OverheadLight` потребуется предоставить более конкретное переопределение. В противном случае компилятор не сможет выбрать между реализациями двух производных интерфейсов. Обычно эту ситуацию можно избежать, сохраняя определения интерфейсов компактными и направленными на одну функцию. В этом сценарии каждая возможность освещения является собственным интерфейсом. Несколько интерфейсов наследуются только классами.

В этом примере показан один из сценариев, в котором можно определить отдельные функции, которые можно комбинировать в классы. Вы объявили любой набор поддерживаемых функциональных возможностей, объявляя интерфейсы, поддерживаемые классом. Виртуальные методы интерфейса по умолчанию позволяют классам использовать или определять различные реализации для любого или всех методов интерфейса. Такая возможность языка предоставляет новые способы для моделирования реальных систем, которые вы создаете. Методы интерфейса по умолчанию предоставляют более понятный способ для выражения связанных классов, которые могут смешивать и сопоставлять различные возможности с помощью их виртуальных реализаций.
