---
title: Консольное приложение
description: Это руководство раскроет для вас некоторые возможности .NET Core и языка C#.
ms.date: 03/06/2017
ms.technology: csharp-fundamentals
ms.assetid: 883cd93d-50ce-4144-b7c9-2df28d9c11a0
ms.openlocfilehash: 921c8fc7824bdb48f08e4d9f5a276bf2284f8a17
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75714605"
---
# <a name="console-app"></a>Консольное приложение

Это руководство раскроет для вас некоторые возможности .NET Core и языка C#. Вы познакомитесь со следующими аспектами:

- работа с интерфейсом командной строки (CLI) в .NET Core;
- структура консольного приложения C#;
- консольный ввод-вывод;
- основные сведения об интерфейсах API файлового ввода-вывода в .NET;
- основные сведениях об асинхронном программировании задач в .NET.

Вам предстоит создать приложение, которое считывает текстовый файл и выводит его содержимое в консоль. Вывод в консоль осуществляется с такой скоростью, которая позволяет читать текст вслух. Скорость можно увеличивать или уменьшать клавишами "<" (меньше) и ">" (больше).

В этом руководстве описано множество функций. Попробуем собрать их по одному.

## <a name="prerequisites"></a>Предварительные требования

- Настройте компьютер для выполнения .NET Core. Инструкции по установке см. на странице [скачиваемых файлов .NET Core](https://dotnet.microsoft.com/download). Это приложение можно запустить в ОС Windows, Linux, macOS или в контейнере Docker.

- Установите любой привычный для вас редактор кода.

## <a name="create-the-app"></a>Создание приложения

Первым шагом является создание нового приложения. Откройте командную строку и создайте новый каталог для приложения. Перейдите в этот каталог. В командной строке введите команду `dotnet new console`. Эта команда создает начальный набор файлов для базового приложения Hello World.

Прежде чем вносить изменения, давайте разберем процедуру запуска простого приложения Hello World. Когда вы создадите приложение, наберите в командной строке команду `dotnet restore`. Она запускает процесс восстановления из пакета NuGet. NuGet представляет собой диспетчер пакетов для .NET. Эта команда загружает все отсутствующие зависимости для проекта. Поскольку мы имеем дело с новым проектом, для него пока не существует зависимостей, поэтому при первом запуске будет загружена только платформа .NET Core. После этого первого запуска команду `dotnet restore` нужно будет запускать только после добавления новых зависимых пакетов или при обновлении версий используемых зависимостей.

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

Когда завершится восстановление пакетов, запустите `dotnet build`. Эта команда запускает подсистему сборки и создает исполняемый файл приложения. Теперь можно выполнить команду `dotnet run`, которая запустит ваше приложение.

Весь код простого приложения Hello World размещается в файле Program.cs. Откройте этот файл в любом текстовом редакторе. Сейчас мы внесем в него первые изменения. В верхней части файла вы видите инструкцию using:

```csharp
using System;
```

Эта инструкция указывает компилятору, что в области действия находятся все типы из пространства имен `System`. Как и другие объектно ориентированные языки, с которыми вы могли работать ранее, C# использует пространства имен для организации типов. В нашей программе Hello World все точно так же. Как вы видите, программа заключена в пространство имен, имя которого соответствует имени текущего каталога. В этом учебнике давайте изменим имя на `TeleprompterConsole`:

```csharp
namespace TeleprompterConsole
```

## <a name="reading-and-echoing-the-file"></a>Чтение и вывод файла

Первая функция, которую мы добавим, будет считывать данные из текстового файла и выводить полученный текст в консоль. Сначала нам нужно добавить текстовый файл. Скопируйте в каталог проекта файл [sampleQuotes.txt](https://github.com/dotnet/samples/raw/master/csharp/getting-started/console-teleprompter/sampleQuotes.txt) из репозитория GitHub для этого [примера](https://github.com/dotnet/samples/tree/master/csharp/getting-started/console-teleprompter). Он будет источником текста для вашего приложения. Чтобы скачать пример приложения для этого раздела, воспользуйтесь инструкциями в разделе [Примеры и руководства](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).

Теперь добавьте в класс `Program` (он расположен сразу за методом `Main`) следующий метод:

```csharp
static IEnumerable<string> ReadFrom(string file)
{
    string line;
    using (var reader = File.OpenText(file))
    {
        while ((line = reader.ReadLine()) != null)
        {
            yield return line;
        }
    }
}
```

Этот метод использует типы из двух новых пространств имен. Чтобы такая программа успешно скомпилировалась, нужно добавить в начало файла следующие две строки:

```csharp
using System.Collections.Generic;
using System.IO;
```

Интерфейс <xref:System.Collections.Generic.IEnumerable%601> определен в пространстве имен <xref:System.Collections.Generic>. Класс <xref:System.IO.File> определен в пространстве имен <xref:System.IO>.

Этот метод является специальным типом *метода перечислителя* C#. Метод перечислителя возвращает последовательности, для которых применяется отложенное вычисление. Это означает, что каждый элемент в последовательности создается только в тот момент, когда к нему выполняется обращение в коде обработки последовательности. Методы перечислителя содержат один или несколько операторов [`yield return`](../language-reference/keywords/yield.md). Возвращаемый методом `ReadFrom` объект содержит код для создания каждого элемента последовательности. В нашем примере он читает следующую строку текста из исходного файла и возвращает эту строку. Каждый раз, когда вызывающий код запрашивает следующий элемент из последовательности, код считывает из файла и возвращает следующую строку текста. Когда файл закончится, последовательность сообщает, что в ней больше нет элементов.

Здесь используются еще два элемента синтаксиса C#, которые могут быть для вас новыми. Оператор [`using`](../language-reference/keywords/using-statement.md) в этом методе управляет освобождением ресурсов. Переменная, которая инициализируется в инструкции `using` (в нашем примере это `reader`) должна реализовывать интерфейс <xref:System.IDisposable>. Этот интерфейс определяет единственный метод (`Dispose`), который вызывается для освобождения ресурса. Компилятор создает такой вызов, когда выполнение кода достигает закрывающей скобки инструкции `using`. Созданный компилятором код гарантирует освобождение ресурса даже в том случае, если в блоке кода, определенном инструкцией using, будет создано исключение.

Переменная `reader` определена с ключевым словом `var`. Ключевое слово [`var`](../language-reference/keywords/var.md) определяет *неявно типизированную локальную переменную*. Это означает, что тип переменной определяется во время компиляции по типу объекта, присвоенного этой переменной. Здесь это возвращаемое значение метода <xref:System.IO.File.OpenText(System.String)>, то есть объект <xref:System.IO.StreamReader>.

Теперь давайте создадим в методе `Main` код для чтения файла:

```csharp
var lines = ReadFrom("sampleQuotes.txt");
foreach (var line in lines)
{
    Console.WriteLine(line);
}
```

Запустите программу командой `dotnet run` и убедитесь в том, что все текстовые строки выводятся в консоль.

## <a name="adding-delays-and-formatting-output"></a>Добавление задержек и форматирование выходных данных

Сейчас данные отображаются слишком быстро для чтения. Поэтому нам нужно добавить задержку в процесс вывода. Для этого вы создадите несложный код, выполняющий асинхронную обработку. Но первые наши действия будут нарушать стандартные рекомендации. Эти нарушения мы укажем в комментариях при создании кода, а затем заменим этот код в последующих шагах.

В этом разделе описаны два действия. Во-первых, обновите метод итератора, чтобы он возвращал не всю строку целиком, а каждое слово отдельно. Для этого внесите такие изменения. Замените инструкцию `yield return line;` следующим кодом:

```csharp
var words = line.Split(' ');
foreach (var word in words)
{
    yield return word + " ";
}
yield return Environment.NewLine;
```

Теперь следует изменить код обработки строк файла, добавив задержку после вывода каждого слова. Замените инструкцию `Console.WriteLine(line)` в методе `Main` на такой блок кода:

```csharp
Console.Write(line);
if (!string.IsNullOrWhiteSpace(line))
{
    var pause = Task.Delay(200);
    // Synchronously waiting on a task is an
    // anti-pattern. This will get fixed in later
    // steps.
    pause.Wait();
}
```

Класс <xref:System.Threading.Tasks.Task> находится в пространства имен <xref:System.Threading.Tasks>, поэтому эту инструкцию `using` нужно добавить в верхней части файла:

```csharp
using System.Threading.Tasks;
```

Запустите пример и проверьте выходные данные. Теперь слова появляются по одному и с задержками по 200 мс. Но пока с выводом сохраняются некоторые проблемы, поскольку в исходном текстовом файле есть несколько строк длиной более 80 символов, и они выводятся без перевода строки. Это не очень удобно читать с прокруткой. Но эту проблему легко исправить. Вам нужно лишь отслеживать длину каждой строки и создавать новую строку каждый раз, когда эта длина достигает определенного порога. После объявления `words` в методе `ReadFrom` объявите локальную переменную для хранения длины строки:

```csharp
var lineLength = 0;
```

Теперь добавьте следующий код после инструкции `yield return word + " ";` (перед закрывающей фигурной скобкой):

```csharp
lineLength += word.Length + 1;
if (lineLength > 70)
{
    yield return Environment.NewLine;
    lineLength = 0;
}
```

Запустите пример, и теперь вы сможете читать текст вслух в заданном темпе.

## <a name="async-tasks"></a>Асинхронные задачи

И на последнем этапе мы добавим код, который позволяет выполнять две асинхронные задачи, одна из которых — вывод текста, а вторая — ожидание ввода от пользователя для ускорения, замедления или прекращения вывода текста. Этот этап разделяется на несколько шагов, по завершении которых вы получите все необходимые обновления. Первым шагом является создание асинхронной задачи (<xref:System.Threading.Tasks.Task>), которая возвращает метод с тем кодом, который вы создали ранее для чтения и отображения файла.

Добавьте следующий метод в класс `Program`. Этот текст основан на тексте метода `Main`:

```csharp
private static async Task ShowTeleprompter()
{
    var words = ReadFrom("sampleQuotes.txt");
    foreach (var word in words)
    {
        Console.Write(word);
        if (!string.IsNullOrWhiteSpace(word))
        {
            await Task.Delay(200);
        }
    }
}
```

Вы можете заметить два изменения. Во-первых, в тексте нет вызова <xref:System.Threading.Tasks.Task.Wait>, который в синхронном режиме ожидает завершения задачи. Вместо него в этой версии используется ключевое слово `await`. Чтобы это работало, в сигнатуру метода нужно добавить модификатор `async`. Этот метод возвращает `Task`. Обратите внимание, что здесь нет инструкции для возвращения объекта `Task`. Вместо этого объект `Task` создается в коде, который компилятор предоставляет в точке использования оператора `await`. Представьте, что метод завершает выполнение при достижении `await`. Он возвращает `Task` в знак того, что работа еще не завершена. Метод возобновит свою работу, когда завершится ожидаемая задача. Когда работа метода завершится, это будет отражено в возвращаемом объекте `Task`.
Вызывающий код может отслеживать состояние полученного `Task`, чтобы определить момент завершения метода.

Теперь наш новый метод можно вызвать из метода `Main`:

```csharp
ShowTeleprompter().Wait();
```

Здесь, в методе `Main`, код синхронно ожидает завершения. Всегда, когда это возможно, следует использовать оператор `await` вместо синхронного ожидания. Но в методе `Main` консольного приложения запрещено использовать оператор `await`. В противном случае приложение завершит работу раньше, чем выполнит все свои задачи.

> [!NOTE]
> При использовании C# 7.1 или более поздней версии консольные приложения можно создавать с помощью [`async``Main` метода](../whats-new/csharp-7-1.md#async-main).

Теперь следует создать второй асинхронный метод, который позволяет считывать данные ввода из консоли и реагировать на клавиши "<" (меньше), ">" (больше) и "X" или "x". Для выполнения этой задачи добавьте приведенный ниже метод.

```csharp
private static async Task GetInput()
{
    var delay = 200;
    Action work = () =>
    {
        do {
            var key = Console.ReadKey(true);
            if (key.KeyChar == '>')
            {
                delay -= 10;
            }
            else if (key.KeyChar == '<')
            {
                delay += 10;
            }
            else if (key.KeyChar == 'X' || key.KeyChar == 'x')
            {
                break;
            }
        } while (true);
    };
    await Task.Run(work);
}
```

Здесь создается лямбда-выражение, представляющее делегат <xref:System.Action>, который считывает нажатие клавиши из консоли и изменяет локальную переменную с длительностью задержки, если пользователь нажал клавишу "<" (меньше) или ">" (больше). Выполнение метода делегата можно завершить, нажав клавишу "X" или "x". Таким образом пользователь может в любой момент прекратить отображение текста. Этот метод использует метод <xref:System.Console.ReadKey>, чтобы блокировать выполнение и ожидать нажатия клавиши.

Чтобы завершить создание этой функции, нам нужна новая инструкция `async Task`, которая вернет метод, запускающий обе задачи (`GetInput` и `ShowTeleprompter`) и управляющий обменом данными между этими задачами.

Пришло время создать класс, который может обрабатывать совместное использование данных двумя задачами. Этот класс содержит два открытых свойства: delay (задержка) и флаг `Done`, который означает, что файл прочитан полностью:

```csharp
namespace TeleprompterConsole
{
    internal class TelePrompterConfig
    {
        public int DelayInMilliseconds { get; private set; } = 200;

        public void UpdateDelay(int increment) // negative to speed up
        {
            var newDelay = Min(DelayInMilliseconds + increment, 1000);
            newDelay = Max(newDelay, 20);
            DelayInMilliseconds = newDelay;
        }

        public bool Done { get; private set; }

        public void SetDone()
        {
            Done = true;
        }
    }
}
```

Поместите этот класс в отдельный новый файл и заключите в пространство имен `TeleprompterConsole`, как показано выше. Также следует добавить оператор `using static`, чтобы можно было ссылаться на методы `Min` и `Max` без указания имени внешнего класса или пространства имен. Оператор [`using static`](../language-reference/keywords/using-static.md) импортирует методы из одного класса. В этом она отличается от использованной ранее инструкции `using`, которая импортирует все классы из пространства имен.

```csharp
using static System.Math;
```

Теперь вам нужно обновить методы `ShowTeleprompter` и `GetInput` для использования нового объекта `config`. И еще одна инструкция `Task`, которая возвращает метод `async`, запускающий обе задачи и завершающий работу после окончания первой задачи:

```csharp
private static async Task RunTeleprompter()
{
    var config = new TelePrompterConfig();
    var displayTask = ShowTeleprompter(config);

    var speedTask = GetInput(config);
    await Task.WhenAny(displayTask, speedTask);
}
```

Новым методом здесь является <xref:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])>. Этот метод создает задачу (`Task`), которая завершается сразу, как только завершится любая из задач в списке аргументов.

Теперь вам нужно обновить методы `ShowTeleprompter` и `GetInput`, чтобы они использовали объект `config` для задержки:

```csharp
private static async Task ShowTeleprompter(TelePrompterConfig config)
{
    var words = ReadFrom("sampleQuotes.txt");
    foreach (var word in words)
    {
        Console.Write(word);
        if (!string.IsNullOrWhiteSpace(word))
        {
            await Task.Delay(config.DelayInMilliseconds);
        }
    }
    config.SetDone();
}

private static async Task GetInput(TelePrompterConfig config)
{
    Action work = () =>
    {
        do {
            var key = Console.ReadKey(true);
            if (key.KeyChar == '>')
                config.UpdateDelay(-10);
            else if (key.KeyChar == '<')
                config.UpdateDelay(10);
            else if (key.KeyChar == 'X' || key.KeyChar == 'x')
                config.SetDone();
        } while (!config.Done);
    };
    await Task.Run(work);
}
```

Новая версия метода `ShowTeleprompter` вызывает новый метод из класса `TeleprompterConfig`. Сейчас нужно изменить метод `Main`, чтобы вместо `ShowTeleprompter` он вызывал `RunTeleprompter`:

```csharp
RunTeleprompter().Wait();
```

## <a name="conclusion"></a>Заключение

В этом учебнике мы продемонстрировали вам ряд функций языка C# и библиотек .NET Core, связанных с работой в консольных приложениях. На основе полученных знаний вы сможете развивать свои представления о языке и представленных здесь классах. Вы увидели базовые примеры использования файлового и консольного ввода-вывода, асинхронного программирования на основе задач с блокировкой и без блокировки. Вы получили информацию о языке C#, структуре программ на C#, а также об интерфейсе командной строки и средствах .NET Core.

Дополнительные сведения о файловом вводе-выводе см. в статье [Файловый и потоковый ввод-вывод](../../standard/io/index.md). Дополнительные сведения о модели асинхронного программирования, используемой в учебнике, см. в статьях [Асинхронное программирование на основе задач](../..//standard/parallel-programming/task-based-asynchronous-programming.md) и [Асинхронное программирование](../async.md).
