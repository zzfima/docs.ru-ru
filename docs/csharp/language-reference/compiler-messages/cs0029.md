---
title: Ошибка компилятора CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: f4dec41945ace6c6b0821b9870a88960efbe1e52
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "71332304"
---
# <a name="compiler-error-cs0029"></a>Ошибка компилятора CS0029

Не удается неявно преобразовать тип "type" в "type"

 Компилятору требуется явное преобразование. Например, может потребоваться приведение r-значения к тому же типу, который имеет l-значение. Или может быть необходимо предоставить подпрограммы преобразования для поддержки перегрузки определенных операторов.

 Преобразование должно выполняться в том случае, когда переменная одного типа присваивается переменной другого типа. При присвоении между переменными разных типов компилятор должен преобразовать тип в правой части оператора присваивания в тип в его левой части. Рассмотрим следующий код:

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 `i = lng;` выполняет присваивание, однако типы данных переменных в левой и правой частях оператора присваивания не совпадают. Прежде чем выполнять присваивание, компилятор неявно преобразует переменную `lng` типа long в тип int. Выполнение этого преобразования не предписывается явно какими-либо инструкциями кода и поэтому называется неявным. Обратите внимание, что в этом коде реализуется неявное сужающее преобразование, которое не допускается компилятором из-за риска потери данных.

 Преобразование является сужающим в тех случаях, когда целевой тип данных занимает в памяти меньше места, чем исходный. Например, сужающим является преобразование из long в int. Тип long занимает в памяти 8 байт, а тип int — 4 байта. Ниже показан пример потери данных в результате такого преобразования:

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 Переменная `lng` содержит слишком большое значение, которое нельзя сохранить в переменной `i`. Таким образом, при преобразовании этого значения в тип int потеряется часть данных, а преобразованное значение не будет в точности равно исходному.

 Расширяющие преобразования являются противоположностью сужающих. В этом случае целевой тип данных занимает в памяти больше места, чем исходный. Ниже приведен пример расширяющего преобразования:

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 Обратите внимание на отличие этого примера кода от первого. На этот раз переменная `lng` находится в левой части оператора присваивания и является его целевой переменной. Перед присвоением компилятор должен неявно преобразовать переменную `i` типа int в тип long. Это будет расширяющее преобразование, поскольку исходный тип (int) занимает в памяти 4 байта, а целевой (long) — 8 байт. Неявные расширяющие преобразования не связаны с риском потери данных и допускаются к применению. Любое значение типа int может быть сохранено в переменной типа long.

 Поскольку неявные сужающие преобразования не допускаются, для успешной компиляции этого кода необходимо явно выполнить преобразование типа данных. Явные преобразования выполняются путем приведения типов. Понятие приведения типов в языке C# описывает преобразование одного типа в другой. Чтобы гарантировать успешную компиляцию кода, необходимо использовать следующий синтаксис:

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 В третьей строке кода содержится инструкция для явного преобразования переменной `lng` типа long в тип int перед выполнением присвоения. Помните, что при сужающем преобразовании существует риск потери данных. Сужающие преобразования следует использовать с осторожностью, поскольку даже в случае успешной компиляции кода во время выполнения могут быть получены непредвиденные результаты.

 Приведенная здесь информация относится только к типам значений. При использовании типов значений вы работаете напрямую с данными, хранящимися в переменной. Тем не менее на платформе .NET Framework также используются ссылочные типы. В случае с ними вы работаете не с фактическими данными, а со ссылками на переменные. Например, к ссылочным типам относятся классы, интерфейсы и массивы. Неявные или явные преобразования между ссылочными типами не поддерживаются кроме случаев, когда компилятор допускает конкретные преобразования или реализованы соответствующие операторы преобразования.

 В следующем примере возникает ошибка CS0029:

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a>См. также

- [Операторы пользовательского преобразования](../operators/user-defined-conversion-operators.md)
