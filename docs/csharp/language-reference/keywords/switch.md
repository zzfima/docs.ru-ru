---
title: Ключевое слово switch (справочник по C#)
ms.date: 03/07/2017
f1_keywords:
- switch_CSharpKeyword
- switch
- case
- case_CSharpKeyword
helpviewer_keywords:
- switch statement [C#]
- switch keyword [C#]
- case statement [C#]
- default keyword [C#]
ms.assetid: 44bae8b8-8841-4d85-826b-8a94277daecb
ms.openlocfilehash: 4e21700b36437bf9bd60bb4f33e2833819333f1e
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33288896"
---
# <a name="switch-c-reference"></a>switch (Справочник по C#)
`switch` — это оператор выбора, который выбирает для выполнения один *раздел switch* из списка кандидатов, сравнивая их с *выражением соответствия*. 
  
 [!code-csharp[switch#1](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch1.cs#1)]  

Оператор `switch` часто используется вместо конструкции [if-else](if-else.md), если одно выражение проверяется на соответствие трем или больше условиям. Например, следующий оператор `switch` определяет, имеет ли переменная типа `Color` одно из трех значений: 

[!code-csharp[switch#3](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch3.cs#1)] 

Это эквивалентно следующему примеру, в котором используется конструкция `if` - `else`. 

[!code-csharp[switch#3a](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch3a.cs#1)] 

## <a name="the-match-expression"></a>Выражение соответствия

Выражение соответствия предоставляет значение для сравнения в шаблонами в метках `case`. Он имеет следующий синтаксис:

```csharp
   switch (expr)
```

В C# 6 выражение соответствия должно быть выражением, возвращающим значение следующих типов:

- [char](char.md);
- [string](string.md);
- [bool](bool.md); 
- целочисленное значение, например [int](int.md) или [long](long.md);
- значение [enum](enum.md).

Начиная с C# 7.0 выражение соответствия может быть любым выражением, отличным от NULL.
 
## <a name="the-switch-section"></a>Раздел switch
 
 Оператор `switch` включает один или несколько разделов switch. Каждый раздел switch содержит одну или несколько *меток case*, за которыми следует один или несколько операторов. В следующем примере показан простой оператор `switch` с тремя разделами switch. Каждый раздел switch содержит одну метку case, например `case 1:`, и два оператора.
 
  Оператор `switch` может содержать любое количество разделов switch, а каждый раздел может иметь одну или несколько меток case (как показано в следующем примере). Однако две метки case не могут содержать одно и то же выражение.  

 [!code-csharp[switch#2](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch2.cs#1)]  

 Выполняет только раздел switch в операторе switch. C# не позволяет продолжить выполнение следующего раздела switch после выполнения предыдущего раздела. В связи с этим приведенный ниже код создает ошибку компилятора CS0163: "Управление не может передаваться вниз от одной метки case (<case label>) к другой".  

```csharp  
switch (caseSwitch)  
{  
    // The following switch section causes an error.  
    case 1:  
        Console.WriteLine("Case 1...");  
        // Add a break or other jump statement here.  
    case 2:  
        Console.WriteLine("... and/or Case 2");  
        break;  
}  
```  
Обычно для соблюдения этого требования выполняется явный выход из раздела switch с использованием оператора [break](break.md), [goto](goto.md) или [return](return.md). При этом допустим также следующий код, поскольку он гарантирует, что управление программой не будет передано дальше, в раздел switch `default`.
  
 [!code-csharp[switch#4](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch4.cs#1)]    
  
 Выполнение списка операторов в разделе switch с меткой case, соответствующей выражению сопоставления, начинается с первого оператора и продолжается по списку, обычно до достижения оператора перехода, такого как `break`, `goto case`, `goto label`, `return` или `throw`. В этой точке управление передается за пределы оператора `switch` или к другой метке case. Оператор `goto`, если он используется, должен передать управление константе типа метки. Это ограничение является обязательным, поскольку попытка передачи управления переменной типа метки может иметь нежелательные побочные эффекты, такие передача управления в непредусмотренное расположение в коде или создание бесконечного цикла.

## <a name="case-labels"></a>Метки case

 Каждая метка case указывает на шаблон для сравнения с выражением сопоставления (переменная `caseSwitch` в предыдущем примере). Если они совпадают, управление передается разделу switch, который содержит **первую** соответствующую метку case. Если с выражением соответствия не совпадает ни один шаблон метки case, управление передается разделу с меткой case `default`, если такой раздел существует. Если метки case `default` нет, никакие операторы ни в одном из разделов switch не выполняются, а оператор `switch` теряет управление.

 Дополнительные сведения об операторе `switch` и сопоставлении шаблонов см. в разделе [Сопоставление шаблонов с оператором `switch`](#pattern).

 Поскольку C# 6 поддерживает только шаблон констант и не допускает повтор постоянных значений, метки case определяют взаимоисключающие значения, и выражению сопоставления может соответствовать только один шаблон. В связи с этим порядок отображения операторов `case` не имеет значения.

 Тем не менее, поскольку в C# 7.0 поддерживаются другие шаблоны, метки case не нужно определять как взаимоисключающие значения, и выражению соответствия могут соответствовать сразу несколько шаблонов. Поскольку в разделе switch выполняются только те операторы, которые содержат первый совпадающий шаблон, порядок отображения операторов `case` становится важным. Обнаружив раздел switch, оператор или операторы которого эквивалентны предыдущим операторам или являются их подмножествами, C# выдает ошибку компилятора CS8120, "Метка case оператора switch уже обработана предыдущей меткой case". 

 В следующем примере демонстрируется оператор `switch` с использованием различных не взаимоисключающих шаблонов. Если раздел switch `case 0:` перемещается и перестает быть первым разделом в операторе `switch`, C# выдает ошибку компилятора, поскольку целое число с нулевым значением представляет собой подмножество всех целых чисел — этот шаблон определен оператором `case int val`.

 [!code-csharp[switch#5](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch5.cs#1)]    

Устранить эту проблему и предупреждение компилятора можно одним из двух способов:

- изменив порядок разделов switch; 
 
- вставив предложение </a name="when">when</a> в метку `case`.
 
## <a name="the-default-case"></a>Метка case `default`

Метка case `default` указывает на раздел switch, который будет выполнен, если выражение соответствия не совпадет ни с одной другой меткой `case`. Если метки case `default` нет, а выражение соответствия не совпадает ни с одной другой меткой `case`, выполнение программы передается оператору `switch`.

Метка case `default` может отображаться в операторе `switch` в любом порядке. Она всегда оценивается последней, после оценки всех меток `case`, независимо от их порядка.

## <a name="a-namepattern--pattern-matching-with-the-switch-statement"></a>Сопоставление шаблонов <a name="pattern" /> с оператором `switch`
  
Каждый оператор `case` определяет шаблон, который в случае совпадения с выражением соответствия вызывает выполнение входящего в него раздела switch. Шаблон константы поддерживают все версии C#. Остальные шаблоны поддерживаются начиная с C# 7.0. 
  
### <a name="constant-pattern"></a>Шаблон константы 

Шаблон константы проверяет, равно ли выражение указанной константе. Он имеет следующий синтаксис:

```csharp
   case constant:
```

здесь *constant* — это значение для проверки. Значением *constant* может быть любое из следующих константных выражений: 

- литерал [bool](bool.md), `true` или `false`;
- любой целочисленный тип, такой как [int](int.md), [long](long.md) или [byte](byte.md); 
- имя объявленной переменной `const`;
- константа перечисления;
- литерал [char](char.md);
- литерал [string](string.md).

Константное выражение вычисляется следующим образом.

- Если *expr* и *constant* являются целочисленными типами, оператор равенства C# определяет, возвращает ли выражение `true` (то есть выполняется ли условие `expr == constant`).

- В противном случае значение выражения определяется с помощью вызова статического метода [Object.Equals (expr, constant)](xref:System.Object.Equals(System.Object,System.Object)).  

В следующем примере шаблон константы используется для того, чтобы определить, выпадает ли определенная дата на выходные, первый или последний рабочий день недели либо середину недели. Он сравнивает свойство <xref:System.DateTime.DayOfWeek?displayProperty=nameWithType> текущего дня с членами перечисления <xref:System.DayOfWeek>. 

[!code-csharp[switch#7](../../../../samples/snippets/csharp/language-reference/keywords/switch/const-pattern.cs#1)]

В следующем примере шаблон констант используется для обработки данных, введенных пользователем в консольное приложение, имитирующее кофейный автомат.
  
 [!code-csharp[switch#6](../../../../samples/snippets/csharp/language-reference/keywords/switch/switch6.cs)]  

### <a name="type-pattern"></a>Шаблон типа

Шаблон типа обеспечивает точное определение и преобразование типов. При использовании оператора `switch` для сопоставления шаблонов он проверяет, можно ли преобразовать выражение в указанный тип и, если это возможно, приводит его к переменной этого типа. Он имеет следующий синтаксис:

```csharp
   case type varname 
```
здесь *type* — это имя типа, в который должен быть преобразован результат *expr*, *varname* — это объект, в который преобразуется результат *expr*, если сопоставление завершается успешно. 

Выражение `case` имеет значение `true`, если выполняется одно из следующих условий:

- *expr* представляет собой экземпляр того же типа, что и *type*;

- *expr* является экземпляром типа, производного от *type*. Другими словами, результат *expr* может быть приведен с повышением к экземпляру *type*.

- *expr* имеет тип времени компиляции, который является базовым классом для *type*, и *expr* имеет тип среды выполнения, который является *type* или производным от *type*. *Тип времени компиляции* переменной представляет собой тип переменной, заданный в ее определении типа. *Тип среды выполнения* переменной представляет собой тип экземпляра, назначенный этой переменной.

- *expr* является экземпляром типа, который реализует интерфейс *type*.

Если case имеет значение true, *varname* присваивается определенным образом и получает локальную область в пределах раздела switch.

Обратите внимание на то, что `null` не соответствует типу. Для сопоставления `null` используйте следующую метку `case`:

```csharp
case null:
```
 
В следующем примере шаблон типа используется для предоставления сведений о различные видах коллекций типов.

[!code-csharp[switch#5](../../../../samples/snippets/csharp/language-reference/keywords/switch/type-pattern.cs#1)]

Без сопоставления шаблонов этот код может быть написан следующим образом. При использовании шаблона типа создается более лаконичный и удобочитаемый код, причем проверять результат преобразования (`null`) или выполнять повторное приведение не требуется.  

[!code-csharp[switch#6](../../../../samples/snippets/csharp/language-reference/keywords/switch/type-pattern2.cs#1)]

## <a name="the-case-statement-and-the-when-clause"></a>Оператор `case` и предложение `when`

Начиная с C# 7.0 операторы case необязательно должны быть взаимоисключающими. В связи с этим можно добавить предложение `when`, определяющее дополнительное условие, которому должен соответствовать оператор case, чтобы иметь значение true. Предложение `when` может быть любым выражением, возвращающим логическое значение. Чаще всего предложение `when` используется для того, чтобы запретить выполнение раздела switch, если выражение соответствия имеет значение `null`. 

 В следующем примере определяется базовый класс `Shape`, класс `Rectangle`, производный от `Shape`, и класс `Square`, производный от `Rectangle`. Предложение `when` используется в нем для того, чтобы `ShowShapeInfo` обрабатывал объект `Rectangle`, которому назначена такая же длина и ширина, как у объекта `Square`, даже если экземпляр для него не создается как объект `Square`. Метод не пытается отобразить сведения ни об объекте со значением `null`, ни о форме с нулевой областью. 

[!code-csharp[switch#8](../../../../samples/snippets/csharp/language-reference/keywords/switch/when-clause.cs#1)]
  
Обратите внимание на то, что предложение `when` в этом примере, проверяющее, имеет ли объект `Shape` значение `null`, не выполняется. Правильный шаблон пути для проверки на наличие значения `null` — `case null:`.

## <a name="c-language-specification"></a>Спецификация языка C#  
 [!INCLUDE[CSharplangspec](../../../../includes/csharplangspec-md.md)]  
  
## <a name="see-also"></a>См. также  

 [Справочник по C#](../index.md)  
 [Руководство по программированию на C#](../../programming-guide/index.md)  
 [Ключевые слова в C#](index.md)  
 [if-else](if-else.md)  
 [Соответствие шаблону](../../pattern-matching.md)  
 

 
