---
title: Описание деревьев выражений
description: Сведения о деревьях выражений и их использовании при преобразовании алгоритмов для выполнения кода во внешних средах и его проверки перед выполнением.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036995"
---
# <a name="expression-trees-explained"></a>Описание деревьев выражений

[Предыдущий раздел: "Обзор"](expression-trees.md)

Дерево выражения — это структура данных, которая определяет код. Деревья выражений основаны на тех же структурах, которые компилятор использует для анализа кода и создания скомпилированных выходных данных. По мере изучения этого раздела вы заметите много общего между деревьями выражений и типами, используемыми в API Roslyn для создания [анализаторов и исправлений кода](https://github.com/dotnet/roslyn-analyzers).
(Анализаторы и исправления кода — это пакеты NuGet, которые осуществляют статический анализ кода и могут предлагать разработчику возможные исправления.) Принципы очень схожи, а конечным результатом является структура данных, которая позволяет осмысленно изучать исходный код. Однако деревья выражений основаны на совершенно другом наборе классов и интерфейсов API, нежели API Roslyn.

Рассмотрим простой пример.
Вот строка кода:

```csharp
var sum = 1 + 2;
```

Если анализировать ее как дерево выражения, то оно содержит несколько узлов.
Внешний узел — это оператор объявления переменной с присваиванием (`var sum = 1 + 2;`). Этот внешний узел содержит несколько дочерних узлов: объявление переменной, оператор присваивания и выражение, представляющее часть справа от знака равенства. Это выражение далее делится на выражения, представляющие операцию сложения, а также ее левый и правый операнды.

Давайте немного более подробно рассмотрим выражения, составляющие часть справа от знака равенства.
Выражение имеет вид `1 + 2`. Это двоичное выражение. Если точнее, это выражение двоичного сложения. Выражение двоичного сложения имеет два дочерних элемента, представляющих левый и правый узлы выражения сложения. В этом случае оба узла являются константными выражениями: левый операнд представляет значение `1`, а правый — значение `2`.

Визуально весь оператор представляет собой дерево: вы можете начать с корневого узла и переходить к каждому узлу дерева, чтобы просмотреть код, составляющий оператор.

- Оператор объявления переменной с присваиванием (`var sum = 1 + 2;`)
  - Неявное объявление типа переменной (`var sum`)
    - Неявное ключевое слово var (`var`)
    - Объявление имени переменной (`sum`)
  - Оператор присваивания (`=`)
  - Выражение двоичного сложения (`1 + 2`)
    - Левый операнд (`1`)
    - Оператор сложения (`+`)
    - Правый операнд (`2`)

Это может показаться сложным, но это очень удобно. Тем же самым образом можно раскладывать на составные части гораздо более сложные выражения. Рассмотрим следующее выражение:

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

Приведенное выше выражение также является объявлением переменной с присваиванием.
В этом экземпляре правая часть присваивания представляет собой гораздо более сложное дерево.
Мы не будем раскладывать это выражение на составные части, но рассмотрим возможные узлы. Имеются вызовы методов, использующие текущий объект в качестве получателя: в одном случае получатель указан явно `this`; в другом нет. Имеются вызовы методов, использующие другие объекты-получатели, а также константные аргументы различных типов. Наконец, имеется оператор двоичного сложения. В зависимости от типа возвращаемого значения `SecretSauceFunction()` или `MoreSecretSauce()` оператор двоичного сложения может быть вызовом метода, адресованным к переопределенному оператору сложения, который разрешается в вызов статического метода, адресованный к оператору двоичного сложения, определенному для класса.

Несмотря на кажущуюся сложность, приведенное выше выражение образует структуру дерева, по которой можно переходить так же легко, как и в первом примере. Вы можете обходить дочерние узлы для поиска листовых узлов в выражении. Родительские узлы содержат ссылки на свои дочерние узлы, и каждый узел имеет свойство, описывающее тип этого узла.

Структура дерева выражения очень согласована. Изучив основы, вы сможете разобраться даже в самом сложном коде, если он представлен деревом выражения. Стройность структуры данных объясняет, почему компилятор C# может анализировать самые сложные программы C# и создавать правильные выходные данные на основе исходного кода.

Когда вы разберетесь в структуре деревьев выражений, полученные знания позволят вам работать с множеством еще более сложных сценариев. Деревья выражений крайне эффективны.

Помимо преобразования алгоритмов для выполнения в других средах, деревья выражений можно использовать с целью упростить написание алгоритмов, проверяющих код перед его выполнением. Можно создать метод, аргументами которого являются выражения, а затем анализировать эти выражения перед выполнением кода. Дерево выражения — это полное представление кода: вы можете просмотреть значения любого подвыражения.
Вы можете просмотреть имена методов и свойств. Вы можете узнать значение любого константного выражения.
Кроме того, вы можете преобразовать дерево выражения в исполняемый делегат, а затем выполнить код.

Интерфейсы API для деревьев выражений позволяют создавать деревья, которые представляют практически любую допустимую конструкцию кода. Однако для обеспечения максимальной простоты некоторые идиомы C# нельзя создавать в дереве выражения. Одним из примеров являются асинхронные выражения (с ключевыми словами `async` и `await`). Если требуются асинхронные алгоритмы, то необходимо работать с объектами `Task` напрямую, а не полагаться на поддержку компилятора. Другой пример — создание циклов. Как правило, они создаются с помощью операторов `for`, `foreach`, `while` и `do`. Как вы увидите [далее в этой серии](expression-trees-building.md), интерфейсы API для деревьев выражений поддерживают единственное выражение цикла, причем повторами управляют выражения `break` и `continue`.

Единственное, чего нельзя сделать, — это изменить дерево выражения.  Деревья выражений являются неизменяемыми структурами данных. Если необходимо изменить дерево выражения, следует создать копию исходного дерева и внести в нее требуемые изменения.

[Следующий раздел: "Типы платформ, поддерживающие деревья выражений"](expression-classes.md)
