---
title: Начало работы с функциями синтаксического анализа (Roslyn API)
description: Введение в обходы, отправка запросов и прохождение деревьев синтаксиса.
ms.date: 02/05/2018
ms.custom: mvc
ms.openlocfilehash: d4163e8aadf577a5a5cbed225b26a0ec8390277e
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75346999"
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="9936a-103">Начало работы с функциями синтаксического анализа</span><span class="sxs-lookup"><span data-stu-id="9936a-103">Get started with syntax analysis</span></span>

<span data-ttu-id="9936a-104">В этом учебнике рассматривается **синтаксический API**.</span><span class="sxs-lookup"><span data-stu-id="9936a-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="9936a-105">Синтаксический API предоставляет доступ к структурам данных, описывающих программы на языке C# или Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9936a-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="9936a-106">Эти структуры данных достаточно подробны, чтобы обеспечивать полное представление любой программы любого размера.</span><span class="sxs-lookup"><span data-stu-id="9936a-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="9936a-107">Эти структуры могут описывать готовые программы, обеспечивающие корректное выполнение и работу.</span><span class="sxs-lookup"><span data-stu-id="9936a-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="9936a-108">Они также могут описывать неполные программы по мере их написания в редакторе.</span><span class="sxs-lookup"><span data-stu-id="9936a-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="9936a-109">Для обеспечения такого богатого выражения структуры данных и API, составляющие синтаксический API, имеют высокую сложность.</span><span class="sxs-lookup"><span data-stu-id="9936a-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="9936a-110">Начнем с описания структуры данных для типичной программы "Hello, World!".</span><span class="sxs-lookup"><span data-stu-id="9936a-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="9936a-111">Посмотрите на текст предыдущей программы.</span><span class="sxs-lookup"><span data-stu-id="9936a-111">Look at the text of the previous program.</span></span> <span data-ttu-id="9936a-112">Вы узнаете знакомые элементы.</span><span class="sxs-lookup"><span data-stu-id="9936a-112">You recognize familiar elements.</span></span> <span data-ttu-id="9936a-113">Весь текст представляет один исходный файл, или **блок компиляции**.</span><span class="sxs-lookup"><span data-stu-id="9936a-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="9936a-114">Первые три строки этого исходного файла являются **директивами using**.</span><span class="sxs-lookup"><span data-stu-id="9936a-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="9936a-115">Остальной исходный код содержится в **объявлении пространства имен**.</span><span class="sxs-lookup"><span data-stu-id="9936a-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="9936a-116">Объявление пространства имен содержит дочернее **объявление класса**.</span><span class="sxs-lookup"><span data-stu-id="9936a-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="9936a-117">Объявление класса содержит одно **объявление метода**.</span><span class="sxs-lookup"><span data-stu-id="9936a-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="9936a-118">Синтаксический API создает древовидную структуру, корень которой представляет блок компиляции.</span><span class="sxs-lookup"><span data-stu-id="9936a-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="9936a-119">Узлы в дереве представляют директивы using, объявление пространства имен и все остальные элементы программы.</span><span class="sxs-lookup"><span data-stu-id="9936a-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="9936a-120">Структура дерева продолжается до самых нижних уровней. Строка "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="9936a-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="9936a-121">представляет собой **токен строкового литерала**, который является потомком **аргумента**.</span><span class="sxs-lookup"><span data-stu-id="9936a-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="9936a-122">Синтаксический API предоставляет доступ к структуре программы.</span><span class="sxs-lookup"><span data-stu-id="9936a-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="9936a-123">Можно создавать запросы к определенным практикам написания кода, выполнять обход всего дерева для понимания кода и создавать новые деревья путем изменения существующего дерева.</span><span class="sxs-lookup"><span data-stu-id="9936a-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="9936a-124">Это краткое описание представляет собой обзор видов сведений, к которым можно получить доступ с помощью синтаксического API.</span><span class="sxs-lookup"><span data-stu-id="9936a-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="9936a-125">Синтаксический API является не более чем формальным API, который описывает уже знакомые конструкции кода из C#.</span><span class="sxs-lookup"><span data-stu-id="9936a-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="9936a-126">Все возможности включают в себя сведения о форматировании кода, в том числе об использовании разрывов строк, пробелов и отступов.</span><span class="sxs-lookup"><span data-stu-id="9936a-126">The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.</span></span> <span data-ttu-id="9936a-127">С помощью этих сведений можно полностью представить код как написанный и прочитанный программистами или компилятором.</span><span class="sxs-lookup"><span data-stu-id="9936a-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="9936a-128">Эта структура позволяет взаимодействовать с исходным кодом на глубоко осмысленном уровне.</span><span class="sxs-lookup"><span data-stu-id="9936a-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="9936a-129">Это уже не просто строки текста, а данные, представляющие структуру программы на языке C#.</span><span class="sxs-lookup"><span data-stu-id="9936a-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="9936a-130">Чтобы приступить к работе, потребуется установить **пакет SDK для .NET Compiler Platform**:</span><span class="sxs-lookup"><span data-stu-id="9936a-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="9936a-131">Основные сведения о синтаксисе деревьев</span><span class="sxs-lookup"><span data-stu-id="9936a-131">Understanding syntax trees</span></span>

<span data-ttu-id="9936a-132">Синтаксический API используется для любого анализа структуры кода C#.</span><span class="sxs-lookup"><span data-stu-id="9936a-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="9936a-133">**Синтаксический API** предоставляет средства синтаксического анализа, деревья синтаксиса и служебные программы для анализа и создания деревьев синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="9936a-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="9936a-134">С его помощью выполняется поиск определенных элементов синтаксиса в коде или чтение кода программы.</span><span class="sxs-lookup"><span data-stu-id="9936a-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="9936a-135">Дерево синтаксиса — это структура данных, которая используется компиляторами C# и Visual Basic для понимания программ на языках C# и Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="9936a-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="9936a-136">Деревья синтаксиса создает тот же синтаксический анализатор, что выполняется при построении проекта или при нажатии на клавишу F5.</span><span class="sxs-lookup"><span data-stu-id="9936a-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="9936a-137">Деревья синтаксиса полностью соответствуют языку. Каждый бит сведений в файле кода представлен в дереве.</span><span class="sxs-lookup"><span data-stu-id="9936a-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="9936a-138">При записи дерева синтаксиса в текст воспроизводится в точности тот исходный текст, который был проанализирован.</span><span class="sxs-lookup"><span data-stu-id="9936a-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="9936a-139">Деревья синтаксиса являются **неизменяемыми**. После создания дерево синтаксиса невозможно изменить.</span><span class="sxs-lookup"><span data-stu-id="9936a-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="9936a-140">Пользователи могут анализировать деревья в нескольких потоках без блокировки и принятия других меры по обеспечению параллелизма, поскольку данные не изменяются.</span><span class="sxs-lookup"><span data-stu-id="9936a-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="9936a-141">Можно использовать API для создания новых деревьев посредством изменения существующего дерева.</span><span class="sxs-lookup"><span data-stu-id="9936a-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="9936a-142">Ниже перечислены четыре основных стандартных блока деревьев синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="9936a-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="9936a-143">Класс <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, экземпляр которого представляет дерево синтаксического анализа целиком.</span><span class="sxs-lookup"><span data-stu-id="9936a-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="9936a-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> является абстрактным классом с производными, соответствующими конкретному языку.</span><span class="sxs-lookup"><span data-stu-id="9936a-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="9936a-145">Для синтаксического анализа текста на языке C# или Visual Basic используются методы синтаксического анализа класса <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (или <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="9936a-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or Visual Basic.</span></span>
* <span data-ttu-id="9936a-146">Класс <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>, экземпляры которого представляют такие синтаксические конструкции, как объявления, инструкции, предложения и выражения.</span><span class="sxs-lookup"><span data-stu-id="9936a-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="9936a-147">Структура <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType>, которая представляет отдельные ключевые слова, идентификаторы, операторы или знаки препинания.</span><span class="sxs-lookup"><span data-stu-id="9936a-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="9936a-148">И, наконец, структура <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>, которая представляет малозначимые с точки зрения синтаксиса элементы сведений, такие как пробелы между токенами, директивы предварительной обработки и комментарии.</span><span class="sxs-lookup"><span data-stu-id="9936a-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="9936a-149">Заметки, токены и узлы иерархически компонуются для формирования дерева, которое полностью представляет все содержимое в фрагменте кода Visual Basic или C#.</span><span class="sxs-lookup"><span data-stu-id="9936a-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="9936a-150">Эту структуру можно посмотреть с помощью окна **визуализатора синтаксиса**.</span><span class="sxs-lookup"><span data-stu-id="9936a-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="9936a-151">В Visual Studio выберите **Вид** > **Другие окна** > **Визуализатор синтаксиса**.</span><span class="sxs-lookup"><span data-stu-id="9936a-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="9936a-152">Например, предыдущий исходный файл на языке C# при просмотре с помощью **визуализатора синтаксиса** выглядит, как показано на следующем рисунке.</span><span class="sxs-lookup"><span data-stu-id="9936a-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="9936a-153">**SyntaxNode**: синий текст | **SyntaxToken**: зеленый текст | **SyntaxTrivia**: красный текст ![файл с кодом C#](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="9936a-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="9936a-154">При перемещении по структуре дерева вы можете найти в файле кода все инструкции, выражения, токены и пробелы.</span><span class="sxs-lookup"><span data-stu-id="9936a-154">By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.</span></span>

<span data-ttu-id="9936a-155">С помощью синтаксического API можно найти все, что угодно, в файле кода, но большинство сценариев предусматривает исследование небольших фрагментов кода либо поиск определенных инструкций или фрагментов.</span><span class="sxs-lookup"><span data-stu-id="9936a-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="9936a-156">Ниже приводятся два примера, иллюстрирующие типичные сценарии использования для просмотра структуры кода или поиска отдельных инструкций.</span><span class="sxs-lookup"><span data-stu-id="9936a-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="9936a-157">Обход деревьев</span><span class="sxs-lookup"><span data-stu-id="9936a-157">Traversing trees</span></span>

<span data-ttu-id="9936a-158">Узлы дерева синтаксиса можно исследовать двумя способами.</span><span class="sxs-lookup"><span data-stu-id="9936a-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="9936a-159">Можно выполнить обход дерева для исследования каждого узла или выполнить запрос к определенным элементам или узлам.</span><span class="sxs-lookup"><span data-stu-id="9936a-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="9936a-160">Обход вручную</span><span class="sxs-lookup"><span data-stu-id="9936a-160">Manual traversal</span></span>

<span data-ttu-id="9936a-161">Окончательный код этого примера доступен в [репозитории на сайте GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="9936a-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="9936a-162">Типы синтаксического дерева используют наследование для описания различных элементов синтаксиса, которые являются допустимыми в разных местах в программе.</span><span class="sxs-lookup"><span data-stu-id="9936a-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="9936a-163">Применение этих API часто означает приведение свойств или элементов коллекции к конкретным производным типам.</span><span class="sxs-lookup"><span data-stu-id="9936a-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="9936a-164">В следующих примерах назначения и приведения являются отдельными инструкциями, использующими явно типизированные переменные.</span><span class="sxs-lookup"><span data-stu-id="9936a-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="9936a-165">Прочитайте код, чтобы увидеть типы возвращаемых значений API и тип среды выполнения возвращаемых объектов.</span><span class="sxs-lookup"><span data-stu-id="9936a-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="9936a-166">На практике более распространено использование неявно типизированных переменных и имен API для описания типа рассматриваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="9936a-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="9936a-167">Создайте новый проект C# для **автономного средства анализа кода**:</span><span class="sxs-lookup"><span data-stu-id="9936a-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="9936a-168">В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**, чтобы открыть диалоговое окно "Новый проект".</span><span class="sxs-lookup"><span data-stu-id="9936a-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="9936a-169">В разделе **Visual C#**  > **Расширяемость** выберите **Автономное средство анализа кода**.</span><span class="sxs-lookup"><span data-stu-id="9936a-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="9936a-170">Присвойте проекту имя "**SyntaxTreeManualTraversal**" и нажмите кнопку ОК.</span><span class="sxs-lookup"><span data-stu-id="9936a-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="9936a-171">Вы будете анализировать программу "Hello World!",</span><span class="sxs-lookup"><span data-stu-id="9936a-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="9936a-172">показанную ранее.</span><span class="sxs-lookup"><span data-stu-id="9936a-172">program shown earlier.</span></span>
<span data-ttu-id="9936a-173">Добавьте текст для программы "Hello World" в качестве константы в класс `Program`:</span><span class="sxs-lookup"><span data-stu-id="9936a-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="9936a-174">Затем добавьте в константу `programText` следующий код для создания **дерева синтаксиса** для текста кода.</span><span class="sxs-lookup"><span data-stu-id="9936a-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="9936a-175">Добавьте следующую строку в метод `Main`:</span><span class="sxs-lookup"><span data-stu-id="9936a-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="9936a-176">Эти две строки создают дерево и извлекают корневой узел этого дерева.</span><span class="sxs-lookup"><span data-stu-id="9936a-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="9936a-177">Теперь можно исследовать узлы в дереве.</span><span class="sxs-lookup"><span data-stu-id="9936a-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="9936a-178">Добавьте следующие строки в метод `Main` для отображения некоторых свойств корневого узла дерева:</span><span class="sxs-lookup"><span data-stu-id="9936a-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="9936a-179">Запустите приложение для просмотра сведений, которые код собрал о корневом узле этого дерева.</span><span class="sxs-lookup"><span data-stu-id="9936a-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="9936a-180">Как правило, для получения сведений о коде выполняется обход дерева.</span><span class="sxs-lookup"><span data-stu-id="9936a-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="9936a-181">В этом примере анализируется известный вам код для изучения API.</span><span class="sxs-lookup"><span data-stu-id="9936a-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="9936a-182">Добавьте следующий код для исследования первого элемента узла `root`:</span><span class="sxs-lookup"><span data-stu-id="9936a-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="9936a-183">Этот элемент — <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9936a-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9936a-184">Он представляет все, что входит в объявление `namespace HelloWorld`.</span><span class="sxs-lookup"><span data-stu-id="9936a-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="9936a-185">Добавьте следующий код, чтобы посмотреть, какие узлы объявляются внутри пространства имен `HelloWorld`:</span><span class="sxs-lookup"><span data-stu-id="9936a-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="9936a-186">Запустите программу, чтобы посмотреть, что вы узнали.</span><span class="sxs-lookup"><span data-stu-id="9936a-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="9936a-187">Теперь, когда известно, что объявление является <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, объявите новую переменную этого типа для исследования объявления класса.</span><span class="sxs-lookup"><span data-stu-id="9936a-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="9936a-188">Этот класс содержит только один элемент: метод `Main`.</span><span class="sxs-lookup"><span data-stu-id="9936a-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="9936a-189">Добавьте следующий код, чтобы найти метод `Main`, и приведите его к <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9936a-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="9936a-190">Узел объявления метода содержит полные синтаксические сведения о методе.</span><span class="sxs-lookup"><span data-stu-id="9936a-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="9936a-191">Давайте посмотрим тип возвращаемого значения для метода `Main`, количество и типы аргументов, а также основной текст метода.</span><span class="sxs-lookup"><span data-stu-id="9936a-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="9936a-192">Добавьте следующий код:</span><span class="sxs-lookup"><span data-stu-id="9936a-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="9936a-193">Запустите программу, чтобы просмотреть все полученные сведения об этой программе:</span><span class="sxs-lookup"><span data-stu-id="9936a-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="9936a-194">Методы запросов</span><span class="sxs-lookup"><span data-stu-id="9936a-194">Query methods</span></span>

<span data-ttu-id="9936a-195">Помимо обхода деревьев можно также исследовать деревья синтаксиса с помощью методов запросов, определенных в <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9936a-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9936a-196">Эти методы известны всем, кто знаком с XPath.</span><span class="sxs-lookup"><span data-stu-id="9936a-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="9936a-197">Эти методы можно использовать совместно с LINQ для быстрого поиска в дереве.</span><span class="sxs-lookup"><span data-stu-id="9936a-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="9936a-198"><xref:Microsoft.CodeAnalysis.SyntaxNode> содержит такие методы запросов, как <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> и <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span><span class="sxs-lookup"><span data-stu-id="9936a-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="9936a-199">Эти методы запроса можно использовать для поиска аргументов к методу `Main` в качестве альтернативы навигации по дереву.</span><span class="sxs-lookup"><span data-stu-id="9936a-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="9936a-200">Добавьте следующий код в конец метода `Main`:</span><span class="sxs-lookup"><span data-stu-id="9936a-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="9936a-201">В первой инструкции используется выражение LINQ и метод <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> для обнаружения того же параметра, что и в предыдущем примере.</span><span class="sxs-lookup"><span data-stu-id="9936a-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="9936a-202">Запустите программу, и выражение LINQ обнаружит тот же параметр, что и при навигации по дереву вручную.</span><span class="sxs-lookup"><span data-stu-id="9936a-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="9936a-203">В этом образце используются инструкции `WriteLine` для отображения сведений о деревьях синтаксиса по мере их обхода.</span><span class="sxs-lookup"><span data-stu-id="9936a-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="9936a-204">Гораздо больше сведений можно получить, запустив готовую программу в отладчике.</span><span class="sxs-lookup"><span data-stu-id="9936a-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="9936a-205">Можно просмотреть другие свойства и методы в составе дерева синтаксиса, созданного для программы "hello world".</span><span class="sxs-lookup"><span data-stu-id="9936a-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="9936a-206">Средства обхода синтаксиса</span><span class="sxs-lookup"><span data-stu-id="9936a-206">Syntax walkers</span></span>

<span data-ttu-id="9936a-207">Часто бывает необходимо найти все узлы определенного типа в дереве синтаксиса, например каждое объявление свойств в файле.</span><span class="sxs-lookup"><span data-stu-id="9936a-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="9936a-208">Путем расширения класса <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> и переопределения метода <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> можно обработать каждое объявление свойств в дереве синтаксиса, не зная заранее его структуры.</span><span class="sxs-lookup"><span data-stu-id="9936a-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="9936a-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> — это особый тип <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor>, который рекурсивно обходит узел и все его дочерние элементы.</span><span class="sxs-lookup"><span data-stu-id="9936a-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="9936a-210">Этот пример реализует <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> для исследования дерева синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="9936a-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="9936a-211">Он собирает обнаруженные директивы `using`, которые не импортируют пространство имен `System`.</span><span class="sxs-lookup"><span data-stu-id="9936a-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="9936a-212">Создайте новый проект C# для **автономного средства анализа кода**. Присвойте ему имя "**SyntaxWalker**".</span><span class="sxs-lookup"><span data-stu-id="9936a-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="9936a-213">Окончательный код этого примера доступен в [репозитории на сайте GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="9936a-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="9936a-214">Пример на GitHub содержит оба проекта, описанные в этом учебнике.</span><span class="sxs-lookup"><span data-stu-id="9936a-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="9936a-215">Как показано в предыдущем примере, можно определить строковую константу, которая будет содержать текст программы для анализа:</span><span class="sxs-lookup"><span data-stu-id="9936a-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="9936a-216">Этот исходный текст содержит директивы `using`, расположенные в четырех разных местах: на уровне файлов, в пространстве имен верхнего уровня и в двух вложенных пространствах имен.</span><span class="sxs-lookup"><span data-stu-id="9936a-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="9936a-217">В этом примере представлен основной сценарий использования класса <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> для выполнения запросов к коду.</span><span class="sxs-lookup"><span data-stu-id="9936a-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="9936a-218">Было бы сложно посетить каждый узел в корневом дереве синтаксиса для поиска объявлений using.</span><span class="sxs-lookup"><span data-stu-id="9936a-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="9936a-219">Вместо этого создается производный класс и переопределяется метод, который вызывается только в том случае, когда текущий узел в дереве является директивой using.</span><span class="sxs-lookup"><span data-stu-id="9936a-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="9936a-220">Обходчик не работает с узлами других типов.</span><span class="sxs-lookup"><span data-stu-id="9936a-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="9936a-221">Этот единичный метод проверяет каждую из инструкций `using` и создает коллекцию пространств имен, которые не входят в пространство имен `System`.</span><span class="sxs-lookup"><span data-stu-id="9936a-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="9936a-222">Создается <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> для проверки всех инструкций `using`, но только инструкций `using`.</span><span class="sxs-lookup"><span data-stu-id="9936a-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="9936a-223">Теперь, когда вы определили текст программы, необходимо создать `SyntaxTree` и получить корень этого дерева:</span><span class="sxs-lookup"><span data-stu-id="9936a-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="9936a-224">Теперь создайте новый класс.</span><span class="sxs-lookup"><span data-stu-id="9936a-224">Next, create a new class.</span></span> <span data-ttu-id="9936a-225">В Visual Studio выберите **Проект** > **Добавить новый элемент**.</span><span class="sxs-lookup"><span data-stu-id="9936a-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="9936a-226">В диалоге **Добавление нового элемента** введите имя файла *UsingCollector.cs*.</span><span class="sxs-lookup"><span data-stu-id="9936a-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="9936a-227">Вы реализуете функцию обходчика `using` в классе `UsingCollector`.</span><span class="sxs-lookup"><span data-stu-id="9936a-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="9936a-228">Для начала сделайте класс `UsingCollector` производным от <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span><span class="sxs-lookup"><span data-stu-id="9936a-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="9936a-229">Потребуется хранилище для хранения узлов пространства имен, которые вы будете собирать.</span><span class="sxs-lookup"><span data-stu-id="9936a-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="9936a-230">Объявите свойство только для чтения в классе `UsingCollector`. Эта переменная будет использоваться для хранения найденных узлов <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax>:</span><span class="sxs-lookup"><span data-stu-id="9936a-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="9936a-231">Базовый класс, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>, реализует логику для посещения каждого узла в дереве синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="9936a-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="9936a-232">Производный класс переопределяет методы, вызываемые для определенных интересующих вас узлов.</span><span class="sxs-lookup"><span data-stu-id="9936a-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="9936a-233">В этом примере вас интересует любая директива `using`.</span><span class="sxs-lookup"><span data-stu-id="9936a-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="9936a-234">Это означает, что требуется переопределить метод <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>.</span><span class="sxs-lookup"><span data-stu-id="9936a-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="9936a-235">Единственный аргумент этого метода — объект <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9936a-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="9936a-236">Это важное преимущество обходчиков: они вызывают переопределенные методы с использованием аргументов, уже приведенных к типу конкретного узла.</span><span class="sxs-lookup"><span data-stu-id="9936a-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="9936a-237">Класс <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> имеет свойство <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name>, которое содержит имя импортируемого пространства имен.</span><span class="sxs-lookup"><span data-stu-id="9936a-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="9936a-238">Это <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9936a-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9936a-239">Добавьте следующий код в переопределение <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>:</span><span class="sxs-lookup"><span data-stu-id="9936a-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="9936a-240">Как и в прошлом примере, были добавлены разнообразные инструкции `WriteLine` для облегчения понимания этого метода.</span><span class="sxs-lookup"><span data-stu-id="9936a-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="9936a-241">Вы можете посмотреть, когда он вызывается и какие при этом передаются аргументы.</span><span class="sxs-lookup"><span data-stu-id="9936a-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="9936a-242">Наконец, необходимо добавить две строки кода для создания `UsingCollector` и направить его в корневой узел для сбора всех инструкций `using`.</span><span class="sxs-lookup"><span data-stu-id="9936a-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="9936a-243">Затем добавьте цикл `foreach` для отображения всех инструкций `using`, найденных сборщиком:</span><span class="sxs-lookup"><span data-stu-id="9936a-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="9936a-244">Скомпилируйте и запустите программу.</span><span class="sxs-lookup"><span data-stu-id="9936a-244">Compile and run the program.</span></span> <span data-ttu-id="9936a-245">Должны выводиться следующие данные:</span><span class="sxs-lookup"><span data-stu-id="9936a-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="9936a-246">Поздравляем!</span><span class="sxs-lookup"><span data-stu-id="9936a-246">Congratulations!</span></span> <span data-ttu-id="9936a-247">Вы использовали **синтаксический API** для поиска определенных типов инструкций и объявлений C# в исходном коде C#.</span><span class="sxs-lookup"><span data-stu-id="9936a-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
