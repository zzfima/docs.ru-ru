---
title: Начало работы с семантическим анализом
description: В этом учебнике содержатся общие сведения о работе с семантическим анализом с помощью пакета SDK для компилятора .NET.
ms.date: 02/06/2018
ms.custom: mvc
ms.openlocfilehash: a6dcaeeb86acb5c0e1602f01dc5952ffd9d5e3f5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240515"
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="88244-103">Начало работы с семантическим анализом</span><span class="sxs-lookup"><span data-stu-id="88244-103">Get started with semantic analysis</span></span>

<span data-ttu-id="88244-104">В учебнике предполагается, что вы знакомы с синтаксическим API.</span><span class="sxs-lookup"><span data-stu-id="88244-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="88244-105">Вводные сведения можно найти в статье о [начале работы с синтаксическим анализом](syntax-analysis.md).</span><span class="sxs-lookup"><span data-stu-id="88244-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="88244-106">В этом учебнике вы изучите **символы** и **API привязки**.</span><span class="sxs-lookup"><span data-stu-id="88244-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="88244-107">Эти API предоставляют сведения о _семантическом значении_ программы.</span><span class="sxs-lookup"><span data-stu-id="88244-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="88244-108">Они позволяют задавать вопросы, касающиеся типов, представленных любыми символами в программе, и получать на них ответы.</span><span class="sxs-lookup"><span data-stu-id="88244-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

<span data-ttu-id="88244-109">Вам нужно установить **пакет SDK для .NET Compiler Platform**:</span><span class="sxs-lookup"><span data-stu-id="88244-109">You'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="88244-110">Общие сведения о компиляциях и символах</span><span class="sxs-lookup"><span data-stu-id="88244-110">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="88244-111">В процессе работы с пакетом SDK для компилятора .NET вы узнаете различия между синтаксическим API и семантическим API.</span><span class="sxs-lookup"><span data-stu-id="88244-111">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="88244-112">**Синтаксический API** позволяет получить представление о _структуре_ программы.</span><span class="sxs-lookup"><span data-stu-id="88244-112">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="88244-113">Однако часто требуются более полные сведения о семантике или _значении_ программы.</span><span class="sxs-lookup"><span data-stu-id="88244-113">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="88244-114">Хотя синтаксический анализ свободного файла либо фрагмента кода Visual Basic или C# можно выполнить изолированно, задавать вопросы, к примеру о типе переменной, в отрыве от реальности не имеет смысла.</span><span class="sxs-lookup"><span data-stu-id="88244-114">While a loose code file or snippet of Visual Basic or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="88244-115">Значение имени типа может зависеть от ссылок на сборки, операций импорта пространств имен или других файлов кода.</span><span class="sxs-lookup"><span data-stu-id="88244-115">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="88244-116">Ответы на эти вопросы можно получить с помощью **семантического API**, в частности класса <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="88244-116">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="88244-117">Экземпляр <xref:Microsoft.CodeAnalysis.Compilation> является аналогом отдельного проекта с точки зрения компилятора и представляет все необходимое для компиляции программы Visual Basic или C#.</span><span class="sxs-lookup"><span data-stu-id="88244-117">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="88244-118">**Компиляция** включает в себя набор компилируемых исходных файлов, ссылки на сборки и параметры компилятора.</span><span class="sxs-lookup"><span data-stu-id="88244-118">The **compilation** includes the set of source files to be compiled, assembly references, and compiler options.</span></span> <span data-ttu-id="88244-119">О значении кода можно рассуждать, используя в этом контексте все остальные сведения.</span><span class="sxs-lookup"><span data-stu-id="88244-119">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="88244-120"><xref:Microsoft.CodeAnalysis.Compilation> позволяет находить **символы** — сущности, такие как типы, пространства имен, члены и переменные, на которые указывают имена и другие выражения.</span><span class="sxs-lookup"><span data-stu-id="88244-120">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="88244-121">Процесс связывания имен и выражений с **символами** называется **привязкой**.</span><span class="sxs-lookup"><span data-stu-id="88244-121">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="88244-122">Как <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> является абстрактным классом с производными, соответствующими конкретному языку.</span><span class="sxs-lookup"><span data-stu-id="88244-122">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="88244-123">При создании экземпляра компиляции необходимо вызвать фабричный метод в классе <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (или <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="88244-123">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="88244-124">Выполнение запросов к символам</span><span class="sxs-lookup"><span data-stu-id="88244-124">Querying symbols</span></span>

<span data-ttu-id="88244-125">В этом учебнике мы снова обратимся к программе "Hello, World!".</span><span class="sxs-lookup"><span data-stu-id="88244-125">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="88244-126">На этот раз вы будете запрашивать символы в программе, чтобы понять, какие типы они представляют.</span><span class="sxs-lookup"><span data-stu-id="88244-126">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="88244-127">Вы будете запрашивать типы в пространстве имен и узнаете, как найти методы, доступные для типа.</span><span class="sxs-lookup"><span data-stu-id="88244-127">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

<span data-ttu-id="88244-128">Окончательный код этого примера доступен в [репозитории на сайте GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="88244-128">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="88244-129">Типы синтаксического дерева используют наследование для описания различных элементов синтаксиса, которые являются допустимыми в разных местах в программе.</span><span class="sxs-lookup"><span data-stu-id="88244-129">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="88244-130">Применение этих API часто означает приведение свойств или элементов коллекции к конкретным производным типам.</span><span class="sxs-lookup"><span data-stu-id="88244-130">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="88244-131">В следующих примерах назначения и приведения являются отдельными инструкциями, использующими явно типизированные переменные.</span><span class="sxs-lookup"><span data-stu-id="88244-131">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="88244-132">Прочитайте код, чтобы увидеть типы возвращаемых значений API и тип среды выполнения возвращаемых объектов.</span><span class="sxs-lookup"><span data-stu-id="88244-132">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="88244-133">На практике более распространено использование неявно типизированных переменных и имен API для описания типа рассматриваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="88244-133">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="88244-134">Создайте новый проект C# для **автономного средства анализа кода**:</span><span class="sxs-lookup"><span data-stu-id="88244-134">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="88244-135">В Visual Studio последовательно выберите **Файл** > **Создать** > **Проект**, чтобы открыть диалоговое окно "Новый проект".</span><span class="sxs-lookup"><span data-stu-id="88244-135">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="88244-136">В разделе **Visual C#**  > **Расширяемость** выберите **Автономное средство анализа кода**.</span><span class="sxs-lookup"><span data-stu-id="88244-136">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="88244-137">Присвойте проекту имя "**SemanticQuickStart**" и нажмите кнопку "ОК".</span><span class="sxs-lookup"><span data-stu-id="88244-137">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="88244-138">Вы будете анализировать программу "Hello World!",</span><span class="sxs-lookup"><span data-stu-id="88244-138">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="88244-139">показанную ранее.</span><span class="sxs-lookup"><span data-stu-id="88244-139">program shown earlier.</span></span>
<span data-ttu-id="88244-140">Добавьте текст для программы "Hello World" в качестве константы в класс `Program`:</span><span class="sxs-lookup"><span data-stu-id="88244-140">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="88244-141">Затем добавьте в константу `programText` следующий код для создания дерева синтаксиса для текста кода.</span><span class="sxs-lookup"><span data-stu-id="88244-141">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="88244-142">Добавьте следующую строку в метод `Main`:</span><span class="sxs-lookup"><span data-stu-id="88244-142">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="88244-143">Далее постройте <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> из уже созданного дерева.</span><span class="sxs-lookup"><span data-stu-id="88244-143">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="88244-144">В примере "Hello World!" используются типы <xref:System.String> и <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="88244-144">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="88244-145">Необходимо сослаться на сборку, объявляющую эти два типа при компиляции.</span><span class="sxs-lookup"><span data-stu-id="88244-145">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="88244-146">Добавьте следующую строку в метод `Main` для создания компиляции дерева синтаксиса, включая ссылку на соответствующую сборку:</span><span class="sxs-lookup"><span data-stu-id="88244-146">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="88244-147">Метод <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> добавит ссылки на компиляцию.</span><span class="sxs-lookup"><span data-stu-id="88244-147">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="88244-148">Метод <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> загрузит сборку как ссылку.</span><span class="sxs-lookup"><span data-stu-id="88244-148">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference.</span></span>

## <a name="querying-the-semantic-model"></a><span data-ttu-id="88244-149">Выполнение запросов к семантической модели</span><span class="sxs-lookup"><span data-stu-id="88244-149">Querying the semantic model</span></span>

<span data-ttu-id="88244-150">К существующему объекту <xref:Microsoft.CodeAnalysis.Compilation> можно отправить запрос на класс <xref:Microsoft.CodeAnalysis.SemanticModel> для любого класса <xref:Microsoft.CodeAnalysis.SyntaxTree>, содержащегося в этом объекте <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="88244-150">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="88244-151">Семантическую модель можно представить как источник всей информации, которая обычно доступна из IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="88244-151">You can think of the semantic model as the source for all the information you would normally get from intellisense.</span></span> <span data-ttu-id="88244-152"><xref:Microsoft.CodeAnalysis.SemanticModel> может ответить, какие имена находятся в области в том или ином расположении, какие элементы доступны в определенном методе, какие переменные используются в неком блоке текста, на что ссылается некое имя или выражение, а также на другие подобные вопросы.</span><span class="sxs-lookup"><span data-stu-id="88244-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?", "What members are accessible from this method?", "What variables are used in this block of text?", and "What does this name/expression refer to?"</span></span> <span data-ttu-id="88244-153">Добавьте этот оператор для создания семантической модели:</span><span class="sxs-lookup"><span data-stu-id="88244-153">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="88244-154">Привязка имени</span><span class="sxs-lookup"><span data-stu-id="88244-154">Binding a name</span></span>

<span data-ttu-id="88244-155"><xref:Microsoft.CodeAnalysis.Compilation> создает <xref:Microsoft.CodeAnalysis.SemanticModel> из <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="88244-155">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="88244-156">После создания модели можно выполнить запрос на поиск первой директивы `using` и получение сведений о символах для пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="88244-156">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="88244-157">Добавьте следующие две строки в метод `Main` для создания семантической модели и получения символа для первого оператора using:</span><span class="sxs-lookup"><span data-stu-id="88244-157">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="88244-158">В предыдущем коде показано, как привязать имя в первой директиве `using`, чтобы получить <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> для пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="88244-158">The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="88244-159">В предыдущем коде также демонстрируется, что для поиска структуры кода используется **синтаксическая модель**, а для понимания ее значения — **семантическая модель**.</span><span class="sxs-lookup"><span data-stu-id="88244-159">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="88244-160">**Синтаксическая модель** находит строку `System` в операторе using.</span><span class="sxs-lookup"><span data-stu-id="88244-160">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="88244-161">**Семантическая модель** располагает всеми сведениями о типах, определенных в пространстве имен `System`.</span><span class="sxs-lookup"><span data-stu-id="88244-161">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="88244-162">Из объекта <xref:Microsoft.CodeAnalysis.SymbolInfo> можно получить интерфейс <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> с помощью свойства <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="88244-162">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="88244-163">Это свойство возвращает символ, на который ссылается это выражение.</span><span class="sxs-lookup"><span data-stu-id="88244-163">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="88244-164">Для выражений, не ссылающихся ни на какие объекты (например, числовые литералы), это свойство имеет значение `null`.</span><span class="sxs-lookup"><span data-stu-id="88244-164">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="88244-165">Если <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> не задано значение NULL, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> обозначает тип символа.</span><span class="sxs-lookup"><span data-stu-id="88244-165">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="88244-166">В этом примере свойству <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> присваивается значение <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="88244-166">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="88244-167">Добавьте приведенный ниже код в метод `Main`.</span><span class="sxs-lookup"><span data-stu-id="88244-167">Add the following code to your `Main` method.</span></span> <span data-ttu-id="88244-168">Он возвращает символ для пространства имен `System`, а затем отображает все дочерние пространства имен, объявленные в пространстве имен `System`:</span><span class="sxs-lookup"><span data-stu-id="88244-168">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="88244-169">Запустите программу. Вы должны увидеть следующие результаты:</span><span class="sxs-lookup"><span data-stu-id="88244-169">Run the program and you should see the following output:</span></span>

```output
System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="88244-170">Выходные данные не содержат каждое пространство имен, имеющее дочернее пространство имен от пространства имен `System`.</span><span class="sxs-lookup"><span data-stu-id="88244-170">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="88244-171">В них отображается каждое пространство имен, которое присутствует в этой компиляции и ссылается только на сборку, где объявлено `System.String`.</span><span class="sxs-lookup"><span data-stu-id="88244-171">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="88244-172">Этой компиляции неизвестно о пространствах имен, объявленных в других сборках.</span><span class="sxs-lookup"><span data-stu-id="88244-172">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="88244-173">Привязка выражения</span><span class="sxs-lookup"><span data-stu-id="88244-173">Binding an expression</span></span>

<span data-ttu-id="88244-174">В предыдущем коде показано, как найти символ путем привязки к имени.</span><span class="sxs-lookup"><span data-stu-id="88244-174">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="88244-175">В программе C# существуют и другие не являющиеся именами выражения, которые можно привязать.</span><span class="sxs-lookup"><span data-stu-id="88244-175">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="88244-176">Чтобы продемонстрировать эту возможность, выполним привязку к простому строковому литералу.</span><span class="sxs-lookup"><span data-stu-id="88244-176">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="88244-177">Программа "Hello World" содержит класс <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, строку "Hello World",</span><span class="sxs-lookup"><span data-stu-id="88244-177">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="88244-178">отображаемую в консоли.</span><span class="sxs-lookup"><span data-stu-id="88244-178">string displayed to the console.</span></span>

<span data-ttu-id="88244-179">Строку "Hello World"</span><span class="sxs-lookup"><span data-stu-id="88244-179">You find the "Hello, World!"</span></span> <span data-ttu-id="88244-180">можно найти путем поиска одного строкового литерала в программе.</span><span class="sxs-lookup"><span data-stu-id="88244-180">string by locating the single string literal in the program.</span></span> <span data-ttu-id="88244-181">Затем после обнаружения узла синтаксиса получите сведения о типе для этого узла из семантической модели.</span><span class="sxs-lookup"><span data-stu-id="88244-181">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="88244-182">Добавьте приведенный ниже код в метод `Main`:</span><span class="sxs-lookup"><span data-stu-id="88244-182">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="88244-183">Структура <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> содержит свойство <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType>, которое обеспечивает доступ к семантическим сведениям о типе литерала.</span><span class="sxs-lookup"><span data-stu-id="88244-183">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="88244-184">В этом примере типом является `string`.</span><span class="sxs-lookup"><span data-stu-id="88244-184">In this example, that's the `string` type.</span></span> <span data-ttu-id="88244-185">Добавьте объявление, которое присваивает это свойство локальной переменной:</span><span class="sxs-lookup"><span data-stu-id="88244-185">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="88244-186">Чтобы завершить действия в этом учебнике, сформируем запрос LINQ, который создает последовательность всех открытых методов, объявленных в типе `string` и возвращающих `string`.</span><span class="sxs-lookup"><span data-stu-id="88244-186">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="88244-187">Поскольку запрос сложный, мы будем создавать его построчно, а затем перестроим в один запрос.</span><span class="sxs-lookup"><span data-stu-id="88244-187">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="88244-188">Источником для этого запроса является последовательность всех элементов, объявленных в типе `string`:</span><span class="sxs-lookup"><span data-stu-id="88244-188">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="88244-189">Эта исходная последовательность содержит все элементы, включая свойства и поля, поэтому ее нужно отфильтровать с помощью метода <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType>, чтобы найти элементы, которые являются объектами <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="88244-189">That source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="88244-190">Затем добавьте другой фильтр, чтобы вернуть только открытые методы, возвращающие `string`:</span><span class="sxs-lookup"><span data-stu-id="88244-190">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="88244-191">Выберите только свойство имени и только уникальные имена, удаляя все перегрузки:</span><span class="sxs-lookup"><span data-stu-id="88244-191">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="88244-192">Можно также создать полный запрос с помощью синтаксиса запросов LINQ и затем отобразить имена всех методов в консоли:</span><span class="sxs-lookup"><span data-stu-id="88244-192">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#13 "Build and display the results of the query.")]

<span data-ttu-id="88244-193">Постройте и запустите программу.</span><span class="sxs-lookup"><span data-stu-id="88244-193">Build and run the program.</span></span> <span data-ttu-id="88244-194">Вы должны увидеть следующий результат.</span><span class="sxs-lookup"><span data-stu-id="88244-194">You should see the following output:</span></span>

```output
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```

<span data-ttu-id="88244-195">Вы использовали семантический API для поиска и отображения сведений о символах, которые являются частью этой программы.</span><span class="sxs-lookup"><span data-stu-id="88244-195">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
