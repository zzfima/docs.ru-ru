---
title: Типы кортежей — руководство по C#
description: Сведения о типах именованных и неименованных кортежей в C#
ms.date: 05/15/2018
ms.technology: csharp-fundamentals
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: f551a1df4a31c3311119a0327e02fbc6096ce0a0
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73039724"
---
# <a name="c-tuple-types"></a><span data-ttu-id="2cbd1-103">Типы кортежей в C#</span><span class="sxs-lookup"><span data-stu-id="2cbd1-103">C# tuple types</span></span>

<span data-ttu-id="2cbd1-104">Кортежи в C# — эти типы, которые определяются с помощью упрощенного синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="2cbd1-105">Преимущества: более простой синтаксис, правила преобразований с учетом количества (так называемой кратности) и типов элементов, а также единые правила для копий, тестов на равенство и назначений.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="2cbd1-106">При этом кортежи не поддерживают некоторые объектно-ориентированные идиомы, связанные с наследованием.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="2cbd1-107">Общие сведения см. в разделе "Кортежи" статьи [Новые возможности C# 7.0](whats-new/csharp-7.md#tuples).</span><span class="sxs-lookup"><span data-stu-id="2cbd1-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="2cbd1-108">В этой статье вы узнаете, какие правила языка регулируют кортежи в C# версии 7.0 и более поздних и каким образом их можно использовать, а также получите вводные рекомендации по работе с кортежами.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="2cbd1-109">Для новых функций кортежа требуются типы <xref:System.ValueTuple>.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="2cbd1-110">Для использования на платформах, которые не включают эти типы, необходимо добавить пакет NuGet [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/).</span><span class="sxs-lookup"><span data-stu-id="2cbd1-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="2cbd1-111">Это похоже на другие функции языка, использующие типы, предоставляемые на платформе.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="2cbd1-112">В качестве примеров можно привести функции `async` и `await`, использующие интерфейс `INotifyCompletion`, а также LINQ на базе `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="2cbd1-113">Тем не менее по мере увеличения степени независимости .NET от платформы механизм доставки изменяется.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="2cbd1-114">Периодичность поставки новых выпусков .NET Framework не всегда совпадает с выпусками обновлений для компилятора языка.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="2cbd1-115">Если новые функции языка используют новые типы, эти типы будут предоставляться в виде пакетов NuGet при выпуске таких новых функций.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="2cbd1-116">Как только эти новые типы будут добавлены в стандартный API-интерфейс .NET и включены в состав платформы, требование обязательно использовать пакет NuGet будет снято.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="2cbd1-117">Для начала обсудим, почему была добавлена поддержка кортежей.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="2cbd1-118">Методы возвращают один объект.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-118">Methods return a single object.</span></span> <span data-ttu-id="2cbd1-119">Кортежи позволяют легко упаковать в этот объект сразу несколько значений.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="2cbd1-120">Платформа .NET Framework уже включает универсальные классы `Tuple`,</span><span class="sxs-lookup"><span data-stu-id="2cbd1-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="2cbd1-121">которые, однако, имеют два серьезных ограничения.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="2cbd1-122">Например, классы `Tuple` присваивают своим свойствам имена `Item1`, `Item2` и т. д.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="2cbd1-123">Никакой семантической информации в этих именах нет.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-123">Those names carry no semantic information.</span></span> <span data-ttu-id="2cbd1-124">Эти типы `Tuple` не позволяют сообщить пользователю значение каждого из свойств.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="2cbd1-125">Новые функции языка позволяют объявить и использовать семантически значимые имена для элементов в кортеже.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="2cbd1-126">Классы `Tuple` вызывают несколько проблем с производительностью, так как они имеют ссылочный тип.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="2cbd1-127">При использовании типов `Tuple` происходит распределение объектов.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="2cbd1-128">В критических путях выделение множества небольших объектов может заметно влиять на производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="2cbd1-129">Следовательно, при поддержке языков для кортежей используются новые структуры `ValueTuple`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="2cbd1-130">Чтобы избежать этих недостатков, можно создать `class` или `struct`, включающие несколько элементов.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="2cbd1-131">К сожалению, это означает дополнительную работу и искажает цель вашего проекта.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="2cbd1-132">Создание `struct` или `class` означает, что определение типа включает и данные, и поведение.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="2cbd1-133">Во многих случаях все, что вам нужно, — это сохранить в одном объекте несколько значений.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="2cbd1-134">Возможности языка и универсальные структуры `ValueTuple` обеспечивают соблюдение правила, запрещающего добавлять поведение (методы) в эти типы кортежей.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="2cbd1-135">Все типы `ValueTuple` представляют собой *изменяемые структуры*.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="2cbd1-136">Все поля членов открыты,</span><span class="sxs-lookup"><span data-stu-id="2cbd1-136">Each member field is a public field.</span></span> <span data-ttu-id="2cbd1-137">что делает их очень простыми.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-137">That makes them very lightweight.</span></span> <span data-ttu-id="2cbd1-138">В то же время это означает, что кортежи не стоит использовать в случаях, когда важна неизменность.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="2cbd1-139">Кортежи — это более простые и более гибкие контейнеры данных, чем типы `class` и `struct`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="2cbd1-140">Рассмотрим эти различия.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="2cbd1-141">Именованные и неименованные кортежи</span><span class="sxs-lookup"><span data-stu-id="2cbd1-141">Named and unnamed tuples</span></span>

<span data-ttu-id="2cbd1-142">Структура `ValueTuple` включает поля с именами `Item1`, `Item2`, `Item3` и т. д., аналогичные свойствам, определенным в существующих типах `Tuple`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="2cbd1-143">Только эти имена можно использовать для *неименованных кортежей*.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="2cbd1-144">Если никакие альтернативные имена полей кортежу не предоставлены, значит, вы создали неименованный кортеж:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="2cbd1-145">Кортеж в предыдущем примере был инициализирован с помощью констант-литералов, и в нем не будут созданы имена элементов с помощью *проекций имен полей кортежа* на C# 7.1.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="2cbd1-146">В то же время при инициализации кортежа можно использовать новые возможности языка, позволяющие присваивать всем полям более понятные имена.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="2cbd1-147">При этом создается *именованный кортеж*.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="2cbd1-148">Именованные кортежи тоже содержат имена с элементами `Item1`, `Item2`, `Item3` и т. д.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="2cbd1-149">В то же время у них есть синонимы для всех элементов, которым вы присвоили имена.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="2cbd1-150">Для создания именованного кортежа необходимо указать имя для каждого элемента.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="2cbd1-151">Один из способов — указать имена в процессе инициализации кортежа:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="2cbd1-152">Эти синонимы обрабатываются компилятором и языком, что позволяет эффективно использовать именованные кортежи.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="2cbd1-153">Интегрированные среды разработки и редакторы читают эти семантические имена с помощью API Roslyn.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="2cbd1-154">Вы можете ссылаться на элементы именованного кортежа по семантическим именам в любой части сборки.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="2cbd1-155">При создании компилированных выходных данных компилятор заменяет имена, определенные с помощью эквивалентов `Item*`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="2cbd1-156">Скомпилированный MSIL не включает имена, которые вы присвоили этим элементам.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="2cbd1-157">Начиная с C# 7.1, имена полей для кортежа могут быть получены из переменных, которые используются для его инициализации.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="2cbd1-158">Они называются **[инициализаторами проекций кортежа](#tuple-projection-initializers)** .</span><span class="sxs-lookup"><span data-stu-id="2cbd1-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="2cbd1-159">Следующий код создает кортеж `accumulation` с элементами `count` (целое значение) и `sum` (значение double).</span><span class="sxs-lookup"><span data-stu-id="2cbd1-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="2cbd1-160">Компилятор должен передавать созданные вами имена для кортежей, возвращаемых открытыми методами и свойствами.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="2cbd1-161">В подобных случаях компилятор добавляет к методу атрибут <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute>.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="2cbd1-162">Этот атрибут содержит свойство списка <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames>, которое содержит имена, присвоенные каждому элементу в кортеже.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="2cbd1-163">Средства разработки, такие как Visual Studio, также считывают эти метаданные и предоставляют IntelliSense и другие возможности, используя имена полей метаданных.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="2cbd1-164">Знать основы работы с новыми кортежами и типом `ValueTuple` необходимо для того, чтобы понимать правила назначения именованных кортежей друг другу.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="2cbd1-165">Инициализаторы проекций кортежа</span><span class="sxs-lookup"><span data-stu-id="2cbd1-165">Tuple projection initializers</span></span>

<span data-ttu-id="2cbd1-166">Как правило, инициализаторы проекций кортежа работают с использованием переменной или имен полей в правой части оператора инициализации кортежа.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="2cbd1-167">Если задано явное имя, оно имеет приоритет над именем проекции.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="2cbd1-168">Например, в следующем инициализаторе элементы имеют значения `explicitFieldOne` и `explicitFieldTwo`, а не `localVariableOne` и `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="2cbd1-169">Во всех полях, где не указано явное имя, проецируется применимое неявное имя.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="2cbd1-170">Необязательно указывать семантические имена как явно, так и неявно.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="2cbd1-171">Следующий инициализатор имеет имена полей `Item1` со значением `42` и `stringContent` ("Ответ на все вопросы"):</span><span class="sxs-lookup"><span data-stu-id="2cbd1-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="2cbd1-172">Существуют два условия, при которых имена полей кандидата не проецируются в поле кортежа.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="2cbd1-173">Имя кандидата является зарезервированным именем кортежа.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="2cbd1-174">Примеры: `Item3`, `ToString` или `Rest`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-174">Examples include `Item3`, `ToString`, or `Rest`.</span></span>
1. <span data-ttu-id="2cbd1-175">Имя кандидата является дубликатом другого имени поля кортежа, явного или неявного.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-175">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="2cbd1-176">Эти условия позволяют избежать неоднозначности.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-176">These conditions avoid ambiguity.</span></span> <span data-ttu-id="2cbd1-177">Эти имена вызывали бы неоднозначность, если бы использовались в качестве имен полей для поля в кортеже.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-177">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="2cbd1-178">Ни одно из этих условий не вызовет ошибки времени компиляции.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-178">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="2cbd1-179">Семантические имена элементов без проецируемых имен не будут проецироваться.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-179">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="2cbd1-180">Все это показано в приведенных ниже примерах.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-180">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="2cbd1-181">Эти ситуации не вызывают ошибок компилятора, так как это стало бы критическим изменением кода, написанного на C# 7.0, где проекции имен полей кортежа были недоступны.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-181">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="2cbd1-182">Равенство и кортежи</span><span class="sxs-lookup"><span data-stu-id="2cbd1-182">Equality and tuples</span></span>

<span data-ttu-id="2cbd1-183">Начиная с C# 7.3, типы кортежей поддерживают операторы `==` и `!=`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-183">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="2cbd1-184">Эти операторы работают путем сравнения каждого элемента левого аргумента с каждым элементом правого аргумента по порядку.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-184">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="2cbd1-185">Это сокращенные сравнения.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-185">These comparisons short-circuit.</span></span> <span data-ttu-id="2cbd1-186">Они перестанут сравнивать элементы, как только будет обнаружена неравная пара.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-186">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="2cbd1-187">В следующем примере кода используется оператор `==`, но все правила сравнения применяются к оператору `!=`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-187">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="2cbd1-188">В следующем примере кода показано сравнение двух пар целых чисел на равенство:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-188">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="2cbd1-189">Существует несколько правил, которые упрощают тесты на равенство кортежей.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-189">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="2cbd1-190">Если один из кортежей допускает значение NULL, как показано в следующем коде, функция проверки кортежей на равенство выполняет [преобразования для использования форм, допускающих значение NULL](~/_csharplang/spec/conversions.md#lifted-conversion-operators):</span><span class="sxs-lookup"><span data-stu-id="2cbd1-190">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="2cbd1-191">Функция проверки кортежей на равенство также выполняет неявное преобразование каждого элемента обоих кортежей.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-191">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="2cbd1-192">К ним относятся преобразования для использования форм, допускающих значение NULL, расширяющие преобразования и другие неявные преобразования.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-192">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="2cbd1-193">В следующих примерах показано, что кортеж из 2 элементов типа "целое число" можно сравнить с кортежем из 2 элементов типа "длинное целое" в связи с неявным преобразованием из целого числа в длинное целое:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-193">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="2cbd1-194">Имена элементов кортежей не участвуют в тестах на равенство.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-194">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="2cbd1-195">Тем не менее если один из операндов является литералом кортежа с явными именами, компилятор генерирует предупреждение CS8383 в случае несовпадения этих имен с именами второго операнда.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-195">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="2cbd1-196">В случае, когда оба операнда являются литералами кортежей, предупреждение находится возле правого операнда, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-196">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="2cbd1-197">Наконец, кортежи могут содержать вложенные кортежи.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-197">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="2cbd1-198">Функция проверки кортежей на равенство сравнивает "форму" каждого операнда по вложенным кортежам, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-198">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="2cbd1-199">Это ошибка времени компиляции для сравнения двух кортежей на равенство (или неравенство) при наличии разных фигур.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-199">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="2cbd1-200">Компилятор не пытается выполнить деконструкцию вложенных кортежей, чтобы сравнить их.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-200">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="2cbd1-201">Назначение и кортежи</span><span class="sxs-lookup"><span data-stu-id="2cbd1-201">Assignment and tuples</span></span>

<span data-ttu-id="2cbd1-202">Язык поддерживает назначение между типами кортежей с одинаковым количеством элементов, где каждый расположенный справа элемент может быть неявно преобразован в соответствующий элемент, расположенный слева.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-202">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="2cbd1-203">Другие преобразования в контексте назначений не учитываются.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-203">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="2cbd1-204">Это ошибки времени компиляции для назначения одного кортежа другому при наличии различных фигур.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-204">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="2cbd1-205">Компилятор не будет пытаться выполнить любую деконструкцию вложенных кортежей для их назначения.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-205">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="2cbd1-206">Рассмотрим возможные виды назначений между типами кортежей.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-206">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="2cbd1-207">В приведенных ниже примерах можно использовать указанные переменные:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-207">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="2cbd1-208">В первых двух переменных, `unnamed` и `anonymous`, семантические имена элементам не назначены.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-208">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="2cbd1-209">Имена полей — `Item1` и `Item2`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-209">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="2cbd1-210">Последние две переменные, `named` и `differentName`, включают назначенные элементам семантические имена.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-210">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="2cbd1-211">Элементы в этих двух кортежах называются по-разному.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-211">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="2cbd1-212">Все четыре этих кортежа имеют одинаковое число элементов (так называемую кратность), а типы этих элементов идентичны.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-212">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="2cbd1-213">Таким образом, все эти назначения работают:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-213">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="2cbd1-214">Обратите внимание на то, что имена кортежей не назначаются.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-214">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="2cbd1-215">Значения элементов назначаются в соответствии с порядком элементов в кортеже.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-215">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="2cbd1-216">Кортежи различных типов или с различным количеством элементов не назначаются.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-216">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="2cbd1-217">Кортежи как возвращаемые значения методов</span><span class="sxs-lookup"><span data-stu-id="2cbd1-217">Tuples as method return values</span></span>

<span data-ttu-id="2cbd1-218">Чаще всего кортежи используются как возвращаемое методом значение.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-218">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="2cbd1-219">Разберем конкретный пример.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-219">Let's walk through one example.</span></span> <span data-ttu-id="2cbd1-220">Рассмотрим метод, который вычисляет стандартное отклонение для последовательности чисел:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-220">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="2cbd1-221">Код в этих примерах вычисляет стандартное отклонение неисправленной выборки.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-221">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="2cbd1-222">Формула стандартного отклонения исправленной выборки делит сумму квадратов разности со средним значением на (N-1), как и метод расширения `Average`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-222">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="2cbd1-223">Дополнительные сведения о различиях между этими формулами для расчета стандартного отклонения см. в тексте по статистике.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-223">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="2cbd1-224">Приведенный выше код соответствует учебной формуле для стандартного отклонения.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-224">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="2cbd1-225">Она позволяет получить правильный ответ, однако эта реализация неэффективна.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-225">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="2cbd1-226">Этот метод перечисляет последовательность дважды. Один раз для получения среднего значения, а второй — для получения среднего значения квадратов разницы со средним.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-226">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="2cbd1-227">(Запомните, что запросы LINQ вычисляются в отложенном режиме, поэтому разница со средним значением и среднее этих разниц вычисляются в один прием.)</span><span class="sxs-lookup"><span data-stu-id="2cbd1-227">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="2cbd1-228">Существует альтернативная формула, которая вычисляет стандартное отклонение, используя только одно перечисление последовательности.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-228">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="2cbd1-229">В результате этого вычисления выдаются два значения, поскольку оно перечисляет последовательность: сумма всех элементов в последовательности и сумма квадратов всех значений:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-229">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="2cbd1-230">Эта версия перечисляет последовательность ровно один раз.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-230">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="2cbd1-231">В то же время этот код нельзя повторно использовать.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-231">But it's not reusable code.</span></span> <span data-ttu-id="2cbd1-232">По мере работы вы узнаете, что во многих статистических вычислениях используется число элементов в последовательности, сумма последовательности и сумма квадратов последовательности.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-232">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="2cbd1-233">Выполним рефакторинг этого метода и напишем служебный метод, выдающий все три из этих значений.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-233">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="2cbd1-234">Все три значения могут быть возвращены в виде кортежа.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-234">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="2cbd1-235">Обновим этот метод таким образом, чтобы все три значения, вычисляемые при перечислении, сохранялись в кортеж.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-235">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="2cbd1-236">В результате создается следующая версия:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-236">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="2cbd1-237">Поддержка рефакторинга в Visual Studio позволяет легко извлекать функции основной статистики в закрытый метод.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-237">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="2cbd1-238">В результате вы получаете метод `private static`, возвращающий тип кортежа с тремя значениями — `Sum`, `SumOfSquares` и `Count`:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-238">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]
 
<span data-ttu-id="2cbd1-239">Язык позволяет использовать несколько дополнительных параметров, с помощью которых можно внести несколько быстрых изменений вручную.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-239">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="2cbd1-240">Во-первых, объявление `var` можно использовать для инициализации результата кортежа из вызова метода `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-240">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="2cbd1-241">Кроме того, в методе `ComputeSumAndSumOfSquares` можно создать три дискретные переменные.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-241">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="2cbd1-242">Итоговая версия показана в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-242">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="2cbd1-243">Окончательную версию можно применять к любому методу, которому требуются эти три значения, а также к любому их подмножеству.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-243">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="2cbd1-244">Язык поддерживает другие варианты управления именами элементов в методах, возвращающих кортежи.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-244">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="2cbd1-245">Имена полей можно удалить из объявления возвращаемого значения и вернуть неименованный кортеж:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-245">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="2cbd1-246">Поля этого кортежа называются `Item1`, `Item2` и `Item3`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-246">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="2cbd1-247">Для элементов кортежей, возвращаемых из методов, рекомендуется указывать семантические имена.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-247">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="2cbd1-248">Еще одна идиома, в которой кортежи могут быть полезны, связана с созданием запросов LINQ.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-248">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="2cbd1-249">Итоговый проецируемый результат часто содержит некоторые, но не все свойства выбранных объектов.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-249">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="2cbd1-250">Обычно результаты запроса проецируются в последовательность объектов анонимного типа.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-250">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="2cbd1-251">С этим связано множество ограничений, в первую очередь потому, что анонимным типам нельзя присваивать удобные имена в возвращаемом типе для метода.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-251">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="2cbd1-252">Альтернативные варианты с типом результата `object` или `dynamic` вызывают серьезные потери в производительности.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-252">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="2cbd1-253">Вернуть последовательность с типом кортежа легко, а имена и типы элементов можно получить во время компиляции и с помощью средств IDE.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-253">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="2cbd1-254">В качестве примера рассмотрим приложение ToDo.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-254">For example, consider a ToDo application.</span></span> <span data-ttu-id="2cbd1-255">Определите класс следующего вида — он будет представлять одну запись в списке дел ToDo:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-255">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="2cbd1-256">Мобильные приложения могут поддерживать компактную форму текущих пунктов в списке дел, когда отображается только заголовок.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-256">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="2cbd1-257">Этот запрос LINQ выполняет проекцию, включающую только идентификатор и заголовок.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-257">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="2cbd1-258">Эту модель хорошо демонстрирует метод, возвращающий последовательность кортежей:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-258">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="2cbd1-259">В C# 7.1 проекции кортежей позволяют создавать именованные кортежи с помощью элементов аналогично именованию свойств в анонимных типах.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-259">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="2cbd1-260">В коде выше оператор `select` в проекции запросов создает кортеж с элементами `ID` и `Title`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-260">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="2cbd1-261">Именованный кортеж может быть частью сигнатуры.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-261">The named tuple can be part of the signature.</span></span> <span data-ttu-id="2cbd1-262">Это позволяет компилятору и средствам IDE статически проверять, правильно ли используются результаты.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-262">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="2cbd1-263">Именованный кортеж также несет в себе данные статического типа, избавляя от необходимости использовать для работы с результатами дорогостоящие функции среды выполнения, такие как отражение или динамическая привязка.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-263">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="2cbd1-264">Деконструкция</span><span class="sxs-lookup"><span data-stu-id="2cbd1-264">Deconstruction</span></span>

<span data-ttu-id="2cbd1-265">Все элементы в кортеже можно распаковать, выполнив *деконструкцию* возвращаемого методом кортежа.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-265">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="2cbd1-266">Деконструкцию кортежей можно выполнять тремя различными способами.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-266">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="2cbd1-267">Во-первых, можно явно объявить тип каждого поля, заключив его в круглые скобки, чтобы создать дискретные переменные для каждого элемента в кортеже:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-267">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="2cbd1-268">Типизированные переменные для каждого поля в кортеже можно также объявить неявно, используя ключевое слово `var` за скобками:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-268">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="2cbd1-269">Кроме того, в объявлении одной или всех переменных можно также свободно использовать ключевое слово `var`, заключив его в скобки.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-269">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span> 

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="2cbd1-270">Определенный тип использовать за скобками нельзя, даже если каждое поле в кортеже имеет одинаковый тип.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-270">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="2cbd1-271">Можно также выполнить деконструкцию кортежей с существующими объявлениями:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-271">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="2cbd1-272">Нельзя смешивать существующие объявления с объявлениями в круглых скобках.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-272">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="2cbd1-273">Например, следующее выражение является недопустимым: `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-273">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="2cbd1-274">В результате возникает ошибка CS8184, так как переменная *x* объявлена внутри скобок, а переменная *y* объявлена ранее в другом месте.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-274">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="2cbd1-275">Деконструкция пользовательских типов</span><span class="sxs-lookup"><span data-stu-id="2cbd1-275">Deconstructing user-defined types</span></span>

<span data-ttu-id="2cbd1-276">Любой тип кортежа можно деконструировать, как показано выше.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-276">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="2cbd1-277">Деконструкцию можно легко активировать для любого пользовательского типа (классов, структур и даже интерфейсов).</span><span class="sxs-lookup"><span data-stu-id="2cbd1-277">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="2cbd1-278">Автор типа может определить один или несколько методов `Deconstruct`, присваивающих значения любому количеству переменных `out`, которые представляют составляющие этот тип элементы данных.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-278">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="2cbd1-279">Например, следующий тип `Person` определяет метод `Deconstruct`, который деконструирует объект person в элементы, представляющие имя и фамилию:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-279">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="2cbd1-280">Метод deconstruct позволяет выполнять назначение из объекта `Person` в две строки, представляющие свойства `FirstName` и `LastName`:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-280">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="2cbd1-281">Вы можете включить деконструкцию даже для типов, которые не создавали.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-281">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="2cbd1-282">Метод `Deconstruct` может быть методом расширения, который распаковывает доступные элементы данных в объекте.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-282">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="2cbd1-283">В следующем примере показан тип `Student`, производный от типа `Person`, и метод расширения, который разбивает `Student` на три переменные, представляющие `FirstName`, `LastName` и `GPA`:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-283">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="2cbd1-284">Теперь у объекта `Student` есть два доступных метода `Deconstruct`: метод расширения, объявленный для типов `Student`, и элемент типа `Person`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-284">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="2cbd1-285">Оба из них входят в область, что позволяет разбить `Student` либо на две, либо на три переменные.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-285">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="2cbd1-286">Если учащийся назначается трем переменным, возвращается все — имя, фамилия и GPA.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-286">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="2cbd1-287">Если учащийся назначается двум переменным, возвращаются только имя и фамилия.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-287">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="2cbd1-288">Определять несколько методов `Deconstruct` в классе или иерархии классов необходимо с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-288">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="2cbd1-289">Несколько методов `Deconstruct` с одинаковым числом параметров `out` могут быстро вызвать неоднозначность.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-289">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="2cbd1-290">В итоге вызывающие объекты могут лишиться возможности вызвать желаемый метод `Deconstruct`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-290">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="2cbd1-291">В этом примере вероятность неоднозначного вызова минимальна, поскольку метод `Deconstruct` для `Person` имеет два параметра вывода, а метод `Deconstruct` для `Student` — три.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-291">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="2cbd1-292">Операторы деконструкции не участвуют в проверке равенства.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-292">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="2cbd1-293">Следующий пример создает ошибку компилятора CS0019.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-293">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="2cbd1-294">Метод `Deconstruct` может преобразовать объект `Person` `p` в кортеж, содержащий две строки, но он неприменим в контексте проверок на равенство.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-294">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="tuples-as-out-parameters"></a><span data-ttu-id="2cbd1-295">Кортежи как параметры вывода</span><span class="sxs-lookup"><span data-stu-id="2cbd1-295">Tuples as out parameters</span></span>

<span data-ttu-id="2cbd1-296">Кортежи можно использовать в качестве параметров вывода *сами по себе*.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-296">Tuples can be used as out parameters *themselves*.</span></span> <span data-ttu-id="2cbd1-297">Это не является неоднозначностью, как упоминается выше в разделе [Деконструирование](#deconstruction).</span><span class="sxs-lookup"><span data-stu-id="2cbd1-297">Not to be confused with any ambiguity previously mentioned in the [Deconstruction](#deconstruction) section.</span></span> <span data-ttu-id="2cbd1-298">В вызове метода необходимо описать только форму кортежа:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-298">In a method call, you need only describe the tuple's shape:</span></span>

[!code-csharp[TuplesAsOutParameters](~/samples/snippets/csharp/tuples/program.cs#01_TupleAsOutVariable "Tuples as out parameters")]

<span data-ttu-id="2cbd1-299">Кроме того, можно использовать [_безымянный_](#named-and-unnamed-tuples) кортеж и ссылаться на его поля как на `Item1` и `Item2`:</span><span class="sxs-lookup"><span data-stu-id="2cbd1-299">Alternatively, you could use an [_unnamed_](#named-and-unnamed-tuples) tuple and refer to its fields as `Item1` and `Item2`:</span></span>

```csharp
dict.TryGetValue(2, out (int, string) pair);
// ...
Console.WriteLine($"{pair.Item1}: {pair.Item2}");
```

## <a name="conclusion"></a><span data-ttu-id="2cbd1-300">Заключение</span><span class="sxs-lookup"><span data-stu-id="2cbd1-300">Conclusion</span></span> 

<span data-ttu-id="2cbd1-301">Добавленная в язык и библиотеку поддержка именованных кортежей значительно упрощает работу с проектами, в которых используются структуры данных, хранящие несколько элементов, но не определяющие поведение подобно классам или структурам.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-301">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="2cbd1-302">Для этих типов удобно использовать кортежи.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-302">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="2cbd1-303">Они дают вам все преимущества статической поддержки типов и в то же время избавляют от необходимости создавать типы с использованием более подробного синтаксиса `class` или `struct`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-303">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="2cbd1-304">И все же наибольшую пользу они приносят при использовании со служебными методами, имеющими атрибут `private` или `internal`.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-304">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="2cbd1-305">Создавайте пользовательские типы, `class` или `struct`, если ваши открытые методы возвращают значение с несколькими элементами.</span><span class="sxs-lookup"><span data-stu-id="2cbd1-305">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
