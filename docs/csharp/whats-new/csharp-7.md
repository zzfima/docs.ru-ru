---
title: Новые возможности C# 7.0. Руководство по языку C#
description: Общие сведения о новых возможностях версии 7.0 языка C#.
ms.date: 02/20/2019
ms.assetid: fd41596d-d0c2-4816-b94d-c4d00a5d0243
ms.openlocfilehash: a6ac5c00ceb2ce8e5e56e2a86a8cde937d5108e2
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79398343"
---
# <a name="whats-new-in-c-70"></a>Новые возможности C# 7.0

В C# 7.0 язык C# получает ряд новых возможностей:

- [Переменные `out`](#out-variables)
  - Значения `out` можно объявлять встроенными как аргументы для метода, в котором они используются.
- [Кортежи](#tuples)
  - Вы можете создать простые, неименованные типы, содержащие несколько открытых полей. Компиляторы и инструменты IDE понимают семантику этих типов.
- [Операции удаления](#discards)
  - Пустые переменные представляют собой временные переменные, доступные только для записи, которые используются при присвоении в тех случаях, когда присваиваемое значение не важно. Они особенно полезны при деконструкции кортежей и пользовательских типов, а также при вызове методов с параметрами `out`.
- [Соответствие шаблону](#pattern-matching)
  - На основе произвольных типов и значений их членов можно создать логику ветвления.
- [Локальные переменные и возвращаемые значения `ref`](#ref-locals-and-returns)
  - Локальные переменные метода и возвращаемые значения могут быть ссылками на другое хранилище.
- [Локальные функции](#local-functions)
  - Функции можно вкладывать в другие функции, чтобы ограничить область их действия и видимость.
- [Другие элементы, воплощающие выражение](#more-expression-bodied-members)
  - Список элементов, которые можно создавать с помощью выражений, увеличился.
- [Выражения `throw`](#throw-expressions)
  - Исключения могут возникать в конструкциях кода, которые ранее не допускались, поскольку `throw` был оператором.
- [Обобщенные асинхронные типы возвращаемых значений](#generalized-async-return-types)
  - Методы, объявленные с модификатором `async`, могут возвращать другие типы помимо `Task` и `Task<T>`.
- [Усовершенствования в синтаксисе числовых литералов](#numeric-literal-syntax-improvements)
  - Новые маркеры делают числовые константы более удобочитаемыми.

В оставшейся части этой статьи представлены общие сведения об этих функциях. Каждая функция сопровождается обоснованием. Вы изучите синтаксис Эти функции можно изучить в своей среде с помощью глобального средства `dotnet try`:

1. Установите глобальное средство [dotnet-try](https://github.com/dotnet/try/blob/master/README.md#setup).
1. Клонируйте репозиторий [dotnet/try-samples](https://github.com/dotnet/try-samples).
1. Для репозитория *try-samples* установите в качестве текущего каталога подкаталог *csharp7*.
1. Выполните `dotnet try`.

## <a name="out-variables"></a>Переменные `out`

Существующий синтаксис, поддерживающий параметры `out`, в этой версии был улучшен. Переменные `out` можно объявлять в списке аргументов в вызове метода, не записывая отдельный оператор объявления:

[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations "Out variable declarations")]

Для ясности можно указать тип переменной `out`, как показано выше. В то же время язык поддерживает использование неявно типизированной локальной переменной:

[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations "Implicitly typed Out variable")]

- Код проще читать.
  - Переменная out объявляется при использовании, а не в другой, вышестоящей строке.
- Назначать начальное значение не нужно.
  - Объявляя переменную `out`, когда она используется при вызове метода, ее нельзя случайно использовать прежде, чем она будет назначена.

## <a name="tuples"></a>Кортежи

C# предоставляет расширенный синтаксис для классов и структур, который используется для объяснения цели проекта. Однако в некоторых случаях расширенный синтаксис требует дополнительной работы с минимальной результативностью. Зачастую требуется написание методов, которым нужна простая структура, состоящая из более чем одного элемента данных. Для поддержки этих сценариев в C# были добавлены *кортежи*. Кортежи — это упрощенные структуры данных, содержащие несколько полей для представления элементов данных.
Поля не проверяются, и собственные методы определять нельзя.

> [!NOTE]
> Кортежи существовали и в версиях C#, предшествовавших версии 7.0, но были неэффективны и не имели языковой поддержки.
> Это означает, что ссылки на элементы кортежа можно было задавать только в виде `Item1`, `Item2` и т. д. В C# 7.0 реализуется языковая поддержка кортежей, что позволяет работать с семантическими именами полей кортежа с использованием новых, более эффективных типов кортежей.

Можно создать кортеж путем присваивания значения каждого элемента, а также (необязательно) задать семантические имена для каждого из элементов кортежа:

[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple "Named tuple")]

Кортеж `namedLetters` содержит поля, которые называются `Alpha` и `Beta`. Эти имена существуют только во время компиляции и не сохраняются, например при проверке кортежа посредством отражения во время выполнения.

В назначении кортежа можно также указать имена полей в правой части назначения:

[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple "Implicitly named tuple")]

В некоторых случаях элементы возвращаемого методом кортежа необходимо распаковать.  С этой целью для каждого значения в этом кортеже объявляется отдельная переменная. Такая распаковка называется *деконструкцией* кортежа:

[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor "Deconstructing a tuple")]

Аналогичную деконструкцию можно обеспечить для любого типа в .NET. Можно написать метод `Deconstruct` в качестве члена класса. Метод `Deconstruct` предоставляет набор аргументов `out` для каждого из свойств, которые нужно извлечь. Рассмотрим этот класс `Point`, предоставляющий метод deconstructor, который извлекает координаты `X` и `Y`:

[!code-csharp[PointWithDeconstruction](~/samples/snippets/csharp/new-in-7/point.cs#PointWithDeconstruction "Point with deconstruction method")]

Отдельные поля можно извлекать, назначая кортежу метод `Point`:

[!code-csharp[DeconstructPoint](~/samples/snippets/csharp/new-in-7/program.cs#DeconstructPoint "Deconstruct a point")]

Дополнительные сведения о кортежах см. в [статье о кортежах](../tuples.md).

## <a name="discards"></a>Пустые переменные

При деконструкции кортежа или вызове метода с параметрами `out` часто требуется определить переменную, которую вы не планируете использовать и значение которой не важно. Для работы в таких сценариях в C# реализована поддержка *пустых переменных*. Пустая переменная представляет собой доступную только для записи переменную с именем `_` (знак подчеркивания). Вы можете назначить одной переменной все значения, которые не потребуются в дальнейшем. Пустая переменная является аналогом неприсвоенной переменной и не может использоваться в коде где-либо, за исключением оператора присваивания.

Пустые переменные поддерживается в следующих случаях.

- При деконструкции кортежей или пользовательских типов.
- При вызове методов с параметрами [out](../language-reference/keywords/out-parameter-modifier.md).
- В операции сопоставления шаблонов с выражениями [is](../language-reference/keywords/is.md) и [switch](../language-reference/keywords/switch.md).
- В качестве автономного идентификатора в тех случаях, когда требуется явно идентифицировать значение присваивания как пустую переменную.

В приведенном ниже примере определяется метод `QueryCityDataForYears`, который возвращает кортеж из 6 элементов, содержащий данные по городу за два разных года. В вызове метода в этом примере учитываются только два возвращаемых методом значения population, поэтому при деконструкции кортежа оставшиеся значения обрабатываются как пустые переменные.

[!code-csharp[Tuple-discard](~/samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

Дополнительные сведения см. в разделе [Пустые переменные](../discards.md).

## <a name="pattern-matching"></a>Сопоставление шаблонов

*Сопоставление шаблонов* — это функция, которая позволяет применять отправку метода для свойств, а не для типа объекта. Возможно, вы уже знакомы с отправкой метода на основе типа объекта. В объектно-ориентированном программировании виртуальные и переопределяющие методы предоставляют синтаксис языка, позволяющий отправлять метод, исходя из типа объекта. Базовый и производный классы предусматривают различные реализации.
Выражения сопоставления шаблонов расширяют эту концепцию, позволяя легко внедрять аналогичные шаблоны отправки для типов и элементов данных, не связанных иерархией наследования.

Сопоставление шаблонов поддерживает выражения `is` и `switch`. Каждое из них позволяет проверять объект и его свойства и определять, соответствует ли этот объект искомому шаблону. Для добавления правил в шаблон используется ключевое слово `when`.

Выражение шаблона `is` позволяет использовать знакомый [оператор `is`](../language-reference/keywords/is.md#pattern-matching-with-is) для запроса объекта о типе и присваивания результата в одной инструкции. Следующий код проверяет, является ли переменная `int`; если да, добавляет ее к текущей сумме:

```csharp
if (input is int count)
    sum += count;
```

Предыдущий небольшой пример показывает улучшенное выражение `is`. Можно проверять типы значений, а также ссылочные типы; успешный результат можно назначить переменной соответствующего типа.

Выражение сопоставления со switch имеет знакомый синтаксис, основанный на операторе `switch`, который уже является частью языка C#. Обновленный оператор switch имеет несколько новых конструкций:

- Определяющий тип выражения `switch` больше не ограничен интегральными типами, типами `Enum`, `string` или типами, принимающими значения NULL, соответствующими одному из таких типов. Может использоваться любой тип.
- Можно проверить тип выражения `switch` в каждой метке `case`. Как и в выражении `is`, можно назначить новую переменную этого типа.
- Можно добавить предложение `when` для дальнейшей проверки условий по этой переменной.
- Порядок меток `case` становится важным. Будет выполнена первая совпавшая ветвь; другие пропускаются.

Это демонстрируется в следующем коде:

```csharp
public static int SumPositiveNumbers(IEnumerable<object> sequence)
{
    int sum = 0;
    foreach (var i in sequence)
    {
        switch (i)
        {
            case 0:
                break;
            case IEnumerable<int> childSequence:
            {
                foreach(var item in childSequence)
                    sum += (item > 0) ? item : 0;
                break;
            }
            case int n when n > 0:
                sum += n;
                break;
            case null:
                throw new NullReferenceException("Null found in sequence");
            default:
                throw new InvalidOperationException("Unrecognized type");
        }
    }
    return sum;
}
```

- `case 0:` — знакомый шаблон константы.
- `case IEnumerable<int> childSequence:` — шаблон типа.
- `case int n when n > 0:` — шаблон типа с дополнительным условием `when`.
- `case null:` — шаблон NULL.
- `default:` — знакомый вариант по умолчанию.

Дополнительные сведения о сопоставлении шаблонов см. в разделе [Сопоставление шаблонов в C#](../pattern-matching.md).

## <a name="ref-locals-and-returns"></a>Локальные переменные и возвращаемые значения Ref

Эта функция активирует алгоритмы, которые используют и возвращают ссылки на переменные, определенные в другом месте. В качестве примера можно привести работу с большими матрицами и поиск одного местоположения с определенными характеристиками. Следующий метод возвращает **ссылку** на это хранилище в матрице:

[!code-csharp[FindReturningRef](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#FindReturningRef "Find returning by reference")]

Можно объявить возвращаемое значение как `ref` и изменять это значение в матрице, как показано в следующем коде:

[!code-csharp[AssignRefReturn](~/samples/snippets/csharp/new-in-7/Program.cs#AssignRefReturn "Assign ref return")]

Язык C# включает правила, которые защищают вас от неправильного использования локальных переменных и возвращаемых значений `ref`:

- Необходимо добавить ключевое слово `ref` в сигнатуру метода и все инструкции `return` в методе.
  - Это позволяет уточнить, что метод возвращает значение по ссылке, во всех местах.
- Объект `ref return` может быть назначен переменной-значению или переменной `ref`.
  - Вызывающий объект определяет, копируется ли возвращаемое значение. Пропуск модификатора `ref` при присваивании возвращаемого значения указывает, что вызывающий объект хочет получить копию значения, а не ссылку на хранилище.
- Присвоить локальной переменной `ref` стандартное возвращаемое значение метода невозможно.
  - Это запрещает использовать операторы вида `ref int i = sequence.Count();`
- Переменную `ref` невозможно возвращать переменной, которая продолжает существовать даже после того, как метод будет выполнен.
  - Это означает невозможность возвращения ссылки на локальную переменную или переменную с аналогичной областью.
- Возвращаемые значения и локальные переменные `ref` не могут использоваться с асинхронными методами.
  - На момент, когда асинхронный метод возвращает значение, компилятору неизвестно, присвоено ли переменной, на которую указывает ссылка, окончательное значение.

Добавление локальных переменных и возвращаемых значений ref дает возможность использовать более эффективные алгоритмы, поскольку избавляет от необходимости многократно копировать значения или выполнять операции разыменования.

Добавление `ref` для возврата значения является [изменением, совместимым на уровне исходного кода](version-update-considerations.md#source-compatible-changes). Существующий код компилируется, но возвращаемое значение ссылочного типа копируется при назначении. Вызывающие объекты должны изменить переменную хранилища для возвращаемого значения на локальную переменную `ref`, чтобы это значение хранилось в качестве ссылки.

Дополнительные сведения см. в статье [ref (Справочник по C#)](../language-reference/keywords/ref.md).

## <a name="local-functions"></a>Локальные функции

Модели многих классов включают методы, вызываемые только из одного места. Эти дополнительные закрытые методы делают каждый метод небольшим и направленным. *Локальные функции* позволяют объявлять методы в контексте другого метода. Локальные функции позволяют читателям класса легче увидеть, что локальный метод вызывается только из контекста, в котором он объявлен.

Существуют два общих варианта использования локальных функций: открытые методы итератора и открытые асинхронные методы. Оба эти типа методов создают код, который сообщает об ошибках позднее, чем могли ожидать программисты. В случае методов итератора исключения наблюдаются только при вызове кода, перечисляющего возвращенную последовательность. В случае асинхронных методов исключения наблюдаются только при ожидании возвращаемого объекта `Task`. В следующем примере показано отделение проверки параметров от реализации итератора с использованием локальной функции:

[!code-csharp[22_IteratorMethodLocal](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocal "Iterator method with local function")]

Та же технология может применяться с методами `async` для того, чтобы исключения, возникающие при проверке параметров, выдавались до начала асинхронной работы:

[!code-csharp[TaskExample](~/samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

> [!NOTE]
> Некоторые из макетов, поддерживаемых локальными функциями, также могут выполняться с помощью *лямбда-выражений*. Дополнительные сведения см. в статье [Сравнение локальных функций и лямбда-выражений](../local-functions-vs-lambdas.md).

## <a name="more-expression-bodied-members"></a>Другие элементы, воплощающие выражение

В C# версии 6 появились [элементы, воплощающие выражение](csharp-6.md#expression-bodied-function-members), для функций-членов и свойств, доступных только для чтения. В C# 7.0 расширен список допустимых членов, которые могут быть реализованы как выражения. В C# 7.0 можно реализовать *конструкторы*, *методы завершения*, а также методы доступа `get` и `set` для *свойств* и *индексаторов*. В следующем коде показаны примеры каждого из них:

[!code-csharp[ExpressionBodiedMembers](~/samples/snippets/csharp/new-in-7/expressionmembers.cs#ExpressionBodiedEverything "new expression-bodied members")]

> [!NOTE]
> В этом примере метод завершения не требуется, он приводится для демонстрации синтаксиса. Метод завершения следует реализовывать в классе только в том случае, если это необходимо для высвобождения неуправляемых ресурсов. Кроме того, вместо управления неуправляемыми ресурсами напрямую можно воспользоваться классом <xref:System.Runtime.InteropServices.SafeHandle>.

Новые расположения для элементов, воплощающих выражение, составляют важную веху для языка C#: они были реализованы членами сообщества, работающими над проектом [Roslyn](https://github.com/dotnet/Roslyn) с открытым исходным кодом.

Изменение метода на элемент, воплощающий выражение, является [совместимым на уровне двоичного кода](version-update-considerations.md#binary-compatible-changes).

## <a name="throw-expressions"></a>Выражения throw

В C# `throw` всегда был оператором. Поскольку `throw` — оператор, а не выражение, конструкции C# находились там, где использовать их было невозможно. Они включали условные выражения, выражения объединения со значением NULL и некоторые лямбда-выражения. Добавление элементов, воплощающих выражение, расширяет список мест, в которых могут пригодиться выражения `throw`. Для записи этих конструкций в C# 7.0 представлены [*выражения throw*](../language-reference/keywords/throw.md#the-throw-expression).

Это добавление упрощает написание кода на основе выражений. Дополнительные инструкции для проверки на наличие ошибок не требуются.

## <a name="generalized-async-return-types"></a>Обобщенные асинхронные типы возвращаемых значений

В некоторых случаях возврат объекта `Task` из асинхронных методов может вызывать сложности. `Task` — это тип ссылки, поэтому его применение означает распределение объекта. В случаях, когда метод, объявленный с модификатором `async`, возвращает кэшированный результат или завершается синхронно, лишние распределения могут вызывать серьезные потери времени при выполнении фрагментов кода, зависящих от производительности. Эта проблема встает серьезно, если распределения происходят в коротких циклах.

Новая возможность языка означает, что этот асинхронный метод возвращает типы, не ограниченные `Task`, `Task<T>` и `void`. Возвращаемый тип должен по-прежнему соответствовать асинхронному шаблону, а значит, метод `GetAwaiter` должен быть доступен. Конкретный пример. В .NET добавлен новый тип `ValueTask`, позволяющий применять эту новую возможность языка:

[!code-csharp[UsingValueTask](~/samples/snippets/csharp/new-in-7/AsyncWork.cs#UsingValueTask "Using ValueTask")]

> [!NOTE]
> Чтобы использовать тип [, необходимо добавить пакет NuGet `System.Threading.Tasks.Extensions`](https://www.nuget.org/packages/System.Threading.Tasks.Extensions/)<xref:System.Threading.Tasks.ValueTask%601>.

Это улучшение особенно полезно для авторов библиотек, которые хотят избежать выделения `Task` в критическом по производительности коде.

## <a name="numeric-literal-syntax-improvements"></a>Усовершенствования в синтаксисе числовых литералов

Неправильное толкование числовых констант затрудняет понимание кода при первом прочтении. Битовые маски или другие символьные значения могут вызывать затруднения. C# 7.0 содержит две новые возможности для записи чисел в удобочитаемом виде: *двоичные литералы* и *разделители цифр*.

Если вы создаете битовые маски или двоичное представление числа дает наиболее удобочитаемый код, используйте запись в двоичном формате:

[!code-csharp[ThousandSeparators](~/samples/snippets/csharp/new-in-7/Program.cs#ThousandSeparators "Thousands separators")]

`0b` в начале константы означает, что число записано в двоичном формате. Двоичные числа могут быть длинными, поэтому для удобства работы с битовыми шаблонами можно разделять разряды с помощью символа `_`, как показано выше в двоичной константе. Разделитель разрядов может находиться в любом месте константы. В десятичных числах он обычно используется для разделения тысяч:

[!code-csharp[LargeIntegers](~/samples/snippets/csharp/new-in-7/Program.cs#LargeIntegers "Large integer")]

Разделитель разрядов можно также использовать с типами `decimal`, `float` и `double`:

[!code-csharp[OtherConstants](~/samples/snippets/csharp/new-in-7/Program.cs#OtherConstants "non-integral constants")]

Суммируя вышеизложенное, числовые константы можно объявлять в гораздо более удобочитаемом виде.
