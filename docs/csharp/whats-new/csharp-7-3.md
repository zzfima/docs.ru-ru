---
title: Что нового в C# 7.3
description: Обзор новых возможностей в C# 7.3
ms.date: 05/16/2018
ms.openlocfilehash: ba4cea302d91b395e88940d087fcaed306920840
ms.sourcegitcommit: 81ad1f09b93f3b3e6706a7f2e4ddf50ef229ea3d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2019
ms.locfileid: "74204559"
---
# <a name="whats-new-in-c-73"></a>Что нового в C# 7.3

Новые возможности в выпуске C# 7.3 можно разделить на две основные группы. Одна из них — набор функций для повышения эффективности безопасного кода до уровня небезопасного кода. Вторая — постепенные улучшения существующих функций. Кроме того, в этом выпуске добавлены новые параметры компилятора.

В ту группу, которая отвечает за повышение производительности безопасного кода, входят следующие новые возможности:

- доступ к полям фиксированной ширины без закрепления;
- возможность переназначать локальные переменные `ref`;
- возможность использовать инициализаторы для массивов `stackalloc`;
- возможность использовать инструкции `fixed` с любым типом, который поддерживает шаблон;
- возможность использовать дополнительные универсальные ограничения.

Для существующих функций предоставлены следующие улучшения:

- возможность проверить `==` и `!=` с типами кортежа;
- больше мест для использование переменных выражений;
- возможность подключить атрибуты к резервному полю автоматически реализуемых свойств;
- улучшенное разрешение методов, аргументы которых отличаются модификатором `in`;
- стало меньше неоднозначных вариантов при разрешении перегрузок.

Новые параметры компилятора:

- `-publicsign` позволяет включить подписывание сборок как программного обеспечения с открытым кодом;
- `-pathmap` позволяет предоставить сопоставление для исходных каталогов.

В оставшейся части этой статьи представлены дополнительные сведения и ссылки по каждому из перечисленных улучшений. Эти функции можно изучить в своей среде с помощью глобального средства `dotnet try`:

1. Установите глобальное средство [dotnet-try](https://github.com/dotnet/try/blob/master/README.md#setup).
1. Клонируйте репозиторий [dotnet/try-samples](https://github.com/dotnet/try-samples).
1. Для репозитория *try-samples* установите в качестве текущего каталога подкаталог *csharp7*.
1. Запустите `dotnet try`.

## <a name="enabling-more-efficient-safe-code"></a>Повышение эффективности безопасного кода

Теперь вы сможете создавать безопасный код C#, который выполняется не хуже небезопасного кода. Безопасный код позволяет избежать ошибок некоторых типов, таких как переполнение буфера, свободные указатели и другие ошибки доступа к памяти. Новые функции расширяют возможности гарантированно безопасного кода. Старайтесь как можно большую часть кода создавать из безопасных конструкций. Благодаря новым возможностям это станет проще.

### <a name="indexing-fixed-fields-does-not-require-pinning"></a>Индексирование полей `fixed` не требует закрепления

Давайте рассмотрим такую структуру:

```csharp
unsafe struct S
{
    public fixed int myFixedField[10];
}
```

В более ранних версиях C# переменную необходимо закрепить, чтобы получить доступ к целым числам, входящим в `myFixedField`. Теперь приведенный ниже код компилируется без закрепления переменной `p` внутри отдельного оператора `fixed`:

```csharp
class C
{
    static S s = new S();

    unsafe public void M()
    {
        int p = s.myFixedField[5];
    }
}
```

Переменная `p` обращается к одному элементу в `myFixedField`. Для этого не нужно объявлять отдельную переменную `int*`. Обратите внимание, что контекст `unsafe` по-прежнему является обязательным. В более ранних версиях C# необходимо объявить второй фиксированный указатель:

```csharp
class C
{
    static S s = new S();

    unsafe public void M()
    {
        fixed (int* ptr = s.myFixedField)
        {
            int p = ptr[5];
        }
    }
}
```

Дополнительные сведения см. в статье, посвященной [инструкции `fixed`](../language-reference/keywords/fixed-statement.md).

### <a name="ref-local-variables-may-be-reassigned"></a>Локальные переменные `ref` могут быть переназначены

Теперь локальные переменные `ref` можно переназначить другим экземплярам после инициализации. Следующая команда теперь успешно компилируется:

```csharp
ref VeryLargeStruct refLocal = ref veryLargeStruct; // initialization
refLocal = ref anotherVeryLargeStruct; // reassigned, refLocal refers to different storage.
```

Дополнительные сведения см. в статье о возвращаемых значениях [`ref` и локальных переменных `ref`](../programming-guide/classes-and-structs/ref-returns.md), а также в статье [`foreach`](../language-reference/keywords/foreach-in.md).

### <a name="stackalloc-arrays-support-initializers"></a>Массивы `stackalloc` поддерживают инициализаторы

Раньше вы могли задавать значения для элементов массива при его инициализации:

```csharp
var arr = new int[3] {1, 2, 3};
var arr2 = new int[] {1, 2, 3};
```

Теперь такой же синтаксис можно применять к массивам, в объявлении которых есть `stackalloc`:

```csharp
int* pArr = stackalloc int[3] {1, 2, 3};
int* pArr2 = stackalloc int[] {1, 2, 3};
Span<int> arr = stackalloc [] {1, 2, 3};
```

Дополнительные сведения см. в статье [Оператор `stackalloc`](../language-reference/operators/stackalloc.md).

### <a name="more-types-support-the-fixed-statement"></a>Больше типов поддерживают инструкцию `fixed`

Инструкция `fixed` ранее поддерживала лишь ограниченный набор типов. Начиная с C# 7.3 любой тип, содержащий метод `GetPinnableReference()`, который возвращает `ref T` или `ref readonly T`, может иметь инструкцию `fixed`. Добавление этой возможности означает, что `fixed` можно применять для <xref:System.Span%601?displayProperty=nameWithType> и связанных типов.

Дополнительные сведения см. в статье [об инструкции `fixed`](../language-reference/keywords/fixed-statement.md) в справочнике по языку.

### <a name="enhanced-generic-constraints"></a>Расширенные универсальные ограничения

Теперь вы можете указать тип <xref:System.Enum?displayProperty=nameWithType> или <xref:System.Delegate?displayProperty=nameWithType> в качестве ограничения базового класса для параметра типа.

Вы также можете использовать новое ограничение `unmanaged`, чтобы указать, что параметр типа должен быть [неуправляемым типом](../language-reference/builtin-types/unmanaged-types.md), не допускающим значения NULL.

Дополнительные сведения см. в статьях [об универсальных ограничениях `where`](../language-reference/keywords/where-generic-type-constraint.md) и [ограничениях параметров типа](../programming-guide/generics/constraints-on-type-parameters.md).

Добавление этих ограничений в существующие типы — это [несовместимое изменение](version-update-considerations.md#incompatible-changes). Закрытые универсальные типы не будут соответствовать подобным ограничениям.

## <a name="make-existing-features-better"></a>Улучшение существующих функций

Во второй группе представлены улучшения существующих возможностей языка. Эти возможности повышают производительность при создании кода на C#.

### <a name="tuples-support--and-"></a>Поддержка `==` и `!=` для кортежей

Типы кортежей в C# теперь поддерживают `==` и `!=`. Дополнительные сведения см. в разделе о [равенстве](../tuples.md#equality-and-tuples) в статье о [кортежах](../tuples.md).

### <a name="attach-attributes-to-the-backing-fields-for-auto-implemented-properties"></a>Подключение атрибутов к резервным полям для автоматически реализуемых свойств

Теперь поддерживается такой синтаксис:

```csharp
[field: SomeThingAboutFieldAttribute]
public int SomeProperty { get; set; }
```

Атрибут `SomeThingAboutFieldAttribute` применяется к резервному полю, созданному компилятором для `SomeProperty`. Дополнительные сведения см. в статье об [атрибутах](../programming-guide/concepts/attributes/index.md) в руководстве по программированию на C#.

### <a name="in-method-overload-resolution-tiebreaker"></a>Критерии для разрешения перегрузки метода `in`

При добавлении модификатора аргумента `in` следующие два метода создавали неоднозначность:

```csharp
static void M(S arg);
static void M(in S arg);
```

Теперь перегрузка по значению (первая в предыдущем примере) считается лучше, чем перегрузка по атрибуту "только для чтения". Чтобы вызвать версию со ссылочным аргументом "только для чтения", необходимо при вызове метода указать модификатор `in`.

> [!NOTE]
> Эта возможность реализована как исправление ошибки. Теперь эта ситуация не создает неоднозначности, даже если установлена версия языка 7.2.

Дополнительные сведения см. в статье, посвященной [модификатору параметра `in`](../language-reference/keywords/in-parameter-modifier.md).

### <a name="extend-expression-variables-in-initializers"></a>Расширение переменных выражений в инициализаторах

Синтаксис, который с версии C# 7.0 позволяет объявлять переменные `out`, теперь также поддерживает инициализаторы полей, инициализаторы свойств, инициализаторы конструктора и предложения запроса. Он позволяет создать такой код, как в следующем примере:

```csharp
public class B
{
   public B(int i, out int j)
   {
      j = i;
   }
}

public class D : B
{
   public D(int i) : base(i, out var j)
   {
      Console.WriteLine($"The value of 'j' is {j}");
   }
}
```

### <a name="improved-overload-candidates"></a>Улучшенный отбор потенциальных перегрузок

В каждом выпуске обновляются правила разрешения перегрузок для устранения ситуаций, где неоднозначный вызов методов можно решить "очевидным" способом. В этот выпуск добавлены три новых правила, которые помогают компилятору выбрать очевидный вариант.

1. Если группа методов содержит элементы экземпляра и статические элементы, компилятор отклоняет все элементы экземпляра при вызове метода без экземпляра-получателя и вне контекста экземпляра. Компилятор отклоняет статические элементы, если метод был вызван с экземпляром-получателем. Если получатель не указан, компилятор включает в статический контекст только статические элементы, а в противном случае — статические элементы и элементы экземпляра. Если получатель невозможно однозначно определить как экземпляр или тип, компилятор включает и те, и другие элементы. В статический контекст, в котором невозможно использовать неявный экземпляр-получатель `this`, включается текст тех элементов, для которых не определено `this`, например статические элементы, а также все места, где не может использоваться `this`, такие как инициализаторы полей и конструкторы-инициализаторы.
1. Если группа методов содержит некоторые универсальные методы, у которых аргументы типа не удовлетворяют ограничениям, такие элементы удаляются из набора кандидатов.
1. При преобразовании группы методов из набора удаляются методы-кандидаты, у которых возвращаемый тип не соответствует возвращаемому типу делегата.

Это изменение проявится только тем, что вы реже будете встречать ошибки компилятора о неоднозначной перегрузке методов в тех ситуациях, когда вы точно уверены в выборе лучшего метода.

## <a name="new-compiler-options"></a>Новые параметры компилятора

Новые параметры компилятора поддерживают сценарии сборки и DevOps для программ на C#.

### <a name="public-or-open-source-signing"></a>Подписывание открытым ключом или с открытым исходным кодом

Параметр компилятора `-publicsign` указывает, что сборку нужно подписать открытым ключом. Такая сборка будет помечена как подписанная, но подпись для нее берется из открытого ключа. Этот параметр позволяет создавать подписанные сборки из проектов с открытым кодом с помощью открытого ключа.

Дополнительные сведения см. в статье [о параметре компилятора -publicsign](../language-reference/compiler-options/publicsign-compiler-option.md).

### <a name="pathmap"></a>pathmap

Параметр компилятора `-pathmap` указывает, что исходные пути в среде создания следует заменить сопоставленными исходными путями. Параметр `-pathmap` управляет исходными путями, которые компилятор записывает в PDB-файлы или для <xref:System.Runtime.CompilerServices.CallerFilePathAttribute>.

Дополнительные сведения см. в статье [о параметре компилятора -pathmap](../language-reference/compiler-options/pathmap-compiler-option.md).
