---
title: Различия между делегатами и событиями
description: Сведения о различиях между делегатами и событиями, а также о том, когда следует использовать каждый из этих компонентов в .NET Core.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 04738ac2dd82da9c577e88598d0bb737a93333c1
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "79146182"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="55c57-103">Различия между делегатами и событиями</span><span class="sxs-lookup"><span data-stu-id="55c57-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="55c57-104">Назад</span><span class="sxs-lookup"><span data-stu-id="55c57-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="55c57-105">Разработчики, не имеющие опыта работы с платформой .NET Core, часто не могут решить, что следует выбрать: структуру на основе `delegates` или на основе `events`.</span><span class="sxs-lookup"><span data-stu-id="55c57-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="55c57-106">Это сложный вопрос, так как эти две возможности языка очень похожи.</span><span class="sxs-lookup"><span data-stu-id="55c57-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="55c57-107">Более того, события основаны на тех же средствах языка, которые обеспечивают поддержку делегатов.</span><span class="sxs-lookup"><span data-stu-id="55c57-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="55c57-108">И те и другие обеспечивают сценарии позднего связывания, в которых взаимодействие компонента осуществляется путем вызова метода, известного только во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="55c57-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="55c57-109">И те и другие поддерживают методы с одним или несколькими подписчиками.</span><span class="sxs-lookup"><span data-stu-id="55c57-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="55c57-110">Иногда это называют поддержкой одноадресности и многоадресности.</span><span class="sxs-lookup"><span data-stu-id="55c57-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="55c57-111">Синтаксис добавления и удаления обработчиков в обоих случаях похож.</span><span class="sxs-lookup"><span data-stu-id="55c57-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="55c57-112">Наконец, при вызове событий и делегатов используется абсолютно одинаковый синтаксис вызова методов.</span><span class="sxs-lookup"><span data-stu-id="55c57-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="55c57-113">Более того, поддерживается одинаковый синтаксис метода `Invoke()` для использования с оператором `?.`.</span><span class="sxs-lookup"><span data-stu-id="55c57-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="55c57-114">Учитывая такое сходство, легко могут возникнуть проблемы с выбором подходящего механизма в той или иной ситуации.</span><span class="sxs-lookup"><span data-stu-id="55c57-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="55c57-115">Прослушивание событий необязательно</span><span class="sxs-lookup"><span data-stu-id="55c57-115">Listening to Events is Optional</span></span>

<span data-ttu-id="55c57-116">Самым важным фактором при выборе подходящего механизма является обязательность наличия подключенного подписчика.</span><span class="sxs-lookup"><span data-stu-id="55c57-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="55c57-117">Если ваш код должен вызывать код, предоставленный подписчиком, следует использовать структуру на основе делегатов.</span><span class="sxs-lookup"><span data-stu-id="55c57-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="55c57-118">Если код может выполнить все задачи, не вызывая подписчики, следует использовать структуру на основе событий.</span><span class="sxs-lookup"><span data-stu-id="55c57-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="55c57-119">Обратите внимание на примеры, рассматривавшиеся в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="55c57-119">Consider the examples built during this section.</span></span> <span data-ttu-id="55c57-120">Код, который вы создавали с помощью `List.Sort()`, должен содержать функцию сравнения для правильной сортировки элементов.</span><span class="sxs-lookup"><span data-stu-id="55c57-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="55c57-121">Запросам LINQ необходимо предоставить делегаты для определения элементов, которые следует вернуть.</span><span class="sxs-lookup"><span data-stu-id="55c57-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="55c57-122">В обоих случаях использовалась структура на основе делегатов.</span><span class="sxs-lookup"><span data-stu-id="55c57-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="55c57-123">Рассмотрим событие `Progress`.</span><span class="sxs-lookup"><span data-stu-id="55c57-123">Consider the `Progress` event.</span></span> <span data-ttu-id="55c57-124">Оно сообщает о ходе выполнения задачи.</span><span class="sxs-lookup"><span data-stu-id="55c57-124">It reports progress on a task.</span></span>
<span data-ttu-id="55c57-125">Задача продолжает выполняться вне зависимости от того, есть ли прослушиватели.</span><span class="sxs-lookup"><span data-stu-id="55c57-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="55c57-126">Еще один пример — `FileSearcher`.</span><span class="sxs-lookup"><span data-stu-id="55c57-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="55c57-127">Нахождение всех искомых файлов производится, даже если не подключены обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="55c57-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="55c57-128">Элементы управления UX продолжают работать правильно, даже если нет подписчиков, прослушивающих события.</span><span class="sxs-lookup"><span data-stu-id="55c57-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="55c57-129">В обоих примерах используются структуры на основе событий.</span><span class="sxs-lookup"><span data-stu-id="55c57-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="55c57-130">Для возвращаемых значений требуются делегаты</span><span class="sxs-lookup"><span data-stu-id="55c57-130">Return Values Require Delegates</span></span>

<span data-ttu-id="55c57-131">Еще одним аспектом является прототип метода, который требуется для метода делегата.</span><span class="sxs-lookup"><span data-stu-id="55c57-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="55c57-132">Как вы уже видели, все делегаты, используемые для событий, имеют тип возвращаемого значения void.</span><span class="sxs-lookup"><span data-stu-id="55c57-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="55c57-133">Вы уже также знаете, что есть идиомы для создания обработчиков событий, которые передают информацию обратно источникам событий, изменяя свойства объекта аргумента события.</span><span class="sxs-lookup"><span data-stu-id="55c57-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="55c57-134">Хотя такие идиомы работают, они не так естественны, как возвращение значения из метода.</span><span class="sxs-lookup"><span data-stu-id="55c57-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="55c57-135">Обратите внимание на то, что часто используются оба этих эвристических метода: если метод делегата возвращает значение, то оно, скорее всего, будет каким-либо образом влиять на алгоритм.</span><span class="sxs-lookup"><span data-stu-id="55c57-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="55c57-136">Прослушиватели событий часто имеют более длительный срок существования</span><span class="sxs-lookup"><span data-stu-id="55c57-136">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="55c57-137">Это не столь важный фактор.</span><span class="sxs-lookup"><span data-stu-id="55c57-137">This is a slightly weaker justification.</span></span> <span data-ttu-id="55c57-138">Однако структура на основе событий может оказаться более естественной, когда источник событий инициирует события в течение длительного периода времени.</span><span class="sxs-lookup"><span data-stu-id="55c57-138">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="55c57-139">Примерами могут служить элементы управления UX во многих системах.</span><span class="sxs-lookup"><span data-stu-id="55c57-139">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="55c57-140">После подписания на событие источник события может вызывать события в течение всего времени существования программы.</span><span class="sxs-lookup"><span data-stu-id="55c57-140">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="55c57-141">(Когда события больше не нужны, вы можете отменить подписку на них.)</span><span class="sxs-lookup"><span data-stu-id="55c57-141">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="55c57-142">Сравните это с часто встречающимися структурами на основе делегатов, когда делегат применяется в качестве аргумента метода и не используется после того, как метод возвращает управление.</span><span class="sxs-lookup"><span data-stu-id="55c57-142">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="55c57-143">Тщательно оценивайте ситуацию</span><span class="sxs-lookup"><span data-stu-id="55c57-143">Evaluate Carefully</span></span>

<span data-ttu-id="55c57-144">Приведенные выше указания не являются строгими правилами.</span><span class="sxs-lookup"><span data-stu-id="55c57-144">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="55c57-145">Они представляют собой лишь рекомендации, которые могут помочь вам выбрать правильный вариант в конкретном случае.</span><span class="sxs-lookup"><span data-stu-id="55c57-145">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="55c57-146">Так как эти механизмы схожи, вы можете смоделировать и тот и другой, чтобы проверить, какой из них окажется естественнее.</span><span class="sxs-lookup"><span data-stu-id="55c57-146">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="55c57-147">Оба они хорошо подходят для сценариев с поздним связыванием.</span><span class="sxs-lookup"><span data-stu-id="55c57-147">They both handle late binding scenarios well.</span></span> <span data-ttu-id="55c57-148">Используйте тот механизм, который лучше соответствует вашим требованиям.</span><span class="sxs-lookup"><span data-stu-id="55c57-148">Use the one that communicates your design the best.</span></span>
