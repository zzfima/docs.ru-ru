---
title: "Структура программы в C# | Краткий обзор языка C#"
description: "Узнайте, из каких блоков составляется программа на C#"
keywords: .NET, .NET Core
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 984f0314-507f-47a0-af56-9011243f5e65
translationtype: Human Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: 9ef19d7fa2164990edd5e27651d28aa085ec90ad
ms.lasthandoff: 03/13/2017

---

# <a name="program-structure"></a>Структура программы

В C# основными понятиями организационной структуры являются ***программы***, ***пространства имен***, ***типы***, ***члены*** и ***сборки***. Программа на языке C# состоит из одного или нескольких файлов. В программе объявляются типы, которые содержат члены. Эти типы можно организовать в пространства имен. Примерами типов являются классы и интерфейсы. К членам относятся поля, методы, свойства и события. При компиляции программы на C# упаковываются в сборки. Сборка — это файл, обычно с расширением `.exe` или `.dll`, если она реализует ***приложение*** или ***библиотеку***, соответственно.

Этот пример кода объявляет класс с именем `Stack` в пространство имен с именем `Acme.Collections`:

[!code-csharp[Stack](../../../samples/snippets/csharp/tour/program-structure/program.cs#L1-L34)]

Полное имя этого класса: `Acme.Collections.Stack`. Этот класс содержит несколько членов: поле с именем `top`, два метода с именами `Push` и `Pop`, а также вложенный класс с именем `Entry`. Класс `Entry`, в свою очередь, содержит три члена: поле с именем `next`, поле с именем `data` и конструктор. Если мы сохраним исходный код этого примера в файле `acme.cs`, то для его компиляции нужно выполнить такую командную строку:

```
csc /t:library acme.cs
```

Результатом компиляции будет библиотека (код без точки входа `Main`), сохраненная в сборке с именем `acme.dll`.

> [!IMPORTANT]
> В приведенных выше примерах используется компилятор командной строки `csc` для C#. Он существует в виде исполняемого файла Windows. Чтобы использовать C# на других платформах, вам понадобятся средства для .NET Core. Экосистема .NET Core использует `dotnet` CLI для управления сборкой из командной строки. Она позволяет управлять зависимостями и вызывать компилятор C#. [В этом руководстве](../../core/tutorials/using-with-xplat-cli.md) вы найдете полное описание средств для всех платформ, поддерживаемых .NET Core.

Сборки содержат исполняемый код в виде инструкций промежуточного языка (IL) и символьную информацию в виде метаданных. Перед выполнением сборки ее код на языке IL автоматически преобразуется в код для конкретного процессора. Эту задачу выполняет JIT-компилятор среды .NET CLR (Common Language Runtime).

Cборка полностью описывает сама себя и содержит весь код и метаданные, поэтому в C# не используются директивы `#include` и файлы заголовков. Чтобы использовать в программе C# открытые типы и члены, содержащиеся в определенной сборке, вам достаточно указать ссылку на эту сборку при компиляции программы. Например, эта программа использует класс `Acme.Collections.Stack` из сборки `acme.dll`:

[!code-csharp[UsingStack](../../../samples/snippets/csharp/tour/program-structure/Program.cs#L38-L52)]

Если на момент компиляции `example.cs` программа хранится в файле `example.cs`, то ссылка на сборку acme.dll с использованием параметра компилятора /r будет выглядеть так:

```
csc /r:acme.dll example.cs
```

Эта команда создает исполняемую сборку с именем `example.exe`, которая при запуске возвращает такие данные:

```
100
10
1
```

В C# исходный текст программы можно хранить в нескольких исходных файлах. При компиляции многофайловой программы на C# все исходные файлы обрабатываются вместе, и все они могут свободно ссылаться друг на друга. По сути обработка выполняется так, как если бы все исходные файлы были объединены в один большой файл. В C# никогда не используются опережающие объявления, поскольку порядок объявления, за редким исключением, не играет никакой роли. В C# нет требований объявлять только один открытый тип в одном исходном файле, а также имя исходного файла не обязано совпадать с типом, объявляемом в этом файле.

>[!div class="step-by-step"]
[Назад](index.md)
[Вперед](types-and-variables.md)

