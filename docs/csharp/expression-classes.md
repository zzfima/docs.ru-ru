---
title: Типы платформ, поддерживающие деревья выражений
description: Сведения о типах платформ, поддерживающих деревья выражений, создании деревьев выражений и способах работы с API деревьев выражений.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: e9c85021-0d36-48af-91b7-aaaa66f22654
ms.openlocfilehash: 157e97594f27345ac96fe91f7dd6f29907c2c7ac
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73037623"
---
# <a name="framework-types-supporting-expression-trees"></a>Типы платформ, поддерживающие деревья выражений

[Предыдущий раздел: "Описание деревьев выражений"](expression-trees-explained.md)

Платформа .NET Core содержит множество классов для работы с деревьями выражений.
Полный список можно просмотреть в разделе <xref:System.Linq.Expressions>.
Вместо того чтобы знакомиться с этим списком, давайте разберемся, как строятся классы платформы.

Согласно принципам языка выражение — это блок кода, который выполняет вычисления и возвращает значение. Выражения могут быть очень простыми: константное выражение `1` всегда возвращает значение 1. Они могут быть более сложными: выражение `(-B + Math.Sqrt(B*B - 4 * A * C)) / (2 * A)` возвращает один корень квадратного уравнения (если у уравнения есть решение).  

## <a name="it-all-starts-with-systemlinqexpression"></a>Все начинается с System.Linq.Expression

Одна из трудностей при работе с деревьями выражений заключается в том, что выражения различных типов могут использоваться в программах в самых разных местах. Возьмем для примера выражение присваивания. В правой его части может быть константа, переменная, выражение вызова метода или иной элемент. Такая гибкость языка означает, что при обходе дерева выражения в его узлах вам могут встретиться различные типы выражений. Поэтому, если есть возможность использовать базовый тип выражения, это простейший способ работы. Однако иногда этого недостаточно.
На этот случай базовый класс Expression содержит свойство `NodeType`.
Оно возвращает `ExpressionType` — перечисление возможных типов выражений.
Если вы знаете тип узла выражения, то можете привести его к этому типу и выполнять с ним определенные действия. Можно выполнить поиск узлов определенных типов, а затем работать со свойствами данного типа выражения.

Например, приведенный ниже код печатает имя переменной для выражения доступа к переменной. В нем используется метод, заключающийся в проверке типа узла, приведении к выражению доступа к переменной и последующей проверке свойств определенного типа выражения.

```csharp
Expression<Func<int, int>> addFive = (num) => num + 5;

if (addFive.NodeType == ExpressionType.Lambda)
{
    var lambdaExp = (LambdaExpression)addFive;

    var parameter = lambdaExp.Parameters.First();

    Console.WriteLine(parameter.Name);
    Console.WriteLine(parameter.Type);
}
```

## <a name="creating-expression-trees"></a>Создание деревьев выражений

Класс `System.Linq.Expression` также содержит множество статических методов для создания выражений. Эти методы создают узел выражения с помощью аргументов, предоставленных для его дочерних элементов. Таким образом, выражение строится на основе листовых узлов. Например, следующий код создает выражение сложения:

```csharp
// Addition is an add expression for "1 + 2"
var one = Expression.Constant(1, typeof(int));
var two = Expression.Constant(2, typeof(int));
var addition = Expression.Add(one, two);
```

На этом простом примере видно, что в создании деревьев выражений и работе с ними задействовано множество типов. Такая сложность необходима для предоставления широких возможностей словаря C#.

## <a name="navigating-the-apis"></a>Перемещение по API
Существуют типы узлов выражений, которые сопоставляются почти со всеми элементами синтаксиса языка C#. Каждый тип имеет определенные методы для конкретного типа элементов языка. Держать в голове приходится слишком многое. Вместо того чтобы запоминать все это, при работе с деревьями выражений можно применять описанные ниже приемы.

1. Просмотрите элементы перечисления `ExpressionType`, чтобы определить возможные узлы для анализа. Это очень полезно, если нужно выполнить обход дерева и изучить его.
2. Просмотрите статические члены класса `Expression`, которые служат для создания выражения. С помощью этих методов можно создать выражение любого типа на основе набора дочерних узлов.
3. Обратите внимание на класс `ExpressionVisitor`, который служит для создания измененного дерева выражения.

В каждой из этих трех областей доступны и другие возможности. Вы обязательно найдете то, что вам нужно, если начнете с этих трех основных шагов.
 
 [Следующий раздел: "Выполнение деревьев выражений"](expression-trees-execution.md)
