---
title: Руководство по программированию на C#. Строки
ms.custom: seodec18
ms.date: 06/27/2019
helpviewer_keywords:
- C# language, strings
- strings [C#]
ms.assetid: 21580405-cb25-4541-89d5-037846a38b07
ms.openlocfilehash: 46820fe4137f5080b956cd1345d3e95c2e06f9ca
ms.sourcegitcommit: 7bc6887ab658550baa78f1520ea735838249345e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/03/2020
ms.locfileid: "75635084"
---
# <a name="strings-c-programming-guide"></a>Строки (Руководство по программированию на C#)
Строка — это объект типа <xref:System.String>, значением которого является текст. Внутри программы текст хранится в виде упорядоченной коллекции объектов <xref:System.Char> только для чтения. В конце строки C# нет нуль-символов. Поэтому строка C# может содержать любое число внедренных нуль-символов ('\0'). Свойство <xref:System.String.Length%2A> строки соответствует числу содержащихся в ней объектов `Char`, но не числу символов Юникода. Для доступа к отдельным кодовым точкам Юникода в строке используйте объект <xref:System.Globalization.StringInfo>.  
  
## <a name="string-vs-systemstring"></a>Сравнение строки и System.String  
 В C# ключевое слово `string` является псевдонимом для <xref:System.String>. Таким образом, `String` и `string` эквивалентны, их можно использовать независимо от используемого соглашения об именовании. Класс `String` предоставляет множество методов для безопасного создания, обработки и сравнения строк. Кроме того, язык C# перегружает некоторые операторы для упрощения типичных операций со строками. Дополнительные сведения о ключевых словах см. в статье, посвященной [строкам](../../language-reference/builtin-types/reference-types.md). Дополнительные сведения о типе и его методах см. здесь: <xref:System.String>.  
  
## <a name="declaring-and-initializing-strings"></a>Объявление и инициализация строк  
 Вы можете объявлять и инициализировать строки различными способами, как показано в следующем примере:  
  
 [!code-csharp[csProgGuideStrings#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#1)]  
  
 Обратите внимание, что вы не используете оператор [new](../../language-reference/operators/new-operator.md) для создания объекта строки, за исключением случаев инициализации строки с помощью массива символов.  
  
 Инициализируйте строку с константным значением <xref:System.String.Empty> для создания нового объекта <xref:System.String>, строка которого имеет нулевую длину. Представлением строкового литерала строки с нулевой длиной является "". Если вы инициализируете строки со значением <xref:System.String.Empty> вместо [NULL](../../language-reference/keywords/null.md), вы снизите вероятность появления исключения <xref:System.NullReferenceException>. Используйте статический метод <xref:System.String.IsNullOrEmpty%28System.String%29>, чтобы проверить значение строки, прежде чем пытаться получить к ней доступ.  
  
## <a name="immutability-of-string-objects"></a>Неизменность строковых объектов  
 Строковые объекты являются *неизменяемыми*: их нельзя изменить после создания. Может показаться, что все методы <xref:System.String> и операторы C# изменяют строку, но в действительности они возвращают результаты в новый строковый объект. Когда содержимое `s1` и `s2` объединяется для формирования одной строки, две исходные строки не изменяются, как показано в следующем примере. Оператор `+=` создает новую строку, которая содержит объединенное содержимое. Этот новый объект присваивается переменной `s1`, а исходный объект, который был присвоен `s1`, освобождается для сборки мусора, так как ни одна переменная не ссылается на него.  
  
 [!code-csharp[csProgGuideStrings#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#2)]  
  
 Так как "изменение" строки на самом деле является созданием новой строки, создавать ссылки на строки следует с осторожностью. Если вы создадите ссылку на строку, а затем "измените" исходную строку, ссылка будет по-прежнему указывать на исходный объект, а не на новый объект, который был создан при изменении строки. Это поведение проиллюстрировано в следующем коде:  
  
 [!code-csharp[csProgGuideStrings#25](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#25)]  
  
 Сведения о создании новых строк, основанных на таких изменениях, как операции поиска и замены исходной строки, см. в инструкциях по [изменению содержимого строки](../../how-to/modify-string-contents.md).  
  
## <a name="regular-and-verbatim-string-literals"></a>Регулярные и буквальные строковые литералы  
 Используйте регулярные строковые литералы, когда вам нужно внедрить escape-символы, доступные в C#, как показано в следующем примере:  
  
 [!code-csharp[csProgGuideStrings#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#3)]  
  
 Буквальные строковые литералы используются для удобства и читабельности, если текст строки содержит символы обратной косой черты, например в путях к файлам. Так как буквальные строки сохраняют символы новой строки как часть текста строки, их можно использовать для инициализации многострочных строк. Используйте двойные кавычки, чтобы вставить кавычки в буквальной строке. В следующем примере показаны наиболее часто используемым буквальные строки:  
  
 [!code-csharp[csProgGuideStrings#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#4)]  
  
## <a name="string-escape-sequences"></a>Escape-последовательности строк  
  
|Escape-последовательность|Имя символа|Кодировка Юникод|  
|---------------------|--------------------|----------------------|  
|\\'|Одинарная кавычка|0x0027|  
|\\"|Двойная кавычка|0x0022|  
|\\\\ |Обратная косая черта|0x005C|  
|\0|Null|0x0000|  
|\a|Предупреждение|0x0007|  
|\b|Backspace|0x0008|  
|\f|Перевод страницы|0x000C|  
|\n|Новая строка|0x000A|  
|\r|Возврат каретки|0x000D|  
|\t|Горизонтальная табуляция|0x0009|  
|\v|Вертикальная табуляция|0x000B|  
|\u|Escape-последовательность Юникода (UTF-16)|`\uHHHH` (диапазон: 0000–FFFF; пример: `\u00E7` = "ç")|  
|\U|Escape-последовательность Юникода (UTF-32)|`\U00HHHHHH` (диапазон: 000000–10FFFF; пример: `\U0001F47D` = "&#x1F47D;")|  
|\x|Escape-последовательность Юникода аналогична "\u", она отличается только длиной переменной|`\xH[H][H][H]` (диапазон: 0–FFFF; пример: `\x00E7` или `\x0E7` или `\xE7` = "ç")|  
  
> [!WARNING]
> Если вы используете escape-последовательность `\x` с менее чем четырьмя шестнадцатеричными цифрами, то когда непосредственно следующие за ней символы также являются допустимыми шестнадцатеричными цифрами (т. е. 0–9, A–F и a–f), они будут интерпретированы как часть этой escape-последовательности. Например, `\xA1` дает результат "&#161;", являющийся кодовой точкой U+00A1. Однако если следующий символ — "A" или "a", тогда escape-последовательность будет интерпретироваться как `\xA1A` и даст результат "&#x0A1A;", являющийся кодовой точкой U+0A1A. В таких случаях, чтобы избежать некорректной интерпретации, указывайте все четыре шестнадцатеричных знака (например, `\x00A1`).  
  
> [!NOTE]
> Во время компиляции буквальные строки преобразуются в обычные строки с теми же escape-последовательностями. Поэтому, если вы просматриваете буквальную строку в окне контрольных значений отладчика, вы увидите escape-символы, добавленные компилятором, а не буквальную версию из исходного кода. Например, буквальная строка `@"C:\files.txt"`будет отображаться в окне контрольных значений как "C:\\\files.txt".  
  
## <a name="format-strings"></a>Строки формата  
 Строка формата — это строка, содержимое которой можно определить динамически во время выполнения. Строки формата создаются путем внедрения *интерполированных выражений* или заполнителей внутри фигурных скобок в строке. Весь код внутри фигурных скобок (`{...}`) будет преобразован в значение и выходные данные как отформатированная строка во время выполнения. Существует два способа создания строк формата: интерполяция строк и составное форматирование.

### <a name="string-interpolation"></a>Интерполяция строк
В C# 6.0 и более поздних версий [*интерполированные строки*](../../language-reference/tokens/interpolated.md) определяются по специальному символу `$`. Они включают интерполированные выражения в фигурных скобках. См. дополнительные сведения в интерактивном руководстве по [ интерполяции строк в C#](../../tutorials/exploration/interpolated-strings.yml).

Используйте интерполяцию для повышения удобства чтения и обслуживаемости кода. Интерполяция строк позволяет достичь тех же результатов, что и использование метода `String.Format`, но более простым и понятным способом.

[!code-csharp[csProgGuideFormatStrings](~/samples/snippets/csharp/programming-guide/strings/Strings_1.cs#StringInterpolation)]

### <a name="composite-formatting"></a>Составное форматирование
<xref:System.String.Format%2A?displayProperty=nameWithType> использует заполнители в фигурных скобках, чтобы создать строку формата. В этом примере результат аналогичен выходным данным, получаемым с помощью метода интерполяции строк, описанного выше.
  
[!code-csharp[csProgGuideFormatStrings](~/samples/snippets/csharp/programming-guide/strings/Strings_1.cs#StringFormat)]

См. дополнительные сведения о [типах форматирования в .NET](../../../standard/base-types/formatting-types.md).
  
## <a name="substrings"></a>Подстроки  
 Подстрока — это последовательность символов, содержащихся в строке. Используйте метод <xref:System.String.Substring%2A>, чтобы создать новую строку из части исходной строки. Одно вхождение подстроки или несколько можно найти с помощью метода <xref:System.String.IndexOf%2A>. Используйте метод <xref:System.String.Replace%2A>, чтобы заменить все вхождения указанной подстроки новой строкой. Как и метод <xref:System.String.Substring%2A>, метод <xref:System.String.Replace%2A> фактически возвращает новую строку и не изменяет исходную строку. См. дополнительные сведения о [поиске строк](../../how-to/search-strings.md) и [изменении содержимого строк](../../how-to/modify-string-contents.md).
  
 [!code-csharp[csProgGuideStrings#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#9)]  
  
## <a name="accessing-individual-characters"></a>Доступ к отдельным символам  
 Используя нотацию массива со значением индекса, можно получить доступ только для чтения к отдельным символам, как показано в следующем примере:  
  
 [!code-csharp[csProgGuideStrings#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#8)]  
  
 Если вам необходимо изменить отдельные символы в строке и функций методов <xref:System.String> вам недостаточно, используйте объект <xref:System.Text.StringBuilder>, чтобы изменить отдельные символы "на месте", а затем создайте новую строку для сохранения результатов с помощью методов <xref:System.Text.StringBuilder>. В следующем примере предположим, что необходимо определенным образом изменить исходную строку, а затем сохранить результаты для дальнейшего использования:  
  
 [!code-csharp[csProgGuideStrings#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#27)]  
  
## <a name="null-strings-and-empty-strings"></a>Строки NULL и пустые строки  
 Пустая строка — это экземпляр объекта <xref:System.String?displayProperty=nameWithType>, который содержит нуль символов. Пустые строки часто используются в различных сценариях программирования для представления пустого текстового поля. Вы можете вызывать методы для пустых строк, так как они являются допустимыми объектами <xref:System.String?displayProperty=nameWithType>. Пустые строки инициализируются следующим образом:  
  
```csharp  
string s = String.Empty;  
```  
  
 В отличие от пустых строк строка NULL не ссылается на экземпляр объекта <xref:System.String?displayProperty=nameWithType>, поэтому любая попытка вызвать метод для строки NULL приводит к исключению <xref:System.NullReferenceException>. Но вы можете использовать строки NULL в операциях объединения и сравнения с другими строками. В следующих примерах показаны случаи, в которых ссылка на строку NULL вызывает и не вызывает исключение:  
  
 [!code-csharp[csProgGuideStrings#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#20)]  
  
## <a name="using-stringbuilder-for-fast-string-creation"></a>Использование класса StringBuilder для быстрого создания строк  
 Операции со строками в .NET хорошо оптимизированы, и в большинстве случаев они не снижают производительность. Но в некоторых сценариях, например в сплошных циклах, которые выполняются сотни и тысячи раз, операции со строками могут повлиять на производительность. Класс <xref:System.Text.StringBuilder> создает строковый буфер, который ускоряет работу, если программа выполняет много операций над строками. Строка <xref:System.Text.StringBuilder> также позволяет заново присваивать отдельные символы, что не поддерживает встроенный строковый тип данных. Например, этот код изменяет содержимое строки без создания новой строки:  
  
 [!code-csharp[csProgGuideStrings#15](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/Strings.cs#15)]  
  
 В этом примере объект <xref:System.Text.StringBuilder> используется для создания строки из набора числовых типов:  
  
 [!code-csharp[TestStringBuilder#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStrings/CS/TestStringBuilder.cs)]
  
## <a name="strings-extension-methods-and-linq"></a>Строки, методы расширения и LINQ  
 Так как тип <xref:System.String> использует <xref:System.Collections.Generic.IEnumerable%601>, вы можете применять методы расширения, определенные для строк в классе <xref:System.Linq.Enumerable>. Чтобы избежать визуального загромождения, эти методы исключены из IntelliSense для типа <xref:System.String>, но все равно доступны. Можно также использовать выражения запроса LINQ в строках. Дополнительные сведения см. в документации по [LINQ и строкам](../concepts/linq/linq-and-strings.md).  
  
## <a name="related-topics"></a>См. также  
  
|Раздел|Описание|  
|-----------|-----------------|  
|[Практическое руководство. Изменение содержимого строки](../../how-to/modify-string-contents.md)|Описание методов преобразования строк и изменения их содержимого.|  
|[Сравнение строк](../../how-to/compare-strings.md)|Рассказывает, как строки сравниваются по языку, региональным параметрам и порядку.|  
|[Сцепка нескольких строк](../../how-to/concatenate-multiple-strings.md)|Демонстрирует разные способы соединения нескольких строк в одну.|
|[Анализ строк с помощью метода String.Split](../../how-to/parse-strings-using-split.md)|Содержит примеры кода, демонстрирующие использование метода `String.Split` для анализа строк.|  
|[Практическое руководство. Поиск по строкам](../../how-to/search-strings.md)|Описание использования поиска для нахождения в строках определенных шаблонов или текста.|  
|[Определение представления числового значения в строке](./how-to-determine-whether-a-string-represents-a-numeric-value.md)|Объясняет, как безопасно проанализировать строку, чтобы проверить, содержит ли она допустимое числовое значение.|  
|[Интерполяция строк](../../language-reference/tokens/interpolated.md)|Описывает функцию интерполяции строк, которая предоставляет удобный синтаксис для форматирования строк.|
|[Базовые операции со строками в .NET Framework](../../../standard/base-types/basic-string-operations.md)|Содержит ссылки на статьи, в которых показаны базовые операции над строками с помощью методов <xref:System.String?displayProperty=nameWithType> и <xref:System.Text.StringBuilder?displayProperty=nameWithType>.|  
|[Parsing Strings](../../../standard/base-types/parsing-strings.md)|Описывает, как преобразовать строковые представления базовых типов .NET в экземпляры соответствующих типов.|  
|[Синтаксический анализ строк даты и времени в .NET](../../../standard/base-types/parsing-datetime.md)|Показывает, как преобразовать строку, например "01/24/2008", в объект <xref:System.DateTime?displayProperty=nameWithType>.|  
|[Сравнение строк в .NET Framework](../../../standard/base-types/comparing.md)|Объясняет, как сравнивать строки, и содержит примеры на языках C# и Visual Basic.|  
|[Using the StringBuilder class](../../../standard/base-types/stringbuilder.md) (Использование класса StringBuilder)|Описывает создание и изменение динамических строковых объектов с помощью класса <xref:System.Text.StringBuilder>.|  
|[LINQ и строки](../concepts/linq/linq-and-strings.md)|Содержит инструкции по выполнению различных операций со строками с помощью запросов LINQ.|  
|[Руководство по программированию на C#](../index.md)|Содержит ссылки на статьи с конструкциями программирования на C#.|  
