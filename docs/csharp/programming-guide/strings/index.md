---
title: "Строки (Руководство по программированию на C#) | Microsoft Docs"
ms.date: "2015-07-20"
ms.prod: ".net"
ms.technology: 
  - "devlang-csharp"
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "C# - язык, строки"
  - "строки [C#]"
ms.assetid: 21580405-cb25-4541-89d5-037846a38b07
caps.latest.revision: 41
author: "BillWagner"
ms.author: "wiwagn"
caps.handback.revision: 41
---
# Строки (Руководство по программированию на C#)
Строка является объектом типа <xref:System.String>, значением которого является текст.  По сути, текст хранится в виде последовательной доступной только для чтения коллекции объектов <xref:System.Char>.  В конце строки на языке C\# отсутствует символ, заканчивающийся на NULL; поэтому строка C\# может содержать любое число внедренных символов NULL \("\\0"\).  Свойство <xref:System.String.Length%2A> строки представляет число объектов `Char`, содержащихся в этой строке, а не число символов Юникода.  Для доступа к отдельным точкам в строке кода Юникода используется объект <xref:System.Globalization.StringInfo> object.  
  
## string илиSystem.String  
 В C\# ключевое слово `string` является псевдонимом свойства <xref:System.String>.  Поэтому `String` и `string` эквивалентны, и пользователи могут использовать любое наиболее предпочтительное для них соглашение по наименованию.  Класс `String` предоставляет множество методов для безопасного создания, обработки и сравнения строк.  Кроме того, язык C\# перегружает некоторые операторы для упрощения наиболее употребительных операций со строками.  Дополнительные сведения о ключевом слове см. в разделе [string](../../../csharp/language-reference/keywords/string.md).  Дополнительные сведения о типе и его методах см. в разделе <xref:System.String>.  
  
## Объявление и инициализация строк  
 Объявление и инициализацию строк можно выполнять различными способами, как показано в следующем примере:  
  
 [!code-cs[csProgGuideStrings#1](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#1)]  
  
 Обратите внимание, что для создания строкового объекта оператор [new](../../../csharp/language-reference/keywords/new-operator.md) не используется, за исключением, за исключением случаев инициализации строки массивом символов.  
  
 Инициализация строки значением константы <xref:System.String.Empty> приводит к созданию нового объекта <xref:System.String>, строка которого имеет нулевую длину.  Строковый литерал нулевой длины представляется как "".  При инициализации строк значением <xref:System.String.Empty> вместо [null](../../../csharp/language-reference/keywords/null.md) снижается вероятности возникновения <xref:System.NullReferenceException>.  Используйте статический метод <xref:System.String.IsNullOrEmpty%28System.String%29>, чтобы проверить значение строки перед попыткой обращения к ней.  
  
## Неизменность строковых объектов  
 Строковые объекты являются *неизменяемыми*: после создания их нельзя изменить.  Все методы <xref:System.String> и операторы C\#, которые, как можно было бы представить, изменяют строку, в действительности возвращают результаты в новый строковый объект.  В следующем примере, когда содержимое строк `s1` и `s2` объединяется в одну строку, две исходные строки не изменяются.  Оператор `+=` создает новую строку с объединенным содержимым.  Этот новый объект присваивается переменной `s1`, а исходный объект, который был присвоен строке `s1`, освобождается для сборки мусора, поскольку ни одна переменная не содержит ссылку на него.  
  
 [!code-cs[csProgGuideStrings#2](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#2)]  
  
 Поскольку "изменением" строки в действительности является созданием новой строки, необходима предосторожность при создании ссылок на строки.  Если создать ссылку на строку, а затем "изменить" исходную строку, то ссылка будет по\-прежнему указывать на исходный объект, а не на новый объект, который был создан при изменении строки.  Это поведение демонстрируется в следующем коде.  
  
 [!code-cs[csProgGuideStrings#25](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#25)]  
  
 Дополнительные сведения о том, как создавать новые строки, основанные на таких изменениях как операции поиска и замены исходной строки, см. в разделе [Практическое руководство. Изменение содержимого строки](../../../csharp/programming-guide/strings/how-to-modify-string-contents.md).  
  
## Правильные и буквальные строковые литералы  
 Правильные строковые литералы используются, если нужно внедрить escape\-символы, предоставляемые языком C\#, как показано в следующем примере.  
  
 [!code-cs[csProgGuideStrings#3](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#3)]  
  
 Буквальные строковые литералы используются для удобства и удобства чтения, если текст строки содержит символы обратной косой черты, например в путях к файлу.  Поскольку в буквальных строках сохраняются символы новой строки как часть текста строки, они могут использоваться для инициализации многострочных строк.  Для встраивания кавычек в буквальную строку используются двойные кавычки.  В следующем примере показаны примеры наиболее типичного использования буквальных строк.  
  
 [!code-cs[csProgGuideStrings#4](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#4)]  
  
## Escape\-последовательности строк  
  
|Escape\-последовательность|Имя символа|Кодировка Юникода|  
|--------------------------------|-----------------|-----------------------|  
|\\'|Одинарная кавычка|0x0027|  
|\\"|Двойная кавычка|0x0022|  
|\\\\|Обратная косая черта|0x005C|  
|\\0|Null|0x0000|  
|\\a|ALERT|0x0007|  
|\\b|Backspace|0x0008|  
|\\f|FORM FEED|0x000C|  
|\\n|Новая строка|0x000A|  
|\\r|Возврат каретки|0x000D|  
|\\t|Горизонтальная табуляция|0x0009|  
|\\U|Escape\-последовательность Юникода для пар символов\-заместителей.|\\Unnnnnnnn|  
|\\u|Escape\-последовательность Юникода|\\u0041 \= "A"|  
|\\v|Вертикальная табуляция|0x000B|  
|\\x|Escape\-последовательность Юникода аналогична "\\u", за исключением строк с переменной длиной.|\\x0041 \= "A"|  
  
> [!NOTE]
>  Во время компиляции буквальные строки преобразуются в обычные строки со всеми теми же escape\-последовательностями.  Поэтому, если в окне отладчика просматривается буквальная строка, будут видны escape\-символы, добавленные компилятором, а не буквальная версия из исходного кода.  Например, буквальная строка @"C:\\files.txt" в окне отладчика будет выглядеть как "C:\\\\files.txt".  
  
## Строки форматов  
 Строкой формата является строка, содержимое которой можно определить динамически во время выполнения.  Строка формата создается при помощи статического метода <xref:System.String.Format%2A> и внедренных местозаполнителей в скобках, которые во время выполнения будут заменены другими значениями.  В следующем примере используется строка формата для вывода результатов каждой итерации цикла.  
  
 [!code-cs[csProgGuideStrings#26](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#26)]  
  
 Одна перегрузка метода <xref:System.Console.WriteLine%2A> в качестве параметра принимает строку формата.  Поэтому можно просто внедрить строковый литерал формата без явного вызова метода.  Но если используется метод <xref:System.Diagnostics.Trace.WriteLine%2A> для отображения вывода отладочных данных в окно **Вывод** среды Visual Studio, необходимо явно вызвать метод <xref:System.String.Format%2A>, поскольку <xref:System.Diagnostics.Trace.WriteLine%2A> принимает только строку, а не строку формата.  Дополнительные сведения о строках форматах см. в разделе [Типы форматирования](../Topic/Formatting%20Types%20in%20the%20.NET%20Framework.md).  
  
## Подстроки  
 Подстрокой является последовательность символов, содержащихся в строке.  Метод <xref:System.String.Substring%2A> используется для создания новой строки на основании части исходной строки.  Одно или несколько вхождений подстроки можно найти с использованием метода <xref:System.String.IndexOf%2A>.  Метод <xref:System.String.Replace%2A> используется для замены всех вхождений заданной подстроки новой строкой.  Так же, как и метод <xref:System.String.Substring%2A>, метод <xref:System.String.Replace%2A> фактически возвращает новую строку и не изменяет исходную строку.  Дополнительные сведения см. в разделах [Практическое руководство. Поиск строк с помощью строковых методов](../../../csharp/programming-guide/strings/how-to-search-strings-using-string-methods.md) и [Практическое руководство. Изменение содержимого строки](../../../csharp/programming-guide/strings/how-to-modify-string-contents.md).  
  
 [!code-cs[csProgGuideStrings#7](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#7)]  
  
## Доступ к отдельным знакам  
 Нотацию массива можно использовать со значением индекса, чтобы получить доступ только для чтения к отдельным символам, как в следующем примере:  
  
 [!code-cs[csProgGuideStrings#9](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#9)]  
  
 Если методы <xref:System.String> не предоставляют функциональных возможностей, которые необходимы для изменения отдельных символов в строке, можно использовать объект <xref:System.Text.StringBuilder>, чтобы изменить отдельные символы "на месте", а затем создать новую строку для сохранения результатов с использованием методов <xref:System.Text.StringBuilder>.  В следующем примере предположим, что необходимо изменить исходную строку определенным образом, а затем сохранить результаты для дальнейшего использования.  
  
 [!code-cs[csProgGuideStrings#8](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#8)]  
  
## Строки с нулевыми значениями и пустые строки  
 Пустая строка — это экземпляр объекта <xref:System.String?displayProperty=fullName>, содержащий 0 знаков.  Пустые строки часто используются в различных сценариях программирования, представляя пустое текстовое поле.  Для пустых строк можно вызывать методы, потому что такие строки являются допустимыми объектами <xref:System.String?displayProperty=fullName>.  Пустые строки инициализируются следующим образом:  
  
```  
string s = String.Empty;  
```  
  
 Строки со значениями null \(с нулевыми значениями\), напротив, не ссылаются на экземпляр объекта <xref:System.String?displayProperty=fullName>, любая попытка вызвать метод на строка со значением null приведет к ошибке <xref:System.NullReferenceException>.  Однако такие строки можно использовать в операциях объединения и сравнения с другими строками.  В следующих примерах показаны некоторые случаи, в которых ссылка на строку со значением null вызывает либо не вызывает исключение:  
  
 [!code-cs[csProgGuideStrings#27](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#27)]  
  
## Использование StringBuilder для быстрого создания строк  
 Операции со строками в .NET в высокой степени оптимизированы и в большинстве случаев значительно не снижают производительность.  Однако в некоторых случаях, например, в непрерывных циклах, выполняющихся сотни и тысячи раз, операции со строками могут влиять на производительность.  Класс <xref:System.Text.StringBuilder> создает строковый буфер, который позволяет повысить производительность, если в программе обрабатывается много строк.  Класс <xref:System.Text.StringBuilder> также позволяет заново присваивать отдельные знаки, что не поддерживается встроенным строковым типом данных.  Например, данный код заменяет содержимое строки без создания новой строки:  
  
 [!code-cs[csProgGuideStrings#20](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#20)]  
  
 В этом примере объект <xref:System.Text.StringBuilder> используется для создания строки из набора числовых типов:  
  
 [!code-cs[csProgGuideStrings#15](../../../csharp/programming-guide/strings/codesnippet/csharp/CSRefStrings/Strings.cs#15)]  
  
## Строки, методы расширения и LINQ  
 Поскольку тип <xref:System.String> реализует <xref:System.Collections.Generic.IEnumerable%601>, можно использовать методы расширения, определенные в классе <xref:System.Linq.Enumerable> на строках.  Чтобы избежать загромождения рабочего пространства, эти методы исключены из IntelliSense для типа <xref:System.String>, но тем не менее, они доступны.  Можно также использовать выражения запросов [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq-md.md)] на строках.  Дополнительные сведения см. в разделе [LINQ and Strings](../../../visual-basic/programming-guide/concepts/linq/linq-and-strings.md).  
  
## Связанные разделы  
  
|Раздел|Описание|  
|------------|--------------|  
|[Практическое руководство. Изменение содержимого строки](../../../csharp/programming-guide/strings/how-to-modify-string-contents.md)|Содержит пример кода, с помощью которого показывается, как можно изменить содержимое строк.|  
|[Практическое руководство. Сцепка нескольких строк](../../../csharp/programming-guide/strings/how-to-concatenate-multiple-strings.md)|Иллюстрирует, как использовать оператор `+` и класс `Stringbuilder` для объединения строк во время компиляции и во время выполнения.|  
|[Практическое руководство. Сравнение строк](../../../csharp/programming-guide/strings/how-to-compare-strings.md)|Показано, как выполнять порядковые сравнения строк.|  
|[Практическое руководство. Анализ строк с помощью метода String.Split ](../../../csharp/programming-guide/strings/how-to-parse-strings-using-string-split.md)|Содержит пример кода, с помощью которого показывается, как можно использовать метод `String.Split` для выполнения анализа строк.|  
|[Практическое руководство. Поиск строк с помощью строковых методов](../../../csharp/programming-guide/strings/how-to-search-strings-using-string-methods.md)|Содержит описание использования конкретных методов для выполнения поиска по строкам.|  
|[Практическое руководство. Поиск строк с помощью регулярных выражений](../../../csharp/programming-guide/strings/how-to-search-strings-using-regular-expressions.md)|Содержит описание использования регулярных выражений для выполнения поиска по строкам.|  
|[Практическое руководство. Определение представления числового значения в строке](../../../csharp/programming-guide/strings/how-to-determine-whether-a-string-represents-a-numeric-value.md)|Показано, как безопасно выполнить синтаксический анализ строки, чтобы посмотреть, имеет ли она допустимое числовое значение.|  
|[Практическое руководство. Преобразование строки в значение типа "DateTime"](../../../csharp/programming-guide/strings/how-to-convert-a-string-to-a-datetime.md)|Показано, как преобразовать строку, такую как "24\/01\/2008", в объект <xref:System.DateTime?displayProperty=fullName>.|  
|[Основные операции со строками](../Topic/Basic%20String%20Operations%20in%20the%20.NET%20Framework.md)|Ссылки на разделы, в которых методы <xref:System.String?displayProperty=fullName> и <xref:System.Text.StringBuilder?displayProperty=fullName> используются для выполнения базовых операций на строками.|  
|[Разбор строк](../Topic/Parsing%20Strings%20in%20the%20.NET%20Framework.md)|Вставка знаков или пробелов в строку.|  
|[Сравнение строк](../Topic/Comparing%20Strings%20in%20the%20.NET%20Framework.md)|Содержит сведения о том, как выполняется сравнение строк, и примеры на языках C\# и Visual Basic.|  
|[Использование класса StringBuilder](../Topic/Using%20the%20StringBuilder%20Class%20in%20the%20.NET%20Framework.md)|Создание и изменение динамических строковых объектов с помощью класса <xref:System.Text.StringBuilder>.|  
|[LINQ and Strings](../../../visual-basic/programming-guide/concepts/linq/linq-and-strings.md)|Содержит сведения о том, как выполняются различные операции со строками с помощью запросов LINQ.|  
|[Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)|Содержит ссылки на разделы, содержащие конструкции программирования на языке C\#.|  
  
## Важная глава книги  
 [Дополнительные сведения о переменных](http://go.microsoft.com/fwlink/?LinkId=221230) IN [Начало Visual c\# 2010](http://go.microsoft.com/fwlink/?LinkId=221214)