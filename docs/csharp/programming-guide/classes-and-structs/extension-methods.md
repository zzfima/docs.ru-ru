---
title: Методы расширения (Руководство по программированию в C#)
ms.date: 07/20/2015
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: e2e63953e130dc83ce83bcdd2f8e9a2ffc7fe5f3
ms.sourcegitcommit: 89c93d05c2281b4c834f48f6c8df1047e1410980
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2018
---
# <a name="extension-methods-c-programming-guide"></a>Методы расширения (Руководство по программированию в C#)
Методы расширения позволяют "добавлять" методы в существующие типы без создания нового производного типа, перекомпиляции и иного изменения первоначального типа. Методы расширения представляют собой особую разновидность статического метода, но вызываются так же, как методы экземпляра в расширенном типе. Для клиентского кода, написанного на языках C#, F# и Visual Basic, нет видимого различия между вызовом метода расширения и вызовом методов, фактически определенных в типе.  
  
 Самые обычные методы расширения — стандартные операторы запросов [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)], которые добавляют функции запросов в существующие типы <xref:System.Collections.IEnumerable?displayProperty=nameWithType> и <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>. Для использования стандартных операторов запросов их необходимо ввести в область действия с помощью директивы `using System.Linq`. Тогда каждый тип, реализующий тип <xref:System.Collections.Generic.IEnumerable%601>, будет иметь методы экземпляра, в частности <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A> и т. д. Эти дополнительные методы можно видеть в завершении операторов IntelliSense при вводе точки после экземпляра типа <xref:System.Collections.Generic.IEnumerable%601>, например <xref:System.Collections.Generic.List%601> или <xref:System.Array>.  
  
 В следующем примере показано, как вызывать метод стандартного оператора запроса `OrderBy` для массива целых чисел. Выражение в скобках называется лямбда-выражением. Многие стандартные операторы запроса принимают лямбда-выражения в качестве параметров, но это необязательно для методов расширения. Дополнительные сведения см. в разделе [Лямбда-выражения](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).  
  
 [!code-csharp[csProgGuideExtensionMethods#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_1.cs)]  
  
 Методы расширения определяются как статические методы, но вызываются с помощью синтаксиса обращения к методу экземпляра. Их первый параметр определяет, с каким типом оперирует метод, и параметру предшествует модификатор [this](../../../csharp/language-reference/keywords/this.md). Методы расширения находятся в области действия, только если пространство имен было явно импортировано в исходный код с помощью директивы `using`.  
  
 В приведенном ниже примере показан метод расширения, определенный для класса <xref:System.String?displayProperty=nameWithType>. Обратите внимание, что этот метод определяется внутри невложенного, неуниверсального статического класса.  
  
 [!code-csharp[csProgGuideExtensionMethods#4](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_2.cs)]  
  
 Метод расширения `WordCount` можно ввести в область действия с помощью следующей директивы `using`:  
  
```csharp  
using ExtensionMethods;  
```  
  
 Его можно вызвать из приложения с помощью следующего синтаксиса:  
  
```csharp  
string s = "Hello Extension Methods";  
int i = s.WordCount();  
```  
  
 В созданном коде метод расширения вызывается с помощью синтаксиса обращения к методу экземпляра. Однако промежуточный язык (IL), создаваемый компилятором, преобразует код в вызов статического метода. Поэтому принцип инкапсуляции фактически не нарушается. Фактически, методы расширения не могут получать доступ к частным переменным типа, для расширения которого они используются.  
  
 Дополнительные сведения см. в разделе [Практическое руководство. Реализация и вызов пользовательского метода расширения](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).  
  
 Вообще, обычно гораздо чаще вызываются методы расширения, чем реализуются собственные методы. Так как методы расширения вызываются с помощью синтаксиса обращения к методу экземпляра, для использования их из клиентского кода специальные знания не требуются. Чтобы включить методы расширения для определенного типа, необходимо просто добавить директиву `using` для пространства имен, в котором эти методы определяются. Например, чтобы использовать стандартные операторы запроса, нужно добавить в код следующую директиву `using`:  
  
```csharp  
using System.Linq;  
```  
  
 (Также может потребоваться добавить ссылку на библиотеку System.Core.dll.) Обратите внимание, что стандартные операторы запроса теперь появляются в IntelliSense в виде дополнительных методов, доступных для большинства типов <xref:System.Collections.Generic.IEnumerable%601>.  
  
> [!NOTE]
>  Хотя стандартные операторы запросов не появляются в IntelliSense для типа <xref:System.String>, они все равно доступны.  
  
## <a name="binding-extension-methods-at-compile-time"></a>Привязка методов расширения во время компиляции  
 Методы расширения можно использовать для расширения класса или интерфейса, но не для их переопределения. Метод расширения, имеющий те же имя и сигнатуру, что и интерфейс или метод класса, никогда не вызывается. Во время компиляции методы расширения всегда имеют более низкий приоритет, чем методы экземпляра, определенные в самом типе. Другими словами, если тип имеет метод `Process(int i)`, а также есть метод расширения с такой же сигнатурой, компилятор будет всегда выполнять привязку к методу экземпляра. Если компилятор обнаруживает вызов метода, он сначала ищет совпадения с методами экземпляра типа. Если такое совпадение не найдено, компилятор выполняет поиск методов расширения, определенных для соответствующего типа, и создает привязку к первому обнаруженному методу расширения. В следующем примере кода демонстрируется, как компилятор определяет, к какому методу расширения или методу экземпляра необходимо выполнить привязку.  
  
## <a name="example"></a>Пример  
 В следующем примере демонстрируются правила, которые компилятор C# соблюдает при определении того, к чему необходимо привязать вызов метода — к методу экземпляра типа или к методу расширения. Статический класс `Extensions` содержит методы расширения, определяемые для любого типа, реализующего интерфейс `IMyInterface`. Все три класса — `A`, `B` и `C` — реализуют этот интерфейс.  
  
 Метод расширения `MethodB` никогда не вызывается, потому что его имя и сигнатура точно совпадают с методами, уже реализованными этими классами.  
  
 Если компилятор не может найти метод экземпляра с совпадающей сигнатурой, он выполняет привязку к совпадающему методу расширения, если такой существует.  
  
 [!code-csharp[csProgGuideExtensionMethods#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_3.cs)]  
  
## <a name="general-guidelines"></a>Общие рекомендации  
 В общем, методы расширения рекомендуется реализовывать в ограниченном количестве и только при необходимости. Когда это возможно, клиентский код, служащий для расширения существующего типа, должен осуществлять расширение путем создания нового типа, производного от существующего. Дополнительные сведения см. в разделе [Наследование](../../../csharp/programming-guide/classes-and-structs/inheritance.md).  
  
 При использовании метода расширения для расширения типа, исходный код которого невозможно изменить, возникает риск того, что изменение в реализации типа вызовет сбой метода расширения.  
  
 В случае реализации методов расширения для какого-либо типа необходимо помнить о следующих фактах:  
  
-   Метод расширения никогда не будет вызван, если он имеет ту же сигнатуру, что и метод, определенный в типе.  
  
-   Методы расширения вводятся в область действия на уровне пространства имен. Например, при наличии нескольких статических классов, содержащих методы расширения в единственном пространстве имен с именем `Extensions`, все они будут введены в область действия директивой `using Extensions;`.  
  
 Для реализованной библиотеки классов не следует использовать методы расширения во избежание увеличения номера версии сборки. Если требуется добавить значительную функциональность в библиотеку, владельцем исходного кода которой вы являетесь, необходимо соблюдать стандартные правила .NET Framework по управлению версиями сборок. Дополнительные сведения см. в разделе [Версии сборок](../../../../docs/framework/app-domains/assembly-versioning.md).  
  
## <a name="see-also"></a>См. также  
 [Руководство по программированию на C#](../../../csharp/programming-guide/index.md)  
 [Parallel Programming Samples (Образцы параллельного программирования, включают множество примеров методов расширения)](http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)  
 [Лямбда-выражения](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)  
 [Общие сведения о стандартных операторах запроса](http://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2)  
 [Conversion Rules for Instance Parameters and their Impact (Правила преобразования для параметров экземпляра и их влияние)](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/conversion-rules-for-instance-parameters-and-their-impact)  
 [Extension Methods Interoperability between Languages (Взаимодействие между языками с помощью методов расширения)](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/extension-methods-interoperability-between-languages)  
 [Extension Methods and Curried Delegates (Методы расширения и каррированные делегаты)](https://blogs.msdn.microsoft.com/sreekarc/2007/05/01/extension-methods-and-curried-delegates)  
 [Extension method Binding and Error reporting](https://blogs.msdn.microsoft.com/sreekarc/2007/04/26/extension-method-binding-and-error-reporting)
