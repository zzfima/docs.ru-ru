---
title: Руководство по программированию на C#. Методы расширения
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 0b35ad523fc7f0949cb5243edbdc50cd3e927999
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249224"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="c6990-102">Методы расширения (Руководство по программированию в C#)</span><span class="sxs-lookup"><span data-stu-id="c6990-102">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="c6990-103">Методы расширения позволяют "добавлять" методы в существующие типы без создания нового производного типа, перекомпиляции и иного изменения первоначального типа.</span><span class="sxs-lookup"><span data-stu-id="c6990-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="c6990-104">Методы расширения представляют собой разновидность статического метода, но вызываются так же, как методы экземпляра в расширенном типе.</span><span class="sxs-lookup"><span data-stu-id="c6990-104">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="c6990-105">Для клиентского кода, написанного на языках C#, F# и Visual Basic, нет видимого различия между вызовом метода расширения и вызовом методов, определенных в типе.</span><span class="sxs-lookup"><span data-stu-id="c6990-105">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="c6990-106">Самые распространенные методы расширения — стандартные операторы запросов LINQ, которые добавляют функции запросов в существующие типы <xref:System.Collections.IEnumerable?displayProperty=nameWithType> и <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c6990-106">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="c6990-107">Для использования стандартных операторов запросов их необходимо ввести в область действия с помощью директивы `using System.Linq`.</span><span class="sxs-lookup"><span data-stu-id="c6990-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="c6990-108">Тогда каждый тип, реализующий тип <xref:System.Collections.Generic.IEnumerable%601>, будет иметь методы экземпляра, в частности <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A> и т. д.</span><span class="sxs-lookup"><span data-stu-id="c6990-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="c6990-109">Эти дополнительные методы можно видеть в завершении операторов IntelliSense при вводе точки после экземпляра типа <xref:System.Collections.Generic.IEnumerable%601>, например <xref:System.Collections.Generic.List%601> или <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="c6990-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="c6990-110">Пример OrderBy</span><span class="sxs-lookup"><span data-stu-id="c6990-110">OrderBy Example</span></span>

<span data-ttu-id="c6990-111">В следующем примере показано, как вызывать метод стандартного оператора запроса `OrderBy` для массива целых чисел.</span><span class="sxs-lookup"><span data-stu-id="c6990-111">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="c6990-112">Выражение в скобках называется лямбда-выражением.</span><span class="sxs-lookup"><span data-stu-id="c6990-112">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="c6990-113">Многие стандартные операторы запроса принимают лямбда-выражения в качестве параметров, но это необязательно для методов расширения.</span><span class="sxs-lookup"><span data-stu-id="c6990-113">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="c6990-114">Дополнительные сведения см. в разделе [Лямбда-выражения](../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="c6990-114">For more information, see [Lambda Expressions](../statements-expressions-operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="c6990-115">Методы расширения определяются как статические методы, но вызываются с помощью синтаксиса обращения к методу экземпляра.</span><span class="sxs-lookup"><span data-stu-id="c6990-115">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="c6990-116">Их первый параметр определяет, с каким типом оперирует метод.</span><span class="sxs-lookup"><span data-stu-id="c6990-116">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="c6990-117">Параметру предшествует модификатор [this](../../language-reference/keywords/this.md).</span><span class="sxs-lookup"><span data-stu-id="c6990-117">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="c6990-118">Методы расширения находятся в области действия, только если пространство имен было явно импортировано в исходный код с помощью директивы `using`.</span><span class="sxs-lookup"><span data-stu-id="c6990-118">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="c6990-119">В приведенном ниже примере показан метод расширения, определенный для класса <xref:System.String?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c6990-119">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="c6990-120">Этот метод определяется внутри невложенного, неуниверсального статического класса:</span><span class="sxs-lookup"><span data-stu-id="c6990-120">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="c6990-121">Метод расширения `WordCount` можно ввести в область действия с помощью следующей директивы `using`:</span><span class="sxs-lookup"><span data-stu-id="c6990-121">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="c6990-122">Его можно вызвать из приложения с помощью следующего синтаксиса:</span><span class="sxs-lookup"><span data-stu-id="c6990-122">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="c6990-123">В созданном коде метод расширения вызывается с помощью синтаксиса обращения к методу экземпляра.</span><span class="sxs-lookup"><span data-stu-id="c6990-123">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="c6990-124">Промежуточный язык (IL), создаваемый компилятором, преобразует код в вызов статического метода.</span><span class="sxs-lookup"><span data-stu-id="c6990-124">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="c6990-125">Принцип инкапсуляции фактически не нарушается.</span><span class="sxs-lookup"><span data-stu-id="c6990-125">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="c6990-126">Методы расширения не могут получать доступ к частным переменным типа, для расширения которого они используются.</span><span class="sxs-lookup"><span data-stu-id="c6990-126">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="c6990-127">Дополнительные сведения см. в разделе [Практическое руководство. Реализация и вызов пользовательского метода расширения](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="c6990-127">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="c6990-128">Вообще, обычно гораздо чаще вызываются методы расширения, чем реализуются собственные методы.</span><span class="sxs-lookup"><span data-stu-id="c6990-128">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="c6990-129">Так как методы расширения вызываются с помощью синтаксиса обращения к методу экземпляра, для использования их из клиентского кода специальные знания не требуются.</span><span class="sxs-lookup"><span data-stu-id="c6990-129">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="c6990-130">Чтобы включить методы расширения для определенного типа, необходимо просто добавить директиву `using` для пространства имен, в котором эти методы определяются.</span><span class="sxs-lookup"><span data-stu-id="c6990-130">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="c6990-131">Например, чтобы использовать стандартные операторы запроса, нужно добавить в код следующую директиву `using`:</span><span class="sxs-lookup"><span data-stu-id="c6990-131">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="c6990-132">(Также может потребоваться добавить ссылку на библиотеку System.Core.dll.) Обратите внимание, что стандартные операторы запроса теперь появляются в IntelliSense в виде дополнительных методов, доступных для большинства типов <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="c6990-132">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="c6990-133">Привязка методов расширения во время компиляции</span><span class="sxs-lookup"><span data-stu-id="c6990-133">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="c6990-134">Методы расширения можно использовать для расширения класса или интерфейса, но не для их переопределения.</span><span class="sxs-lookup"><span data-stu-id="c6990-134">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="c6990-135">Метод расширения, имеющий те же имя и сигнатуру, что и интерфейс или метод класса, никогда не вызывается.</span><span class="sxs-lookup"><span data-stu-id="c6990-135">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="c6990-136">Во время компиляции методы расширения всегда имеют более низкий приоритет, чем методы экземпляра, определенные в самом типе.</span><span class="sxs-lookup"><span data-stu-id="c6990-136">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="c6990-137">Другими словами, если тип имеет метод `Process(int i)`, а также есть метод расширения с такой же сигнатурой, компилятор будет всегда выполнять привязку к методу экземпляра.</span><span class="sxs-lookup"><span data-stu-id="c6990-137">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="c6990-138">Если компилятор обнаруживает вызов метода, он сначала ищет совпадения с методами экземпляра типа.</span><span class="sxs-lookup"><span data-stu-id="c6990-138">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="c6990-139">Если такое совпадение не найдено, компилятор выполняет поиск методов расширения, определенных для соответствующего типа, и создает привязку к первому обнаруженному методу расширения.</span><span class="sxs-lookup"><span data-stu-id="c6990-139">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="c6990-140">В следующем примере кода демонстрируется, как компилятор определяет, к какому методу расширения или методу экземпляра необходимо выполнить привязку.</span><span class="sxs-lookup"><span data-stu-id="c6990-140">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="c6990-141">Пример</span><span class="sxs-lookup"><span data-stu-id="c6990-141">Example</span></span>

<span data-ttu-id="c6990-142">В следующем примере демонстрируются правила, которые компилятор C# соблюдает при определении того, к чему необходимо привязать вызов метода — к методу экземпляра типа или к методу расширения.</span><span class="sxs-lookup"><span data-stu-id="c6990-142">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="c6990-143">Статический класс `Extensions` содержит методы расширения, определяемые для любого типа, реализующего интерфейс `IMyInterface`.</span><span class="sxs-lookup"><span data-stu-id="c6990-143">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="c6990-144">Все три класса — `A`, `B` и `C` — реализуют этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="c6990-144">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="c6990-145">Метод расширения `MethodB` никогда не вызывается, потому что его имя и сигнатура точно совпадают с методами, уже реализованными этими классами.</span><span class="sxs-lookup"><span data-stu-id="c6990-145">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="c6990-146">Если компилятор не может найти метод экземпляра с совпадающей сигнатурой, он выполняет привязку к совпадающему методу расширения, если такой существует.</span><span class="sxs-lookup"><span data-stu-id="c6990-146">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="c6990-147">Общие варианты использования</span><span class="sxs-lookup"><span data-stu-id="c6990-147">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="c6990-148">Функциональные возможности коллекций</span><span class="sxs-lookup"><span data-stu-id="c6990-148">Collection Functionality</span></span>

<span data-ttu-id="c6990-149">В прошлом было распространено создание классов коллекций, которые реализовали интерфейс <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> для данного типа и содержали функциональные возможности, действующие на коллекции этого типа.</span><span class="sxs-lookup"><span data-stu-id="c6990-149">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="c6990-150">Хотя в создании этого типа объекта коллекции нет ничего плохого, те же функциональные возможности можно получить, используя расширение <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c6990-150">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c6990-151">Преимущество расширений заключается в том, что они позволяют вызывать функциональные возможности из любой коллекции, например <xref:System.Array?displayProperty=nameWithType> или <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>, которая реализует <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> для этого типа.</span><span class="sxs-lookup"><span data-stu-id="c6990-151">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="c6990-152">Пример использования массива Int32 описан [ранее в этой статье](#orderby-example).</span><span class="sxs-lookup"><span data-stu-id="c6990-152">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="c6990-153">Функциональные возможности конкретного слоя</span><span class="sxs-lookup"><span data-stu-id="c6990-153">Layer-Specific Functionality</span></span>

<span data-ttu-id="c6990-154">При использовании многослойной архитектуры или другой многослойной модели приложения обычно используется набор сущностей предметной области или объектов передачи данных, которые можно использовать для обмена данными между границами приложений.</span><span class="sxs-lookup"><span data-stu-id="c6990-154">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="c6990-155">Обычно эти объекты содержат только минимальные функциональные возможности (или вовсе их не содержат), применимые ко всем слоям приложения.</span><span class="sxs-lookup"><span data-stu-id="c6990-155">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="c6990-156">Методы расширения можно использовать, чтобы добавить функциональные возможности для каждого конкретного слоя приложения без загрузки объекта с помощью методов, которые не нужны или не требуются для других слоев.</span><span class="sxs-lookup"><span data-stu-id="c6990-156">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```aspx-csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="c6990-157">Расширение предопределенных типов</span><span class="sxs-lookup"><span data-stu-id="c6990-157">Extending Predefined Types</span></span>

<span data-ttu-id="c6990-158">Если необходимо создать многократно используемые функциональные возможности, вы можете расширить существующий тип, например .NET Framework или тип CLR, чтобы не создавать дополнительные объекты.</span><span class="sxs-lookup"><span data-stu-id="c6990-158">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type such as a .NET Framework or CLR type.</span></span> <span data-ttu-id="c6990-159">Например, если методы расширения не используются, можно создать класс `Engine` или `Query`, чтобы выполнить запрос к SQL Server, который можно вызвать из нескольких расположений в коде.</span><span class="sxs-lookup"><span data-stu-id="c6990-159">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="c6990-160">Однако вместо этого можно расширить класс <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> с помощью методов расширения, чтобы выполнить этот запрос из любого расположения, где установлено подключение с SQL Server.</span><span class="sxs-lookup"><span data-stu-id="c6990-160">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="c6990-161">В качестве второго примера можно привести добавление общих функциональных возможностей в класс <xref:System.String?displayProperty=nameWithType>, расширение возможностей обработки данных объектов <xref:System.IO.File?displayProperty=nameWithType> и <xref:System.IO.Stream?displayProperty=nameWithType>, а также объектов <xref:System.Exception?displayProperty=nameWithType> для функциональных возможностей обработки конкретных ошибок.</span><span class="sxs-lookup"><span data-stu-id="c6990-161">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="c6990-162">Сценарии использования ограничиваются только воображением и здравым смыслом.</span><span class="sxs-lookup"><span data-stu-id="c6990-162">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="c6990-163">Расширение предопределенных типов с помощью типов `struct` может быть сложным, так как они передаются методам по значению.</span><span class="sxs-lookup"><span data-stu-id="c6990-163">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="c6990-164">Это означает, что любые изменения структуры вносятся в ее копию.</span><span class="sxs-lookup"><span data-stu-id="c6990-164">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="c6990-165">Эти изменения не отображаются после выхода из метода расширения.</span><span class="sxs-lookup"><span data-stu-id="c6990-165">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="c6990-166">Начиная с C# 7.2, вы можете добавить модификатор `ref` к первому аргументу метода расширения.</span><span class="sxs-lookup"><span data-stu-id="c6990-166">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="c6990-167">Добавление модификатора `ref` означает, что первый аргумент передается по ссылке.</span><span class="sxs-lookup"><span data-stu-id="c6990-167">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="c6990-168">Это позволяет создавать методы расширения, изменяющие состояние расширяемой структуры.</span><span class="sxs-lookup"><span data-stu-id="c6990-168">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="c6990-169">Общие рекомендации</span><span class="sxs-lookup"><span data-stu-id="c6990-169">General Guidelines</span></span>

<span data-ttu-id="c6990-170">Хотя по-прежнему предпочтительнее добавлять функциональные возможности путем изменения кода объекта или создания производного типа, когда это целесообразно и возможно, методы расширения стали ключевым вариантом для создания многократно используемых функциональных возможностей во всей экосистеме .NET.</span><span class="sxs-lookup"><span data-stu-id="c6990-170">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="c6990-171">Методы расширения также являются отличным выбором, если вы не управляете исходным источником, если производный объект недопустим или невозможен или если функциональные возможности должны быть недоступными за пределами применимой области.</span><span class="sxs-lookup"><span data-stu-id="c6990-171">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="c6990-172">Дополнительные сведения о производных типах см. в статье [Наследование (Руководство по программированию на C#)](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="c6990-172">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="c6990-173">При использовании метода расширения для расширения типа, исходный код которого невозможно изменить, возникает риск того, что изменение в реализации типа вызовет сбой метода расширения.</span><span class="sxs-lookup"><span data-stu-id="c6990-173">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="c6990-174">В случае реализации методов расширения для какого-либо типа необходимо помнить о следующих фактах:</span><span class="sxs-lookup"><span data-stu-id="c6990-174">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="c6990-175">Метод расширения никогда не будет вызван, если он имеет ту же сигнатуру, что и метод, определенный в типе.</span><span class="sxs-lookup"><span data-stu-id="c6990-175">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="c6990-176">Методы расширения вводятся в область действия на уровне пространства имен.</span><span class="sxs-lookup"><span data-stu-id="c6990-176">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="c6990-177">Например, при наличии нескольких статических классов, содержащих методы расширения в единственном пространстве имен с именем `Extensions`, все они будут введены в область действия директивой `using Extensions;`.</span><span class="sxs-lookup"><span data-stu-id="c6990-177">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="c6990-178">Для реализованной библиотеки классов не следует использовать методы расширения во избежание увеличения номера версии сборки.</span><span class="sxs-lookup"><span data-stu-id="c6990-178">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="c6990-179">Если требуется добавить значительную функциональность в библиотеку, владельцем исходного кода которой вы являетесь, необходимо соблюдать стандартные правила .NET Framework по управлению версиями сборок.</span><span class="sxs-lookup"><span data-stu-id="c6990-179">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="c6990-180">Дополнительные сведения см. в разделе [Версии сборок](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="c6990-180">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="c6990-181">См. также</span><span class="sxs-lookup"><span data-stu-id="c6990-181">See also</span></span>

- [<span data-ttu-id="c6990-182">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="c6990-182">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="c6990-183">Parallel Programming Samples (Образцы параллельного программирования, включают множество примеров методов расширения)</span><span class="sxs-lookup"><span data-stu-id="c6990-183">Parallel Programming Samples (these include many example extension methods)</span></span>](https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)
- [<span data-ttu-id="c6990-184">Лямбда-выражения</span><span class="sxs-lookup"><span data-stu-id="c6990-184">Lambda Expressions</span></span>](../statements-expressions-operators/lambda-expressions.md)
- [<span data-ttu-id="c6990-185">Общие сведения о стандартных операторах запроса</span><span class="sxs-lookup"><span data-stu-id="c6990-185">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="c6990-186">Conversion Rules for Instance Parameters and their Impact (Правила преобразования для параметров экземпляра и их влияние)</span><span class="sxs-lookup"><span data-stu-id="c6990-186">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="c6990-187">Extension Methods Interoperability between Languages (Взаимодействие между языками с помощью методов расширения)</span><span class="sxs-lookup"><span data-stu-id="c6990-187">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="c6990-188">Extension Methods and Curried Delegates (Методы расширения и каррированные делегаты)</span><span class="sxs-lookup"><span data-stu-id="c6990-188">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="c6990-189">Extension method Binding and Error reporting</span><span class="sxs-lookup"><span data-stu-id="c6990-189">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
