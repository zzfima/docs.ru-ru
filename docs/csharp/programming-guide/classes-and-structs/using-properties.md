---
title: "Использование свойств (Руководство по программированию в C#) | Microsoft Docs"
ms.date: "2015-07-20"
ms.prod: ".net"
ms.technology: 
  - "devlang-csharp"
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "get - метод доступа [C#]"
  - "свойства [C#], о свойствах"
  - "set - метод доступа [C#]"
ms.assetid: f7f67b05-0983-4cdb-96af-1855d24c967c
caps.latest.revision: 24
author: "BillWagner"
ms.author: "wiwagn"
caps.handback.revision: 24
---
# Использование свойств (Руководство по программированию в C#)
Свойства объединяют функции полей и методов.  Для объекта, использующего какой\-либо объект, свойство является полем, поэтому для доступа к свойству требуется тот же синтаксис, что и для поля.  Для средства реализации класса свойство является одним или двумя блоками кода, представляющими метод доступа [get](../../../csharp/language-reference/keywords/get.md) и\/или метод доступа [set](../../../csharp/language-reference/keywords/set.md).  Блок кода для метода доступа `get` выполняется, когда осуществляется чтение свойства; блок кода для метода доступа `set` выполняется, когда свойству присваивается новое значение.  Свойство без метода доступа `set` считается доступным только для чтения.  Свойство без метода доступа `get` считается доступным только для чтения.  Свойство с обоими методами доступа доступно для чтения и для записи.  
  
 В отличие от полей свойства не классифицируются как переменные.  Поэтому свойство нельзя передать в качестве параметра [ref](../../../csharp/language-reference/keywords/ref.md) или [out](../../../csharp/language-reference/keywords/out.md).  
  
 Свойства имеют множество применений: с их помощью можно проверить данные перед разрешением изменения, они могут прозрачно представлять данные в классе, куда эти данные извлекаются из какого\-либо другого источника, например базы данных, они могут выполнять действие при изменении данных, например вызов события или изменение значения в других полях.  
  
 Свойства объявляются в блоке класса с помощью последовательного указания уровня доступа для поля, типа свойства, имени свойства и блока кода, в котором объявляется метод доступа `get` и\/или `set`.  Примеры.  
  
 [!code-cs[csProgGuideProperties#7](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_1.cs)]  
  
 В данном примере `Month` объявляется как свойство, поэтому метод доступа `set` может обеспечить задание для свойства `Month` значения от 1 до 12.  Свойство `Month` использует частное поле для отслеживания фактического значения.  Фактическое местоположение данных свойства часто называется "резервным хранилищем" этого свойства. Обычно в качестве резервного хранилища свойств используются частные поля.  Поле помечается как частное для того, чтобы предотвратить изменение других полей при вызове данного свойства.  Дополнительные сведения об ограничениях общего и закрытого доступа см. в разделе [Модификаторы доступа](../../../csharp/programming-guide/classes-and-structs/access-modifiers.md).  
  
 Автоматически реализуемые свойства позволяют использовать упрощенный синтаксис для простых объявлений свойств.  Дополнительные сведения см. в разделе [Автоматически реализуемые свойства](../../../csharp/programming-guide/classes-and-structs/auto-implemented-properties.md).  
  
## Метод доступа get  
 Основная часть метода доступа `get` похожа на основную часть метода.  Она должна возвращать значение типа свойства.  Выполнение метода доступа `get` эквивалентно считыванию значения поля.  Например, когда возвращается частная переменная из метода доступа `get` и разрешена оптимизация, вызов метода доступа `get` встраивается компилятором, что позволяет избежать ненужных затрат на вызов метода.  Однако виртуальный метод доступа `get` не может быть встроен, поскольку во время компиляции у компилятора нет данных о том, какой метод может быть вызван во время выполнения.  Ниже приведен метод доступа `get`, который возвращает значение частного поля `name`:  
  
 [!code-cs[csProgGuideProperties#8](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_2.cs)]  
  
 При создании ссылки на свойство, кроме случая присвоения ему значения, для чтения значения свойства вызывается метод доступа `get`.  Примеры.  
  
 [!code-cs[csProgGuideProperties#9](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_3.cs)]  
  
 Метод доступа `get` должен заканчиваться оператором [return](../../../csharp/language-reference/keywords/return.md) или [throw](../../../csharp/language-reference/keywords/throw.md), а элемент управления не должен выходить за основную часть метода доступа.  
  
 Изменение состояния объекта с помощью метода доступа `get` указывает на низкую квалификацию программиста.  Например, следующий метод доступа имеет побочный эффект, заключающийся в изменении состояния объекта при каждой операции доступа к полю `number`.  
  
 [!code-cs[csProgGuideProperties#10](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_4.cs)]  
  
 Метод доступа `get` можно использовать для возвращения значения поля или для вычисления и возвращения этого значения.  Примеры.  
  
 [!code-cs[csProgGuideProperties#11](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_5.cs)]  
  
 Если в предыдущем фрагменте кода свойству `Name` не назначается какое\-либо значение, это свойство возвращает значение "NA".  
  
## Метод доступа set  
 Метод доступа `set` похож на метод, имеющий тип возвращаемого значения [void](../../../csharp/language-reference/keywords/void.md).  В нем используется неявный параметр `value`, тип которого соответствует типу свойства.  В следующем примере метод доступа `set` добавляется в свойство `Name`:  
  
 [!code-cs[csProgGuideProperties#12](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_6.cs)]  
  
 Когда свойству присваивается значение, выполняется вызов метода доступа `set` с помощью аргумента, предоставляющего новое значение.  Примеры.  
  
 [!code-cs[csProgGuideProperties#13](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_7.cs)]  
  
 Использование имени неявного параметра `value` для объявления локальной переменной в методе доступа `set` является ошибкой.  
  
## Заметки  
 Свойства можно пометить как `public`, `private`, `protected`, `internal` или `protected internal`.  Эти модификаторы доступа определяют порядок доступа к свойству для пользователей класса.  Методы доступа `get` и `set` могут иметь различные модификаторы доступа для одного свойства.  Например, метод доступа `get` может иметь модификатор `public` для разрешения доступа только для чтения из типа, а метод доступа `set` может иметь модификатор `private` или `protected`.  Дополнительные сведения см. в разделе [Модификаторы доступа](../../../csharp/programming-guide/classes-and-structs/access-modifiers.md).  
  
 Свойство можно объявить как статическое свойство при помощи ключевого слова `static`.  При этом свойство становится доступным для вызова в любое время, даже если экземпляр класса отсутствует.  Дополнительные сведения см. в разделе [Статические классы и члены статических классов](../../../csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members.md).  
  
 Свойство можно пометить как статическое свойство при помощи ключевого слова [virtual](../../../csharp/language-reference/keywords/virtual.md).  Это позволяет производным классам переопределять поведение свойства при помощи ключевого слова [override](../../../csharp/language-reference/keywords/override.md).  Дополнительные сведения об этих параметрах содержатся в разделе [Наследование](../../../csharp/programming-guide/classes-and-structs/inheritance.md).  
  
 Свойство, переопределяющее виртуальное свойство, может также быть [sealed](../../../csharp/language-reference/keywords/sealed.md), что указывает на то, что для производных классов оно более не является виртуальным.  И наконец, свойство можно объявить как [abstract](../../../csharp/language-reference/keywords/abstract.md).  Это означает, что в классе отсутствует реализация, поэтому производные классы должны создавать свою собственную реализацию.  Дополнительные сведения об этих параметрах содержатся в разделе [Абстрактные и запечатанные классы и члены классов](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).  
  
> [!NOTE]
>  Использование модификатора [виртуальные](../../../csharp/language-reference/keywords/virtual.md), [abstract](../../../csharp/language-reference/keywords/abstract.md) или [override](../../../csharp/language-reference/keywords/override.md) для метода доступа свойства [static](../../../csharp/language-reference/keywords/static.md) является ошибкой.  
  
## Пример  
 В данном примере демонстрируются свойства экземпляра, статические свойства и свойства, доступные только для чтения.  Данный код принимает имя сотрудника, введенное с клавиатуры, увеличивает на 1 значение `NumberOfEmployees` и отображает имя и номер сотрудника.  
  
 [!code-cs[csProgGuideProperties#2](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_8.cs)]  
  
## Пример  
 В данном примере демонстрируется доступ к свойству в базовом классе, которое скрыто другим свойством, имеющим такое же имя в производном классе.  
  
 [!code-cs[csProgGuideProperties#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_9.cs)]  
  
 Далее перечислены важные замечания по предыдущему примеру:  
  
-   Свойство `Name` в производном классе скрыто свойством `Name` в базовом классе.  В этом случае модификатор `new` используется в объявлении свойства в производном классе:  
  
     [!code-cs[csProgGuideProperties#4](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_10.cs)]  
  
-   Приведение `(Employee)` используется для доступа к скрытому свойству в базовом классе:  
  
     [!code-cs[csProgGuideProperties#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_11.cs)]  
  
     Дополнительные сведения о скрытии членов см. в разделе [Модификатор new](../../../csharp/language-reference/keywords/new-modifier.md).  
  
## Пример  
 В данном примере два класса `Cube` и `Square` реализуют абстрактный класс `Shape` и переопределяют его абстрактное свойство `Area`.  Обратите внимание на использование для свойств модификатора [override](../../../csharp/language-reference/keywords/override.md).  Программа принимает размер стороны в качестве входных данных и вычисляет площади квадрата и куба.  Она также принимает площадь в качестве входных данных и вычисляет значение стороны квадрата и куба.  
  
 [!code-cs[csProgGuideProperties#6](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/using-properties_12.cs)]  
  
## См. также  
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Свойства](../../../csharp/programming-guide/classes-and-structs/properties.md)   
 [Свойства интерфейса](../../../csharp/programming-guide/classes-and-structs/interface-properties.md)   
 [Автоматически реализуемые свойства](../../../csharp/programming-guide/classes-and-structs/auto-implemented-properties.md)