---
title: Руководство по программированию на C#. Наследование
ms.custom: seodec18
ms.date: 07/20/2015
helpviewer_keywords:
- abstract methods [C#]
- abstract classes [C#]
- inheritance [C#]
- derived classes [C#]
- virtual methods [C#]
- C# language, inheritance
ms.assetid: 81d64ee4-50f9-4d6c-a8dc-257c348d2eea
ms.openlocfilehash: 9ad7253fb9efc891e1f0fdea118e1fe7bde6a857
ms.sourcegitcommit: 16aefeb2d265e69c0d80967580365fabf0c5d39a
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/18/2019
ms.locfileid: "58125919"
---
# <a name="inheritance-c-programming-guide"></a>Наследование (Руководство по программированию на C#)

Наследование, вместе с инкапсуляцией и полиморфизмом, является одной из трех основных характеристик объектно-ориентированного программирования. Наследование позволяет создавать новые классы, которые повторно используют, расширяют и изменяют поведение, определенное в другом классе. Класс, члены которого наследуются, называется *базовым классом*, а класс, который наследует эти члены, называется *производным классом*. Производный класс может иметь только один прямой базовый класс. Однако наследование является транзитивным. Если класс ClassC является производным от ClassB, и ClassB является производным от ClassA, ClassC наследует члены, объявленные в ClassB и ClassA.  
  
> [!NOTE]
>  Структуры не поддерживают наследование, но могут реализовывать интерфейсы. Дополнительные сведения см. в разделе [Интерфейсы](../../../csharp/programming-guide/interfaces/index.md).  
  
 Концептуально производный класс является специализацией базового класса. Например, при наличии базового класса `Animal` возможно наличие одного производного класса, который называется `Mammal`, и еще одного производного класса, который называется `Reptile`. `Mammal` является `Animal` и `Reptile` является `Animal`, но каждый производный класс представляет разные специализации базового класса.  
  
 При определении класса для наследования от другого класса производный класс явно получает все члены базового класса за исключением конструкторов и методов завершения. Производный класс может, таким образом, повторно использовать код в базовом классе без необходимости в его повторной реализации. В производном классе можно добавить больше членов. Таким образом, производный класс расширяет функциональность базового класса.  
  
 На следующем рисунке показан класс `WorkItem`, представляющий рабочий элемент в бизнес-процессе. Как и другие классы, он является производным от <xref:System.Object?displayProperty=nameWithType> и наследует все его методы. В `WorkItem` имеется пять собственных членов. К ним относятся конструктор, поскольку конструкторы не наследуются. Класс `ChangeRequest` наследует от `WorkItem` и представляет конкретный вид рабочего элемента. `ChangeRequest` добавляет еще два члена к членам, унаследованным от `WorkItem` и <xref:System.Object>. Он должен добавить собственный конструктор, и он также добавляет `originalItemID`. Свойство `originalItemID` позволяет `ChangeRequest` связать экземпляр с исходным объектом `WorkItem`, к которому применен запрос на изменение.  
  
 ![Схема, показывающая наследование классов](./media/inheritance/class-inheritance-diagram.png)  
  
 В следующем примере показано, как выражаются в C# отношения между классами, продемонстрированные на предыдущем рисунке. В примере также показано, как `WorkItem` переопределяет виртуальный метод <xref:System.Object.ToString%2A?displayProperty=nameWithType> и как класс `ChangeRequest` наследует `WorkItem` реализацию метода.  
  
 [!code-csharp[csProgGuideInheritance#49](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#49)]  
  
## <a name="abstract-and-virtual-methods"></a>Абстрактные и виртуальные методы  
 Когда базовый класс объявляет метод как [виртуальный](../../../csharp/language-reference/keywords/virtual.md), производный класс может [переопределить](../../../csharp/language-reference/keywords/override.md) метод с помощью своей собственной реализации. Если базовый класс объявляет член как [абстрактный](../../../csharp/language-reference/keywords/abstract.md), этот метод должен быть переопределен в любом неабстрактном классе, который прямо наследует от этого класса. Если производный класс сам является абстрактным, то он наследует абстрактные члены, не реализуя их. Абстрактные и виртуальные члены являются основой для полиморфизма, который является второй основной характеристикой объектно-ориентированного программирования. Дополнительные сведения см. в разделе [Полиморфизм](../../../csharp/programming-guide/classes-and-structs/polymorphism.md).  
  
## <a name="abstract-base-classes"></a>Абстрактные базовые классы  
 Можно объявить класс как [абстрактный](../../../csharp/language-reference/keywords/abstract.md), если необходимо предотвратить прямое создание экземпляров с помощью ключевого слова [new](../../../csharp/language-reference/keywords/new.md). При таком подходе класс можно использовать, только если новый класс является производным от него. Абстрактный класс может содержать один или несколько сигнатур методов, которые сами объявлены в качестве абстрактных. Эти сигнатуры задают параметры и возвращают значение, но не имеют реализации (тела метода). Абстрактному классу необязательно содержать абстрактные члены; однако если класс все же содержит абстрактный член, то сам класс должен быть объявлен в качестве абстрактного. Производные классы, которые сами не являются абстрактными, должны предоставить реализацию для любых абстрактных методов из абстрактного базового класса. Дополнительные сведения см. в статье [Абстрактные и запечатанные классы и члены классов](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).  
  
## <a name="interfaces"></a>интерфейсов,  
 *Интерфейс* является ссылочным типом, в чем-то схожим с абстрактным базовым классом, который состоит только из абстрактных членов. Если класс реализует интерфейс, этот класс должен предоставлять реализацию для всех членов интерфейса. В классе может быть реализовано несколько интерфейсов, хотя производным он может быть только от одного прямого базового класса.  
  
 Интерфейсы используются для определения определенных возможностей для классов, которые не обязательно имеют отношения тождественности. Например, интерфейс <xref:System.IEquatable%601?displayProperty=nameWithType> может быть реализован любым классом или структурой, включающими клиентский код для определения эквивалентности двух объектов типа (однако тип определяет эквивалентность). <xref:System.IEquatable%601> не подразумевает тот же вид отношений тождественности, который существует между базовым и производным классами (например, `Mammal` является `Animal`). Дополнительные сведения см. в разделе [Интерфейсы](../../../csharp/programming-guide/interfaces/index.md).  
  
## <a name="preventing-further-derivation"></a>Предотвращение дальнейшего наследования  
 Класс может предотвратить наследование от других классов или наследование от любых его членов, объявив себя или члены [запечатанными](../../../csharp/language-reference/keywords/sealed.md). Дополнительные сведения см. в разделе [Абстрактные и запечатанные классы и члены классов](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md).  
  
## <a name="derived-class-hiding-of-base-class-members"></a>Скрытие производного класса членов базового класса  
 Производный класс может скрывать члены базового класса путем объявления членов с тем же именем и сигнатурой. Модификатор [new](../../../csharp/language-reference/keywords/new.md) может использоваться, чтобы явно указать, что член не должен быть переопределением базового члена. Использовать [new](../../../csharp/language-reference/keywords/new.md) необязательно, но если [new](../../../csharp/language-reference/keywords/new.md) не используется, будет создано предупреждение компилятора. Дополнительные сведения см. в разделах [Управление версиями с помощью ключевых слов Override и New](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md) и [Использование ключевых слов Override и New](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md).  
  
## <a name="see-also"></a>См. также

- [Руководство по программированию на C#](../../../csharp/programming-guide/index.md)
- [Классы и структуры](../../../csharp/programming-guide/classes-and-structs/index.md)
- [class](../../../csharp/language-reference/keywords/class.md)
- [struct](../../../csharp/language-reference/keywords/struct.md)
