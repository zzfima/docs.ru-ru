---
title: "Деструкторы (Руководство по программированию в C#) | Microsoft Docs"
ms.date: "2015-07-20"
ms.prod: ".net"
ms.technology: 
  - "devlang-csharp"
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "~ [C#], в деструкторах"
  - "C# - язык, деструкторы"
  - "деструкторы [C#]"
ms.assetid: 1ae6e46d-a4b1-4a49-abe5-b97f53d9e049
caps.latest.revision: 24
author: "BillWagner"
ms.author: "wiwagn"
caps.handback.revision: 24
---
# Деструкторы (Руководство по программированию в C#)
Деструкторы используются для уничтожения экземпляров классов.  
  
## Заметки  
  
-   В структурах определение деструкторов невозможно.  Они применяются только в классах.  
  
-   Класс может иметь только один деструктор.  
  
-   Деструкторы не могут наследоваться или перегружаться.  
  
-   Деструкторы невозможно вызвать.  Они запускаются автоматически.  
  
-   Деструктор не принимает модификаторы и не имеет параметров.  
  
 Например, следующая инструкция является объявлением деструктора класса `Car`:  
  
 [!code-cs[csProgGuideObjects#86](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/destructors_1.cs)]  
  
 Деструктор неявным образом вызывает метод <xref:System.Object.Finalize%2A> для базового класса объекта.  Следовательно, предыдущий код деструктора неявным образом преобразуется в следующий код:  
  
```  
protected override void Finalize()  
{  
    try  
    {  
        // Cleanup statements...  
    }  
    finally  
    {  
        base.Finalize();  
    }  
}  
```  
  
 Это означает, что метод `Finalize` вызывается рекурсивно для всех экземпляров цепочки наследования начиная с самого дальнего и заканчивая самым первым.  
  
> [!NOTE]
>  Пустые деструкторы использовать не следует.  Если класс содержит деструктор, то в очереди метода `Finalize` создается запись.  При вызове деструктора вызывается сборщик мусора, выполняющий обработку очереди.  Если деструктор пустой, это приводит только к ненужному снижению производительности.  
  
 Программист не может управлять моментом вызова деструктора, потому что момент вызова определяется сборщиком мусора.  Сборщик мусора проверяет наличие объектов, которые больше не используются приложением.  Если считает, что какой\-либо объект требует уничтожения, то он вызывает деструктор \(при наличии\) и освобождает память, используемую для хранения этого объекта.  Деструкторы также вызываются при выходе из программы.  
  
 Существует возможность принудительно выполнить сборку мусора, вызвав метод <xref:System.GC.Collect%2A>, но в большинстве случаев этого следует избегать, потому что это может привести с проблемам с производительностью.  
  
## Использование деструкторов для освобождения ресурсов.  
 В целом, язык C\# не требует управления памятью в той степени, в какой это требуется в случае разработки кода на языке, не рассчитанном на среду выполнения со сборкой мусора.  Это связано с тем, что сборщик мусора платформы .NET Framework неявным образом управляет выделением и высвобождением памяти для объектов.  Однако при инкапсуляции приложением неуправляемых ресурсов, например окон, файлов и сетевых подключений, для высвобождения этих ресурсов следует использовать деструкторы.  Если объект требует уничтожения, то сборщик мусора запускает выполнение метода `Finalize` этого объекта.  
  
## Высвобождение ресурсов явным образом  
 В случае, когда приложением используется ценный внешний ресурс, также рекомендуется обеспечить способ высвобождения этого ресурса явным образом, прежде чем сборщик мусора освободит этот объект.  Это выполняется путем реализации метода `Dispose` интерфейса <xref:System.IDisposable>, который выполняет необходимую очистку для объекта.  Это может значительно повысить производительность приложения.  Даже в случае использования данного явного управления ресурсами деструктор становится резервным средством очистки ресурсов, если вызов метода `Dispose` не будет выполнен.  
  
 Дополнительные сведения об очистке ресурсов см. в следующих разделах:  
  
-   [Cleaning Up Unmanaged Resources](../Topic/Cleaning%20Up%20Unmanaged%20Resources.md)  
  
-   [Implementing a Dispose Method](../Topic/Implementing%20a%20Dispose%20Method.md)  
  
-   [Оператор using](../../../csharp/language-reference/keywords/using-statement.md)  
  
## Пример  
 В следующем примере создаются три класса, образующих цепочку наследования.  Класс `First` является базовым, класс `Second` является производным от класса `First`, а класс `Third` является производным от класса `Second`.  Все три класса имеют деструкторы.  В методе `Main()` создается экземпляр самого дальнего в цепочке наследования класса.  При выполнении программы обратите внимание, что происходит автоматический вызов деструкторов всех трех классов по порядку от самого дальнего до первого в цепочке наследования.  
  
 [!code-cs[csProgGuideObjects#85](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/destructors_2.cs)]  
  
## Спецификация языка C\#  
 [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec-md.md)]  
  
## См. также  
 <xref:System.IDisposable>   
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Конструкторы](../../../csharp/programming-guide/classes-and-structs/constructors.md)   
 [Garbage Collection](../Topic/Garbage%20Collection.md)