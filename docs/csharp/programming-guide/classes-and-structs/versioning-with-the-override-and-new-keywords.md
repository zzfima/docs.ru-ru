---
title: Руководство по программированию на C#. Управление версиями с помощью ключевых слов Override и New
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, versioning
- C# language, override and new
ms.assetid: 88247d07-bd0d-49e9-a619-45ccbbfdf0c5
ms.openlocfilehash: 089d5d7c7a95e2de4629f53255d9d9790fd5508a
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "75705396"
---
# <a name="versioning-with-the-override-and-new-keywords-c-programming-guide"></a><span data-ttu-id="b292d-102">Практическое руководство. Управление версиями с помощью ключевых слов "Override" и "New" (Руководство по программированию в C#)</span><span class="sxs-lookup"><span data-stu-id="b292d-102">Versioning with the Override and New Keywords (C# Programming Guide)</span></span>
<span data-ttu-id="b292d-103">Язык C# построен таким образом, что управление версиями [базовых](../../language-reference/keywords/base.md) и производных классов в различных библиотеках может включать сохранение и расширение обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="b292d-103">The C# language is designed so that versioning between [base](../../language-reference/keywords/base.md) and derived classes in different libraries can evolve and maintain backward compatibility.</span></span> <span data-ttu-id="b292d-104">Это означает, например, то, что C# полностью поддерживает введение в базовый [класс](../../language-reference/keywords/class.md) нового члена с таким же именем, как у члена производного класса, и никакое непредвиденное поведение при этом не возникает.</span><span class="sxs-lookup"><span data-stu-id="b292d-104">This means, for example, that the introduction of a new member in a base [class](../../language-reference/keywords/class.md) with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior.</span></span> <span data-ttu-id="b292d-105">Кроме того, это значит, что класс должен прямо указывать, в каких случаях метод будет перезаписывать унаследованный метод, а в каких он будет становиться новым методом, скрывающим одноименный унаследованный метод.</span><span class="sxs-lookup"><span data-stu-id="b292d-105">It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.</span></span>  
  
 <span data-ttu-id="b292d-106">В C# производные классы могут содержать методы с такими же именами, как у методов базового класса.</span><span class="sxs-lookup"><span data-stu-id="b292d-106">In C#, derived classes can contain methods with the same name as base class methods.</span></span>  
  
- <span data-ttu-id="b292d-107">Метод базового класса должен быть определен как [виртуальный](../../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="b292d-107">The base class method must be defined [virtual](../../language-reference/keywords/virtual.md).</span></span>  
  
- <span data-ttu-id="b292d-108">Если методу в производном классе не предшествуют ключевые слова [new](../../language-reference/keywords/new-modifier.md) или [override](../../language-reference/keywords/override.md), компилятор выдаст предупреждение, а метод будет вести себя так, как если бы имелось ключевое слово `new`.</span><span class="sxs-lookup"><span data-stu-id="b292d-108">If the method in the derived class is not preceded by [new](../../language-reference/keywords/new-modifier.md) or [override](../../language-reference/keywords/override.md) keywords, the compiler will issue a warning and the method will behave as if the `new` keyword were present.</span></span>  
  
- <span data-ttu-id="b292d-109">Если методу в производном классе предшествует ключевое слово `new`, он определяется как независимый от метода в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="b292d-109">If the method in the derived class is preceded with the `new` keyword, the method is defined as being independent of the method in the base class.</span></span>  
  
- <span data-ttu-id="b292d-110">Если методу в производном классе предшествует ключевое слово `override`, объекты производного класса вызывают этот метод вместо метода базового класса.</span><span class="sxs-lookup"><span data-stu-id="b292d-110">If the method in the derived class is preceded with the `override` keyword, objects of the derived class will call that method instead of the base class method.</span></span>  
  
- <span data-ttu-id="b292d-111">Метод базового класса можно вызывать из производного класса с помощью ключевого слова `base`.</span><span class="sxs-lookup"><span data-stu-id="b292d-111">The base class method can be called from within the derived class using the `base` keyword.</span></span>  
  
- <span data-ttu-id="b292d-112">Ключевые слова `override`, `virtual` и`new` можно также применять к свойствам, индексаторам и событиям.</span><span class="sxs-lookup"><span data-stu-id="b292d-112">The `override`, `virtual`, and `new` keywords can also be applied to properties, indexers, and events.</span></span>  
  
 <span data-ttu-id="b292d-113">По умолчанию методы C# не являются виртуальными.</span><span class="sxs-lookup"><span data-stu-id="b292d-113">By default, C# methods are not virtual.</span></span> <span data-ttu-id="b292d-114">Если метод объявлен как виртуальный, любой наследующий его класс может реализовать свою собственную версию.</span><span class="sxs-lookup"><span data-stu-id="b292d-114">If a method is declared as virtual, any class inheriting the method can implement its own version.</span></span> <span data-ttu-id="b292d-115">Чтобы сделать метод виртуальным, в объявление метода базового класса добавляется модификатор `virtual`.</span><span class="sxs-lookup"><span data-stu-id="b292d-115">To make a method virtual, the `virtual` modifier is used in the method declaration of the base class.</span></span> <span data-ttu-id="b292d-116">После этого производный класс может переопределить базовый виртуальный метод с помощью ключевого слова `override` или скрыть виртуальный метод в базовом классе с помощью ключевого слова `new`.</span><span class="sxs-lookup"><span data-stu-id="b292d-116">The derived class can then override the base virtual method by using the `override` keyword or hide the virtual method in the base class by using the `new` keyword.</span></span> <span data-ttu-id="b292d-117">Если ключевое слово `override` или `new` не указано, компилятор выдает предупреждение, а метод в производном классе скрывает метод в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="b292d-117">If neither the `override` keyword nor the `new` keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.</span></span>  
  
 <span data-ttu-id="b292d-118">Чтобы продемонстрировать это на практике, предположим, что компания А создала класс с именем `GraphicsClass`, который использует ваша программа.</span><span class="sxs-lookup"><span data-stu-id="b292d-118">To demonstrate this in practice, assume for a moment that Company A has created a class named `GraphicsClass`, which your program uses.</span></span> <span data-ttu-id="b292d-119">Ниже показан `GraphicsClass`:</span><span class="sxs-lookup"><span data-stu-id="b292d-119">The following is `GraphicsClass`:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#27](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#27)]  
  
 <span data-ttu-id="b292d-120">Ваша компания использует этот класс, на основе которого вы создаете собственный производный класс, добавляя новый метод:</span><span class="sxs-lookup"><span data-stu-id="b292d-120">Your company uses this class, and you use it to derive your own class, adding a new method:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#28](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#28)]  
  
 <span data-ttu-id="b292d-121">Ваше приложение работает, пока компания А не выпускает новую версию `GraphicsClass`, напоминающую следующий код:</span><span class="sxs-lookup"><span data-stu-id="b292d-121">Your application is used without problems, until Company A releases a new version of `GraphicsClass`, which resembles the following code:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#29](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#29)]  
  
 <span data-ttu-id="b292d-122">Новая версия `GraphicsClass` содержит метод с именем `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="b292d-122">The new version of `GraphicsClass` now contains a method named `DrawRectangle`.</span></span> <span data-ttu-id="b292d-123">Сначала ничего не происходит.</span><span class="sxs-lookup"><span data-stu-id="b292d-123">Initially, nothing occurs.</span></span> <span data-ttu-id="b292d-124">Новая версия по-прежнему совместима со старой версией на уровне двоичного кода.</span><span class="sxs-lookup"><span data-stu-id="b292d-124">The new version is still binary compatible with the old version.</span></span> <span data-ttu-id="b292d-125">Любая развернутая вами программа будет работать как раньше, даже если в системе соответствующего компьютера установлен новый класс.</span><span class="sxs-lookup"><span data-stu-id="b292d-125">Any software that you have deployed will continue to work, even if the new class is installed on those computer systems.</span></span> <span data-ttu-id="b292d-126">Существующие вызовы метода `DrawRectangle` будут и дальше ссылаться на вашу версию в производном классе.</span><span class="sxs-lookup"><span data-stu-id="b292d-126">Any existing calls to the method `DrawRectangle` will continue to reference your version, in your derived class.</span></span>  
  
 <span data-ttu-id="b292d-127">Однако, как только вы выполните повторную компиляцию приложения с новой версией `GraphicsClass`, компилятор выдаст предупреждение CS0108.</span><span class="sxs-lookup"><span data-stu-id="b292d-127">However, as soon as you recompile your application by using the new version of `GraphicsClass`, you will receive a warning from the compiler, CS0108.</span></span> <span data-ttu-id="b292d-128">В предупреждении будет сказано, что вам необходимо указать, каким образом метод `DrawRectangle` будет вести себя в приложении.</span><span class="sxs-lookup"><span data-stu-id="b292d-128">This warning informs you that you have to consider how you want your `DrawRectangle` method to behave in your application.</span></span>  
  
 <span data-ttu-id="b292d-129">Если метод должен переопределять новый метод базового класса, используйте ключевое слово `override`:</span><span class="sxs-lookup"><span data-stu-id="b292d-129">If you want your method to override the new base class method, use the `override` keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#30)]  
  
 <span data-ttu-id="b292d-130">Ключевое слово `override` гарантирует, что все объекты, производные от `YourDerivedGraphicsClass`, будут использовать версию производного класса `DrawRectangle`.</span><span class="sxs-lookup"><span data-stu-id="b292d-130">The `override` keyword makes sure that any objects derived from `YourDerivedGraphicsClass` will use the derived class version of `DrawRectangle`.</span></span> <span data-ttu-id="b292d-131">Объекты, производные от `YourDerivedGraphicsClass`, сохраняют доступ к версии базового класса `DrawRectangle` за счет ключевого слова base:</span><span class="sxs-lookup"><span data-stu-id="b292d-131">Objects derived from `YourDerivedGraphicsClass` can still access the base class version of `DrawRectangle` by using the base keyword:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#44](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#44)]  
  
 <span data-ttu-id="b292d-132">Если вы не хотите, чтобы ваш метод переопределял новый метод базового класса, воспользуйтесь следующими рекомендациями.</span><span class="sxs-lookup"><span data-stu-id="b292d-132">If you do not want your method to override the new base class method, the following considerations apply.</span></span> <span data-ttu-id="b292d-133">Чтобы избежать путаницы между двумя методами, вы можете переименовать свой метод.</span><span class="sxs-lookup"><span data-stu-id="b292d-133">To avoid confusion between the two methods, you can rename your method.</span></span> <span data-ttu-id="b292d-134">Эта работа требует времени и подвержена ошибкам, а в некоторых случаях непрактична.</span><span class="sxs-lookup"><span data-stu-id="b292d-134">This can be time-consuming and error-prone, and just not practical in some cases.</span></span> <span data-ttu-id="b292d-135">В то же время, если проект относительно небольшой, метод можно переименовать, используя параметры рефакторинга в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="b292d-135">However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.</span></span> <span data-ttu-id="b292d-136">Дополнительные сведения см. в разделе [Рефакторинг классов и типов (конструктор классов)](/visualstudio/ide/class-designer/refactoring-classes-and-types).</span><span class="sxs-lookup"><span data-stu-id="b292d-136">For more information, see [Refactoring Classes and Types (Class Designer)](/visualstudio/ide/class-designer/refactoring-classes-and-types).</span></span>  
  
 <span data-ttu-id="b292d-137">Кроме того, предупреждения можно избежать с помощью ключевого слова `new` в определении производного класса:</span><span class="sxs-lookup"><span data-stu-id="b292d-137">Alternatively, you can prevent the warning by using the keyword `new` in your derived class definition:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#31)]  
  
 <span data-ttu-id="b292d-138">Ключевое слово `new` сообщает компилятору о том, что ваше определение скрывает определение, которое содержится в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="b292d-138">Using the `new` keyword tells the compiler that your definition hides the definition that is contained in the base class.</span></span> <span data-ttu-id="b292d-139">Это поведение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="b292d-139">This is the default behavior.</span></span>  
  
## <a name="override-and-method-selection"></a><span data-ttu-id="b292d-140">Переопределение и выбор метода</span><span class="sxs-lookup"><span data-stu-id="b292d-140">Override and Method Selection</span></span>  
 <span data-ttu-id="b292d-141">Если метод в классе именован, с вызовом совместимы сразу несколько методов (например, если существуют два метода с одинаковыми именами), а параметры совместимы с переданным параметром, компилятор C# выбирает метод, наиболее подходящий для вызова.</span><span class="sxs-lookup"><span data-stu-id="b292d-141">When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed.</span></span> <span data-ttu-id="b292d-142">Пример совместимых методов:</span><span class="sxs-lookup"><span data-stu-id="b292d-142">The following methods would be compatible:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#32)]  
  
 <span data-ttu-id="b292d-143">При вызове `DoWork` к экземпляру `Derived` компилятор C#, в первую очередь, пытается сделать вызов совместимым с версиями `DoWork`, изначально объявленными в `Derived`.</span><span class="sxs-lookup"><span data-stu-id="b292d-143">When `DoWork` is called on an instance of `Derived`, the C# compiler will first try to make the call compatible with the versions of `DoWork` declared originally on `Derived`.</span></span> <span data-ttu-id="b292d-144">Методы переопределения не считаются объявленными в классе, они представляют собой новые реализации метода, объявленного в базовом классе.</span><span class="sxs-lookup"><span data-stu-id="b292d-144">Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class.</span></span> <span data-ttu-id="b292d-145">Если же компилятор C# не может сопоставить вызов метода с исходным методом в `Derived`, он пытается сопоставить его с переопределенным методом, имеющим такое же имя и совместимые параметры.</span><span class="sxs-lookup"><span data-stu-id="b292d-145">Only if the C# compiler cannot match the method call to an original method on `Derived` will it try to match the call to an overridden method with the same name and compatible parameters.</span></span> <span data-ttu-id="b292d-146">Пример:</span><span class="sxs-lookup"><span data-stu-id="b292d-146">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#33](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#33)]  
  
 <span data-ttu-id="b292d-147">Поскольку переменная `val` может быть преобразована в значение double неявно, компилятор C# вызывает `DoWork(double)`, а не `DoWork(int)`.</span><span class="sxs-lookup"><span data-stu-id="b292d-147">Because the variable `val` can be converted to a double implicitly, the C# compiler calls `DoWork(double)` instead of `DoWork(int)`.</span></span> <span data-ttu-id="b292d-148">Избежать этого можно двумя способами.</span><span class="sxs-lookup"><span data-stu-id="b292d-148">There are two ways to avoid this.</span></span> <span data-ttu-id="b292d-149">Во-первых, избегайте объявления новых методов, имена которых совпадают с виртуальными методами.</span><span class="sxs-lookup"><span data-stu-id="b292d-149">First, avoid declaring new methods with the same name as virtual methods.</span></span> <span data-ttu-id="b292d-150">Во-вторых, можно настроить компилятор C# на вызов виртуального метода, заставив его выполнить поиск метода базового класса путем приведения экземпляра `Derived` к `Base`.</span><span class="sxs-lookup"><span data-stu-id="b292d-150">Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of `Derived` to `Base`.</span></span> <span data-ttu-id="b292d-151">Поскольку метод виртуальный, будет вызвана реализация `DoWork(int)` в `Derived`.</span><span class="sxs-lookup"><span data-stu-id="b292d-151">Because the method is virtual, the implementation of `DoWork(int)` on `Derived` will be called.</span></span> <span data-ttu-id="b292d-152">Пример:</span><span class="sxs-lookup"><span data-stu-id="b292d-152">For example:</span></span>  
  
 [!code-csharp[csProgGuideInheritance#34](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideInheritance/CS/Inheritance.cs#34)]  
  
 <span data-ttu-id="b292d-153">Дополнительные примеры `new` и `override` см. в разделе [Использование ключевых слов Override и New](./knowing-when-to-use-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="b292d-153">For more examples of `new` and `override`, see [Knowing When to Use Override and New Keywords](./knowing-when-to-use-override-and-new-keywords.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b292d-154">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="b292d-154">See also</span></span>

- [<span data-ttu-id="b292d-155">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="b292d-155">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="b292d-156">Классы и структуры</span><span class="sxs-lookup"><span data-stu-id="b292d-156">Classes and Structs</span></span>](./index.md)
- [<span data-ttu-id="b292d-157">Методы</span><span class="sxs-lookup"><span data-stu-id="b292d-157">Methods</span></span>](./methods.md)
- [<span data-ttu-id="b292d-158">Наследование</span><span class="sxs-lookup"><span data-stu-id="b292d-158">Inheritance</span></span>](./inheritance.md)
