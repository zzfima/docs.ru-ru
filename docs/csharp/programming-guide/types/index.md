---
title: "Типы (Руководство по программированию на C#) | Microsoft Docs"
ms.date: "2015-07-20"
ms.prod: ".net"
ms.technology: 
  - "devlang-csharp"
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "типы значений [C#]"
  - "ссылочные типы [C#]"
  - "типы [C#]"
  - "язык C#, типы данных"
  - "система общих типов [C#]"
  - "типы данных [C#]"
  - "язык C#, типы"
  - "строгая типизация [C#]"
ms.assetid: f782d7cc-035e-4500-b1b1-36a9881130ad
caps.latest.revision: 53
author: "BillWagner"
ms.author: "wiwagn"
caps.handback.revision: 53
---
# Типы (Руководство по программированию на C#)
## Типы, переменные и значения  
 C\# является строго типизированным языком.  Каждая переменная и константа имеет тип, как и каждое выражение, результатом вычисления которого является значение.  Каждая сигнатура метода задает тип для каждого входного параметра и для возвращаемого значения.  Библиотека классов платформы .NET Framework определяет набор встроенных числовых типов, а также более сложных типов, представляющих широкое разнообразие логических конструкций, например, файловую систему, сетевые подключения, коллекции и массивы объектов и даты.  Типичная программа C\# использует типы из библиотеки классов, а также пользовательские типы, моделирующие принципы, относящиеся к проблемной области программы.  
  
 К сведениям, хранимым в типе, может относиться следующее:  
  
-   Место для хранения, необходимое для переменной типа.  
  
-   Максимальное и минимальное значения, которые могут быть представлены.  
  
-   Содержащиеся члены \(методы, поля, события и т. д.\).  
  
-   Базовый тип, которому он наследует.  
  
-   Расположение, в котором будет выделена память для переменных во время выполнения.  
  
-   Разрешенные виды операций.  
  
 Компилятор использует сведения о типе, чтобы убедиться, что все операции, выполняемые в коде, являются *типобезопасными*.  Например, при объявлении переменной типа [int](../../../csharp/language-reference/keywords/int.md), компилятор позволяет использовать в дополнение переменную и операции вычитания.  При попытке выполнить эти же операции в переменной типа [bool](../../../csharp/language-reference/keywords/bool.md), компилятор вызовет ошибку, как показано в следующем примере:  
  
 [!code-cs[csProgGuideTypes#42](../../../csharp/programming-guide/nullable-types/codesnippet/csharp/index_1.cs)]  
  
> [!NOTE]
>  Разработчикам, работающим с C и C\+\+, следует обратить внимание на то, что в C\# [bool](../../../csharp/language-reference/keywords/bool.md) нельзя преобразовать в [int](../../../csharp/language-reference/keywords/int.md).  
  
 Компилятор внедряет сведения о типе в исполняемый файл в качестве метаданных.  Среда CLR использует эти метаданные во время выполнения для дальнейшего обеспечения безопасности типа при выделении и освобождении памяти.  
  
### Задание типов в объявлениях переменных  
 При объявлении переменной или константы в программе необходимо либо задать ее тип, либо использовать ключевое слово [var](../../../csharp/language-reference/keywords/var.md), чтобы дать возможность компилятору определить его.  В следующем примере показаны некоторые объявления переменных, использующие встроенные числовые типы и сложные пользовательские типы:  
  
 [!code-cs[csProgGuideTypes#36](../../../csharp/programming-guide/nullable-types/codesnippet/csharp/index_2.cs)]  
  
 Типы параметров метода и возвращаемые значения задаются в сигнатуре метода.  В следующей сигнатуре показан метод, который требует [int](../../../csharp/language-reference/keywords/int.md) в качестве входного аргумента, и который возвращает строку:  
  
 [!code-cs[csProgGuideTypes#35](../../../csharp/programming-guide/nullable-types/codesnippet/csharp/index_3.cs)]  
  
 После объявления переменной она не может быть повторно объявлена с новым типом, и ей нельзя присвоить значение, несовместимое с ее объявленным типом.  Например, нельзя объявить [int](../../../csharp/language-reference/keywords/int.md) и затем присвоить ему логическое значение [true](../../../csharp/language-reference/keywords/true-literal.md).  Однако значения могут быть преобразованы в другие типы, например, при их присвоении новым переменным или при передаче в качестве аргументов метода.  *Преобразование типов*, которое не приводит к потере данных, автоматически выполняется компилятором.  Для преобразования, которое может привести к потере данных, необходимо *приведение* в исходном коде.  
  
 Для получения дополнительной информации см. [Приведение и преобразование типов](../../../csharp/programming-guide/types/casting-and-type-conversions.md).  
  
## Встроенные типы  
 C\# предоставляет стандартный набор встроенных числовых типов для представления целых чисел, значений с плавающей запятой, логических выражений, текстовых символов, десятичных значений и других типов данных.  Существуют также встроенные типы `string` и `object`.  Они доступны для использования в любой программе C\#.  Дополнительные сведения о встроенных типах см. в разделе [Справочные таблицы по типам](../../../csharp/language-reference/keywords/reference-tables-for-types.md).  
  
## Пользовательские типы  
 Конструкции [структура](../../../csharp/language-reference/keywords/struct.md), [класс](../../../csharp/language-reference/keywords/class.md), [интерфейс](../../../csharp/language-reference/keywords/interface.md) и [перечисление](../../../csharp/language-reference/keywords/enum.md) используются для создания собственных пользовательских типов.  Сама библиотека классов платформы .NET Framework является коллекцией пользовательских типов, предоставленной корпорацией Microsoft, которую можно использовать в собственных приложениях.  По умолчанию наиболее часто используемые типы в библиотеке классов доступны в любой программе C\#.  Другие становятся доступными только при явном добавлении ссылки проекта на сборку, в которой они определены.  Если компилятор имеет ссылку на сборку, то можно объявить переменные \(и константы\) типов, объявленных в сборке в исходном коде.  Дополнительные сведения см. в [Библиотеке классов платформы .NET Framework](http://go.microsoft.com/fwlink/?LinkID=217856).  
  
## Система общих типов CTS  
 Важно понимать две фундаментальные точки о системе типов в [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort-md.md)]:  
  
-   Она поддерживает принцип наследования.  Типы могут быть производными от других типов, которые называются *базовыми типами*.  Производный тип наследует \(с некоторыми ограничениями\) методы, свойства и другие члены базового типа.  Базовый тип, в свою очередь, может быть производным от какого\-то другого типа, при этом производный тип наследует члены обоих базовых типов в иерархии наследования.  Все типы, включая встроенные числовые типы, например, <xref:System.Int32?displayProperty=fullName> \(ключевое слово C\#: [int](../../../csharp/language-reference/keywords/int.md)\), в конечном счете являются производными от одного базового типа, который является <xref:System.Object?displayProperty=fullName> \(ключевое слово C\#: [объектом](../../../csharp/language-reference/keywords/object.md)\).  Эта унифицированная иерархия типов называется [Система общих типов CTS](../../../standard/base-types/common-type-system.md) \(CTS\).  Дополнительные сведения о наследовании в C\# см. в разделе [Наследование](../../../csharp/programming-guide/classes-and-structs/inheritance.md).  
  
-   Каждый тип в CTS определен либо как *тип значения*, либо как *ссылочный тип*.  Сюда включены все пользовательские типы в библиотеке классов платформы .NET Framework, а также собственные пользовательские типы.  Типы, определяемые с помощью ключевого слова [struct](../../../csharp/language-reference/keywords/struct.md), являются типами значений; все встроенные числовые типы являются `structs`.  Типы, определяемые с помощью ключевого слова [class](../../../csharp/language-reference/keywords/class.md), являются ссылочными типами.  Правила времени компиляции и поведение времени выполнения ссылочных типов отличается от правил времени компиляции и поведения времени выполнения типов значений.  
  
 В следующем примере показана связь между типами значений и ссылочными типами в CTS.  
  
 ![Типы значений и ссылочные типы](../../../csharp/programming-guide/types/media/valuetypescts.png "ValueTypesCTS")  
Типы значений и ссылочные типы в CTS  
  
> [!NOTE]
>  Можно увидеть, что наиболее часто используемые типы все организованы в пространстве имен <xref:System>.  Однако пространство имен, в котором содержится тип, не имеет отношения к тому, является ли этот тип типом значения или ссылочным типом.  
  
### Типы значений  
 Типы значений являются производными от <xref:System.ValueType?displayProperty=fullName>, являющегося производным от <xref:System.Object?displayProperty=fullName>.  Типы, производные от <xref:System.ValueType?displayProperty=fullName>, имеют особое поведение в среде CLR.  Переменные типа значения напрямую содержат их значения, что означает, что память встроена в контекст, в котором объявлена переменная.  Не существует отдельного размещения кучи или служебных данных сборки мусора для переменных типа значения.  
  
 Существует две категории типов значений: [структура](../../../csharp/language-reference/keywords/struct.md) и [перечисление](../../../csharp/language-reference/keywords/enum.md).  
  
 Встроенные числовые типы являются структурами, и к их свойствам и методам можно получить доступ.  
  
```c#  
// Static method on type Byte.  
byte b = Byte.MaxValue;  
```  
  
 Но значения объявляются и присваиваются им, как если бы они были простыми не статическими типами:  
  
```c#  
byte num = 0xA;  
int i = 5;  
char c = 'Z';  
```  
  
 Типы значений являются *запечатанными*, что означает, например, что нельзя произвести тип от <xref:System.Int32?displayProperty=fullName>, и нельзя определить структуру для наследования от любого пользовательского класса или структуры, поскольку структура может наследовать только от <xref:System.ValueType?displayProperty=fullName>.  Однако структура может реализовать один или несколько интерфейсов.  Можно выполнить приведение типа структуры в тип интерфейса; это приведет к операции *упаковки\-преобразования* для создания программы\-оболочки структуры внутри объекта ссылочного типа в управляемой куче.  Операции упаковки\-преобразования возникают при передаче типа значения методу, принимающему <xref:System.Object?displayProperty=fullName> в качестве входного параметра.  Для получения дополнительной информации см. [Упаковка–преобразование и распаковка–преобразование](../../../csharp/programming-guide/types/boxing-and-unboxing.md).  
  
 Ключевое слово [struct](../../../csharp/language-reference/keywords/struct.md) используется для создания собственных пользовательских типов значений.  Обычно структура используется как контейнер для небольшого набора связанных переменных, как показано в следующем примере:  
  
 [!code-cs[csProgGuideObjects#1](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/index_4.cs)]  
  
 Дополнительные сведения о структурах см. в разделе [Структуры](../../../csharp/programming-guide/classes-and-structs/structs.md).  Дополнительные сведения о типах значений в [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort-md.md)] см. в разделе [Система общих типов CTS](../../../standard/base-types/common-type-system.md).  
  
 Другой категорией типов значений является [перечисление](../../../csharp/language-reference/keywords/enum.md).  Перечисление определяет набор именованных интегральных констант.  Например, перечисление <xref:System.IO.FileMode?displayProperty=fullName> в библиотеке классов платформы .NET Framework содержит набор именованных констант целого типа, которые задают, как должен быть открыт файл.  Это определено, как показано в следующем примере:  
  
 [!code-cs[csProgGuideTypes#44](../../../csharp/programming-guide/nullable-types/codesnippet/csharp/index_5.cs)]  
  
 Значение константы `System.IO.FileMode.Create` равно 2.  Однако имя намного более значимо для пользователей, читающих исходный код, и по этой причине лучше использовать перечисления вместо литеральных номеров констант.  Для получения дополнительной информации см. <xref:System.IO.FileMode?displayProperty=fullName>.  
  
 Все перечисления наследуются от <xref:System.Enum?displayProperty=fullName>, который наследуется от <xref:System.ValueType?displayProperty=fullName>.  Все правила, применимые к структурам, также применяются к перечислениям.  Дополнительные сведения о перечислениях см. в разделе [Типы перечислений](../../../csharp/programming-guide/enumeration-types.md).  
  
### Ссылочные типы  
 Тип, определенный как [класс](../../../csharp/language-reference/keywords/class.md), [делегат](../../../csharp/language-reference/keywords/delegate.md), массив или [интерфейс](../../../csharp/language-reference/keywords/interface.md), является *ссылочным типом*.  Во время выполнения при объявлении переменной ссылочного типа переменная содержит значение [null](../../../csharp/language-reference/keywords/null.md) до явного создания экземпляра объекта с помощью оператора [new](../../../csharp/language-reference/keywords/new.md) или назначения его объекту, который был создан в другом месте, с помощью `new, as shown in the following example:`.  
  
```c#  
MyClass mc = new MyClass();  
MyClass mc2 = mc;  
```  
  
 Интерфейс должен быть инициализирован вместе с объектом класса, который его реализует.  Если `MyClass` реализует `IMyInterface`, то создайте экземпляр `IMyInterface`, как показано в следующем примере:  
  
```c#  
IMyInterface iface = new MyClass();  
```  
  
 При создании объекта память размещается в управляемой куче, и переменная хранит только ссылку на расположение объекта.  Для типов в управляемой куче требуются служебные данные и при их размещении, и при их удалении функциональной возможностью автоматического управления памятью среды CLR, также известной как *сборка мусора*.  Однако сборка мусора также в высокой степени оптимизирована, и в большинстве сценариев она не создает проблем с производительностью.  Дополнительные сведения о сборке мусора см. в разделе [Автоматическое управление памятью](../Topic/Automatic%20Memory%20Management.md).  
  
 Все массивы являются ссылочными типами, даже если их члены являются типами значений.  Массивы являются неявно производными от класса <xref:System.Array?displayProperty=fullName>, но объявляются и используются они с упрощенным синтаксисом, предоставленным C\#, как показано в следующем примере:  
  
 [!code-cs[csProgGuideTypes#45](../../../csharp/programming-guide/nullable-types/codesnippet/csharp/index_6.cs)]  
  
 Ссылочные типы полностью поддерживают наследование.  При создании класса можно наследовать от любого другого интерфейса или класса, который не определен как [запечатанный](../../../csharp/language-reference/keywords/sealed.md), а другие классы могут наследовать от этого класса и переопределять виртуальные методы.  Дополнительные сведения о создании собственных классов см. в разделе [Классы и структуры](../../../csharp/programming-guide/classes-and-structs/index.md).  Дополнительные сведения о наследовании и виртуальных методах см. в разделе [Наследование](../../../csharp/programming-guide/classes-and-structs/inheritance.md).  
  
## Типы литеральных значений  
 В C\# литеральные значения получают тип от компилятора.  Можно задать, как числовой литерал должен быть типизирован, путем добавления буквы в конце номера.  Например, чтобы задать, что значение 4,56 должно обрабатываться как число с плавающей запятой, добавьте после номера "f" или "F": `4.56f`.  При отсутствии добавленной буквы компилятор определит тип для литерала.  Дополнительные сведения о том, какие типы могут быть заданы с буквенными суффиксами, см. на страницах справочника для отдельных типов в разделе [Типы значений](../../../csharp/language-reference/keywords/value-types.md).  
  
 Поскольку литералы являются типизированными и все типы в конечном счете являются производными от <xref:System.Object?displayProperty=fullName>, можно записать и скомпилировать код, например, следующий:  
  
 [!code-cs[csProgGuideTypes#37](../../../csharp/programming-guide/nullable-types/codesnippet/csharp/index_7.cs)]  
  
## Универсальные типы  
 Тип может быть объявлен с одним или несколькими *параметрами типа*, служащими в качестве местозаполнителя для фактического типа \(*устойчивого типа*\), который клиентский код предоставит при создании экземпляра типа.  Такие типы называются *универсальными типами*.  Например, тип платформы .NET Framework <xref:System.Collections.Generic.List%601?displayProperty=fullName> имеет один параметр типа, которому в соответствии с соглашением предоставлено имя *T*.  При создании экземпляра типа необходимо задать тип объектов, которые будут содержаться в списке, например, строку:  
  
<CodeContentPlaceHolder>4</CodeContentPlaceHolder>  
 Использование параметра типа делает возможным повторное использование этого же класса для хранения любого типа элемента, не преобразовывая каждый элемент в [объект](../../../csharp/language-reference/keywords/object.md).  Универсальные классы коллекции называются *строго типизированными коллекциями*, поскольку компилятор знает определенный тип элементов коллекции и может вызвать ошибку во время компиляции, если, к примеру, будет произведена попытка добавить целое число к объекту `strings` в предыдущем примере.  Для получения дополнительной информации см. [Универсальные шаблоны](../../../csharp/programming-guide/generics/index.md).  
  
## Неявные типы, анонимные типы и типы, допускающие значение NULL  
 Как уже говорилось ранее, можно неявно типизировать локальную переменную \(но не члены класса\) с помощью ключевого слова [var](../../../csharp/language-reference/keywords/var.md).  Переменная все же получает тип во время компиляции, но тип предоставляется компилятором.  Для получения дополнительной информации см. [Неявно типизированные локальные переменные](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).  
  
 В некоторых случаях неудобно создавать именованный тип для простых наборов связанных значений, которые не будут сохранены или переданы за пределы метода.  Для этой цели можно создать *анонимные типы*.  Дополнительные сведения см. в разделе [Анонимные типы](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md).  
  
 Обычные типы значений не могут иметь значение [null](../../../csharp/language-reference/keywords/null.md).  Однако можно создать типы значений, допускающие значение NULL, путем привязки `?` после типа.  Например, `int?` является типом `int`, который также может иметь значение [null](../../../csharp/language-reference/keywords/null.md).  В CTS типы, допускающие значения NULL, являются экземплярами универсального типа структуры <xref:System.Nullable%601?displayProperty=fullName>.  Типы, допускающие значение NULL, особенно полезны при передаче данных в базы данных и из них, в которых числовые значение могут быть равны NULL.  Для получения дополнительной информации см. [Типы, допускающие значения NULL](../../../csharp/programming-guide/nullable-types/index.md).  
  
## Связанные разделы  
 Дополнительные сведения см. в следующих разделах:  
  
-   [Приведение и преобразование типов](../../../csharp/programming-guide/types/casting-and-type-conversions.md)  
  
-   [Упаковка–преобразование и распаковка–преобразование](../../../csharp/programming-guide/types/boxing-and-unboxing.md)  
  
-   [Использование типа dynamic](../../../csharp/programming-guide/types/using-type-dynamic.md)  
  
-   [Типы значений](../../../csharp/language-reference/keywords/value-types.md)  
  
-   [Ссылочные типы](../../../csharp/language-reference/keywords/reference-types.md)  
  
-   [Классы и структуры](../../../csharp/programming-guide/classes-and-structs/index.md)  
  
-   [Анонимные типы](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)  
  
-   [Универсальные шаблоны](../../../csharp/programming-guide/generics/index.md)  
  
-   [Переменные и выражения](http://go.microsoft.com/fwlink/?LinkId=221228) в [Начало работы с Visual C\# 2010](http://go.microsoft.com/fwlink/?LinkId=221214)  
  
## Спецификация языка C\#  
 [!INCLUDE[CSharplangspec](../../../csharp/language-reference/keywords/includes/csharplangspec-md.md)]  
  
## См. также  
 [Справочник по C\#](../../../csharp/language-reference/index.md)   
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Преобразование типов XML\-данных](../Topic/Conversion%20of%20XML%20Data%20Types.md)   
 [Таблица целых типов](../../../csharp/language-reference/keywords/integral-types-table.md)