---
title: Основные принципы и терминология (функциональное преобразование) (C#)
ms.date: 07/20/2015
ms.assetid: 03defb3a-7e17-4ab1-8efa-4dd66621e860
ms.openlocfilehash: 3e2ecc4c2f70700ae92ee36b6f122059b922332e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2020
ms.locfileid: "70040633"
---
# <a name="concepts-and-terminology-functional-transformation-c"></a>Основные принципы и терминология (функциональное преобразование) (C#)

В данном разделе вводятся основные понятия и терминология чисто функциональных преобразований. Подход с использованием функциональных преобразований для преобразования данных порождает код, который обычно быстрее для программирования, более выразительный и легче для отладки и сопровождения, чем порожденный с использованием традиционного императивного программирования.

Заметим, что темы в данном разделе не претендуют на подробное объяснение функционального программирования. Но при этом они определяют некоторые возможности функционального программирования, которые позволяют легче переводить XML из одной формы в другую.

## <a name="what-is-pure-functional-transformation"></a>Что такое чисто функциональное преобразование?

При *чисто функциональном преобразовании* набор функций, называемых *чистыми функциями*, определяет способ преобразования набора структурированных данных из одной формы в другую. Слово "чистые" указывает на то, что функции *допускают композицию*, то есть отвечают следующим требованиям:

- *Замкнутые*, то есть они должны свободно упорядочиваться и переупорядочиваться без вовлечения остальных частей программы и взаимных зависимостей от них. Чистые преобразования не имеют представления о своей среде и не влияют на нее. Иными словами, использованные при преобразовании функции не имеют *побочных эффектов*.

- *Без учета состояния*, то есть исполнение одной и той же функции или определенного набора функций с одинаковыми входными данными будет всегда приводить к одинаковым выходным данным. Чистые преобразования не знают о предыдущих использованиях.

> [!IMPORTANT]
> До конца данного учебника термин «чистая возможность» используется в основном для указания подхода к программированию, а не специальной характеристики языка.
>
> Отметим, что чистые функции должны быть реализованы как методы в языке C#.
>
> Также не надо путать чистые функции с чисто виртуальными методами в C++. Второй случай показывает, что содержащийся класс абстрактный и текст метода не указан.

### <a name="functional-programming"></a>Функциональное программирование

Термин *функциональное программирование* обозначает такой подход к программированию, при котором непосредственно поддерживаются чисто функциональные преобразования.

Исторически языки функционального программирования общего назначения, такие как ML, Scheme, Haskell и F#, представляли интерес в первую очередь для научного сообщества. Хотя на языке C# всегда можно было создавать чисто функциональные преобразования, эта возможность не привлекала большинство программистов из-за своей сложности. В последних версиях C#, однако, новые конструкции языка, такие как лямбда-выражения и определение типов, сделали функциональное программирование гораздо более простым и продуктивным.

Дополнительные сведения о функциональном программировании см. в разделе [Сравнение функционального и императивного программирования (C#)](./functional-programming-vs-imperative-programming.md).

#### <a name="domain-specific-fp-languages"></a>Предметные языки функционального программирования

Не смотря на то что основные языки функционального программирования широко не используются, специальные предметные языки функционального программирования имеют больший успех. Например, каскадные таблицы стилей (CSS) используются для определения вида многих веб-страниц, а преобразования XSLT широко используются в обработке XML-данных. Дополнительные сведения об XSLT см. в разделе [Преобразования XSLT](../../../../standard/data/xml/xslt-transformations.md).

## <a name="terminology"></a>Терминология

Следующие таблицы определяют некоторые термины, связанные с функциональными преобразованиями.

функция высокого порядка (первого класса) \
Функция, которая может быть интерпретирована как программный объект. Например, функция высокого порядка может быть передана и возвращена другими функциями. В C# делегаты и лямбда-выражения являются компонентами языка, которые поддерживают функции высокого порядка. Для написания функции высокого порядка необходимо объявить один или несколько аргументов для принятия делегатов, при этом обычно используются лямбда-выражения. Многие стандартные операторы запроса являются функциями высокого порядка.

Дополнительные сведения см. в разделе [Общие сведения о стандартных операторах запроса (C#)](./standard-query-operators-overview.md).

лямбда-выражение \
По сути это встроенная анонимная функция, которая может использоваться, когда тип делегата неизвестен. Это упрощенное значение лямбда-выражений, однако оно достаточно для целей данного учебника.

Дополнительные сведения см. в разделе [Лямбда-выражения](../../statements-expressions-operators/lambda-expressions.md).

коллекция \
Структурированный набор данных обычно стандартного типа. Для обеспечения совместимости с LINQ коллекция должна реализовывать интерфейс <xref:System.Collections.IEnumerable> или интерфейс <xref:System.Linq.IQueryable> (или один из их основных прототипов <xref:System.Collections.Generic.IEnumerator%601> или <xref:System.Linq.IQueryable%601>).

кортеж (анонимные типы) \
Как математическое понятие, кортеж представляет собой конечную последовательность объектов, каждый определенного типа. Кортеж называется также упорядоченным списком. Анонимные типы представляют собой языковую реализацию этой концепции, которая позволяет объявить класс неименованного типа и одновременно создать экземпляр объекта этого типа.

Дополнительные сведения см. в статье [Анонимные типы](../../classes-and-structs/anonymous-types.md).

определение типов (скрытое типизирование) \
Возможность компилятора определить тип переменной при отсутствии явной декларации типа.

Дополнительные сведения см. в статье [Неявно типизированные локальные переменные (руководство по программированию на C#)](../../classes-and-structs/implicitly-typed-local-variables.md).

отложенное исполнение и отложенные вычисления \
Задержка вычисления выражения до тех пор, пока его результат не станет нужен. В коллекциях поддерживается отложенное исполнение.

Дополнительные сведения см. в разделах [Введение в запросы LINQ (C#)](./introduction-to-linq-queries.md) и [Отложенное выполнение и отложенное вычисление в LINQ to XML (C#)](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).

Эти языковые возможности будут использованы в образцах кода на протяжении данного раздела.

## <a name="see-also"></a>См. также

- [Введение в чистые функциональные преобразования (C#)](./introduction-to-pure-functional-transformations.md)
- [Сравнение функционального и императивного программирования (C#)](./functional-programming-vs-imperative-programming.md)
