---
title: "Query Syntax and Method Syntax in LINQ (C#) | Microsoft Docs"
ms.custom: ""
ms.date: "2015-07-20"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-csharp"
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "LINQ [C#], query syntax vs. method syntax"
  - "queries [LINQ in C#], syntax comparisons"
ms.assetid: eedd6dd9-fec2-428c-9581-5b8783810ded
caps.latest.revision: 30
author: "BillWagner"
ms.author: "wiwagn"
caps.handback.revision: 28
---
# Query Syntax and Method Syntax in LINQ (C#)
Большинство запросов в вводной документации LINQ \([!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq-md.md)]\) записываются с помощью декларативного синтаксиса запросов LINQ.  Однако синтаксис запроса должны быть преобразованы в вызовы методов для среды CLR .NET \(CLR\), когда код компилироваться.  Эти вызовы метода вызываются стандартных операторов запросов, которые имеют имена, такие как `Where`, `Select`, `GroupBy`, `Join`, `Max` и `Average`.  Можно вызывать их непосредственно с помощью синтаксиса методов вместо синтаксиса запроса.  
  
 Синтаксис запросов и синтаксис метода семантически идентичны, но многие пользователи найдут синтаксис запроса более простой и более удобный для чтения.  Некоторые запросы должны быть выражены черезыми вызовами методов.  Например, необходимо использовать вызов метода для выражения запроса, который возвращает число элементов, соответствующие указанным критериям.  Необходимо также использовать вызов метода для запроса, который получает элемент, имеющий максимальное значение в последовательности источника.  В справочной документации по стандартным операторам запросов в пространстве имен <xref:System.Linq> обычно используется синтаксис методов.  Поэтому, даже на начальном этапе написания запросов [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq-md.md)] полезно знать, как использовать синтаксис методов в запросах и самих выражениях запроса.  
  
## Методы расширения стандартных операторов запросов  
 В следующем примере показано простое *выражение запроса* и семантически эквивалентный ему запрос, написанный как *запрос на основе метода*.  
  
 [!code-cs[csLINQGettingStarted#22](../../../../csharp/programming-guide/concepts/linq/codesnippet/csharp/GettingStarted/Class1.cs#22)]  
  
 Два примера имеют идентичные результаты.  Тип переменной запроса одинаковый в обеих формах: <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Чтобы понять запрос на основе метода, рассмотрим его более детально.  Обратите внимание, что в правой части выражения предложение `where` теперь выражено в виде метода экземпляра объекта `numbers`, который имеет тип `IEnumerable<int>`.  Если вы знакомы с универсальным интерфейсом <xref:System.Collections.Generic.IEnumerable%601>, вам известно, что он не имеет метода `Where`.  Однако при вызове списка завершения IntelliSense в IDE Visual Studio будет отображен не только метод `Where`, но и многие другие методы, такие как `Select`, `SelectMany`, `Join` и `Orderby`.  Они все являются стандартными операторами запросов.  
  
 ![Стандартный оператор запроса в Intellisense](../../../../csharp/programming-guide/concepts/linq/media/standardqueryops.png "StandardQueryOps")  
  
 Несмотря на то, что кажется, как будто интерфейс <xref:System.Collections.Generic.IEnumerable%601> был переопределен для включения этих дополнительных методов, на самом деле это не так.  Стандартные операторы запросов реализуются как новый тип методов, называемых *методами расширения*.  Методы расширения "расширяют" существующий тип; их можно вызывать так, как если бы они были методами экземпляра типа.  Стандартные операторы запросов расширяют <xref:System.Collections.Generic.IEnumerable%601>, что позволяет написать `numbers.Where(...)`.  
  
 Все, что нужно знать о методах расширения, чтобы начать работу с [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq-md.md)], — способы их добавления в область видимости в приложении с помощью подходящих директив `using`.  Они объясняются дополнительно в разделе [How to: Create a LINQ Project](../Topic/How%20to:%20Create%20a%20LINQ%20Project.md).  С точки зрения приложения методы расширения и обычные методы экземпляра одинаковы.  
  
 Дополнительные сведения о методах расширения см. в разделе [Методы расширения](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md).  Дополнительные сведения о стандартных операторах запроса см в разделе [Standard Query Operators Overview](../../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md).  Некоторые поставщики [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq-md.md)], например [!INCLUDE[vbtecdlinq](../../../../csharp/includes/vbtecdlinq-md.md)] и [!INCLUDE[sqltecxlinq](../../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq-md.md)], реализуют свои собственные стандартные операторы запросов и дополнительные методы расширения для типов, отличных от <xref:System.Collections.Generic.IEnumerable%601>.  
  
## Лямбда\-выражения  
 В предыдущем примере обратите внимание, что условное выражение \(`num % 2 == 0`\) встроенный передается в качестве аргумента методу `Where` : `Where(num => num % 2 == 0).` это встроенное выражение называется лямбда\-выражением.  Оно является удобным способом написания кода, который в противном случае пришлось бы записывать в более громоздкой форме как анонимный метод, универсальный делегат или дерево выражений.  В C\# `=>` является лямбда\-оператором, который читается как "переходит".  `num` слева от оператора является входной переменной, которая соответствует `num` в выражении запроса.  Компилятор может определить тип `num`, так как ему известно, что `numbers` является универсальным типом <xref:System.Collections.Generic.IEnumerable%601>.  Основная часть лямбда\-выражения представляет то же самое, что и выражение в синтаксисе запроса или в любом другом выражении или операторе C\#; она может включать вызовы методов и другую сложную логику.  Возвращаемым значением является просто результат выражения.  
  
 Приступая к работе с [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq-md.md)], нет необходимости широко использовать лямбда\-выражения.  Однако некоторые запросы могут выражаться только в синтаксисе методов, а некоторые из них требуют лямбда\-выражений.  После знакомства с лямбда\-выражениями станет понятно, что они являются мощными и гибкими элементами в панели элементов [!INCLUDE[vbteclinq](../../../../csharp/includes/vbteclinq-md.md)].  Дополнительные сведения см. в разделе [Лямбда\-выражения](../../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).  
  
## Возможность компоновки запросов  
 Обратите внимание, что в предыдущем примере кода метод `OrderBy` вызывается с помощью оператора точки при вызове `Where`.  Выражение `Where` создает фильтрованную последовательность, и метод `Orderby` работает с этой последовательностью, сортируя ее.  Поскольку запросы возвращают `IEnumerable`, их можно компоновать в синтаксисе методов, объединяя вызовы методов в цепочки.  При использовании синтаксиса запросов эти действия выполняет компилятор.  Поскольку переменная запроса не сохраняет результаты запроса, ее можно изменить или в любое время использовать в качестве основы для нового запроса, даже после ее выполнения.  
  
## См. также  
 [Getting Started with LINQ in C\#](../../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)