---
title: "Практическое руководство. Перебор дерева папок (Руководство по программированию на C#) | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-csharp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "итерация по файлам [C#]"
  - "итерация по папкам [C#]"
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
caps.latest.revision: 10
caps.handback.revision: 10
author: "BillWagner"
ms.author: "wiwagn"
manager: "wpickett"
---
# Практическое руководство. Перебор дерева папок (Руководство по программированию на C#)
[!INCLUDE[vs2017banner](../../../csharp/includes/vs2017banner.md)]

Под фразой "итерация дерева каталога" подразумевается доступ к каждому файлу в каждом вложенном подкаталоге в заданной корневой папке на любую глубину.  Необязательно открывать каждый файл.  Можно просто извлечь имя файла или подкаталога как `string` или можно извлечь дополнительные сведения в форме объекта <xref:System.IO.FileInfo?displayProperty=fullName> или <xref:System.IO.DirectoryInfo?displayProperty=fullName>.  
  
> [!NOTE]
>  В Windows термины "каталог" и "папка" являются взаимозаменяемыми.  В большинстве документации и в текстах пользовательского интерфейса используется термин "папка", но в библиотеке классов [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort_md.md)] используется термин "каталог".  
  
 В простейшем случае, когда точно известно, что имеются права доступа ко всем каталогам в указанном корне, можно использовать флаг `System.IO.SearchOption.AllDirectories`.  Этот флаг возвращает все вложенные подкаталоги, соответствующие заданному шаблону.  В следующем примере показано, как использовать этот флаг.  
  
```c#  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 Слабая сторона в этом подходе заключается в том, что если какой\-либо из подкаталогов в указанном корне вызовет <xref:System.IO.DirectoryNotFoundException> или <xref:System.UnauthorizedAccessException>, то весь метод закончится неудачей и каталоги не будут возвращены.  Это также относится к использованию метода <xref:System.IO.DirectoryInfo.GetFiles%2A>.  Если необходимо обработать эти исключения в определенных подпапках, необходимо вручную пройти по дереву каталога, как показано в следующих примерах.  
  
 При проходе вручную по дереву каталога можно обработать сначала подкаталоги \(*обход в прямом порядке*\) или файлы \(*обход в обратном порядке*\).  При выполнении обхода в прямом порядке проходится целое дерево под текущей папкой перед итерацией файлов, которые находятся в самой папке.  В приведенных ниже примерах выполняется обход в обратном порядке, но его можно легко изменить на выполнение обхода в прямом порядке.  
  
 Еще одним параметром является использование рекурсии или обхода на основе стека.  В приведенных ниже примерах показываются оба подхода.  
  
 Если необходимо выполнить различные операции с файлами и папками, то можно смоделировать эти примеры путем оптимизации операции на отдельные функции, которые можно вызвать с помощью одного делегата.  
  
> [!NOTE]
>  Файловые системы NTFS могут содержать *точки повторной обработки* в форме *точек соединения*, *символических ссылок* и *жестких ссылок*.  Методы .NET Framework, например <xref:System.IO.DirectoryInfo.GetFiles%2A> и <xref:System.IO.DirectoryInfo.GetDirectories%2A>, не возвратят подкаталоги под точкой повторной обработки.  Такое поведение предотвратит риск входа в бесконечный цикл, когда две точки повторной обработки ссылаются друг на друга.  В общем, следует быть предельно осторожными при работе с точками повторной обработки, чтобы избежать случайного изменения или удаления файлов.  При получении тщательного контроля над точками повторной обработки используйте вызов неуправляемого кода или машинный код для прямого вызова подходящих методов файловой системы Win32.  
  
## Пример  
 В следующем примере показан проход по дереву каталога с помощью рекурсии.  Рекурсивный подход является элегантным, но он потенциально может вызвать исключение переполнения стека, если дерево каталога большое и имеет большой уровень вложения.  
  
 Определенные обрабатываемые исключения и определенные выполняемые в каждом файле или папке параметры предоставляются только в качестве примеров.  Этот код следует изменить для соответствия конкретным требованиям.  Дополнительные сведения см. в комментариях в коде.  
  
 [!code-cs[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]  
  
## Пример  
 В следующем примере показана итерация файлов и папок в дереве каталога без использования рекурсии.  Этот метод использует обычный тип коллекции <xref:System.Collections.Generic.Stack%601>, который является стеком типа "последним пришел — первым вышел" \(LIFO\).  
  
 Определенные обрабатываемые исключения и определенные выполняемые в каждом файле или папке параметры предоставляются только в качестве примеров.  Этот код следует изменить для соответствия конкретным требованиям.  Дополнительные сведения см. в комментариях в коде.  
  
 [!code-cs[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]  
  
 Обычно проверка каждой папки, чтобы определить, имеет ли приложение разрешение на ее открытие, занимает слишком много времени.  Поэтому пример кода просто включает эту часть операции в блок `try/catch`.  Блок `catch` можно изменить, чтобы при отказе в доступе к папке предпринималась попытка повысить права и затем вновь предпринималась попытка получить доступ.  Как правило, следует перехватывать только те исключения, которые можно обработать, не оставляя приложение в неопределенном состоянии.  
  
 Если необходимо сохранить содержимое дерева каталога либо в памяти, либо на диске, наилучшим параметром будет сохранение только свойства <xref:System.IO.FileSystemInfo.FullName%2A> \(типа `string`\) для каждого файла.  Затем можно использовать эту строку для создания нового объекта <xref:System.IO.FileInfo> или <xref:System.IO.DirectoryInfo> по мере необходимости или открыть любой файл, для которого требуется дополнительная обработка.  
  
## Отказоустойчивость  
 Надежный код итерации файла должен учитывать сложности файловой системы.  Дополнительные сведения см. в [Техническом справочнике по NTFS](http://go.microsoft.com/fwlink/?LinkId=79488).  
  
## См. также  
 <xref:System.IO>   
 [LINQ and File Directories](../../../visual-basic/programming-guide/concepts/linq/linq-and-file-directories.md)   
 [Файловая система и реестр](../../../csharp/programming-guide/file-system/file-system-and-the-registry.md)