---
redirect_url: /dotnet/articles/csharp/linq/perform-inner-joins
caps.handback.revision: 25
---
# Практическое руководство. Выполнение внутренних соединений (Руководство по программированию на C#)
В терминах реляционных баз данных *внутреннее соединение* возвращает результирующий набор, в котором каждый элемент первой коллекции появляется один раз для каждого соответствующего элемента второй коллекции.  Если для элемента первой коллекции нет соответствующего элемента, он не появляется в результирующем наборе.  Метод <xref:System.Linq.Enumerable.Join%2A>, вызываемый предложением `join` в C\#, реализует внутреннее соединение.  
  
 В этом разделе демонстрируется выполнение следующих четырех типов внутреннего соединения.  
  
-   Простое внутреннее соединение, которое сопоставляет элементы из двух источников данных на основании простого ключа.  
  
-   Внутреннее соединение, которое сопоставляет элементы из двух источников данных на основании *составного* ключа.  Составной ключ \(ключ, который содержит несколько значений\) позволяет сопоставлять элементы на основании нескольких свойств.  
  
-   При выполнении *множественного соединения* последовательные операции соединения применяются друг к другу.  
  
-   Внутреннее соединение, которое реализуется с помощью группового соединения.  
  
## Пример  
  
## Пример соединения с использованием простого ключа  
 В следующем примере создаются две коллекции, содержащие объекты двух определяемых пользователем типов `Person` и `Pet`.  В C\# при запросе используется предложение `join` для сопоставления объектов `Person` с объектами `Pet`, для которых `Owner` является `Person`.  Предложение `select` в языке C\# определяет то, как будут выглядеть результирующие объекты.  В этом примере результирующие объекты — анонимные типы, состоящие из имени владельца и клички питомца.  
  
 [!code-cs[CsLINQProgJoining#1](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/how-to-perform-inner-joins_1.cs)]  
  
 Обратите внимание, что объект `Person`,свойство которого `LastName` имеет значение "Huff", не отображается среди результатов, так как не существует объекта `Pet`, свойство `Pet.Owner` которого было бы равно свойству `Person`.  
  
## Пример  
  
## Пример соединения с использованием составного ключа  
 Вместо сопоставления элементов на основании всего лишь одного свойства можно использовать составной ключ для сопоставления элементов на основании нескольких свойств.  Для этого укажите, чтобы функция выбора ключа каждой коллекции возвращала анонимный тип, состоящий из свойств, которые необходимо сравнить.  Если задается метка свойства, необходимо указать одну и ту же метку во всех анонимных типах ключа.  Свойства также должны располагаться в том же порядке.  
  
 В следующем примере списки объектов `Employee` и `Student` используются для определения того, какие работники являются также студентами.  Оба этих типа обладают свойствами `FirstName` и `LastName` типа <xref:System.String>.  Функция, создающая ключи соединения из элементов каждого списка, возвращает анонимный тип, состоящий из свойств `FirstName` и `LastName` каждого элемента.  Операция соединения сравнивает данные составные ключи на признак равенства и возвращает пары объектов из обоих списков, у которых совпадают имя и фамилия.  
  
 [!code-cs[CsLINQProgJoining#2](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/how-to-perform-inner-joins_2.cs)]  
  
## Пример  
  
## Пример множественного соединения  
 Операции соединения в любом количестве могут быть добавлены друг к другу для выполнения группового соединения.  Каждое предложение `join` в C\# сопоставляет указанный источник данных с результатами предыдущего соединения.  
  
 В следующем примере создаются три коллекции: список объектов `Person`, список объектов `Cat` и список объектов `Dog`.  
  
 Первое предложение `join` в C\# проверяет соответствие людей и кошек на основании сопоставления объекта `Person` со свойством `Cat.Owner`.  Возвращается последовательность анонимных типов, содержащая объекты `Person` и свойства `Cat.Name`.  
  
 Второе предложение `join` в C\# сопоставляет анонимные типы, возвращенные первым соединением, с объектами `Dog` в предоставленном списке собак на основании составного ключа, состоящего из свойства `Owner` типа `Person`, и первой буквы клички животного.  Возвращается последовательность анонимных типов, содержащая свойства `Cat.Name` и `Dog.Name` каждой совпадающей пары.  Так как это внутреннее соединение, возвращаются только объекты из первого источника данных, для которых найдено соответствии во втором источнике данных.  
  
 [!code-cs[CsLINQProgJoining#3](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/how-to-perform-inner-joins_3.cs)]  
  
## Пример  
  
## Пример внутреннего соединения, реализуемого с помощью группового соединения  
 В следующем примере показано, как реализовать внутреннее соединение с помощью группового соединения.  
  
 В `query1` выполняется групповое соединение списка объектов `Person` со списком объектов `Pet` на основании сопоставления объекта `Person` и свойства `Pet.Owner`.  Групповое соединение создает коллекцию промежуточных групп, в которой каждая группа состоит из объекта `Person` и последовательности совпадающих объектов `Pet`.  
  
 При добавлении в запрос второго предложения `from` данная последовательность из последовательностей объединяется \(или выравнивается\) в одну более длинную последовательность.  Тип элементов конечной последовательности задается предложением `select`.  В этом примере тип является анонимным типом, состоящим из свойств `Person.FirstName` и `Pet.Name` каждой соответствующей пары.  
  
 Результат `query1` аналогичен результирующему набору, полученному при использовании предложения `join` для выполнения внутреннего соединения без предложения `into`.  Переменная `query2` демонстрирует этот эквивалентный запрос.  
  
 [!code-cs[CsLINQProgJoining#4](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/how-to-perform-inner-joins_4.cs)]  
  
## Компиляция кода  
  
-   Создайте в [!INCLUDE[vs_current_short](../../../csharp/programming-guide/classes-and-structs/includes/vs-current-short-md.md)] новый проект консольного приложения.  
  
-   Добавьте ссылку на System.Core.dll, если она отсутствует.  
  
-   Включите пространство имен <xref:System.Linq>.  
  
-   Скопируйте код из примера в файл program.cs ниже метода `Main`.  Добавьте в метод `Main` строку кода для вызова вставленного метода.  
  
-   Запустите программу.  
  
## См. также  
 <xref:System.Linq.Enumerable.Join%2A>   
 <xref:System.Linq.Enumerable.GroupJoin%2A>   
 [Join Operations](../../../visual-basic/programming-guide/concepts/linq/join-operations.md)   
 [Практическое руководство. Выполнение групповых соединений](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-grouped-joins.md)   
 [Практическое руководство. Выполнение левых внешних соединений](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-left-outer-joins.md)   
 [Как объединить две коллекции](../Topic/How%20to:%20Join%20Two%20Collections%20\(C%23\)%20\(LINQ%20to%20XML\).md)   
 [Анонимные типы](../../../csharp/programming-guide/classes-and-structs/anonymous-types.md)   
 [Анонимные типы](../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)