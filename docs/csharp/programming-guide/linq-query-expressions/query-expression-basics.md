---
title: "Основы выражения запроса (Руководство по программированию в C#) | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-csharp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "запросы [LINQ в C#], основы"
  - "выражения запросов [LINQ в C#], основы"
  - "выражения запросов [LINQ в C#], выполнение запроса"
ms.assetid: d3e1f4e6-1cf0-4066-87e3-1a42387223a6
caps.latest.revision: 32
caps.handback.revision: 32
author: "BillWagner"
ms.author: "wiwagn"
manager: "wpickett"
---
# Основы выражения запроса (Руководство по программированию в C#)
[!INCLUDE[vs2017banner](../../../csharp/includes/vs2017banner.md)]

## Что такое запрос и для чего он нужен  
 *Запрос* — это набор инструкций, которые описывают, какие данные необходимо извлечь из указанного источника \(или источников\) данных, а также описывают форму и организацию извлекаемых данных.  Запрос отличается от полученного с его помощью результата.  
  
 Обычно исходные данные логически организованы как последовательность элементов одного вида.  База данных SQL содержит последовательность строк.  Аналогично, [!INCLUDE[vstecado](../../../csharp/programming-guide/concepts/linq/includes/vstecado_md.md)] <xref:System.Data.DataTable> содержит последовательность объектов <xref:System.Data.DataRow>.  В файле XML содержится "последовательность" элементов XML \(они организованы иерархически в древовидную структуру\).  Коллекция в памяти содержит последовательность объектов.  
  
 С точки зрения приложения определенные тип и структура оригинальных исходных данных не важны.  Исходные данные всегда представляются приложению как коллекция <xref:System.Collections.Generic.IEnumerable%601> или <xref:System.Linq.IQueryable%601>.  В [!INCLUDE[sqltecxlinq](../../../csharp/programming-guide/concepts/linq/includes/sqltecxlinq_md.md)] исходные становятся видимыми как `IEnumerable`\<<xref:System.Xml.Linq.XElement>\>.  В [!INCLUDE[linq_dataset](../../../csharp/programming-guide/linq-query-expressions/includes/linq_dataset_md.md)] — как `IEnumerable`\<<xref:System.Data.DataRow>\>.  В [!INCLUDE[vbtecdlinq](../../../csharp/includes/vbtecdlinq_md.md)] — как `IEnumerable` или `IQueryable` любого из пользовательских объектов, которые были определены для представления данных в таблице SQL.  
  
 При такой исходной последовательности запрос может выполнять одно из трех возможных действий.  
  
-   Извлечение подмножества элементов для получения новой последовательности без изменения отдельных элементов.  Затем запрос может отсортировать или сгруппировать возвращаемую последовательность различными способами, как показано в следующем примере \(предположим, что `scores` является `int[]`\):  
  
     [!code-cs[csrefQueryExpBasics#45](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_1.cs)]  
  
-   Извлечение последовательности элементов, как и в предыдущем примере, но с преобразованием элементов в новый вид объекта.  Например, запрос может извлекать только фамилии из определенных записей клиентов в источнике данных.  Запрос также может извлекать полную запись и использовать ее для создания другого типа объекта в памяти или даже данных XML перед созданием заключительной последовательности результатов.  В следующем примере показана трансформация `int` в `string`.  Обратите внимание на новый тип `highScoresQuery`.  
  
     [!code-cs[csrefQueryExpBasics#46](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_2.cs)]  
  
-   Извлечение одноэлементного значения исходных данных, такого как:  
  
    -   Количество элементов, которое соответствует определенному условию.  
  
    -   Элемент, обладающий наибольшим или наименьшим значением.  
  
    -   Первый элемент, соответствующий условию, или сумма определенных значений в заданном наборе элементов.  Например, следующий запрос возвращает количество оценок выше 80 из целочисленного массива `scores`:  
  
     [!code-cs[csrefQueryExpBasics#47](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_3.cs)]  
  
     В предыдущем примере обратите внимание на использование скобок вокруг выражения запроса перед вызовом метода `Count`.  Его также можно выразить, используя новую переменную для сохранения конкретного результата.  Этот метод является более удобочитаемым, так как переменная, в которой хранится запрос, хранится отдельно от запроса, в котором хранится результат.  
  
     [!code-cs[csrefQueryExpBasics#48](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_4.cs)]  
  
 В предыдущем примере запрос выполняется в вызове `Count`, так как `Count` должен выполнить итерацию результатов, чтобы определить количество элементов, возвращенных `highScoresQuery`.  
  
## Что такое выражение запроса  
 *Выражение запроса* — запрос, выраженный с помощью синтаксиса запроса.  Выражение запроса является конструкцией языка первого класса.  Выражение запроса похоже на любое другое выражение, оно может использоваться в любом контексте, в котором выражение C\# является допустимым.  Выражение запроса состоит их набора предложений, написанных в декларативном синтаксисе, аналогичном SQL или XQuery.  Каждое предложение, в свою очередь, содержит одно или несколько выражений C\#, которые могут являться выражениями запроса или могут содержать выражение запроса.  
  
 Выражение запроса должно начинаться предложением [from](../../../csharp/language-reference/keywords/from-clause.md) и оканчиваться предложением [select](../../../csharp/language-reference/keywords/select-clause.md) или [group](../../../csharp/language-reference/keywords/group-clause.md).  Между первым предложением `from` и последним предложением `select` или `group` может содержаться одно или несколько необязательных предложений [where](../../../csharp/language-reference/keywords/where-clause.md), [orderby](../../../csharp/language-reference/keywords/orderby-clause.md), [join](../../../csharp/language-reference/keywords/join-clause.md), [let](../../../csharp/language-reference/keywords/let-clause.md) или даже дополнительных предложений [from](../../../csharp/language-reference/keywords/from-clause.md).  Также можно использовать ключевое слово [into](../../../csharp/language-reference/keywords/into.md), чтобы результат предложения `join` или `group` мог служить источником дополнительных предложений запроса в том же выражении запроса.  
  
### Переменная запроса  
 В [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)] переменная запроса — это любая переменная, сохраняющая *запрос* вместо *результатов* запроса. Говоря точнее, переменная запроса всегда является перечислимым типом и производит последовательность элементов, когда она используется в итерации оператора `foreach` или прямом вызове ее метода `IEnumerator.MoveNext`.  
  
 В следующем примере кода показано простое выражение запроса с одним источником данных, одним предложением фильтрации, одним предложением упорядочения и без трансформации исходных элементов.  Предложение `select` завершает запрос.  
  
 [!code-cs[csrefQueryExpBasics#49](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_5.cs)]  
  
 В предыдущем примере `scoreQuery` — *переменная запроса,* которую иногда называют просто *запросом*.  В переменной запроса не хранятся фактические данные результата, которые получаются с помощью цикла `foreach`.  Когда выполняется оператор `foreach`, результаты запроса не возвращаются с помощью переменной запроса `scoreQuery`.  В таком случае они возвращаются с помощью переменной итерации `testScore`.  Итерация переменно `scoreQuery` может выполняться во втором цикле `foreach`.  Результаты будет теми же, если ни они, ни источник данных не изменяются.  
  
 В переменной запроса может храниться запрос, выраженный с помощью синтаксиса запроса или метода запроса, или их комбинации.  В следующих примерах `queryMajorCities` и `queryMajorCities2` являются переменными запроса.  
  
 [!code-cs[csrefQueryExpBasics#50](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_6.cs)]  
  
 С другой стороны, в следующих примерах показаны переменные, которые не являются переменными запроса даже несмотря на то, что все они инициализируются запросом.  Они не являются переменными запроса, так как в них хранятся результаты запроса.  
  
 [!code-cs[csrefQueryExpBasics#51](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_7.cs)]  
  
> [!NOTE]
>  В документации [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)] к именам переменных, в которых хранятся запросы, добавляется слово "query" \(запрос\).  В именах переменных, в которых хранятся фактические результаты, слово "query" \(запрос\) отсутствует.  
  
 Дополнительные сведения о различных способах выражения запросов содержатся в разделе [Query Syntax and Method Syntax in LINQ](../../../csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).  
  
#### Явная и неявная типизация переменных запроса  
 В данной документации обычно явно указывается тип переменной запроса для того, чтобы продемонстрировать типичное отношение между переменной запроса и [предложением select](../../../csharp/language-reference/keywords/select-clause.md).  Кроме того, также можно использовать ключевое слово [var](../../../csharp/language-reference/keywords/var.md), для указания компилятору вывести тип переменной запроса \(или любой другой локальной переменной\) во время компиляции.  Например, ранее приведенный в данном разделе пример запроса также может быть выражен путем неявной типизации:  
  
 [!code-cs[csrefQueryExpBasics#52](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_8.cs)]  
  
 Дополнительные сведения см. в разделах [Неявно типизированные локальные переменные](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md) и [Type Relationships in LINQ Query Operations](../../../csharp/programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).  
  
### Начало выражения запроса  
 Выражение запроса должно начинаться с предложения `from`.  Оно задает источник данных вместе с переменной диапазона.  Переменная диапазона предоставляет каждый последующий элемент в исходной последовательности во время ее обзора.  Переменная диапазона строго типизируется на основе типа элементов в источнике данных.  В следующем примере переменная диапазона типизируется как `Country`, так как `countries` является массивом объектов `Country`.  Так как переменная диапазона строго типизируется, для доступа к любым доступным элементам типа можно использовать оператор\-точку.  
  
 [!code-cs[csrefQueryExpBasics#53](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_9.cs)]  
  
 Переменная диапазона находится в области до тех пор, пока запрос не завершится с помощью точки с запятой или предложения *продолжения*.  
  
 Выражение запроса может содержать несколько предложений `from`.  Используйте дополнительные предложения `from`, если каждый элемент в источнике является коллекцией или содержит коллекцию.  Например, предположим, что имеется коллекция объектов `Country`, каждый их которых содержит коллекцию объектов `City` с именем `Cities`.  Для выполнения запросов к объектам `City` в каждой коллекции `Country` используйте два предложения `from`, как показано ниже:  
  
 [!code-cs[csrefQueryExpBasics#54](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_10.cs)]  
  
 Дополнительные сведения см. в разделе [Предложение from](../../../csharp/language-reference/keywords/from-clause.md).  
  
### Окончание выражения запроса  
 Выражение запроса должно завершаться предложением `select` или `group`.  
  
#### Предложение "group"  
 Используйте предложение `group` для получения последовательности групп, организованной на основе указанного ключа.  Ключом могут быть данные любого типа.  Например, следующий запрос создает последовательность групп, содержащую один или несколько объектов `Country`, ключ для которых имеет значение `char`.  
  
 [!code-cs[csrefQueryExpBasics#55](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_11.cs)]  
  
 Дополнительные сведения о группировании см. в разделе [Предложение group](../../../csharp/language-reference/keywords/group-clause.md).  
  
#### Предложение "select"  
 Используйте предложение `select` для получения всех других типов последовательностей.  Простое предложение `select` просто создает последовательность с тем же типом объектов, что и у объектов, которые содержатся в источнике данных.  В этом примере источник данных содержит объекты типа `Country`.  Предложение `orderby` просто сортирует элементы в новом порядке, а предложение `select` создает последовательность переупорядоченных объектов `Country`.  
  
 [!code-cs[csrefQueryExpBasics#56](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_12.cs)]  
  
 Предложение `select` может использоваться для преобразования исходных данных в последовательности новых типов.  Такое преобразование также называют *проекцией*.  В следующем примере предложение `select` создает *проекцию* последовательности анонимных типов, содержащую только подмножество полей оригинального элемента.  Обратите внимание, что новые объекты инициализируются с помощью инициализатора объекта.  
  
 [!code-cs[csrefQueryExpBasics#57](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_13.cs)]  
  
 Дополнительные сведения обо всех методах использования предложения `select` для преобразования исходных данных см. в разделе [Предложение select](../../../csharp/language-reference/keywords/select-clause.md).  
  
#### Продолжения с использованием ключевого слова "into"  
 Ключевое слово `into` можно использовать в предложении `select` или `group` для создания временного идентификатора, в котором хранится запрос.  Это действие рекомендуется выполнять, если требуется выполнить в запросе дополнительные операции запроса после операции группирования или выбора.  В следующем примере объекты `countries` группируются в соответствии с численностью населения в диапазоны по 10 миллионов.  После создания этих групп дополнительные предложения отфильтровывают некоторые группы, а затем сортируют группы в порядке возрастания.  Чтобы выполнить эти дополнительные операции, требуется продолжение, представляемое с помощью `countryGroup`.  
  
 [!code-cs[csrefQueryExpBasics#58](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_14.cs)]  
  
 Дополнительные сведения см. в разделе [into](../../../csharp/language-reference/keywords/into.md).  
  
### Фильтрация, упорядочение и присоединение  
 Между открывающим предложением `from` и завершающим предложением `select` или `group` могут размещаться все остальные, необязательные предложения \(`where`, `join`, `orderby`, `from`, `let`\).  Любое необязательное предложение может использоваться в теле запроса несколько раз или отсутствовать вообще.  
  
#### Предложение "where"  
 Используйте предложение `where` для фильтрации элементов из источника данных по одному или нескольким выражениям предиката.  У предложения `where` в следующем примере имеются два предиката.  
  
 [!code-cs[csrefQueryExpBasics#59](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_15.cs)]  
  
 Дополнительные сведения см. в разделе [Предложение where](../../../csharp/language-reference/keywords/where-clause.md).  
  
#### Предложение "orderby"  
 Используйте предложение `orderby`, чтобы сортировать результаты в порядке возрастания или убывания.  Также можно задать порядок дополнительной сортировки.  В следующем примере выполняется основная сортировка объектов `country` по свойству `Area`.  Затем выполняется дополнительная сортировка по свойству `Population`.  
  
 [!code-cs[csrefQueryExpBasics#60](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_16.cs)]  
  
 Ключевое слово `ascending` является необязательным, так как сортировка по умолчанию происходит по возрастанию, если не задан порядок сортировки.  Дополнительные сведения см. в разделе [Предложение orderby](../../../csharp/language-reference/keywords/orderby-clause.md).  
  
#### Предложение "join"  
 Используйте предложение `join` для связи или объединения элементов из одного источника данных с элементами из другого источника данных на основе сравнения на равенство определенных ключей в каждом элементе.  В [!INCLUDE[vbteclinq](../../../csharp/includes/vbteclinq_md.md)] операции объединения выполняются над последовательностями объектов, элементы которых относятся к различным типам.  После объединения двух последовательностей необходимо использовать оператор `select` или `group`, чтобы указать элемент для сохранения в выходной последовательности.  Также можно использовать анонимный тип, чтобы объединить свойства каждого набора связанных элементов в новый тип для выходной последовательности.  В следующем примере связываются объекты `prod`, свойство `Category` которых соответствует одной из категорий в массиве строк `categories`.  Отфильтровываются продукты, свойство `Category` которых не соответствует ни одной строке в `categories`.  Оператор `select` формирует новый тип, свойства которого берутся как из `cat`, так и из `prod`.  
  
 [!code-cs[csrefQueryExpBasics#61](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_17.cs)]  
  
 Также можно выполнить групповое соединение путем сохранения результатов операции `join` во временную переменную, используя ключевое слово [into](../../../csharp/language-reference/keywords/into.md).  Дополнительные сведения см. в разделе [Предложение join](../../../csharp/language-reference/keywords/join-clause.md).  
  
#### Предложение "let"  
 Используйте предложение `let` для сохранения результатов выражения, такого как вызов метода, в новую переменную диапазона.  В следующем примере в переменную диапазона `firstName` сохраняется первый элемент массива строк, возвращенного с помощью `Split`.  
  
 [!code-cs[csrefQueryExpBasics#62](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_18.cs)]  
  
 Дополнительные сведения см. в разделе [Предложение let](../../../csharp/language-reference/keywords/let-clause.md).  
  
### Вложенные запросы в выражении запроса  
 Предложение запроса может само содержать выражение запроса, которое иногда называют *вложенным запросом*.  Каждый вложенный запрос начинается собственным предложением `from`, которое может указывать на источник данных, отличный от источника данных первого предложения `from`.  Например, в следующем запросе показано выражение запроса, которое используется в операторе "select" для извлечения результатов операции группирования.  
  
 [!code-cs[csrefQueryExpBasics#63](../../../csharp/programming-guide/linq-query-expressions/codesnippet/CSharp/query-expression-basics_19.cs)]  
  
 Дополнительные сведения см. в разделе [Практическое руководство. Вложенный запрос в операции группирования](../../../csharp/programming-guide/linq-query-expressions/how-to-perform-a-subquery-on-a-grouping-operation.md).  
  
## См. также  
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)   
 [Выражения запросов LINQ](../../../csharp/programming-guide/linq-query-expressions/index.md)   
 [LINQ \(Language\-Integrated Query\)](../Topic/LINQ%20\(Language-Integrated%20Query\).md)   
 [Ключевые слова запроса \(LINQ\)](../../../csharp/language-reference/keywords/query-keywords.md)   
 [Standard Query Operators Overview](../../../visual-basic/programming-guide/concepts/linq/standard-query-operators-overview.md)