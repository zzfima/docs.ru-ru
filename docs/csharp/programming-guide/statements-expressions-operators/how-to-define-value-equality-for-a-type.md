---
title: "Практическое руководство. Определение равенства значений для типа (Руководство по программированию на C#) | Microsoft Docs"
ms.date: "2015-07-20"
ms.prod: ".net"
ms.technology: 
  - "devlang-csharp"
ms.topic: "article"
dev_langs: 
  - "CSharp"
helpviewer_keywords: 
  - "Equals - метод [C#], переопределение"
  - "эквивалентность [C#]"
  - "эквивалентность объектов [C#]"
  - "переопределение метода Equals [C#]"
  - "равенство значений [C#]"
ms.assetid: 4084581e-b931-498b-9534-cf7ef5b68690
caps.latest.revision: 15
author: "BillWagner"
ms.author: "wiwagn"
caps.handback.revision: 15
---
# Практическое руководство. Определение равенства значений для типа (Руководство по программированию на C#)
При определении класса или структуры необходимо решить, имеет ли смысл создавать пользовательское определение равенства значений \(или эквивалентности\) для этого типа.  Обычно правила определения равенства реализуются, если объекты этого типа будут добавляться в коллекции или если они в первую очередь предназначены для хранения набора полей или свойств.  В основу определения равенства значений можно положить сравнение всех полей и свойств в типе или только их части.  Но в любом случае \(как для классов, так и для структур\) реализация должна соответствовать следующим пяти гарантиям равенства.  
  
1.  x.`Equals`\(x\) возвращает значение `true.` Это называется свойством рефлексивности.  
  
2.  x. `Equals` \(y\) возвращает то же значение, что и y. `Equals` \(x\).  Это называется свойством симметрии.  
  
3.  Если \(x.`Equals`\(y\) && y.`Equals`\(z\)\) возвращает `true`, то x.`Equals`\(z\) возвращает `true`.  Это называется свойством транзитивности.  
  
4.  Последовательные вызовы x.`Equals` \(y\) возвращают одно и то же значение до тех пор, пока объекты, на которые ссылаются x и y, не будут изменены.  
  
5.  x.`Equals`\(null\) возвращает значение `false`.  Однако null.Equals\(null\) вызывает исключение; эта инструкция не удовлетворяет приведенному выше правилу номер 2.  
  
 У любой определяемой структуры уже имеется реализация равенства значений по умолчанию, наследуемая от переопределения <xref:System.ValueType?displayProperty=fullName> метода <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>.  Эта реализация использует отражение для проверки всех открытых и неоткрытых полей и свойств типа.  Хотя эта реализация возвращает верный результат, она отличается невысокой скоростью по сравнению с пользовательской реализацией, которую можно написать специально для конкретного типа.  
  
 Детали реализации равенства значений для классов и структур различаются.  Тем не менее для реализации равенства как для классов, так и для структур, необходимо выполнить одни и те же базовые действия.  
  
1.  Переопределите [виртуальный](../../../csharp/language-reference/keywords/virtual.md) метод <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>.  В большинстве случаев пользовательская реализация `bool Equals( object obj )` должна вызывать относящийся к конкретному типу метод `Equals`, который является реализацией интерфейса <xref:System.IEquatable%601?displayProperty=fullName>.  \(См. шаг 2.\)  
  
2.  Реализуйте интерфейс <xref:System.IEquatable%601?displayProperty=fullName>, указав относящийся к конкретному типу метод `Equals`.  Именно на этом этапе происходит фактическое сравнение значений.  Например, функцию равенства можно определить путем сравнения только одного из двух полей в типе.  Не создавайте исключений в методе `Equals`.  Только для классов: этот метод должен проверять только те поля, которые были объявлены в классе.  Для проверки полей базового класса следует вызывать метод `base.Equals`.  \(Не следует делать этого, если тип наследует напрямую классу <xref:System.Object>, поскольку реализация <xref:System.Object> метода <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> выполняет проверку равенства ссылок.\)  
  
3.  Рекомендуется \(хотя это и не обязательно\) перегрузить операторы [\=\=](../../../csharp/language-reference/operators/equality-comparison-operator.md) и [\!\=](../../../csharp/language-reference/operators/not-equal-operator.md).  
  
4.  Перегрузите метод <xref:System.Object.GetHashCode%2A?displayProperty=fullName>, чтобы два объекта с равными значениями возвращали один и тот же хэш\-код.  
  
5.  Необязательно: для поддержки определений "больше" и "меньше" реализуйте для типа интерфейс <xref:System.IComparable%601>, а также перегрузите операторы [\<\=](../../../csharp/language-reference/operators/less-than-equal-operator.md) и [\>\=](../../../csharp/language-reference/operators/greater-than-equal-operator.md).  
  
 В первом из приведенных ниже примеров показана реализация класса.  Во втором примере показана реализация структуры.  
  
## Пример  
 В следующем примере показана реализация равенства значений в классе \(ссылочный тип\).  
  
 [!code-cs[csProgGuideStatements#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/how-to-define-value-equa_1.cs)]  
  
 В классах \(ссылочных типах\) реализация по умолчанию обоих методов <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> выполняет проверку равенства ссылок, а не значений.  Когда разработчик переопределяет виртуальный метод, его задача заключается в том, чтобы реализовать семантику равенства значений.  
  
 К объектам класса можно применять операторы `==` и `!=`, даже если они не были перегружены в классе.  Однако по умолчанию они служат для проверки равенства ссылок.  При перегрузке в классе метода `Equals` необходимо перегрузить операторы `==` и `!=`, но это не обязательно.  
  
## Пример  
 В следующем примере показана реализация равенства значений в структуре \(тип значения\).  
  
 [!code-cs[csProgGuideStatements#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/csharp/how-to-define-value-equa_2.cs)]  
  
 В структурах реализация по умолчанию метода <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> \(переопределенная версия <xref:System.ValueType?displayProperty=fullName>\) проверяет равенство всех полей типа за счет отражения.  Когда разработчик переопределяет виртуальный метод `Equals` в структуре, его задача состоит в том, чтобы найти более эффективный способ проверки равенства значений и, если это возможно, реализовать сравнение только на основании части полей или свойств структуры.  
  
 Операторы [\=\=](../../../csharp/language-reference/operators/equality-comparison-operator.md) и [\!\=](../../../csharp/language-reference/operators/not-equal-operator.md) нельзя применять к структурам, если только они не были явным образом перегружены для конкретной структуры.  
  
## См. также  
 [Сравнения на равенство](../../../csharp/programming-guide/statements-expressions-operators/equality-comparisons.md)   
 [Руководство по программированию на C\#](../../../csharp/programming-guide/index.md)