---
title: Функциональное и императивное программирование
ms.date: 07/20/2015
ms.assetid: 6a1f3b57-00e6-447d-9906-74c7c4d5d85c
ms.openlocfilehash: 704beadc29af0de606b8f246360dc6fffca8cfcc
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74353432"
---
# <a name="functional-programming-vs-imperative-programming-visual-basic"></a><span data-ttu-id="80116-102">Functional Programming vs. Imperative Programming (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="80116-102">Functional Programming vs. Imperative Programming (Visual Basic)</span></span>
<span data-ttu-id="80116-103">В этом разделе сравнивается и противопоставляется функциональное программирование с традиционным императивным (процедурным) программированием.</span><span class="sxs-lookup"><span data-stu-id="80116-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="80116-104">Функциональное и императивное программирование</span><span class="sxs-lookup"><span data-stu-id="80116-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="80116-105">Принципы *функционального программирования* формулировались специально для поддержки чисто функционального подхода к решению проблем.</span><span class="sxs-lookup"><span data-stu-id="80116-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="80116-106">Функциональное программирование является одной из форм *декларативного программирования*.</span><span class="sxs-lookup"><span data-stu-id="80116-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="80116-107">В отличие от этого, большинство традиционных языков, в том числе такие языки объектно-ориентированного программирования (OOP), как C#, Visual Basic, C++ и Java, разрабатывались в основном для *императивного* (процедурного) программирования.</span><span class="sxs-lookup"><span data-stu-id="80116-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="80116-108">При императивном подходе разработчик пишет код, подробно определяющий шаги, которые должен выполнить компьютер для достижения цели.</span><span class="sxs-lookup"><span data-stu-id="80116-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="80116-109">Такое программирование иногда называют *алгоритмическим*.</span><span class="sxs-lookup"><span data-stu-id="80116-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="80116-110">В отличие от него, функциональный подход сводится к составлению решения задачи в виде набора функций, которые должны быть выполнены.</span><span class="sxs-lookup"><span data-stu-id="80116-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="80116-111">Разработчик подробно определяет вход каждой функции и возвращаемые ею результаты.</span><span class="sxs-lookup"><span data-stu-id="80116-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="80116-112">В следующей таблице описаны некоторые важные различия между этими двумя подходами.</span><span class="sxs-lookup"><span data-stu-id="80116-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="80116-113">Характеристика</span><span class="sxs-lookup"><span data-stu-id="80116-113">Characteristic</span></span>|<span data-ttu-id="80116-114">Императивный подход</span><span class="sxs-lookup"><span data-stu-id="80116-114">Imperative approach</span></span>|<span data-ttu-id="80116-115">Функциональный подход</span><span class="sxs-lookup"><span data-stu-id="80116-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="80116-116">Основная направленность усилий программиста</span><span class="sxs-lookup"><span data-stu-id="80116-116">Programmer focus</span></span>|<span data-ttu-id="80116-117">Способы выполнения (алгоритмы) задач и отслеживания изменений в их состоянии.</span><span class="sxs-lookup"><span data-stu-id="80116-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="80116-118">Требуемые данные и преобразования.</span><span class="sxs-lookup"><span data-stu-id="80116-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="80116-119">Изменения состояния</span><span class="sxs-lookup"><span data-stu-id="80116-119">State changes</span></span>|<span data-ttu-id="80116-120">Важно!</span><span class="sxs-lookup"><span data-stu-id="80116-120">Important.</span></span>|<span data-ttu-id="80116-121">Не существует.</span><span class="sxs-lookup"><span data-stu-id="80116-121">Non-existent.</span></span>|  
|<span data-ttu-id="80116-122">Порядок выполнения</span><span class="sxs-lookup"><span data-stu-id="80116-122">Order of execution</span></span>|<span data-ttu-id="80116-123">Важно!</span><span class="sxs-lookup"><span data-stu-id="80116-123">Important.</span></span>|<span data-ttu-id="80116-124">Низкая значимость.</span><span class="sxs-lookup"><span data-stu-id="80116-124">Low importance.</span></span>|  
|<span data-ttu-id="80116-125">Управление основным потоком данных</span><span class="sxs-lookup"><span data-stu-id="80116-125">Primary flow control</span></span>|<span data-ttu-id="80116-126">Циклы, условия и вызовы функций (методов).</span><span class="sxs-lookup"><span data-stu-id="80116-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="80116-127">Вызовы функций, включая рекурсивные.</span><span class="sxs-lookup"><span data-stu-id="80116-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="80116-128">Основная единица обработки</span><span class="sxs-lookup"><span data-stu-id="80116-128">Primary manipulation unit</span></span>|<span data-ttu-id="80116-129">Экземпляры структур или классов.</span><span class="sxs-lookup"><span data-stu-id="80116-129">Instances of structures or classes.</span></span>|<span data-ttu-id="80116-130">Функции как полноценные объекты и коллекции данных.</span><span class="sxs-lookup"><span data-stu-id="80116-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="80116-131">Безусловно, большинство языков программирования было разработано в целях поддержки определенных подходов к программированию, но многие языки общего назначения являются достаточно гибкими, чтобы поддерживать несколько подходов.</span><span class="sxs-lookup"><span data-stu-id="80116-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="80116-132">Например, большинство языков, содержащих указатели на функции, могут использоваться для надежной поддержки функционального программирования.</span><span class="sxs-lookup"><span data-stu-id="80116-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="80116-133">Furthermore, Visual Basic includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span><span class="sxs-lookup"><span data-stu-id="80116-133">Furthermore, Visual Basic includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="80116-134">Одной из форм декларативного, функционального программирования является технология LINQ.</span><span class="sxs-lookup"><span data-stu-id="80116-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="80116-135">Функциональное программирование с помощью XSLT</span><span class="sxs-lookup"><span data-stu-id="80116-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="80116-136">Многие разработчики XSLT знакомы с чисто функциональным подходом.</span><span class="sxs-lookup"><span data-stu-id="80116-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="80116-137">Наиболее эффективный способ разработки таблицы стилей XSLT состоит в том, что каждый шаблон рассматривается как изолированное, составное преобразование.</span><span class="sxs-lookup"><span data-stu-id="80116-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="80116-138">При этом совершенно не приходится задумываться над тем, в каком порядке должны проводиться вычисления.</span><span class="sxs-lookup"><span data-stu-id="80116-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="80116-139">XSLT исключает побочные эффекты (если не считать того, что применение механизмов экранирования, предназначенных для выполнения процедурного кода, может приводить к получению результатов функций, не соответствующих определениям этих функций).</span><span class="sxs-lookup"><span data-stu-id="80116-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="80116-140">Таким образом, XSLT является эффективным инструментом, но некоторые его характеристики не оптимальны.</span><span class="sxs-lookup"><span data-stu-id="80116-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="80116-141">Например, программные конструкции приходится представлять на языке XML, в связи с чем объем кода становится довольно большим, поэтому его сопровождение затрудняется.</span><span class="sxs-lookup"><span data-stu-id="80116-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="80116-142">Кроме того, в управлении потоком широко применяется рекурсия, что может привести к созданию трудночитаемого кода.</span><span class="sxs-lookup"><span data-stu-id="80116-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="80116-143">Дополнительные сведения об XSLT см. в разделе [Преобразования XSLT](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="80116-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="80116-144">Тем не менее XSLT доказал свою полезность при чисто функциональном подходе для преобразования XML из одного вида в другой.</span><span class="sxs-lookup"><span data-stu-id="80116-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="80116-145">Чисто функциональное программирование с помощью LINQ to XML во многом похоже на XSLT.</span><span class="sxs-lookup"><span data-stu-id="80116-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="80116-146">However, the programming constructs introduced by LINQ to XML and Visual Basic allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span><span class="sxs-lookup"><span data-stu-id="80116-146">However, the programming constructs introduced by LINQ to XML and Visual Basic allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="80116-147">Преимущества чистых функций</span><span class="sxs-lookup"><span data-stu-id="80116-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="80116-148">Основная причина реализации функциональных преобразований в виде чистых функций заключается в том, что чистые функции являются компонуемыми, т. е. самодостаточными без сохранения состояния.</span><span class="sxs-lookup"><span data-stu-id="80116-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="80116-149">Это дает ряд преимуществ, включая следующие.</span><span class="sxs-lookup"><span data-stu-id="80116-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
- <span data-ttu-id="80116-150">Повышенная удобочитаемость и обслуживаемость.</span><span class="sxs-lookup"><span data-stu-id="80116-150">Increased readability and maintainability.</span></span> <span data-ttu-id="80116-151">Это объясняется тем, что каждая функция разрабатывается для выполнения конкретных задач, определяемых аргументами.</span><span class="sxs-lookup"><span data-stu-id="80116-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="80116-152">Функция не зависит от какого-либо внешнего состояния.</span><span class="sxs-lookup"><span data-stu-id="80116-152">The function does not rely on any external state.</span></span>  
  
- <span data-ttu-id="80116-153">Упрощается разработка, основанная на ранее созданном коде.</span><span class="sxs-lookup"><span data-stu-id="80116-153">Easier reiterative development.</span></span> <span data-ttu-id="80116-154">Код становится более приемлемым для оптимизации кода, поэтому легче реализовать изменения в проекте.</span><span class="sxs-lookup"><span data-stu-id="80116-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="80116-155">Например, предположим, что в процессе написания сложного преобразования выясняется, что какой-то код повторяется несколько раз.</span><span class="sxs-lookup"><span data-stu-id="80116-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="80116-156">Если оптимизация кода предусматривает преобразование в чистый метод, то полученный чистый метод можно вызывать в любое время, не беспокоясь о побочных эффектах.</span><span class="sxs-lookup"><span data-stu-id="80116-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
- <span data-ttu-id="80116-157">Упрощаются тестирование и отладка.</span><span class="sxs-lookup"><span data-stu-id="80116-157">Easier testing and debugging.</span></span> <span data-ttu-id="80116-158">Чистые функции проще тестировать отдельно от основной части кода, поэтому можно написать проверочный код, в котором чистая функция вызывается с типичными значениями, допустимыми краевыми значениями и недопустимыми краевыми значениями.</span><span class="sxs-lookup"><span data-stu-id="80116-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="80116-159">Освоение нового подхода разработчиками объектно-ориентированных приложений</span><span class="sxs-lookup"><span data-stu-id="80116-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="80116-160">Традиционное объектно-ориентированное программирование (OOP) является таковым, что большинство разработчиков привыкает писать код в императивном (процедурном) стиле.</span><span class="sxs-lookup"><span data-stu-id="80116-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="80116-161">Переходя к разработке в чисто функциональном стиле, они должны изменить свое мышление и подход к разработке.</span><span class="sxs-lookup"><span data-stu-id="80116-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="80116-162">Чтобы решить задачу, разработчики объектно-ориентированных приложений проектируют иерархии классов, добиваются правильной инкапсуляции и мыслят в терминах контрактов между классами.</span><span class="sxs-lookup"><span data-stu-id="80116-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="80116-163">Для них первостепенное значение имеет обеспечение правильного поведения и состояния типов объектов, а для достижения этого используются такие возможности языка, как классы, интерфейсы, наследование и полиморфизм.</span><span class="sxs-lookup"><span data-stu-id="80116-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="80116-164">В отличие от этого, в функциональном программировании применяется подход к вычислительным проблемам как к определению чисто функциональных преобразований коллекции данных.</span><span class="sxs-lookup"><span data-stu-id="80116-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="80116-165">В функциональном программировании приходится отказываться от применения состояний и изменяющихся данных, а вместо этого сосредоточиваться на применении функции.</span><span class="sxs-lookup"><span data-stu-id="80116-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="80116-166">Fortunately, Visual Basic doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span><span class="sxs-lookup"><span data-stu-id="80116-166">Fortunately, Visual Basic doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="80116-167">Разработчик может сам выбирать нужный подход в зависимости от конкретного сценария.</span><span class="sxs-lookup"><span data-stu-id="80116-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="80116-168">В действительности в программах часто сочетаются оба стиля.</span><span class="sxs-lookup"><span data-stu-id="80116-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="80116-169">См. также</span><span class="sxs-lookup"><span data-stu-id="80116-169">See also</span></span>

- [<span data-ttu-id="80116-170">Introduction to Pure Functional Transformations (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="80116-170">Introduction to Pure Functional Transformations (Visual Basic)</span></span>](../../../../visual-basic/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="80116-171">Преобразования XSLT</span><span class="sxs-lookup"><span data-stu-id="80116-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="80116-172">Refactoring Into Pure Functions (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="80116-172">Refactoring Into Pure Functions (Visual Basic)</span></span>](../../../../visual-basic/programming-guide/concepts/linq/refactoring-into-pure-functions.md)
