---
title: "Устранение неполадок взаимодействия (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "2015-07-20"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.topic: "article"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "сборки [Visual Basic]"
  - "сборки [Visual Basic], развертывание"
  - "COM-взаимодействие, устранение неполадок"
  - "COM-объекты, устранение неполадок"
  - "сборки взаимодействия"
  - "взаимодействие, развертывание сборок"
  - "взаимодействие, установка сборок, использующих общие компоненты"
  - "взаимодействие, общие компоненты"
  - "взаимодействие, общие компоненты"
  - "взаимодействие, устранение неполадок"
  - "общие компоненты, использованные со сборками"
  - "устранение неполадок взаимодействия"
  - "устранение неполадок - Visual Basic, взаимодействие"
ms.assetid: b324cc1e-b03c-4f39-aea6-6a6d5bfd0e37
caps.latest.revision: 21
author: "stevehoag"
ms.author: "shoag"
caps.handback.revision: 21
---
# Устранение неполадок взаимодействия (Visual Basic)
[!INCLUDE[vs2017banner](../../../visual-basic/includes/vs2017banner.md)]

При взаимодействии между COM и управляемым кодом [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort-md.md)], можно столкнуться с типичными вопросами, рассматриваемыми в следующих разделах:  
  
##  <a name="vbconinteroperabilitymarshalinganchor1"></a> Маршалинг взаимодействия  
 Иногда возникает необходимость в использовании типов данных, не входящие в состав [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort-md.md)].  Сборки взаимодействия выполняют большую часть работы с объектами COM, но может возникнуть необходимость управления типами данных, используемых, когда управляемые объекты предоставляются COM.  Например, структуры в библиотеках класса должны задать неуправляемый тип `BStr` для строк, отправляемых в объекты COM, созданные Visual Basic 6.0 и предыдущими версиями.  В таких случаях можно использовать атрибут <xref:System.Runtime.InteropServices.MarshalAsAttribute>, чтобы управляемые типы предоставлялись как неуправляемые.  
  
##  <a name="vbconinteroperabilitymarshalinganchor2"></a> Экспорт строк фиксированной длины в неуправляемый код  
 В Visual Basic 6.0 и более ранних версиях строки экспортировались в объекты COM как последовательности байтов без пустого завершающего знака.  Для совместимости с другими языками [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong-md.md)] при экспорте строк включает завершающий знак.  Лучший способ решить проблему несовместимости — это экспортировать строки без завершающего знака как массивы типа `Byte` или `Char`.  
  
##  <a name="vbconinteroperabilitymarshalinganchor3"></a> Экспорт иерархий наследования  
 Иерархии управляемого класса выравниваются при представлении их как объектов COM.  Например, если определить базовый класс с помощью элемента, а затем наследовать базовый класс в производном классе, который предоставляется как объект COM, клиенты, использующие производный класс в объекте COM, не смогут использовать унаследованные элементы.  Элементы базового класса доступны из объектов COM только как экземпляры базового класса и только при условии, что базовый класс также создан как объект COM.  
  
## Перегруженные методы  
 Хотя можно создать перегруженные методы с помощью [!INCLUDE[vbprvb](../../../csharp/programming-guide/concepts/linq/includes/vbprvb-md.md)], они не поддерживаются COM.  Когда класс, содержащий перегруженные методы, выставлен как объект COM, новые имена методов создаются для перегруженных методов.  
  
 Например, рассмотрим класс, имеющий две перегрузки метода `Synch`.  Когда класс выставлен как объект COM, новые созданные имена методов могут быть `Synch` и `Synch_2`.  
  
 Переименование может вызвать две проблемы для потребителей COM\-объекта.  
  
1.  Клиенты могут не ожидать созданных имен методов.  
  
2.  Созданные имена методов в классе, выставленном как COM\-объект, можно изменить при добавлении новых перегрузок к классу или его базовому классу.  Это может вызвать проблемы управления версиями.  
  
 Для решения обоих проблем при разработке объектов, которые будут предоставлены в виде объектов COM, присвойте каждому методу уникальное имя вместо использования перегрузки.  
  
##  <a name="vbconinteroperabilitymarshalinganchor4"></a> Использование объектов COM в сборках взаимодействия  
 Сборки взаимодействия используются почти так же, как если бы они были управляемым кодом, заменяющим объекты COM, которые они представляют.  Тем не менее, поскольку они являются обертками, а не настоящими объектами COM, есть некоторые различия в использовании сборок взаимодействия и обычных сборок.  Эти различия касаются предоставления классов, а также типов данных параметров и возвращаемых значений.  
  
##  <a name="vbconinteroperabilitymarshalinganchor5"></a> Классы, предоставляемые и как интерфейсы, и как классы  
 В отличие от классов в обычных сборках классы COM представлены в сборках взаимодействия и как интерфейсы, и как классы, представляющие класс COM.  Имя интерфейса совпадает с именем класса COM.  Имя класса взаимодействия то же, что и имя исходного класса COM, но с добавленным в конце словом "Class".  Предположим, что имеется проект с ссылкой на сборку взаимодействия для объекта COM.  Если COM\-класс назван `MyComClass`, IntelliSense и обозреватель объектов будут показывать интерфейс с именем `MyComClass` и класс с именем `MyComClassClass`.  
  
##  <a name="vbconinteroperabilitymarshalinganchor6"></a> Создание экземпляров класса .NET Framework  
 Как правило, экземпляр класса [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort-md.md)] создается при помощи инструкции `New` с именем класса.  Наличие класса COM, представленного сборкой взаимодействия, — это тот случай, когда можно использовать оператор `New` с интерфейсом.  Пока не используется COM\-класс с инструкцией `Inherits`, интерфейс можно использовать так же, как и класс.  В следующем коде показано, как создать объект `Command` в проекте, который имеет ссылку на объект COM библиотеки Microsoft ActiveX Data Objects 2.8:  
  
 [!code-vb[VbVbalrInterop#20](../../../visual-basic/programming-guide/com-interop/codesnippet/visualbasic/vbvbalrinterop/Class1.vb#20)]  
  
 Тем не менее, если класс COM используется как основа для производного класса, следует использовать класс взаимодействия, представляющий класс COM, например:  
  
 [!code-vb[VbVbalrInterop#21](../../../visual-basic/programming-guide/com-interop/codesnippet/visualbasic/vbvbalrinterop/Class1.vb#21)]  
  
> [!NOTE]
>  Сборки взаимодействия неявно реализуют интерфейсы, представляющие классы COM.  Не следует использовать оператор `Implements` для реализации этих интерфейсов: результатом такой попытки будет ошибка.  
  
##  <a name="vbconinteroperabilitymarshalinganchor7"></a> Типы данных параметров и возвращаемых значений  
 В отличие от элементов обычных сборок, элементы сборки взаимодействия могут иметь типы данных, отличные от используемых в исходном объявлении объекта.  Несмотря на то, что сборки взаимодействия неявно преобразуют типы COM в совместимые типы языковой среды выполнения, во избежание ошибок времени выполнения следует уделять внимание типам данных, используемым обеими сторонами.  Например в объектах COM, созданных в Visual Basic 6.0 и в более ранних версиях, значения типа `Integer` принимают эквивалентный [!INCLUDE[dnprdnshort](../../../csharp/getting-started/includes/dnprdnshort-md.md)] тип `Short`.  Рекомендуется использовать обозреватель объектов для проверки характеристик импортированных элементов перед их использованием.  
  
##  <a name="vbconinteroperabilitymarshalinganchor8"></a> Методы COM уровня модуля  
 Большинство объектов COM используются путем создания экземпляра класса COM с помощью ключевого слова `New` с последующим вызыванием методов объекта.  Одно исключение из этого правила включает COM\-объекты, содержащие COM\-классы `AppObj` или `GlobalMultiUse`.  Такие классы напоминают методы уровня модуля в классах [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong-md.md)].  В Visual Basic 6.0 и более ранних версиях неявно создаются экземпляры таких объектов при первом вызове одного из их методов.  Например, в Visual Basic 6.0 можно добавить ссылку на Microsoft DAO 3.6 Object Library и вызвать метод `DBEngine` без предварительного создания экземпляра:  
  
```  
Dim db As DAO.Database  
' Open the database.  
Set db = DBEngine.OpenDatabase("C:\nwind.mdb")  
' Use the database object.  
```  
  
 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong-md.md)] требует, чтобы экземпляры объектов COM всегда создавались до использования их методов.  Чтобы использовать эти методы в [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong-md.md)], объявите переменную нужного класса и с помощью ключевого слова "new" присвойте объект для переменной объекта.  Ключевое слово `Shared` можно использовать, когда нужно убедиться, что создан только один экземпляр класса.  
  
 [!code-vb[VbVbalrInterop#23](../../../visual-basic/programming-guide/com-interop/codesnippet/visualbasic/vbvbalrinterop/Class1.vb#23)]  
  
##  <a name="vbconinteroperabilitymarshalinganchor9"></a> Необработанные ошибки в обработчиках событий  
 Одна из общих проблем взаимодействия касается ошибок в обработчиках событий, которые обрабатывают события объектов COM.  Такие ошибки игнорируются, пока Вы специально не проверите на наличие ошибок с помощью инструкций `On Error` или `Try...Catch...Finally`.  Например, следующий пример взят из проекта [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong-md.md)], в котором присутствует ссылка на объект COM библиотеки Microsoft ActiveX Data Objects 2.8.  
  
 [!code-vb[VbVbalrInterop#24](../../../visual-basic/programming-guide/com-interop/codesnippet/visualbasic/vbvbalrinterop/Class1.vb#24)]  
  
 Этот пример, как и предполагалось, вызывает исключение.  Однако, при использовании того же примера без блока `Try...Catch...Finally`, ошибка не обрабатывается, как если бы использовалась инструкция `OnError Resume Next`.  Без обработки ошибок деление на ноль вызовет неявную ошибку.  Поскольку такие ошибки никогда не вызывают ошибку необработанного исключения, крайне важно использовать ту или иную форму обработки исключений в обработчиках событий для объектов COM.  
  
### Общие сведения об ошибках взаимодействия COM  
 Без обработки ошибок вызовы взаимодействия часто создают ошибки, несущие в себе мало полезной информации.  По возможности следует использовать структурированную обработку ошибок, чтобы получать более подробные сведения об их характере.  Это может быть особенно полезным при отладке приложений.  Примеры.  
  
 [!code-vb[VbVbalrInterop#25](../../../visual-basic/programming-guide/com-interop/codesnippet/visualbasic/vbvbalrinterop/Class1.vb#25)]  
  
 Проверка содержимого объекта исключения дает такие сведения, как описание ошибки, HRESULT и источник ошибок COM.  
  
##  <a name="vbconinteroperabilitymarshalinganchor10"></a> Вопросы, связанные с элементами управления ActiveX  
 Большинство элементов управления ActiveX, работающих в Visual Basic 6.0, работают и в [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong-md.md)].  Большинство исключений — это контейнерные элементы управления, то есть элементы управления, которые визуально содержат в себе другие элементы управления.  Ниже приведены некоторые примеры старых элементов управления, которые не работают корректно с [!INCLUDE[vsprvs](../../../csharp/includes/vsprvs-md.md)].  
  
-   Элемент управления Frame из Microsoft Forms 2.0  
  
-   Элемент управления Up\-Down, называемый также элементом управления вращением  
  
-   Элемент управления Sheridan Tab  
  
 Способов обойти проблемы с неподдерживаемыми элементами управления ActiveX мало.  Если у вас есть исходный код, можно выполнить миграцию существующих элементов управления в [!INCLUDE[vsprvs](../../../csharp/includes/vsprvs-md.md)].  Другой вариант — запросить у поставщиков программы обновленные версии элементов управления, совместимые с .NET, для замены неподдерживаемых элементов управления ActiveX.  
  
##  <a name="vbconinteroperabilitymarshalinganchor11"></a> Передача ByRef свойств ReadOnly элементов управления  
 [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong-md.md)] иногда вызывает ошибки COM, такие как "Ошибка 0x800A017F CTL\_E\_SETNOTSUPPORTED", когда Вы передаете свойства `ReadOnly` некоторых старых элементов управления ActiveX в качестве параметров `ByRef` в другие процедуры.  Такая же процедура, вызванная в Visual Basic 6.0, не вызывает ошибки, и параметры обрабатываются так, как если бы они передавались по значению.  Сообщение об ошибке в [!INCLUDE[vbprvblong](../../../visual-basic/developing-apps/customizing-extending-my/includes/vbprvblong-md.md)] является COM\-объектом отчетности от том, что вы пытаетесь изменить свойство, у которого нет процедуры свойства `Set`.  
  
 При наличии доступа к вызываемой процедуре можно предотвратить эту ошибку, объявив с ключевого слова `ByVal` параметры, которые поддерживают свойства `ReadOnly`.  Примеры.  
  
 [!code-vb[VbVbalrInterop#26](../../../visual-basic/programming-guide/com-interop/codesnippet/visualbasic/vbvbalrinterop/Class1.vb#26)]  
  
 Если исходный код для вызываемой процедуры недоступен, можно принудительно передать свойство по значению, заключив вызываемую процедуру в дополнительную пару квадратных скобок.  Например, в проекте, в котором есть ссылка на объект COM библиотеки Microsoft ActiveX Data Objects 2.8, можно использовать:  
  
 [!code-vb[VbVbalrInterop#27](../../../visual-basic/programming-guide/com-interop/codesnippet/visualbasic/vbvbalrinterop/Class1.vb#27)]  
  
##  <a name="vbconinteroperabilitymarshalinganchor12"></a> Развертывание сборок, предоставляющих взаимодействие  
 С развертыванием сборок, которые предоставляют интерфейсы COM, связаны особые проблемы.  Например, проблема может возникнуть тогда, когда различные приложения ссылаются на одну и ту же сборку COM.  Эта ситуация обычна, когда установлена новая версия сборки, а другое приложение все еще использует прежнюю версию.  Следствием удаление любой сборки, содержащей совместно используемую библиотеку DLL, может оказаться недоступность этой библиотеки.  
  
 Во избежание этой проблемы следует устанавливать совместно используемые сборки в глобальный кэш сборок \(GAC\) и использовать MergeModule для этого компонента.  Если невозможно установить приложение в глобальный кэш сборок, тогда его следует установить в CommonFilesFolder в связанную с версией вложенную папку.  
  
 Сборки, не используемые совместно, должны быть размещены в одной папке с вызывающим приложением.  
  
## См. также  
 <xref:System.Runtime.InteropServices.MarshalAsAttribute>   
 [COM\-взаимодействие](../../../visual-basic/programming-guide/com-interop/index.md)   
 [Tlbimp.exe \(Type Library Importer\)](../Topic/Tlbimp.exe%20\(Type%20Library%20Importer\).md)   
 [Tlbexp.exe \(Type Library Exporter\)](../Topic/Tlbexp.exe%20\(Type%20Library%20Exporter\).md)   
 [Пошаговое руководство. Реализация наследования с использованием COM\-объектов](../../../visual-basic/programming-guide/com-interop/walkthrough-implementing-inheritance-with-com-objects.md)   
 [Инструкция Inherits](../../../visual-basic/language-reference/statements/inherits-statement.md)   
 [глобальный кэш сборок](../Topic/Global%20Assembly%20Cache.md)