---
title: Пошаговое руководство. Вызов API Windows (Visual Basic)
ms.date: 07/20/2015
helpviewer_keywords:
- DLLs, calling
- Windows API, walkthroughs
- platform invoke, walkthroughs
- API calls [Visual Basic], walkthroughs [Visual Basic]
- Windows API, calling
- walkthroughs [Visual Basic], API calls
- DllImport attribute, calling Windows API
- Declare statement [Visual Basic], declaring DLL functions
ms.assetid: 9280ca96-7a93-47a3-8d01-6d01be0657cb
ms.openlocfilehash: 8e6d3e7f84c96d145a48daa27918cbb2cb3b61ac
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2019
ms.locfileid: "69958315"
---
# <a name="walkthrough-calling-windows-apis-visual-basic"></a>Пошаговое руководство. Вызов API Windows (Visual Basic)
Windows API — это библиотеки динамической компоновки (DLL), которые являются частью операционной системы Windows. Они используются для выполнения задач, когда трудно писать эквивалентные процедуры. Например, Windows предоставляет функцию с именем `FlashWindowEx` , которая позволяет сделать строку заголовка для приложения альтернативой светлой и темной тени.  
  
 Преимущество использования API-интерфейсов Windows в коде состоит в том, что они могут сэкономить время разработки, поскольку они содержат десятки полезных функций, которые уже написаны и ожидают использования. Недостаток заключается в том, что API Windows может быть трудно работать с и унфоргивинг в случае неправильной работы.  
  
 Интерфейсы API Windows представляют особую категорию взаимодействия. Интерфейсы API Windows не используют управляемый код, не имеют встроенных библиотек типов и используют типы данных, отличные от используемых в Visual Studio. Из-за этих различий и, поскольку интерфейсы API Windows не являются объектами COM, взаимодействия с API Windows и .NET Framework выполняются с помощью вызова неуправляемого кода или PInvoke. Платформенный вызов — это служба, которая позволяет управляемому коду вызывать неуправляемые функции, реализованные в библиотеках DLL. Дополнительные сведения см. в разделе [Использование неуправляемых функций DLL](../../../framework/interop/consuming-unmanaged-dll-functions.md). Вы можете использовать PInvoke в Visual Basic, используя либо `Declare` инструкцию, либо `DllImport` применяя атрибут к пустой процедуре.  
  
 Вызовы Windows API были важной частью Visual Basic программирования в прошлом, но они редко требуются для Visual Basic .NET. Везде, где это возможно, следует использовать управляемый код из .NET Framework для выполнения задач, а не вызовов Windows API. В этом пошаговом руководстве содержатся сведения о ситуациях, в которых требуется использовать API Windows.  
  
[!INCLUDE[note_settings_general](~/includes/note-settings-general-md.md)]  
  
## <a name="api-calls-using-declare"></a>Вызовы API с помощью Declare  
 Наиболее распространенным способом вызова API Windows является использование `Declare` инструкции.  
  
### <a name="to-declare-a-dll-procedure"></a>Объявление процедуры DLL  
  
1. Определите имя функции, которую необходимо вызвать, а также ее аргументы, типы аргументов и возвращаемое значение, а также имя и расположение библиотеки DLL, содержащей ее.  
  
    > [!NOTE]
    > Полные сведения о API Windows см. в документации по пакету SDK для Win32 в Windows API Platform SDK. Дополнительные сведения о константах, используемых API Windows, см. в файлах заголовков, таких как Windows. h, входящих в состав пакета Platform SDK.  
  
2. Откройте новый проект приложения Windows, щелкнув **создать** в меню **файл** , а затем выбрав пункт **проект**. Откроется диалоговое окно **Новый проект** .  
  
3. Выберите **приложение Windows** в списке шаблонов проектов Visual Basic. Отобразится новый проект.  
  
4. Добавьте следующую `Declare` функцию либо в класс, либо в модуль, в котором требуется использовать библиотеку DLL:  
  
     [!code-vb[VbVbalrInterop#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#9)]  
  
### <a name="parts-of-the-declare-statement"></a>Части инструкции DECLARE  
 `Declare` Инструкция включает следующие элементы.  
  
#### <a name="auto-modifier"></a>Модификатор Auto  
 `Auto` Модификатор указывает среде выполнения преобразовать строку на основе имени метода в соответствии с правилами среды CLR (или именем псевдонима, если оно указано).  
  
#### <a name="lib-and-alias-keywords"></a>Ключевые слова lib и Alias  
 Имя, следующее `Function` за ключевым словом, — это имя, которое программа использует для доступа к импортируемой функции. Оно может совпадать с реальным именем вызываемой функции, или можно использовать любое допустимое имя процедуры, а затем применить `Alias` ключевое слово, чтобы указать реальное имя вызываемой функции.  
  
 `Lib` Укажите ключевое слово, а затем имя и расположение библиотеки DLL, содержащей вызываемую функцию. Указывать путь к файлам, расположенным в системных каталогах Windows, не требуется.  
  
 Используйте ключевое слово, `Alias` если имя вызываемой функции не является допустимым Visual Basic именем процедуры или конфликтует с именами других элементов в приложении. `Alias`Указывает на истинное имя вызываемой функции.  
  
#### <a name="argument-and-data-type-declarations"></a>Объявления аргументов и типов данных  
 Объявите аргументы и их типы данных. Эта часть может быть сложной, поскольку типы данных, используемые Windows, не соответствуют типам данных Visual Studio. Visual Basic выполняет большой объем работы, преобразуя аргументы в совместимые типы данных, процесс, называемый *упаковкой*. Можно явно управлять упаковкой аргументов с помощью <xref:System.Runtime.InteropServices.MarshalAsAttribute> атрибута, определенного <xref:System.Runtime.InteropServices> в пространстве имен.  
  
> [!NOTE]
> Предыдущие версии Visual Basic позволяли объявлять параметры `As Any`, то есть могут использоваться данные любого типа данных. Visual Basic требует, чтобы для всех `Declare` инструкций использовался конкретный тип данных.  
  
#### <a name="windows-api-constants"></a>Константы Windows API  
 Некоторые аргументы являются сочетаниями констант. Например, `MessageBox` API, показанный в этом пошаговом руководстве, принимает `Typ` целочисленный аргумент с именем, который управляет отображением окна сообщения. Можно определить числовое значение этих констант, изучив `#define` инструкции в файле WinUser. h. Числовые значения обычно отображаются в шестнадцатеричном виде, поэтому для их добавления и преобразования в десятичный формат может потребоваться калькулятор. Например, если вы хотите объединить константы для стиля `MB_ICONEXCLAMATION` с восклицательным знаком 0x00000030, а стиль `MB_YESNO` «да/нет», можно добавить числа и получить результат 0x00000034 или 52 Decimal. Хотя вы можете использовать десятичный результат непосредственно, лучше объявить эти значения как константы в приложении и объединить их с помощью `Or` оператора.  
  
##### <a name="to-declare-constants-for-windows-api-calls"></a>Объявление констант для вызовов API Windows  
  
1. Обратитесь к документации по функции Windows, которую вы вызываете. Определите имена констант, которые он использует, и имя h файла, содержащего числовые значения для этих констант.  
  
2. Используйте текстовый редактор, например Блокнот, для просмотра содержимого файла заголовка (. h) и поиска значений, связанных с используемыми константами. Например, `MessageBox` API использует константу `MB_ICONQUESTION` для отображения вопросительного знака в окне сообщения. Определение для `MB_ICONQUESTION` находится в файле WinUser. h и выглядит следующим образом:  
  
     `#define MB_ICONQUESTION             0x00000020L`  
  
3. Добавьте эквивалентные `Const` операторы в класс или модуль, чтобы сделать эти константы доступными для приложения. Например:  
  
     [!code-vb[VbVbalrInterop#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#11)]  
  
###### <a name="to-call-the-dll-procedure"></a>Вызов процедуры DLL  
  
1. Добавьте кнопку с именем `Button1` в форму запуска проекта, а затем дважды щелкните ее, чтобы просмотреть код. Появится обработчик событий для кнопки.  
  
2. Добавьте код в `Click` обработчик событий для добавленной кнопки, чтобы вызвать процедуру и предоставить соответствующие аргументы:  
  
     [!code-vb[VbVbalrInterop#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#12)]  
  
3. Запустите проект, нажав клавишу F5. Появится окно сообщения с кнопками **Да** и **нет** . Щелкните один из них.  
  
#### <a name="data-marshaling"></a>Маршалирование данных  
 Visual Basic автоматически преобразует типы данных параметров и возвращаемые значения для вызовов API Windows, но можно использовать `MarshalAs` атрибут, чтобы явно указать неуправляемые типы данных, которые ожидает API. Дополнительные сведения о маршалинге взаимодействия см. в разделе [Маршалинг взаимодействия](../../../framework/interop/interop-marshaling.md).  
  
##### <a name="to-use-declare-and-marshalas-in-an-api-call"></a>Использование Declare и MarshalAs в вызове API  
  
1. Определите имя функции, которую необходимо вызвать, а также ее аргументы, типы данных и возвращаемое значение.  
  
2. Чтобы упростить доступ `MarshalAs` к атрибуту, `Imports` добавьте оператор в начало кода для класса или модуля, как показано в следующем примере:  
  
     [!code-vb[VbVbalrInterop#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#13)]  
  
3. Добавьте прототип функции для импортированной функции в класс или модуль, который вы используете, и примените `MarshalAs` атрибут к параметрам или возвращаемому значению. В следующем примере вызов API, который принимает тип `void*` , маршалируется как: `AsAny`  
  
     [!code-vb[VbVbalrInterop#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#14)]  
  
## <a name="api-calls-using-dllimport"></a>Вызовы API с помощью DllImport  
 `DllImport` Атрибут предоставляет второй способ вызова функций в библиотеках DLL без библиотек типов. `DllImport`примерно эквивалентно использованию `Declare` оператора, но обеспечивает более полный контроль над вызовом функций.  
  
 С большинством `DllImport` вызовов API Windows можно использовать, если вызов ссылается на общий (иногда называемый статическим) метод. Нельзя использовать методы, для которых требуется экземпляр класса. В `DllImport` `Declare` отличиеотинструкцийвызовыне`MarshalAs` могут использовать атрибут.  
  
### <a name="to-call-a-windows-api-using-the-dllimport-attribute"></a>Вызов API Windows с помощью атрибута DllImport  
  
1. Откройте новый проект приложения Windows, щелкнув **создать** в меню **файл** , а затем выбрав пункт **проект**. Откроется диалоговое окно **Новый проект** .  
  
2. Выберите **приложение Windows** в списке шаблонов проектов Visual Basic. Отобразится новый проект.  
  
3. Добавьте кнопку с именем `Button2` в форму запуска.  
  
4. Дважды щелкните `Button2` , чтобы открыть представление кода для формы.  
  
5. Чтобы упростить доступ `DllImport`к, `Imports` добавьте оператор в начало кода для класса формы Startup:  
  
     [!code-vb[VbVbalrInterop#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#13)]  
  
6. Объявите пустую функцию перед `End Class` оператором для формы и назовите функцию `MoveFile`.  
  
7. Примените модификаторы `Shared` `MoveFile` и к объявлению функции и задайте параметры в зависимости от аргументов, используемых функцией Windows API: `Public`  
  
     [!code-vb[VbVbalrInterop#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#16)]  
  
     Функция может иметь любое допустимое имя процедуры; `DllImport` атрибут указывает имя в библиотеке DLL. Он также обрабатывает упаковку взаимодействия для параметров и возвращаемых значений, поэтому можно выбирать типы данных Visual Studio, аналогичные типам данных, используемым API.  
  
8. Примените `DllImport` атрибут к пустой функции. Первый параметр — это имя и расположение библиотеки DLL, содержащей вызываемую функцию. Указывать путь к файлам, расположенным в системных каталогах Windows, не требуется. Второй параметр — это именованный аргумент, указывающий имя функции в API Windows. В этом примере `DllImport` атрибут принудительно перенаправляет `MoveFile` `MoveFileW` вызовы в в kernel32. Компоновки. Метод копирует файл из пути `src` в путь `dst`. `MoveFileW`  
  
     [!code-vb[VbVbalrInterop#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#17)]  
  
9. Добавьте код в `Button2_Click` обработчик событий для вызова функции:  
  
     [!code-vb[VbVbalrInterop#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#18)]  
  
10. Создайте файл с именем Test. txt и поместите его в каталог К:\тмп на жестком диске. При необходимости создайте каталог tmp.  
  
11. Нажмите клавишу F5 для запуска приложения. Откроется Главная форма.  
  
12. Нажмите кнопку **Button2**. Если файл можно переместить, отображается сообщение "файл перемещен успешно".  
  
## <a name="see-also"></a>См. также

- <xref:System.Runtime.InteropServices.DllImportAttribute>
- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [Оператор Declare](../../../visual-basic/language-reference/statements/declare-statement.md)
- [Auto](../../../visual-basic/language-reference/modifiers/auto.md)
- [Alias](../../../visual-basic/language-reference/statements/alias-clause.md)
- [COM-взаимодействие](../../../visual-basic/programming-guide/com-interop/index.md)
- [Создание прототипов в управляемом коде](../../../framework/interop/creating-prototypes-in-managed-code.md)
- [Маршалинг делегата как метода обратного вызова](../../../framework/interop/marshaling-a-delegate-as-a-callback-method.md)
