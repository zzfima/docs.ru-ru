---
title: Пошаговое руководство. Вызов API Windows
ms.date: 07/20/2015
helpviewer_keywords:
- DLLs, calling
- Windows API, walkthroughs
- platform invoke, walkthroughs
- API calls [Visual Basic], walkthroughs [Visual Basic]
- Windows API, calling
- walkthroughs [Visual Basic], API calls
- DllImport attribute, calling Windows API
- Declare statement [Visual Basic], declaring DLL functions
ms.assetid: 9280ca96-7a93-47a3-8d01-6d01be0657cb
ms.openlocfilehash: ec6b8ddc8769fadde52aaebd6ad3701183fac77a
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74338670"
---
# <a name="walkthrough-calling-windows-apis-visual-basic"></a>Пошаговое руководство. Вызов API Windows (Visual Basic)
Windows API — это библиотеки динамической компоновки (DLL), которые являются частью операционной системы Windows. Они используются для выполнения задач, когда трудно писать эквивалентные процедуры. Например, в Windows имеется функция с именем `FlashWindowEx`, которая позволяет сделать строку заголовка для приложения альтернативой между светлым и темным затенением.  
  
 Преимущество использования API-интерфейсов Windows в коде состоит в том, что они могут сэкономить время разработки, поскольку они содержат десятки полезных функций, которые уже написаны и ожидают использования. Недостаток заключается в том, что API Windows может быть трудно работать с и унфоргивинг в случае неправильной работы.  
  
 Интерфейсы API Windows представляют особую категорию взаимодействия. Интерфейсы API Windows не используют управляемый код, не имеют встроенных библиотек типов и используют типы данных, отличные от используемых в Visual Studio. Из-за этих различий и, поскольку интерфейсы API Windows не являются объектами COM, взаимодействия с API Windows и .NET Framework выполняются с помощью вызова неуправляемого кода или PInvoke. Платформенный вызов — это служба, которая позволяет управляемому коду вызывать неуправляемые функции, реализованные в библиотеках DLL. Дополнительные сведения см. в разделе [Использование неуправляемых функций DLL](../../../framework/interop/consuming-unmanaged-dll-functions.md). Можно использовать PInvoke в Visual Basic с помощью инструкции `Declare` или применения атрибута `DllImport` к пустой процедуре.  
  
 Вызовы Windows API были важной частью Visual Basic программирования в прошлом, но они редко требуются для Visual Basic .NET. Везде, где это возможно, следует использовать управляемый код из .NET Framework для выполнения задач, а не вызовов Windows API. В этом пошаговом руководстве содержатся сведения о ситуациях, в которых требуется использовать API Windows.  
  
[!INCLUDE[note_settings_general](~/includes/note-settings-general-md.md)]  
  
## <a name="api-calls-using-declare"></a>Вызовы API с помощью Declare  
 Наиболее распространенным способом вызова API Windows является использование оператора `Declare`.  
  
### <a name="to-declare-a-dll-procedure"></a>Объявление процедуры DLL  
  
1. Определите имя функции, которую необходимо вызвать, а также ее аргументы, типы аргументов и возвращаемое значение, а также имя и расположение библиотеки DLL, содержащей ее.  
  
    > [!NOTE]
    > Полные сведения о API Windows см. в документации по пакету SDK для Win32 в Windows API Platform SDK. Дополнительные сведения о константах, используемых API Windows, см. в файлах заголовков, таких как Windows. h, входящих в состав пакета Platform SDK.  
  
2. Откройте новый проект приложения Windows, щелкнув **создать** в меню **файл** , а затем выбрав пункт **проект**. Откроется диалоговое окно **Новый проект** .  
  
3. Выберите **приложение Windows** в списке шаблонов проектов Visual Basic. Отобразится новый проект.  
  
4. Добавьте следующую `Declare` функцию либо в класс, либо в модуль, в котором требуется использовать библиотеку DLL:  
  
     [!code-vb[VbVbalrInterop#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#9)]  
  
### <a name="parts-of-the-declare-statement"></a>Части инструкции DECLARE  
 Оператор `Declare` содержит следующие элементы.  
  
#### <a name="auto-modifier"></a>Модификатор Auto  
 Модификатор `Auto` указывает среде выполнения преобразовать строку на основе имени метода в соответствии с правилами общеязыковой среды выполнения (или именем псевдонима, если оно указано).  
  
#### <a name="lib-and-alias-keywords"></a>Ключевые слова lib и Alias  
 Имя, следующее за ключевым словом `Function`, — это имя, которое программа использует для доступа к импортируемой функции. Оно может совпадать с реальным именем вызываемой функции, или можно использовать любое допустимое имя процедуры, а затем применить ключевое слово `Alias`, чтобы указать реальное имя вызываемой функции.  
  
 Укажите ключевое слово `Lib`, а затем имя и расположение библиотеки DLL, содержащей вызываемую функцию. Указывать путь к файлам, расположенным в системных каталогах Windows, не требуется.  
  
 Используйте ключевое слово `Alias`, если имя вызываемой функции не является допустимым Visual Basic именем процедуры или конфликтует с именами других элементов в приложении. `Alias` указывает на истинное имя вызываемой функции.  
  
#### <a name="argument-and-data-type-declarations"></a>Объявления аргументов и типов данных  
 Объявите аргументы и их типы данных. Эта часть может быть сложной, поскольку типы данных, используемые Windows, не соответствуют типам данных Visual Studio. Visual Basic выполняет большой объем работы, преобразуя аргументы в совместимые типы данных, процесс, называемый *упаковкой*. Можно явно управлять упаковкой аргументов с помощью атрибута <xref:System.Runtime.InteropServices.MarshalAsAttribute>, определенного в пространстве имен <xref:System.Runtime.InteropServices>.  
  
> [!NOTE]
> Предыдущие версии Visual Basic позволяли объявлять параметры `As Any`, то есть могут использоваться данные любого типа данных. Visual Basic требует, чтобы для всех инструкций `Declare` использовался конкретный тип данных.  
  
#### <a name="windows-api-constants"></a>Константы Windows API  
 Некоторые аргументы являются сочетаниями констант. Например, `MessageBox` API, показанный в этом пошаговом руководстве, принимает целочисленный аргумент с именем `Typ`, который управляет отображением окна сообщения. Можно определить числовое значение этих констант, изучив инструкции `#define` в файле WinUser. h. Числовые значения обычно отображаются в шестнадцатеричном виде, поэтому для их добавления и преобразования в десятичный формат может потребоваться калькулятор. Например, если вы хотите объединить константы для стиля с восклицательным знаком `MB_ICONEXCLAMATION` 0x00000030, а стиль «да/нет» `MB_YESNO` 0x00000004, можно добавить числа и получить результат 0x00000034 или 52 Decimal. Хотя вы можете использовать десятичный результат непосредственно, лучше объявить эти значения как константы в приложении и объединить их с помощью оператора `Or`.  
  
##### <a name="to-declare-constants-for-windows-api-calls"></a>Объявление констант для вызовов API Windows  
  
1. Обратитесь к документации по функции Windows, которую вы вызываете. Определите имена констант, которые он использует, и имя h файла, содержащего числовые значения для этих констант.  
  
2. Используйте текстовый редактор, например Блокнот, для просмотра содержимого файла заголовка (. h) и поиска значений, связанных с используемыми константами. Например, `MessageBox` API использует константу `MB_ICONQUESTION` для отображения вопросительного знака в окне сообщения. Определение для `MB_ICONQUESTION` находится в файле WinUser. h и выглядит следующим образом:  
  
     `#define MB_ICONQUESTION             0x00000020L`  
  
3. Добавьте в класс или модуль эквивалентные `Const` операторы, чтобы сделать эти константы доступными для приложения. Пример.  
  
     [!code-vb[VbVbalrInterop#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#11)]  
  
###### <a name="to-call-the-dll-procedure"></a>Вызов процедуры DLL  
  
1. Добавьте кнопку с именем `Button1` в форму запуска проекта, а затем дважды щелкните ее, чтобы просмотреть код. Появится обработчик событий для кнопки.  
  
2. Добавьте код в обработчик событий `Click` для добавленной кнопки, чтобы вызвать процедуру и предоставить соответствующие аргументы:  
  
     [!code-vb[VbVbalrInterop#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#12)]  
  
3. Запустите проект, нажав клавишу F5. Появится окно сообщения с кнопками **Да** и **нет** . Щелкните один из них.  
  
#### <a name="data-marshaling"></a>Маршалирование данных  
 Visual Basic автоматически преобразует типы данных параметров и возвращаемые значения для вызовов API Windows, но атрибут `MarshalAs` можно использовать для явного указания неуправляемых типов данных, которые ожидает API. Дополнительные сведения о маршалинге взаимодействия см. в разделе [Маршалинг взаимодействия](../../../framework/interop/interop-marshaling.md).  
  
##### <a name="to-use-declare-and-marshalas-in-an-api-call"></a>Использование Declare и MarshalAs в вызове API  
  
1. Определите имя функции, которую необходимо вызвать, а также ее аргументы, типы данных и возвращаемое значение.  
  
2. Чтобы упростить доступ к атрибуту `MarshalAs`, добавьте оператор `Imports` в начало кода для класса или модуля, как показано в следующем примере:  
  
     [!code-vb[VbVbalrInterop#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#13)]  
  
3. Добавьте прототип функции для импортированной функции в класс или модуль, который вы используете, и примените атрибут `MarshalAs` к параметрам или возвращаемому значению. В следующем примере вызов API, который принимает тип `void*`, маршалируется как `AsAny`:  
  
     [!code-vb[VbVbalrInterop#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#14)]  
  
## <a name="api-calls-using-dllimport"></a>Вызовы API с помощью DllImport  
 Атрибут `DllImport` предоставляет второй способ вызова функций в библиотеках DLL без библиотек типов. `DllImport` примерно эквивалентен использованию оператора `Declare`, но предоставляет больший контроль над тем, как вызываются функции.  
  
 Можно использовать `DllImport` с большинством вызовов API Windows, если вызов ссылается на общий (иногда называемый *статическим*) метод. Нельзя использовать методы, для которых требуется экземпляр класса. В отличие от инструкций `Declare`, `DllImport` вызовы не могут использовать атрибут `MarshalAs`.  
  
### <a name="to-call-a-windows-api-using-the-dllimport-attribute"></a>Вызов API Windows с помощью атрибута DllImport  
  
1. Откройте новый проект приложения Windows, щелкнув **создать** в меню **файл** , а затем выбрав пункт **проект**. Откроется диалоговое окно **Новый проект** .  
  
2. Выберите **приложение Windows** в списке шаблонов проектов Visual Basic. Отобразится новый проект.  
  
3. Добавьте кнопку с именем `Button2` в начальную форму.  
  
4. Дважды щелкните `Button2`, чтобы открыть представление кода для формы.  
  
5. Чтобы упростить доступ к `DllImport`, добавьте оператор `Imports` в начало кода для класса формы запуска:  
  
     [!code-vb[VbVbalrInterop#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#13)]  
  
6. Объявите пустую функцию перед оператором `End Class` для формы и назовите функцию `MoveFile`.  
  
7. Примените модификаторы `Public` и `Shared` к объявлению функции и задайте параметры для `MoveFile` на основе аргументов, используемых функцией Windows API:  
  
     [!code-vb[VbVbalrInterop#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#16)]  
  
     Функция может иметь любое допустимое имя процедуры; атрибут `DllImport` указывает имя в библиотеке DLL. Он также обрабатывает упаковку взаимодействия для параметров и возвращаемых значений, поэтому можно выбирать типы данных Visual Studio, аналогичные типам данных, используемым API.  
  
8. Примените атрибут `DllImport` к пустой функции. Первый параметр — это имя и расположение библиотеки DLL, содержащей вызываемую функцию. Указывать путь к файлам, расположенным в системных каталогах Windows, не требуется. Второй параметр — это именованный аргумент, указывающий имя функции в API Windows. В этом примере атрибут `DllImport` принудительно перенаправляет вызовы `MoveFile` в `MoveFileW` в KERNEL32. Компоновки. Метод `MoveFileW` копирует файл из пути `src` в путь `dst`.  
  
     [!code-vb[VbVbalrInterop#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#17)]  
  
9. Добавьте код в обработчик событий `Button2_Click` для вызова функции:  
  
     [!code-vb[VbVbalrInterop#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#18)]  
  
10. Создайте файл с именем Test. txt и поместите его в каталог К:\тмп на жестком диске. При необходимости создайте каталог tmp.  
  
11. Нажмите клавишу F5 для запуска приложения. Откроется Главная форма.  
  
12. Нажмите кнопку **Button2**. Если файл можно переместить, отображается сообщение "файл перемещен успешно".  
  
## <a name="see-also"></a>См. также

- <xref:System.Runtime.InteropServices.DllImportAttribute>
- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [Оператор Declare](../../../visual-basic/language-reference/statements/declare-statement.md)
- [Auto](../../../visual-basic/language-reference/modifiers/auto.md)
- [Alias](../../../visual-basic/language-reference/statements/alias-clause.md)
- [COM-взаимодействие](../../../visual-basic/programming-guide/com-interop/index.md)
- [Создание прототипов в управляемом коде](../../../framework/interop/creating-prototypes-in-managed-code.md)
- [Маршалинг делегата как метода обратного вызова](../../../framework/interop/marshaling-a-delegate-as-a-callback-method.md)
