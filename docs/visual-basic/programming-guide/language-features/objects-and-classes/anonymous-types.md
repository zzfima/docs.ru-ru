---
title: Анонимные типы
ms.date: 07/20/2015
f1_keywords:
- vb.AnonymousType
helpviewer_keywords:
- anonymous types [Visual Basic], about anonymous types
- anonymous types [Visual Basic]
- types [Visual Basic], anonymous
ms.assetid: 7b87532c-4b3e-4398-8503-6ea9d67574a4
ms.openlocfilehash: 064c43274069be3951f816eaafafac0bbece7651
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74347163"
---
# <a name="anonymous-types-visual-basic"></a>Анонимные типы (Visual Basic)
Visual Basic поддерживает анонимные типы, которые позволяют создавать объекты без написания определения класса для типа данных. Вместо этого компилятор создает класс для вас. Класс не имеет пригодного для использования имени, наследуется непосредственно от <xref:System.Object>и содержит свойства, указанные при объявлении объекта. Так как имя типа данных не указано, оно называется *анонимным типом*.  
  
 В следующем примере объявляется и создается переменная `product` как экземпляр анонимного типа, который имеет два свойства: `Name` и `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#1)]  
  
 *Выражение запроса* использует анонимные типы для объединения столбцов данных, выбранных запросом. Невозможно определить тип результата заранее, так как нельзя предсказать столбцы, которые может выбрать конкретный запрос. Анонимные типы позволяют написать запрос, выбирающий любое количество столбцов в любом порядке. Компилятор создает тип данных, соответствующий указанным свойствам, и заданный порядок.  
  
 В следующих примерах `products` — это список объектов Product, каждый из которых имеет много свойств. Переменная `namePriceQuery` содержит определение запроса, при выполнении которого возвращается коллекция экземпляров анонимного типа с двумя свойствами: `Name` и `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#2)]  
  
 Переменная `nameQuantityQuery` содержит определение запроса, при выполнении которого возвращается коллекция экземпляров анонимного типа с двумя свойствами: `Name` и `OnHand`.  
  
 [!code-vb[VbVbalrAnonymousTypes#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#3)]  
  
 Дополнительные сведения о коде, созданном компилятором для анонимного типа, см. в разделе [Определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md).  
  
> [!CAUTION]
> Имя анонимного типа создается компилятором и может отличаться от компиляции к компиляции. Код не должен использовать имя анонимного типа или полагаться на него, так как имя может измениться при повторной компиляции проекта.  
  
## <a name="declaring-an-anonymous-type"></a>Объявление анонимного типа  
 Объявление экземпляра анонимного типа использует список инициализаторов для указания свойств типа. При объявлении анонимного типа можно указать только свойства, а не другие элементы класса, такие как методы или события. В следующем примере `product1` является экземпляром анонимного типа, который имеет два свойства: `Name` и `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#4)]  
  
 Если вы назначаете свойства ключевыми свойствами, их можно использовать для сравнения двух экземпляров анонимного типа на равенство. Однако значения ключевых свойств нельзя изменить. Дополнительные сведения см. в разделе Ключевые свойства далее в этом разделе.  
  
 Обратите внимание, что объявление экземпляра анонимного типа аналогично объявлению экземпляра именованного типа с помощью инициализатора объекта:  
  
 [!code-vb[VbVbalrAnonymousTypes#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#5)]  
  
 Дополнительные сведения о других способах указания свойств анонимного типа см. [в разделе как вывести имена и типы свойств в объявлениях анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md).  
  
## <a name="key-properties"></a>Ключевые свойства  
 Ключевые свойства отличаются от неключевых свойств несколькими фундаментальными способами:  
  
- Для определения того, равны ли два экземпляра, сравниваются только значения ключевых свойств.  
  
- Значения ключевых свойств доступны только для чтения и не могут быть изменены.  
  
- В созданный компилятором алгоритм хэш-кода для анонимного типа включаются только значения ключевых свойств.  
  
### <a name="equality"></a>Равенство  
 Экземпляры анонимных типов могут быть равны, только если они являются экземплярами одного и того же анонимного типа. Компилятор обрабатывает два экземпляра как экземпляры одного типа, если они отвечают следующим условиям:  
  
- Они объявляются в одной сборке.  
  
- Их свойства имеют одинаковые имена, одни и те же выводимые типы и объявляются в том же порядке. При сравнении имен регистр не учитывается.  
  
- Те же свойства в каждой из них помечаются как ключевые свойства.  
  
- По крайней мере одно свойство в каждом объявлении является ключевым свойством.  
  
 Экземпляр анонимных типов, у которых нет ключевых свойств, равен только самому себе.  
  
 [!code-vb[VbVbalrAnonymousTypes#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#6)]  
  
 Два экземпляра одного и того же анонимного типа равны, если значения их ключевых свойств равны. В следующих примерах показано, как проверяется равенство.  
  
 [!code-vb[VbVbalrAnonymousTypes#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#7)]  
  
### <a name="read-only-values"></a>Значения только для чтения  
 Значения ключевых свойств нельзя изменить. Например, в `prod8` в предыдущем примере поля `Name` и `Price` `read-only`, но `OnHand` можно изменить.  
  
 [!code-vb[VbVbalrAnonymousTypes#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#8)]  
  
## <a name="anonymous-types-from-query-expressions"></a>Анонимные типы из выражений запросов  
 Выражениям запросов не всегда требуется создавать анонимные типы. По возможности они используют существующий тип для хранения данных столбца. Это происходит, когда запрос возвращает либо целые записи из источника данных, либо только одно поле из каждой записи. В следующих примерах кода `customers` представляет собой коллекцию объектов класса `Customer`. Класс имеет много свойств, и вы можете включить один или несколько из них в результат запроса в любом порядке. В первых двух примерах анонимные типы не требуются, поскольку запросы выбирают элементы именованных типов:  
  
- `custs1` содержит коллекцию строк, поскольку `cust.Name` является строкой.  
  
     [!code-vb[VbVbalrAnonymousTypes#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class2.vb#30)]  
  
- `custs2` содержит коллекцию объектов `Customer`, так как каждый элемент `customers` является объектом `Customer`, а весь элемент выбирается запросом.  
  
     [!code-vb[VbVbalrAnonymousTypes#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class2.vb#31)]  
  
 Однако соответствующие именованные типы доступны не всегда. Вам может потребоваться выбрать имена клиентов и адреса для одной цели, ИДЕНТИФИКАТОРы клиентов и местоположения для другого, а также имена клиентов, адреса и журналы заказов для третьего. Анонимные типы позволяют выбирать любое сочетание свойств в любом порядке без предварительного объявления нового именованного типа для хранения результата. Вместо этого компилятор создает анонимный тип для каждой компиляции свойств. Следующий запрос выбирает только имя клиента и ИДЕНТИФИКАЦИОНный номер из каждого `Customer`ного объекта в `customers`. Поэтому компилятор создает анонимный тип, который содержит только эти два свойства.  
  
 [!code-vb[VbVbalrAnonymousTYpes#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class2.vb#32)]  
  
 Имена и типы данных свойств в анонимном типе берутся из аргументов в `Select`, `cust.Name` и `cust.ID`. Свойства в анонимном типе, создаваемом запросом, всегда являются ключевыми свойствами. Когда `custs3` выполняется в следующем цикле `For Each`, результатом является коллекция экземпляров анонимного типа с двумя ключевыми свойствами: `Name` и `ID`.  
  
 [!code-vb[VbVbalrAnonymousTypes#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class2.vb#33)]  
  
 Элементы в коллекции, представленные `custs3`, строго типизированы, и можно использовать IntelliSense для навигации по доступным свойствам и для проверки их типов.  
  
 Дополнительные сведения см. [в разделе Введение в LINQ в Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md).  
  
## <a name="deciding-whether-to-use-anonymous-types"></a>Принятие решения о необходимости использования анонимных типов  
 Перед созданием объекта в качестве экземпляра анонимного класса следует подумать, является ли это лучшим вариантом. Например, если требуется создать временный объект, содержащий связанные данные, и нет необходимости в других полях и методах, которые могут содержаться в полном классе, анонимный тип является хорошим решением. Анонимные типы также удобно использовать, если требуется выбрать другие свойства для каждого объявления или изменить порядок свойств. Однако если проект содержит несколько объектов с одинаковыми свойствами, то их можно объявить в фиксированном порядке, используя именованный тип с конструктором класса. Например, с помощью соответствующего конструктора проще объявить несколько экземпляров класса `Product`, чем объявить несколько экземпляров анонимного типа.  
  
 [!code-vb[VbVbalrAnonymousTypes#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#9)]  
  
 Другое преимущество именованных типов заключается в том, что компилятор может перехватить случайную невозможность ввода имени свойства. В предыдущих примерах `firstProd2`, `secondProd2`и `thirdProd2` должны быть экземплярами одного и того же анонимного типа. Однако если вы случайно объявили `thirdProd2` одним из следующих способов, его тип будет отличаться от `firstProd2` и `secondProd2`.  
  
 [!code-vb[VbVbalrAnonymousTypes#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrAnonymousTypes/VB/Class1.vb#10)]  
  
 Что более важно, существуют ограничения на использование анонимных типов, которые не применяются к экземплярам именованных типов. `firstProd2`, `secondProd2`и `thirdProd2` являются экземплярами одного и того же анонимного типа. Однако имя общего анонимного типа недоступно и не может использоваться, если в коде ожидается имя типа. Например, анонимный тип нельзя использовать для определения сигнатуры метода, для объявления другой переменной или поля или в любом объявлении типа. В результате анонимные типы не подходят, если необходимо обмениваться информацией между методами.  
  
## <a name="an-anonymous-type-definition"></a>Определение анонимного типа  
 В ответ на объявление экземпляра анонимного типа компилятор создает новое определение класса, которое содержит указанные свойства.  
  
 Если анонимный тип содержит по крайней мере одно ключевое свойство, определение переопределяет три члена, унаследованные от <xref:System.Object>: <xref:System.Object.Equals%2A>, <xref:System.Object.GetHashCode%2A>и <xref:System.Object.ToString%2A>. Код, созданный для проверки равенства и определения значения хэш-кода, рассматривает только ключевые свойства. Если анонимный тип не содержит свойств ключа, переопределяется только <xref:System.Object.ToString%2A>. Явно именованные свойства анонимного типа не могут конфликтовать с этими созданными методами. То есть нельзя использовать `.Equals`, `.GetHashCode`или `.ToString` для именования свойства.  
  
 Определения анонимных типов, имеющие по крайней мере одно ключевое свойство, также реализуют интерфейс <xref:System.IEquatable%601?displayProperty=nameWithType>, где `T` является типом анонимного типа.  
  
 Дополнительные сведения о коде, созданном компилятором, и функциональных возможностях переопределенных методов см. в разделе [Определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md).  
  
## <a name="see-also"></a>См. также

- [Инициализаторы объектов. Именованные и анонимные типы](../../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)
- [Вывод локального типа](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)
- [Introduction to LINQ in Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md) (Знакомство с LINQ в Visual Basic)
- [Практическое руководство. Выведение имен свойств и типов в объявлениях анонимных типов](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)
- [Определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md)
- [Key](../../../../visual-basic/language-reference/modifiers/key.md)
