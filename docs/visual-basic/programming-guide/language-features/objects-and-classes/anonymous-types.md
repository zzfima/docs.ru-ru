---
title: "Анонимные типы (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "2015-07-20"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.topic: "article"
f1_keywords: 
  - "vb.AnonymousType"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "анонимные типы [Visual Basic]"
  - "анонимные типы [Visual Basic], сведения об анонимных типах"
  - "типы [Visual Basic], анонимные"
ms.assetid: 7b87532c-4b3e-4398-8503-6ea9d67574a4
caps.latest.revision: 46
author: "stevehoag"
ms.author: "shoag"
caps.handback.revision: 46
---
# Анонимные типы (Visual Basic)
[!INCLUDE[vs2017banner](../../../../visual-basic/includes/vs2017banner.md)]

Visual Basic поддерживает анонимные типы, позволяющие создавать объекты без написания определения класса для типа данных.  Вместо этого компилятор создает класс для вас.  Класс не имеет подходящего имени, непосредственно наследует от <xref:System.Object> и содержит свойства, которые вы объявили в объекте.  Так как имя типа данных не задано, он называется *anonymous type*.  
  
 В следующем примере приведено объявление и создание переменной `product` как экземпляра анонимного типа, имеющего два свойства: `Name` и `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#1](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_1.vb)]  
  
 *Выражение запроса \(query expression\)* использует анонимные типы для объединения столбцов данных, выбранных по запросу.  Нельзя определить тип результата заранее, так как невозможно предсказать, какие именно столбцы может выбрать определенный запрос.  Анонимные типы позволяют написать запрос, выбирающий любое количество столбцов, в любом порядке.  Компилятор создает тип данных, который соответствует указанным свойствам и указанному порядку.  
  
 В следующих примерах `products` — это список объектов продукта, каждый из которых имеет множество свойств.  Переменная `namePriceQuery` содержит определение запроса, который, при ее выполнении, возвращает коллекцию экземпляров анонимного типа, имеющих два свойства `Name` и `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#2](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_2.vb)]  
  
 Переменная `nameQuantityQuery` содержит определение запроса, который, при ее выполнении, возвращает коллекцию экземпляров анонимного типа, имеющих два свойства `Name` и `OnHand`.  
  
 [!code-vb[VbVbalrAnonymousTypes#3](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_3.vb)]  
  
 Дополнительные сведения о коде, созданном компилятором для анонимного типа, см. в разделе [Определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md).  
  
> [!CAUTION]
>  Имя анонимного типа создается компилятором и имеет значение, которое может отличаться от сгенерированного при предыдущей компиляции.  Код не должен использовать или зависеть от имени анонимного типа, так как имя может измениться при повторной компиляции проекта.  
  
## Объявление анонимного типа  
 Объявление экземпляра анонимного типа использует список\-инициализатор для указания свойств типа.  При объявлении анонимного типа можно указывать только свойства, но не другие элементы класса, такие как методы или события.  В следующем примере `product1` представляет собой экземпляр анонимного типа, который имеет два свойства: `Name` and `Price`.  
  
 [!code-vb[VbVbalrAnonymousTypes#4](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_4.vb)]  
  
 Если назначить свойства как ключевые, можно использовать их для сравнения двух экземпляров анонимного типа на признак равенства.  Однако значения ключевых свойств изменить нельзя.  Дополнительные сведения см. в приведенной ниже теме Ключевые свойства.  
  
 Обратите внимание, что объявление экземпляра анонимного типа такое же, как объявление экземпляра именованного типа с помощью инициализатора объекта:  
  
 [!code-vb[VbVbalrAnonymousTypes#5](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_5.vb)]  
  
 Дополнительные сведения о других способах указания свойств анонимного типа содержатся в разделе [Практическое руководство. Выведение имен свойств и типов в объявлениях анонимных типов](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md).  
  
## Ключевые свойства  
 Основные отличительные особенности ключевых свойств от неключевых:  
  
-   Чтобы определить, равны ли два экземпляра, сравниваются только значения ключевых свойств.  
  
-   Значения ключевых свойств доступны только для чтения и не могут быть изменены.  
  
-   В созданный компилятором хэш\-код алгоритма включаются только значения ключевых свойств для анонимного типа.  
  
### Равенство  
 Экземпляры анонимных типов могут быть равны только если они являются экземплярами одинакового анонимного типа.  Компилятор обрабатывает два экземпляра как экземпляры одинакового типа, если они отвечают следующим условиям:  
  
-   Они были объявлены в одной и той же сборке.  
  
-   Их свойства имеют те же имена, те же возвращаемые типы и объявляются в том же порядке.  Сравнение имен не учитывает регистр.  
  
-   Одни и те же свойства помечены как ключевые свойства.  
  
-   По крайней мере одно свойство в каждом из объявлений является ключевым свойством.  
  
 Экземпляр анонимного типа, который не имеет ключевого свойства, является равным только самому себе.  
  
 [!code-vb[VbVbalrAnonymousTypes#6](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_6.vb)]  
  
 Два экземпляра одинаковых анонимных типов равны, если значения их ключевых свойств равны.  Следующие примеры иллюстрируют способ проверки равенства.  
  
 [!code-vb[VbVbalrAnonymousTypes#7](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_7.vb)]  
  
### Значения, доступные только для чтения  
 Значения ключевых свойств не могут быть изменены.  Например, в предыдущем примере `prod8` поля `Name` и `Price` являются `read-only`, но `OnHand` может изменяться.  
  
 [!code-vb[VbVbalrAnonymousTypes#8](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_8.vb)]  
  
## Анонимные типы из выражений запросов  
 Выражения запросов не всегда требуют создания анонимных типов.  Когда это возможно, они используют существующий тип для хранения данных столбца.  Это происходит, когда запрос возвращает либо все записи из источника данных, или только одно поле из каждой записи.  В следующих примерах кода `customers` представляет коллекцию объектов класса `Customer`.  Класс имеет множество свойств, и вы можете включать одно или несколько из них в результат запроса, в любом порядке.  В первых двух примерах анонимные типы не требуются, так как запросы выбирают элементы из именованных типов:  
  
-   `custs1` содержит коллекцию строк, поскольку `cust.Name` является строковым.  
  
     [!code-vb[VbVbalrAnonymousTypes#30](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_9.vb)]  
  
-   `custs2` содержит коллекцию объектов `Customer`, поскольку каждый элемент из `customers` это объект `Customer`, и весь элемент установлен по запросу.  
  
     [!code-vb[VbVbalrAnonymousTypes#31](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_10.vb)]  
  
 Однако, соответствующие именованные типы доступны не всегда.  Возможно вам понадобится выбрать имена и адреса клиентов для одного назначения, идентификаторы клиентов и их расположения для другого, и имена, адреса и журнал заказов клиентов для третьего.  Анонимные типы позволяют выбрать любое сочетание свойств, в любом порядке, без предшествующего объявления нового именованного типа для хранения результатов.  Вместо этого компилятор создает анонимный тип для каждой группы свойств.  Приведенный ниже запрос выбирает только имя клиента и его идентификационный номер из каждого объекта `Customer` в `customers`.  Таким образом, компилятор создает анонимный тип, который содержит только эти два свойства.  
  
 [!code-vb[VbVbalrAnonymousTYpes#32](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_11.vb)]  
  
 Имена и типы данных свойств берутся в анонимный тип из аргументов в `Select`, `cust.Name` и `cust.ID`.  Свойства в анонимном типе, который создается при запросе всегда являются ключевыми свойствами.  При выполнении `custs3` в следующем цикле `For Each` результатом является коллекция экземпляров анонимного типа с двумя ключевыми свойствами `Name` и `ID`.  
  
 [!code-vb[VbVbalrAnonymousTypes#33](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_12.vb)]  
  
 Элементы в коллекции, представленные `custs3` являются строго типизированными, и вы можете использовать IntelliSense для перемещения по доступным свойствам и для проверки их типов.  
  
 Дополнительные сведения см. в разделе [Знакомство с LINQ в Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md).  
  
## Область применения анонимных типов  
 Прежде чем создавать объект как экземпляр анонимного класса, нужно проверить является ли это наилучшим вариантом.  Например, если необходимо создать временный объект для хранения связанных данных, и нет необходимости в других полях и методах, которые обычно содержат полный класс, анонимный тип является хорошим решением.  Анонимные типы также являются удобными, если требуется различный выбор свойств для каждого объявления, или если вы хотите изменить порядок свойств.  Однако, если проект содержит несколько объектов, которые имеют одинаковые свойства, в фиксированном порядке, легче объявить их с помощью именованного типа и конструктора класса.  Например, с соответствующим конструктором, проще объявить несколько экземпляров класса `Product`, чем объявлять несколько экземпляров анонимного типа.  
  
 [!code-vb[VbVbalrAnonymousTypes#9](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_13.vb)]  
  
 Другим преимуществом именованных типов является то, что компилятор может перехватить случайную опечатку в имени свойства.  В предыдущих примерах подразумевается, что `firstProd2`, `secondProd2` и `thirdProd2` должны быть экземплярами одинакового анонимного типа.  Однако, если случайно объявить `thirdProd2` одним из других способов, его тип будет отличаться от `firstProd2` и `secondProd2`.  
  
 [!code-vb[VbVbalrAnonymousTypes#10](../../../../visual-basic/language-reference/modifiers/codesnippet/visualbasic/anonymous-types_14.vb)]  
  
 Более важно, что существуют ограничения на использование анонимных типов, которые не применяются к экземплярам именованных типов.  `firstProd2`, `secondProd2` и `thirdProd2` являются экземплярами одинакового анонимного типа.  Однако имя для общего анонимного типа недоступно и не может находиться в коде, там где ожидалось наличие имени типа.  Например, анонимный тип не может использоваться для определения сигнатуры метода, для объявления других переменных или полей или в любом объявлении типа.  В результате анонимные типы не допустимы при использовании методами совместных сведений.  
  
## Определение анонимного типа  
 В ответ на объявление экземпляра анонимного типа компилятор создает определение нового класса, содержащего указанные свойства.  
  
 Если анонимный тип содержит по крайней мере одно ключевое свойство, определение переопределяет три члена, унаследованные от <xref:System.Object>: <xref:System.Object.Equals%2A>, <xref:System.Object.GetHashCode%2A>, и <xref:System.Object.ToString%2A>.  Код, созданный для проверки равенства и определения значения хэш\-кода, рассматривает только ключевые свойства.  Если анонимный тип не содержит ключевых свойств, переопределяется только <xref:System.Object.ToString%2A>.  Явно именованные свойства анонимного типа не могут конфликтовать с этими созданными методами.  А именно, нельзя использовать `.Equals`, `.GetHashCode` или `.ToString` для имени свойства.  
  
 Определения анонимных типов, которые имеют по крайней мере одно ключевое свойство также реализуют интерфейс <xref:System.IEquatable%601?displayProperty=fullName>, где `T` — тип анонимного типа.  
  
 Дополнительные сведения о коде, созданном компилятором, и функциональные возможности переопределенных методов содержатся в разделе [Определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md).  
  
## См. также  
 [Инициализаторы объектов: именованные и анонимные типы](../../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)   
 [Вывод локального типа](../../../../visual-basic/programming-guide/language-features/variables/local-type-inference.md)   
 [Знакомство с LINQ в Visual Basic](../../../../visual-basic/programming-guide/language-features/linq/introduction-to-linq.md)   
 [Практическое руководство. Выведение имен свойств и типов в объявлениях анонимных типов](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)   
 [Определение анонимного типа](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-type-definition.md)   
 [Key](../../../../visual-basic/language-reference/modifiers/key.md)