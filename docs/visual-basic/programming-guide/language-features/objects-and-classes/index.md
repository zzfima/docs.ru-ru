---
title: "Объекты и классы Visual Basic | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "классы [Visual Basic]"
  - "объекты [Visual Basic]"
ms.assetid: c68c5752-1006-46e1-975a-6717b62a42fc
caps.latest.revision: 26
caps.handback.revision: 26
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
---
# Объекты и классы Visual Basic
[!INCLUDE[vs2017banner](../../../../csharp/includes/vs2017banner.md)]

*Объект* — это совокупность кода и данных, которые воспринимаются как одно целое.  Объект может являться частью приложения, как, например, элемент управления или форма.  Приложение в целом также может быть объектом.  
  
 При создании приложения в [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)], вы постоянно работаете с объектами.  Можно использовать объекты, предоставляемые [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)], такие как элементы управления, формы и объекты доступа к данным.  Можно также использовать объекты из других приложений в приложении [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)].  Можно также создавать собственные объекты и задавать для них дополнительные свойства и методы.  Объекты представляют собой готовые блоки будущих программ — они позволяют вновь и вновь использовать единожды написанный код.  
  
 В этом разделе подробно рассматриваются объекты.  
  
## Объекты и классы  
 Каждый объект в [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] определяется с помощью *класса*.  Класс описывает переменные, свойства, процедуры и события объекта.  Объекты представляют собой экземпляры классов; после того как класс определен, можно создать любое количество объектов.  
  
 Хорошим примером связи между объектом и классом является форма для печенья и само печенье.  Форма для печенья — это класс.  Он определяет характеристики каждого печенья, например размер и форму.  Класс используется для создания объектов.  В нашем примере объект — это печенье.  
  
 Необходимо создать объект перед получением доступа к его элементам.  
  
#### Для создания объекта из класса  
  
1.  Определите из какого класса вы хотите создать объект.  
  
2.  Напишите [Оператор Dim](../../../../visual-basic/language-reference/statements/dim-statement.md) для создания переменной, которой можно присвоить экземпляр класса.  Переменная должна иметь тип нужного класса.  
  
    ```  
  
    Dim nextCustomer As customer   
    ```  
  
3.  Добавьте ключевое слово [Оператор New](../../../../visual-basic/language-reference/operators/new-operator.md) для инициализации переменной, чтобы инициализировать ее новым экземпляром класса.  
  
    ```  
    Dim nextCustomer As New customer  
    ```  
  
4.  Теперь члены класса доступны с помощью объектной переменной.  
  
    ```  
  
    nextCustomer.accountNumber = lastAccountNumber + 1  
    ```  
  
> [!NOTE]
>  По возможности следует объявить переменную с типом класса, который ей планируется присвоить.  Такой подход называется *ранним связыванием*.  Если вы не знаете тип класса во время компиляции, можно вызвать *late binding* при помощи объявления переменной типа [Тип данных Object](../../../../visual-basic/language-reference/data-types/object-data-type.md).  Однако позднее связывание может уменьшить производительность и ограничить доступ к членам объекта времени выполнения.  Дополнительные сведения см. в разделе [Объявление переменных объектов](../../../../visual-basic/programming-guide/language-features/variables/object-variable-declaration.md).  
  
### Несколько экземпляров  
 Объекты, вновь созданные из класса, часто идентичны друг к другу.  Поскольку они существуют как отдельные объекты, однако, их переменные и свойства можно изменить независимо из других экземпляров.  Например, при включении в форму трех отмечаемых окошечек, каждый из них является экземпляром класса <xref:System.Windows.Forms.CheckBox>.  Отдельные объекты <xref:System.Windows.Forms.CheckBox> сообща используют набор характеристик и возможностей \(свойства, переменные и события\), определяемых их классом.  Однако, каждый из них имеет собственное имя, может быть независимо включен и выключен, может быть перемещен в другое место формы.  
  
## Члены объекта  
 Объект является элементом приложения, представляющим собой *экземпляр* класса.  Поля, свойства, методы и события являются составными частями объектов, их *членами*.  
  
### Доступ к членам  
 Для доступа к члену объекта нужно указать последовательно имя объекта, точку \(`.`\) и имя необходимого члена.  В следующем примере устанавливается свойство <xref:System.Windows.Forms.Control.Text%2A> объекта <xref:System.Windows.Forms.Label>.  
  
```  
warningLabel.Text = "Data not saved"  
```  
  
#### Intellisense список элементов  
 Технология IntelliSense перечисляет члены класса при вызове параметра List Members, например при вводе точки \(`.`\) в качестве оператора доступа к членам.  Если ставится точка после имени переменной, объявленной как экземпляр этого класса, то IntelliSense перечисляет все члены экземпляра и ни один из общих членов.  Если ставится точка перед именем самого класса, то IntelliSense перечисляет все общие члены и ни один из членов экземпляров.  Дополнительные сведения см. в разделе [Использование технологии IntelliSense](/visual-studio/ide/using-intellisense).  
  
### Поля и свойства  
 Хранящаяся в объекте информация предоставляется *полями* и *свойствами*.  Можно получить и задать их значения с помощью инструкций присваивания так же, как получить и задать локальные переменные в процедуре.  В следующем примере извлекается свойство <xref:System.Windows.Forms.Control.Width%2A> и устанавливается свойство <xref:System.Windows.Forms.Control.ForeColor%2A> объекта <xref:System.Windows.Forms.Label>.  
  
```  
Dim warningWidth As Integer = warningLabel.Width  
warningLabel.ForeColor = System.Drawing.Color.Red  
```  
  
 Обратите внимание, что поле также называется *переменной\-членом* .  
  
 Свойство следует использовать в следующих случаях:  
  
-   При необходимости контроля фактов и способа установки и извлечения значений.  
  
-   Свойство имеет строго определенный набор значений, требующих проверки.  
  
-   Задание значения приводит к какому\-либо заметному изменению состояния объекта, например свойства `IsVisible`.  
  
-   Назначение свойства приводит к изменению других внутренних переменных или значений других свойств.  
  
-   Должен быть выполнен набор шагов перед тем, как свойство может быть установлено или извлечено.  
  
 Поле следует использовать в следующих случаях:  
  
-   Значение принадлежит к самопроверяющемуся типу.  Например, возникает ошибка или автоматическое преобразование данных в случае присвоения переменной типа `Boolean` значений, отличных от `True` или `False`.  
  
-   Допустимо любое значение из диапазона, поддерживаемого типом данных.  Это выполняется для многих свойств типа `Single` или `Double`.  
  
-   Свойство имеет тип данных `String`, и не имеет ограничений на размер или значение строки.  
  
-   Дополнительные сведения см. в разделе [Процедуры свойств](../../../../visual-basic/programming-guide/language-features/procedures/property-procedures.md).  
  
### Методы  
 Действие, которое выполняет объект, называется *методом*.  Например, <xref:System.Windows.Forms.ComboBox.ObjectCollection.Add%2A> является методом объекта <xref:System.Windows.Forms.ComboBox>, он добавляет новую запись в поле со списком.  
  
 В данном примере демонстрируется метод <xref:System.Windows.Forms.Timer.Start%2A> класса <xref:System.Windows.Forms.Timer>.  
  
```  
Dim safetyTimer As New System.Windows.Forms.Timer  
safetyTimer.Start()  
```  
  
 Обратите внимание, что метод является просто *процедурой*, которая предоставляется объектом.  
  
 Дополнительные сведения см. в разделе [Процедуры](../../../../visual-basic/programming-guide/language-features/procedures/index.md).  
  
### События  
 Событие — это действие, которое объект может распознать \(например, щелчок мышью или нажатие клавиши\), и для которого можно написать специальный код для обработки.  События происходят в результате действия пользователя или выполнения программного кода, а также вызываются системой.  Код, который сигнализирует о событии, называется *вызывающим* событие, а код, который реагирует на это событие, называется *обрабатывающим*.  
  
 Можно также создавать пользовательские события, инициируемые объектами пользователя и обрабатываемые другими объектами.  Дополнительные сведения содержатся в разделе [События](../../../../visual-basic/programming-guide/language-features/events/events.md).  
  
### Элементы экземпляра и общие члены  
 При создании объекта из класса результатом является экземпляр этого класса.  Члены, не объявленные с ключевым словом [Shared](../../../../visual-basic/language-reference/modifiers/shared.md), являются *членами экземпляра*, которые принадлежат исключительно определенному экземпляру.  Член экземпляра в одном экземпляре не зависит от того же члена в другом экземпляре того же класса.  Например, переменная члена экземпляра может иметь различные значения в различных экземплярах.  
  
 Члены, объявляемые с помощью зарезервированного слова `Shared` являются *общими членами*, которые относятся к классу в целом, а не к любому определенному экземпляру.  Общий элемент существует только один, независимо от количества созданных экземпляров класса, или даже в том случае, если не создавать экземпляры.  Например, переменная общего члена имеет только одно значение, которое доступно всем кодам, имеющим доступ к классу.  
  
#### Доступ к собственным членам  
  
###### Чтобы получить доступ к собственному члену объекта  
  
1.  Убедитесь, что объект был создан в своем классе и присвоен объектной переменной.  
  
    ```  
    Dim secondForm As New System.Windows.Forms.Form  
    ```  
  
2.  В операторе, который обращается к члену, необходимо указать имя объектной переменной с *оператором доступа к члену* \(`.`\), а затем имя члена.  
  
    ```  
    secondForm.Show()  
    ```  
  
#### Доступ к общим членам  
  
###### Чтобы получить доступ к общим членам объекта  
  
-   Запишите имя класса с *оператором доступа к члену* \(`.`\), а затем имя члена.  Следует всегда обращаться к `Shared` члену объекта напрямую через имя класса.  
  
    ```  
    MsgBox("This computer is called " & Environment.MachineName)  
    ```  
  
-   Если объект уже создан из класса, можно также обращаться к `Shared` члену с использованием объектной переменной.  
  
### Различия между классами и модулями  
 Основное различие между классами и модулями состоит в том, что классы могут быть инициализированы как объекты, а модули — нет.  Существует только одна копия данных стандартного модуля, поэтому при изменении одной частью программы общей переменной в стандартном модуле при последующем чтении этой переменной любая другая часть программы получает измененное значение.  Напротив, объект данных существует отдельно для каждого экземпляра объекта.  В отличие от стандартных модулей, классы могут реализовывать интерфейсы.  
  
> [!NOTE]
>  Когда модификатор `Shared` применяется к члену класса, он связан с самим классом непосредственно, а не через экземпляр класса.  Непосредственный доступ к члену осуществляется с помощью имени класса. Тем же способом осуществляется доступ к членам модуля.  
  
 Классы и модули используют различные области действия для своих членов.  Члены, определенные внутри класса, находятся в определенном экземпляре класса и существуют только во время существования объекта.  Для доступа к членам класса за пределами класса необходимо использовать полные имена в формате *Объект*.*Член*.  
  
 С другой стороны, члены, объявленные в модуле, общедоступны по умолчанию, и доступ к нему может осуществить любой код, имеющий доступ к модулю.  Это означает, что переменные в стандартном модуле являются фактически глобальными переменными, так как они видимы из любой части проекта и существуют во время выполнения программы.  
  
## Повторное использование классов и объектов  
 Объекты позволяют, однажды объявив переменные и процедуры, использовать их по мере надобности.  Например, если требуется добавить в приложение проверку орфографии, то можно описать все переменные и функции, необходимые для обеспечения проверки орфографии.  Но если описать систему проверки орфографии как отдельный класс, то можно использовать ее в других приложениях, добавив ссылку на скомпилированную сборку.  Более того, можно избавиться от лишних усилий, используя класс проверки орфографии, разработанный ранее.  
  
 [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort_md.md)] предоставляет многие примеры компонентов, которые доступны для использования.  В следующем примере используется класс <xref:System.TimeZone> из пространства имен <xref:System>.  <xref:System.TimeZone> предоставляет элементы, которые позволяют получить сведения о часовом поясе текущего компьютера.  
  
```  
Public Sub examineTimeZone()  
    Dim tz As System.TimeZone = System.TimeZone.CurrentTimeZone  
    Dim s As String = "Current time zone is "  
    s &= CStr(tz.GetUtcOffset(Now).Hours) & " hours and "  
    s &= CStr(tz.GetUtcOffset(Now).Minutes) & " minutes "  
    s &= "different from UTC (coordinated universal time)"  
    s &= vbCrLf & "and is currently "  
    If tz.IsDaylightSavingTime(Now) = False Then s &= "not "  
    s &= "on ""summer time""."  
    MsgBox(s)  
End Sub  
```  
  
 В предыдущем примере первый [Оператор Dim](../../../../visual-basic/language-reference/statements/dim-statement.md) объявляет переменную объекта типа <xref:System.TimeZone> и присваивает ей объект <xref:System.TimeZone>, возвращенный свойством <xref:System.TimeZone.CurrentTimeZone%2A>.  
  
## Отношения между объектами  
 Связь объектов друг с другом может быть различной.  Основными видами связи являются *hierarchical* и *containment*.  
  
### Иерархическая связь  
 При *иерархической связи\(hierarchical relationship\)* одни классы являются наследниками других, более фундаментальных классов.  Иерархии классов удобны при описании объектов — подтипов более универсальных классов.  
  
 В следующем примере предположим, что необходимо определить особый тип <xref:System.Windows.Forms.Button>, который действует как обычный <xref:System.Windows.Forms.Button>, но также предоставляет метод для изменения цвета шрифта и цвета фона.  
  
##### Определение класса, производного от уже существующего класса  
  
1.  Используйте [Оператор Class](../../../../visual-basic/language-reference/statements/class-statement.md) для определения класса, из которого создается нужный объект.  
  
     `Public Class reversibleButton`  
  
     Убедитесь, что оператор `End Class` следует за последней строкой кода в классе.  По умолчанию интегрированная среда разработки \(IDE\) автоматически создает `End Class` при вводе инструкции `Class`.  
  
2.  Используйте инструкцию `Class` вместе с [Инструкция Inherits](../../../../visual-basic/language-reference/statements/inherits-statement.md).  Укажите класс, от которого наследует новый класс.  
  
     `Inherits System.Windows.Forms.Button`  
  
     Новый класс наследует все члены, определенные базовым классом.  
  
3.  Добавьте код для дополнительных элементов, которые предоставляет производный класс.  Например, можно добавить метод `reverseColors`, и производный класс будет выглядеть следующим образом:  
  
    ```  
    Public Class reversibleButton  
        Inherits System.Windows.Forms.Button  
        Public Sub reverseColors()   
            Dim saveColor As System.Drawing.Color = Me.BackColor  
            Me.BackColor = Me.ForeColor  
            Me.ForeColor = saveColor  
        End Sub  
    End Class   
    ```  
  
     При создании объекта из класса `reversibleButton`, он получает доступ ко всем членам класса <xref:System.Windows.Forms.Button>, так же, как к методу `reverseColors` и каким\-либо другим новым элементам, которые можно определить для `reversibleButton`.  
  
 Производные классы наследуют члены класса, от которого они произведены, позволяя добавлять функциональность по мере продвижения вглубь иерархии классов.  Дополнительные сведения см. в разделе [Основы наследования](../../../../visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.md).  
  
#### Компиляция кода  
 Убедитесь, что компилятор может получить доступ к классу, который используется для получения нового класса.  Это может означать полное уточнение его имени, как в предыдущем примере, или определение его пространства имен в [Оператор Imports \(пространство имен .NET и тип\)](../../../../visual-basic/language-reference/statements/imports-statement-net-namespace-and-type.md).  Если класс находится в другом проекте, может потребоваться добавить ссылку на этот проект.  Дополнительные сведения см. в разделе [Управление ссылками в проекте](/visual-studio/ide/managing-references-in-a-project).  
  
### Отношение вложенности  
 Другим способом описания отношений между объектами является *containment relationship*.  Объекты\-контейнеры инкапсулируют другие объекты.  Например, объект <xref:System.OperatingSystem> логически содержит объект <xref:System.Version>, который возвращается с помощью его свойства <xref:System.OperatingSystem.Version%2A>.  Обратите внимание, что объект контейнера физически не содержит любые другие объекты.  
  
#### Коллекции  
 Один из типов отношения вложенности представлен *collections*.  Коллекции представляют собой упорядоченные группы однотипных объектов.  [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb_md.md)] поддерживает определенный синтаксис в [Оператор For Each...Next](../../../../visual-basic/language-reference/statements/for-each-next-statement.md), позволяющем перебирать элементы коллекции.  Кроме того, коллекции часто позволяют использовать свойство <xref:Microsoft.VisualBasic.Collection.Item%2A> для извлечения элементов по индексу или привязки их к уникальной строке.  Коллекции более просты в применении, чем массивы, т.к. они позволяют добавлять или удалять элементы без использования индексов.  Коллекции просты в обращении и потому часто используются для хранения форм и элементов управления.  
  
## Связанные разделы  
 [Пошаговое руководство. Определение классов](../../../../visual-basic/programming-guide/language-features/objects-and-classes/walkthrough-defining-classes.md)  
 Пошаговые инструкции по созданию класса.  
  
 [Перегруженные свойства и методы](../../../../visual-basic/programming-guide/language-features/objects-and-classes/overloaded-properties-and-methods.md)  
 Перегруженные свойства и методы  
  
 [Основы наследования](../../../../visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.md)  
 Описание модификаторов наследования, переопределения методов и свойств, классов MyClass и MyBase.  
  
 [Время существования: создание и уничтожение объектов](../../../../visual-basic/programming-guide/language-features/objects-and-classes/object-lifetime-how-objects-are-created-and-destroyed.md)  
 Описание создания и уничтожения экземпляров класса.  
  
 [Анонимные типы](../../../../visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md)  
 Описание способов создания и использования анонимных типов, которые позволяют создавать объекты без написания определения класса для типа данных.  
  
 [Инициализаторы объектов: именованные и анонимные типы](../../../../visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md)  
 Описание инициализаторов объектов, которые используются для создания экземпляров именованных и анонимных типов с помощью одного выражения.  
  
 [Практическое руководство. Выведение имен свойств и типов в объявлениях анонимных типов](../../../../visual-basic/programming-guide/language-features/objects-and-classes/how-to-infer-property-names-and-types-in-anonymous-type-declarations.md)  
 Объяснение, как вывести имя свойства и типы в объявлениях анонимного типа.  Примеры успешного и неуспешного вывода.