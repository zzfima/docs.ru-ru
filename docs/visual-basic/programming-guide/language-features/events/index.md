---
title: "События (Visual Basic) | Документация Майкрософт"
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.topic: article
dev_langs:
- VB
helpviewer_keywords:
- events [Visual Basic], about events
- events [Visual Basic]
ms.assetid: 8fb0353a-e41b-4e23-b78f-da65db832f70
caps.latest.revision: 12
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: Human Translation
ms.sourcegitcommit: 31905a37f09db5f5192123f0118252fbe8b02eff
ms.openlocfilehash: e4e92b4e47d7cc743233aff3aaa77232a74e789f
ms.contentlocale: ru-ru
ms.lasthandoff: 05/26/2017

---
# <a name="events-visual-basic"></a>События (Visual Basic)
Возможно, вы воспринимаете проект [!INCLUDE[vsprvs](~/includes/vsprvs-md.md)] как набор процедур, выполняемых в определенной последовательности. Но на практике большинство программ управляются событиями, то есть поток выполнения определяется внешними воздействиями, которые называются *событиями*.  
  
 Событие — это сигнал, который сообщает приложению, что произошло нечто важное. Например, когда пользователь щелкает элемент управления на форме, эта форма инициирует событие `Click` и вызывает процедуру обработки события. События позволяют отдельным задачам взаимодействовать друг с другом. Давайте представим, что приложение выполняет задачу по сортировке в отдельном процессе. Если пользователь отменит эту сортировку, приложение отправит событие отмены, по которому процесс сортировки завершит свою работу.  
  
## <a name="event-terms-and-concepts"></a>Термины и основные понятия для событий  
 В этом разделе описываются термины и основные понятия, используемые в отношении событий в [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
### <a name="declaring-events"></a>Объявление событий  
 События объявляются внутри классов, структур, модулей и интерфейсов с помощью ключевого слова `Event`, как показано в следующем примере:  
  
 [!code-vb[VbVbalrEvents#24](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/events_1.vb)]  
  
### <a name="raising-events"></a>Создание событий  
 Событие действует как сообщение о том, что произошло нечто важное. Рассылка такого сообщения называется *созданием* события. В [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] события создаются инструкцией `RaiseEvent`, как показано в следующем примере:  
  
 [!code-vb[VbVbalrEvents#25](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/events_2.vb)]  
  
 События должны создаваться в пределах области действия класса, модуля или структуры, в которых они объявлены. Например, производный класс не может создавать события, унаследованные от базового класса.  
  
### <a name="event-senders"></a>Отправители событий  
 Любой объект, способный создать событие, считается *отправителем события* или *источником события*. Например, отправителями событий могут являться формы, элементы управления и пользовательские объекты.  
  
### <a name="event-handlers"></a>Обработчики событий  
 *Обработчики событий* — это процедуры, вызываемые при создании определенного события. В качестве обработчика событий можно использовать любую допустимую подпрограмму с подходящей сигнатурой. Но в качестве обработчика событий нельзя использовать функцию, поскольку она не может возвращать значение источнику события.  
  
 [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] использует для обработчиков событий стандартное соглашение об именовании: имя обработчика включает имя отправителя события, символ подчеркивания и имя самого события. Например, событие `Click` для кнопки с именем `button1` будет называться `Sub button1_Click`.  
  
> [!NOTE]
>  Мы рекомендуем придерживаться этого соглашения об именовании при создании обработчиков событий и для пользовательских событий. Но это не обязательное условие, вы можете использовать любое допустимое имя процедуры.  
  
## <a name="associating-events-with-event-handlers"></a>Связывание событий с обработчиками событий  
 Чтобы обработчик событий мог выполнять свою функцию, его следует связать с соответствующим событием с помощью инструкции `Handles` или `AddHandler`.  
  
### <a name="withevents-and-the-handles-clause"></a>Оператор WithEvents и предложение Handles  
 Инструкция `WithEvents` и предложение `Handles` предоставляют декларативный способ указания обработчиков событий. Если объект объявлен с ключевым словом `WithEvents`, созданные им события могут обрабатываться любой процедурой с инструкцией `Handles` для этого события, как показано в следующем примере:  
  
 [!code-vb[VbVbalrEvents#1](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/events_3.vb)]  
  
 Инструкция `WithEvents` и предложение `Handles` часто являются наилучшим решением для обработки событий, так как декларативный синтаксис позволяет легко создавать, читать и отлаживать код программы. Но использование переменных `WithEvents` имеет ряд ограничений.  
  
-   Нельзя использовать переменную `WithEvents` в качестве переменной объекта. То есть вы не можете объявить ее как `Object`. При объявлении переменной необходимо указать имя класса.  
  
-   Поскольку общие события не связываются с экземплярами класса, вы не можете использовать `WithEvents` для декларативной обработки общих событий. Аналогично, нельзя использовать `WithEvents` или `Handles` для обработки событий от `Structure`. В обоих случаях для обработки таких событий можно использовать инструкцию `AddHandler`.  
  
-   Вы не можете создавать массивы переменных типа `WithEvents`.  
  
 Переменные `WithEvents` позволяют одному обработчику событий обрабатывать один или несколько видов событий. Также можно создать несколько обработчиков для одного вида событий.  
  
 Предложение `Handles` является стандартным способом связывания события с обработчиком событий, но оно ограничено тем, что может связывать события с обработчиками событий только во время компиляции.  
  
 В некоторых случаях, например при работе с событиями форм или элементов управления, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] автоматически создает пустой обработчик событий в качестве заглушки и связывает его с событием. Например, если вы дважды щелкнете кнопку в форме в режиме конструктора, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] создаст пустой обработчик событий и переменную `WithEvents` для кнопки, как показано в следующем коде:  
  
 [!code-vb[VbVbalrEvents#26](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/events_4.vb)]  
  
### <a name="addhandler-and-removehandler"></a>AddHandler и RemoveHandler  
 Инструкция `AddHandler` похожа на предложение `Handles`, поскольку тоже позволяет задавать обработчик событий. Но `AddHandler` в сочетании с `RemoveHandler` обеспечивает большую гибкость, чем предложение `Handles`. Она позволяет динамически добавлять, удалять и изменять обработчики событий, связанные с событием. Если вы хотите обрабатывать общие события или события от структуры, необходимо использовать `AddHandler`.  
  
 `AddHandler` принимает два аргумента: имя события, которое предоставляет отправитель события, например элемент управления, и выражение, определяющее делегат. Класс делегата при использовании `AddHandler` не обязательно указывать явно, поскольку инструкция `AddressOf` всегда возвращает ссылку на делегат. Следующий пример связывает обработчик событий с событием, создаваемым объектом:  
  
 [!code-vb[VbVbalrEvents#28](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/events_5.vb)]  
  
 Инструкция `RemoveHandler`, которая отсоединяет событие от обработчика событий, использует такой же синтаксис, как `AddHandler`. Пример:  
  
 [!code-vb[VbVbalrEvents#29](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/events_6.vb)]  
  
 В следующем примере обработчик событий связывается с событием, а затем создается событие. Обработчик событий перехватывает это событие и выводит сообщение.  
  
 Затем первый обработчик событий удаляется, а с этим событием связывается другой обработчик событий. Теперь событие создается снова и отображается другое сообщение.  
  
 Наконец, второй обработчик событий удаляется и событие создается в третий раз. Поскольку теперь нет обработчиков событий, связанных с этим событием, никакие действия не выполняются.  
  
 [!code-vb[VbVbalrEvents#38](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/events_7.vb)]  
  
## <a name="handling-events-inherited-from-a-base-class"></a>Обработка событий, наследуемых от базового класса  
 *Производные классы*, которые наследуют характеристики из базового класса, могут обрабатывать события, создаваемые этим базовым классом, используя инструкцию `Handles``MyBase`.  
  
#### <a name="to-handle-events-from-a-base-class"></a>Обработка событий из базового класса  
  
-   Объявите обработчик событий в производном классе, добавив инструкцию `Handles MyBase.`*eventname* в строку объявления процедуры обработчика событий, где *eventname* — это имя события в базовом классе, которое вы хотите обрабатывать. Например:  
  
     [!code-vb[VbVbalrEvents#12](../../../../visual-basic/language-reference/statements/codesnippet/VisualBasic/events_8.vb)]  
  
## <a name="related-sections"></a>Связанные разделы  
  
|Заголовок|Описание|  
|-----------|-----------------|  
|[Пошаговое руководство. Объявление и создание событий](../../../../visual-basic/programming-guide/language-features/events/walkthrough-declaring-and-raising-events.md)|Предоставляет пошаговую инструкцию для объявления и создания событий класса.|  
|[Пошаговое руководство. Обработка событий](../../../../visual-basic/programming-guide/language-features/events/walkthrough-handling-events.md)|Описывает способ создания процедуры обработчика событий.|  
|[Практическое руководство. Объявление пользовательских событий для предотвращения блокировки](../../../../visual-basic/programming-guide/language-features/events/how-to-declare-custom-events-to-avoid-blocking.md)|Показывает, как определить пользовательское событие, которое позволяет асинхронно вызывать обработчики событий.|  
|[Практическое руководство. Объявление пользовательских событий для экономии памяти](../../../../visual-basic/programming-guide/language-features/events/how-to-declare-custom-events-to-conserve-memory.md)|Показывает, как определить пользовательское событие, которое использует память только при обработке события.|  
|[Устранение неполадок, связанных с унаследованными обработчиками событий, в Visual Basic](../../../../visual-basic/programming-guide/language-features/events/troubleshooting-inherited-event-handlers.md)|Перечисляет распространенные проблемы, возникающие для обработчиков событий в наследуемых компонентах.|  
|[События](../../../../standard/events/index.md)|Предоставляет обзор модели событий в [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|[Создание обработчиков событий в Windows Forms](https://msdn.microsoft.com/library/dacysss4.aspx)|Описывает, как работать с событиями, связанными с объектами Windows Forms.|  
|[Делегаты](../../../../visual-basic/programming-guide/language-features/delegates/index.md)|Предоставляет обзор делегатов в Visual Basic.|
