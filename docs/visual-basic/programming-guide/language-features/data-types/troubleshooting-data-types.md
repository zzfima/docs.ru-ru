---
title: "Устранение неполадок, связанных с типами данных (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "2015-07-20"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.topic: "article"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "boolean - тип данных, преобразование"
  - "Char - тип данных, преобразование"
  - "типы данных [Visual Basic], устранение неполадок"
  - "Decimal - тип данных, преобразования"
  - "числа с плавающей запятой"
  - "числа с плавающей запятой, сравнение"
  - "числа с плавающей запятой, неточность"
  - "числа с плавающей запятой, точность"
  - "символы типа литерала"
  - "типы литералов"
  - "литералы, типы по умолчанию"
  - "Mod - оператор [Visual Basic], в операциях с плавающей запятой"
  - "String - тип данных, преобразование"
  - "устранение неполадок, связанных с типами данных"
  - "устранение неполадок - Visual Basic, типы данных"
  - "знаки типов, литерал"
ms.assetid: 90040d67-b630-4125-a6ae-37195b079042
caps.latest.revision: 29
author: "stevehoag"
ms.author: "shoag"
caps.handback.revision: 28
---
# Устранение неполадок, связанных с типами данных (Visual Basic)
[!INCLUDE[vs2017banner](../../../../visual-basic/includes/vs2017banner.md)]

На этой странице перечислены некоторые общие проблемы, которые могут возникнуть при выполнении операций над встроенными типами данных.  
  
## Выражения с плавающей запятой не сравниваются в равенстве  
 При работе с числами с плавающей запятой \([Тип данных Single](../../../../visual-basic/language-reference/data-types/single-data-type.md) и [Тип данных Double](../../../../visual-basic/language-reference/data-types/double-data-type.md)\), помните, что они хранятся в виде двоичных дробей.  Это означает, что они не содержат точное представление любого числа, которое не является двоичной дробью \(формы k \/ \(2 ^ n\) где k  и n целые числа\).  Например, 0,5 \(\= 1\/2\) и 0.3125 \(\= 5\/16\) могут храниться как точные значения, в то время как 0,2 \(\= 1\/5\) и 0,3 \(\= 3\/10\) могут быть только аппроксимацией.  
  
 В результате этой неточности, нельзя полагаться на точные результаты при оперировании со значениями с плавающей заятой.  В частности два значения, равные теоретически, возможно могут иметь слегка отличающиеся представления.  
  
||  
|-|  
|Для сравнения чисел с плавающей запятой|  
|1.  Вычислите абсолютное значение их разницы, с помощью метода <xref:System.Math.Abs%2A> класса <xref:System.Math> в пространстве имен <xref:System>.<br />2.  Определите допустимую максимальную разницу; таким образом, для практических целей можно считать два числа равными, если разница между ними не превышает максимально допустимую.<br />3.  Сравнить абсолютное значение разницы с допустимой разницей.|  
  
 В следующем примере показано неправильное и правильное сравнение двух значений `Double`.  
  
 [!code-vb[VbVbalrDataTypes#10](../../../../visual-basic/language-reference/data-types/codesnippet/visualbasic/troubleshooting-data-types_1.vb)]  
  
 Предыдущий пример использует метод <xref:System.Double.ToString%2A> структуры <xref:System.Double> таким образом, чтобы он мог указать точность лучше, чем ключевое слово `CStr`.  По умолчанию это 15 цифр, но формат "G17" расширяет его до 17 цифр.  
  
## Оператор Mod не возвращает точный результат  
 Из\-за из неточности хранения числа с плавающей запятой, [Оператор Mod](../../../../visual-basic/language-reference/operators/mod-operator.md) может возвращать непредвиденный результат, когда по крайней мере один из операндов является числом с плавающей запятой.  
  
 [Тип данных Decimal](../../../../visual-basic/language-reference/data-types/decimal-data-type.md) не использует представление с плавающей запятой.  Многие числа, не имеющие точного представления в рамках типов `Single` и `Double`, имеют точное значение в рамках типа `Decimal` \(например, 0,2 и 0,3\).  Хотя вычисления происходят медленнее для типа `Decimal`, чем для типов с плавающей запятой, может иметь смысл снизить производительность ради большей точности.  
  
||  
|-|  
|Чтобы найти целочисленный остаток чисел с плавающей запятой|  
|1.  Объявите переменные в качестве `Decimal`.<br />2.  Используйте символьный тип литерала `D` для приведения литералов в `Decimal`, в случае, если их значения слишком велики для типа данных `Long`.|  
  
 В следующем примере показана возможная неточность операндов с плавающей запятой.  
  
 [!code-vb[VbVbalrDataTypes#11](../../../../visual-basic/language-reference/data-types/codesnippet/visualbasic/troubleshooting-data-types_2.vb)]  
  
 Предыдущий пример использует метод <xref:System.Double.ToString%2A> структуры <xref:System.Double> таким образом, чтобы он мог указать точность лучше, чем ключевое слово `CStr`.  По умолчанию это 15 цифр, но формат "G17" расширяет его до 17 цифр.  
  
 Так как `zeroPointTwo` относится к типу `Double`, значение для 0,2 является периодической бесконечной двоичной дробью, которая хранится в виде значения 0,20000000000000001.  Деление числа 2,0 на это число дает 9,9999999999999995 с остатком 0,19999999999999991.  
  
 В выражении для `decimalRemainder` символьный тип литерала `D` приводит оба операнда в `Decimal`, и 0,2 имеет точное представление.  Таким образом оператор `Mod` дает ожидаемый остаток 0,0.  
  
 Обратите внимание, объявить `decimalRemainder` как `Decimal` недостаточно.  Необходимо также привести литералы в `Decimal`, или они используют `Double` по умолчанию и `decimalRemainder` получают тоже самое неточное значение как и `doubleRemainder`.  
  
## Тип Boolean не преобразовывает в числовой тип точно  
 [Тип данных Boolean](../../../../visual-basic/language-reference/data-types/boolean-data-type.md) значения не хранятся в виде чисел, и хранимые значения не предназначены для того чтобы быть эквивалентными числам.  Для обеспечения совместимости с более ранними версиями [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb-md.md)] предоставляет зарезервированные слов \([Функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md), `CBool`, `CInt` и т.д.\) для преобразования между типами `Boolean` и числовые преобразования.  Однако на других языках эти преобразования иногда выполняются по\-разному, так же, как это делают методы [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort-md.md)].  
  
 Никогда не следует писать код, который основывается на эквивалентных числовых значениях для `True` и `False`.  Везде, где это возможно, следует ограничивать применение переменных с типом `Boolean` логическими значениями, для которых этот тип специально предназначен.  Если необходимо смешать `Boolean` и числовые значения, убедитесь, что вы понимаете метод преобразования, который вы выбираете.  
  
### Преобразование в Visual Basic  
 При использовании ключевых слов преобразования `CType` или `CBool` для преобразования числовых типов данных в `Boolean`, 0 становится `False`, а все остальные значения становятся `True`.  При преобразовании значений `Boolean` в числовые типы с помощью зарезервированных слов преобразования, `False` становится 0, а `True` становится 1.  
  
### Преобразование в Framework  
 Метод <xref:System.Convert.ToInt32%2A> класса  <xref:System.Convert> в пространстве имен <xref:System> преобразует `True` к \+ 1.  
  
 Если необходимо преобразовать значение `Boolean` в числовой тип данных, будьте внимательны в том, какой метод преобразования используется.  
  
## Знак Literal порождает ошибку компилятора  
 В случае отсутствия любого типа знаков, [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb-md.md)] предполагает стандартные типы данных для литералов.  Тип, который определен по умолчанию для литерала знаков, заключен в кавычки \(`" "`\) — это `String`.  
  
 Тип данных `String` не расширяется до [Тип данных Char](../../../../visual-basic/language-reference/data-types/char-data-type.md).  Это означает, что если вы хотите назначить литерал к переменной `Char`, необходимо либо сделать сужающее преобразования либо привести литерал к типу `Char`.  
  
||  
|-|  
|Чтобы создать литерал Char для присвоения переменной или константе|  
|1.  Объявите переменную или константу с типом `Char`.<br />2.  Заключите значение символа в кавычки \(`" "`\).<br />3.  После закрытых двойных кавычек поставьте символьный тип литерала `C` для приведения литерала к `Char`.  Это необходимо, если переключатель проверки типа \([Оператор Option Strict](../../../../visual-basic/language-reference/statements/option-strict-statement.md)\) является `On`, и желательно в любом случае.|  
  
 В следующем примере показаны успешные и неудачные попытки назначения литерала переменной `Char`.  
  
 [!CODE [VbVbalrStatements#49](../CodeSnippet/VS_Snippets_VBCSharp/VbVbalrStatements#49)]  
  
 [!code-vb[VbVbalrDataTypes#12](../../../../visual-basic/language-reference/data-types/codesnippet/visualbasic/troubleshooting-data-types_4.vb)]  
  
 Всегда существует угроза при использовании сужающего преобразования, так как возможны сбои во время выполнения.  Например, преобразование из `String` в `Char` может пройти неудачно, если значение `String` содержит более одного знака.  Поэтому в программировании лучше использовать знак типа `C`.  
  
## Не удается преобразовать строку во время выполнения  
 [Тип данных String](../../../../visual-basic/language-reference/data-types/string-data-type.md) участвует лишь в небольшом числе расширяющих преобразований.  `String` расширяется только до себя и типа `Object`, и только типы `Char` и `Char()` \(массив `Char`\) расширяются до типа `String`.  Это происходит потому, что переменные и константы `String` могут содержать значения, которые другие типы данных не могут содержать.  
  
 Если переключатель проверки типа \([Оператор Option Strict](../../../../visual-basic/language-reference/statements/option-strict-statement.md)\) является `On`, компилятор запрещает все неявные сужающие преобразования.  Это включает те включающие `String`.  В коде можно по\-прежнему использовать ключевые слова преобразования, такие как `CStr` и [Функция CType](../../../../visual-basic/language-reference/functions/ctype-function.md), которые направляют [!INCLUDE[dnprdnshort](../../../../csharp/getting-started/includes/dnprdnshort-md.md)], чтобы сделать попытку преобразования.  
  
> [!NOTE]
>  Ошибка сужающего преобразования отбрасывается при преобразовании элементов коллекции `For Each…Next` в переменную цикла.  Дополнительные сведения и примеры см. в подразделе "Сужающие преобразования" [Оператор For Each...Next](../../../../visual-basic/language-reference/statements/for-each-next-statement.md).  
  
### Защита сужающего преобразования  
 Недостатком сужающих преобразований является то, что они могут завершиться ошибкой во время выполнения.  Например если переменная `String` содержит все что угодно, кроме "true" или "false", она не может быть преобразована `Boolean`.  Если она содержит знаки препинания, то преобразование к любому числовому типу завершаются неудачей.  Если вы не знаете, что переменная `String` всегда содержит значения, которые может принимать конечный тип, не пытайтесь выполнить преобразование.  
  
 Если необходимо преобразовать из `String` в другой тип данных, самой безопасной процедурой является заключить попытку преобразования в [Оператор Try...Catch...Finally](../../../../visual-basic/language-reference/statements/try-catch-finally-statement.md).  Это позволяет вам работать с ошибками времени выполнения.  
  
### Массив знаков.  
 Одиночный `Char` и массив `Char` элементов расширяемы до `String`.  Однако `String` нельзя расширить до `Char()`.  Чтобы преобразовать значение `String` в массив `Char`, можно использовать метод <xref:System.String.ToCharArray%2A> класса <xref:System.String?displayProperty=fullName>.  
  
### Не имеющие смысла значения  
 В общем случае значения `String` теряют свой смысл в других типах данных, и делают преобразование очень опасным.  Везде, где это возможно, следует ограничивать применение переменных с типом `String` для последовательности знаков, для которых этот тип специально предназначен.  Никогда не следует писать код, основываясь на эквивалентных значения других типов.  
  
## См. также  
 [Типы данных](../../../../visual-basic/programming-guide/language-features/data-types/index.md)   
 [Символы типов](../../../../visual-basic/programming-guide/language-features/data-types/type-characters.md)   
 [Типы значений и ссылочные типы](../../../../visual-basic/programming-guide/language-features/data-types/value-types-and-reference-types.md)   
 [Преобразование типов в Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/type-conversions.md)   
 [Типы данных](../../../../visual-basic/language-reference/data-types/data-type-summary.md)   
 [Функции преобразования типов](../../../../visual-basic/language-reference/functions/type-conversion-functions.md)   
 [Эффективное использование типов данных](../../../../visual-basic/programming-guide/language-features/data-types/efficient-use-of-data-types.md)