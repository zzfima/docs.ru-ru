---
title: "Универсальные процедуры в Visual Basic | Microsoft Docs"
ms.custom: ""
ms.date: "2015-07-20"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.topic: "article"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "универсальные методы"
  - "универсальные методы, определение типа"
  - "универсальные процедуры"
  - "универсальные процедуры, определение типа"
  - "универсальные шаблоны [Visual Basic], процедуры"
  - "универсальные шаблоны [Visual Basic], определение типа"
  - "процедуры, универсальный"
  - "определение типа"
  - "определение типа, универсальные шаблоны"
ms.assetid: 95577b28-137f-4d5c-a149-919c828600e5
caps.latest.revision: 11
author: "stevehoag"
ms.author: "shoag"
caps.handback.revision: 11
---
# Универсальные процедуры в Visual Basic
[!INCLUDE[vs2017banner](../../../../visual-basic/includes/vs2017banner.md)]

*Универсальная процедура*, также называемая *базовый метод* — это процедура, определенная с помощью минимум одного параметра типа.  Это позволяет вызывающему коду настраивать типы данных согласно их требованиям каждый раз, когда он вызывает процедуру.  
  
 Процедура не является универсальной просто на основании того, что она определена внутри базового класса или универсальной структуры.  Чтобы быть универсальной, процедура должна принимать хотя бы один параметр типа в дополнение к обычным параметрам, которые она может принимать.  Универсальный класс или структура может содержать неуниверсальные процедуры, а неуниверсальные класс, структура, или модуль могут содержать универсальные процедуры.  
  
 Универсальная процедура может использовать свои параметры типа в обычном списке параметров, в возвращаемом типе, если содержит таковой, и в коде процедуры.  
  
## Вывод типа  
 Можно вызвать универсальную процедуру, не указывая аргументов типа вообще.  При ее вызове таким образом компилятор пытается определить соответствующий тип данных, чтобы перейти к аргументам типа процедуры.  Это называется *выводом типа*.  В следующем коде показан вызов, в котором компилятор выводит, что ему следует передать тип `String` параметру типа `t`.  
  
 [!code-vb[VbVbalrDataTypes#15](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-procedures_1.vb)]  
  
 Если компилятор не может вывести аргументы типа из контекста вызова, то он сообщает об ошибке.  Одной из возможных причин такой ошибки является несоответствие ранга массива.  Например, предположим, вы определили обычные параметры в виде массива параметра типа.  При вызове универсальной процедуры с использованием массива другого ранга \(число измерений\), несоответствие вызывает сбой вывода типа.  В следующем коде показан вызов, в котором двумерный массив передается в процедуру, ожидающую одномерный массив.  
  
 `Public Sub demoSub(Of t)(ByVal arg() As t)`  
  
 `End Sub`  
  
 `Public Sub callDemoSub()`  
  
 `Dim twoDimensions(,) As Integer`  
  
 `demoSub(twoDimensions)`  
  
 `End Sub`  
  
 Можно вызвать вывод типа только с посредством исключения всех аргументов типа.  Если вы указываете один аргумент типа, необходимо указать их все.  
  
 Вывод типа поддерживается только для универсальных процедур.  Невозможно вызвать вывод типа в универсальных классах, структурах, интерфейсах или делегатах.  
  
## Пример  
  
### Описание  
 В следующем примере определяется общая процедура `Function` для поиска конкретного элемента в массиве.  Он определяет один параметр типа и использует его для создания двух параметров в списке параметров.  
  
### Код  
 [!code-vb[VbVbalrDataTypes#14](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-procedures_2.vb)]  
  
### Комментарии  
 В предыдущем примере требуется возможность сравнения `searchValue` с каждым элементом `searchArray`.  Чтобы обеспечить эту возможность, параметр типа `T` ограничен для реализации интерфейса <xref:System.IComparable%601>.  Код использует метод <xref:System.IComparable%601.CompareTo%2A> вместо оператора `=`, поскольку нет гарантии того, что аргумент типа, предоставленный для `T`, поддерживает оператор `=`.  
  
 Можно проверить процедуру `findElement` с помощью следующего кода.  
  
 [!code-vb[VbVbalrDataTypes#13](../../../../visual-basic/language-reference/data-types/codesnippet/VisualBasic/generic-procedures_3.vb)]  
  
 Предыдущие вызовы `MsgBox` отображают "0", "1" и "\-1"соответственно.  
  
## См. также  
 [Универсальные типы в Visual Basic](../../../../visual-basic/programming-guide/language-features/data-types/generic-types.md)   
 [Практическое руководство. Определение класса, реализующего одинаковую функциональность для различных типов данных](../../../../visual-basic/programming-guide/language-features/data-types/how-to-define-a-class-that-can-provide-identical-functionality.md)   
 [Практическое руководство. Использование универсального класса](../../../../visual-basic/programming-guide/language-features/data-types/how-to-use-a-generic-class.md)   
 [Процедуры](../../../../visual-basic/programming-guide/language-features/procedures/index.md)   
 [Параметры и аргументы процедуры](../../../../visual-basic/programming-guide/language-features/procedures/procedure-parameters-and-arguments.md)   
 [Список типов](../../../../visual-basic/language-reference/statements/type-list.md)   
 [Список параметров](../../../../visual-basic/language-reference/statements/parameter-list.md)