---
title: Кортежи
ms.date: 04/23/2017
helpviewer_keywords:
- tuples [Visual Basic]
ms.assetid: 3e66cd1b-3432-4e1d-8c37-5ebacae8f53f
ms.openlocfilehash: e0310f31d7becb1f79bb023a277bd565421b44fb
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74350502"
---
# <a name="tuples-visual-basic"></a>Кортежи (Visual Basic)

Начиная с Visual Basic 2017, язык Visual Basic предлагает встроенную поддержку кортежей, которые упрощают создание кортежей и доступ к элементам кортежей. Кортеж — это упрощенная структура данных, которая имеет определенное число и последовательность значений. При создании экземпляра кортежа вы определяете число и тип данных каждого значения (или элемента). Например, 2 кортежа (или пара) имеет два элемента. Первый может быть `Boolean` значением, а второй — `String`. Поскольку кортежи упрощают хранение нескольких значений в одном объекте, они часто используются в качестве упрощенного способа возврата нескольких значений из метода.

> [!IMPORTANT]
> Для поддержки кортежей требуется тип <xref:System.ValueTuple>. Если .NET Framework 4,7 не установлен, необходимо добавить пакет NuGet `System.ValueTuple`, который доступен в коллекции NuGet. Без этого пакета может возникнуть ошибка компиляции, аналогичная "предопределенный тип ValueTuple (Of,,,)" не определен или не импортирован ".

## <a name="instantiating-and-using-a-tuple"></a>Создание экземпляров и использование кортежа

Вы создаете экземпляр кортежа, заключая в круглые скобки значения, разделенные запятыми. Каждое из этих значений затем превращается в поле кортежа. Например, следующий код определяет тройной (или 3-кортежный) элемент с `Date` в качестве первого значения, `String` в качестве второго, а `Boolean` в качестве третьего.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#1)]

По умолчанию имя каждого поля в кортеже состоит из строки `Item` вместе с позицией поля, основанной на единице в кортеже. В этом трехмерном кортеже поле `Date` `Item1`, поле `String` `Item2`, а `Boolean` поле — `Item3`. В следующем примере выводятся значения полей кортежа, созданного в предыдущей строке кода.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#2)]

Поля Visual Basic кортежа доступны для чтения и записи; После создания экземпляра кортежа можно изменить его значения. В следующем примере изменяются два из трех полей кортежа, созданного в предыдущем примере, и отображается результат.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#3)]

## <a name="instantiating-and-using-a-named-tuple"></a>Создание экземпляров и использование именованного кортежа

Вместо использования имен по умолчанию для полей кортежа можно создать экземпляр *именованного кортежа* , назначив собственные имена элементам кортежа. Затем к полям кортежа можно получить доступ по их назначенным именам *или* по именам по умолчанию. В следующем примере создается экземпляр того же трех кортежей, как и ранее, за исключением того, что он явно именует первое поле `EventDate`, второй `Name`и третий `IsHoliday`. Затем он отображает значения полей, изменяет их и снова отображает значения полей.

[!code-vb[Instantiate](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple1.vb#4)]

## <a name="inferred-tuple-element-names"></a>Выводимые имена элементов кортежа

Начиная с Visual Basic 15,3, Visual Basic может определять имена элементов кортежа. их не нужно назначать явным образом. Выводимые имена кортежей полезны при инициализации кортежа из набора переменных и если имя элемента кортежа должно совпадать с именем переменной.

В следующем примере создается `stateInfo` кортеж, содержащий три явно именованных элемента, `state`, `stateName`и `capital`. Обратите внимание, что при именовании элементов оператор инициализации кортежа просто присваивает именованным элементам значения переменных с одинаковыми именами.

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#1)]

Поскольку элементы и переменные имеют одинаковое имя, компилятор Visual Basic может вывести имена полей, как показано в следующем примере.

[!code-vb[ExplicitlyNamed](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

Чтобы включить выводимые имена элементов кортежа, необходимо определить версию компилятора Visual Basic для использования в файле проекта Visual Basic (\*. vbproj):

```xml
<PropertyGroup>
  <LangVersion>15.3</LangVersion>
</PropertyGroup>
```

Номер версии может быть любой версией компилятора Visual Basic, начиная с 15,3. Вместо того чтобы жестко программировать конкретную версию компилятора, можно также указать "latest" в качестве значения `LangVersion` для компиляции с последней версией компилятора Visual Basic, установленного в системе.

Дополнительные сведения см. [в разделе Задание версии языка Visual Basic](../../../language-reference/configure-language-version.md).

В некоторых случаях компилятор Visual Basic не может определить имя элемента кортежа из имени кандидата, а на поле кортежа можно ссылаться только по имени по умолчанию, например `Item1`, `Item2`и т. д. К ним относятся:

- Имя кандидата совпадает с именем элемента кортежа, например `Item3`, `Rest`или `ToString`.

- Имя кандидата дублируется в кортеже.

При сбое определения имени поля Visual Basic не создает ошибку компилятора, а во время выполнения не создается исключение. Вместо этого на поля кортежа должны ссылаться их предопределенные имена, такие как `Item1` и `Item2`.

## <a name="tuples-versus-structures"></a>Кортежи и структуры

Visual Basic кортеж — это тип значения, который является экземпляром одного из универсальных типов **System. ValueTuple** . Например, `holiday` кортеж, определенный в предыдущем примере, является экземпляром структуры <xref:System.ValueTuple%603>. Она разработана как облегченный контейнер для данных. Поскольку кортеж предназначен для упрощения создания объекта с несколькими элементами данных, в нем отсутствуют некоторые функции, которые могут иметься в пользовательской структуре. К ним относятся следующие методы.

- Пользовательские элементы. Нельзя определить собственные свойства, методы или события для кортежа.

- Проверка. Невозможно проверить данные, назначенные полям.

- Неизменяемости. Visual Basic кортежи являются изменяемыми. В отличие от этого, пользовательская структура позволяет контролировать, является ли экземпляр изменяемым или неизменяемым.

Если важны пользовательские члены, проверка свойств и полей или неизменность, следует использовать инструкцию Visual Basic [Structure](../../../language-reference/statements/structure-statement.md) для определения пользовательского типа значения.

Visual Basicный кортеж наследует члены его типа **ValueTuple** . Помимо полей, в их число входят следующие методы.

| Член | Описание |
| ---|---|
| CompareTo | Сравнивает текущий кортеж с другим кортежем с тем же количеством элементов. |
| Равно | Определяет, равен ли текущий кортеж другому кортежу или объекту. |
| GetHashCode | Вычисляет хэш-код для текущего экземпляра. |
| ToString | Возвращает строковое представление этого кортежа, которое принимает форму `(Item1, Item2...)`, где `Item1` и `Item2` представляют значения полей кортежа. |

Кроме того, типы **ValueTuple** реализуют интерфейсы <xref:System.Collections.IStructuralComparable> и <xref:System.Collections.IStructuralEquatable>, которые позволяют определять компараторы клиентов.

## <a name="assignment-and-tuples"></a>Назначение и кортежи

Visual Basic поддерживает присваивание между типами кортежей, которые имеют одинаковое число полей. Типы полей можно преобразовать, если выполняется одно из следующих условий.

- Исходное и целевое поля имеют один и тот же тип.

- Определено расширяющее (или неявное) преобразование исходного типа в целевой тип.

- `Option Strict` `On`и определено суженное (или явное) преобразование исходного типа в целевой тип. Это преобразование может вызвать исключение, если исходное значение находится за пределами диапазона целевого типа.

Другие преобразования в контексте назначений не учитываются. Рассмотрим возможные виды назначений между типами кортежей.

В приведенных ниже примерах можно использовать указанные переменные:

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#1)]

Первые две переменные, `unnamed` и `anonymous`, не имеют семантических имен, предоставленных для полей. Их имена полей являются `Item1` по умолчанию и `Item2`. Последние две переменные, `named` и `differentName` имеют семантические имена полей. Обратите внимание на то, что поля в этих двух кортежах называются по-разному.

Все четыре из этих кортежей имеют одинаковое число полей (называемое арностью), а типы этих полей идентичны. Таким образом, все эти назначения работают:

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#2)]

Обратите внимание на то, что имена кортежей не назначаются. Значения полей назначаются в соответствии с порядком полей в кортеже.

Наконец, обратите внимание, что можно присвоить `named` кортежу `conversion`ному кортежу, несмотря на то, что первое поле `named` — это `Integer`, а первое поле `conversion` — `Long`. Это назначение выполнено, так как преобразование `Integer` в `Long` является расширяющим преобразованием.

[!code-vb[Assign](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple3.vb#3)]

Кортежи с разными числами полей не могут быть назначены:

```vb
' Does not compile.
' VB30311: Value of type '(Integer, Integer, Integer)' cannot be converted
'          to '(Answer As Integer, Message As String)'
var differentShape = (1, 2, 3)
named = differentShape
```

## <a name="tuples-as-method-return-values"></a>Кортежи как возвращаемые значения методов

Метод может возвращать только одно значение. Однако часто требуется, чтобы вызов метода возвращал несколько значений. Существует несколько способов обойти это ограничение:

- Можно создать пользовательский класс или структуру, свойства или поля которой представляют значения, возвращаемые методом. Таким решением является высокоплотное решение; для этого необходимо определить пользовательский тип, предназначенный только для извлечения значений из вызова метода.

- Можно вернуть одно значение из метода и вернуть оставшиеся значения, передав их по ссылке к методу. Это включает дополнительные издержки при создании экземпляра переменной и риск непреднамеренной перезаписи значения переменной, которую вы передаете по ссылке.

- Можно использовать кортеж, который предоставляет упрощенное решение для извлечения нескольких возвращаемых значений.

Например, методы **TryParse** в .NET возвращают `Boolean` значение, указывающее, была ли операция анализа успешной. Результат операции синтаксического анализа возвращается в переменную, передаваемой по ссылке на метод. Как правило, вызов метода синтаксического анализа, например <xref:System.Int32.TryParse%2A?displayProperty=nameWithType>, выглядит следующим образом:

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#1)]

Мы можем вернуть кортеж из операции синтаксического анализа, если заключить вызов метода <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> в собственный метод. В следующем примере `NumericLibrary.ParseInteger` вызывает метод <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> и возвращает именованный кортеж с двумя элементами.

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

Затем можно вызвать метод с помощью следующего кода:

[!code-vb[Return](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

## <a name="visual-basic-tuples-and-tuples-in-the-net-framework"></a>Visual Basic кортежи и кортежи в .NET Framework

Visual Basic кортеж — это экземпляр одного из универсальных типов **System. ValueTuple** , которые появились в .NET Framework 4,7. .NET Framework также включает набор универсальных классов **System. Tuple** . Однако эти классы отличаются от Visual Basic кортежей и универсальных типов **System. ValueTuple** несколькими способами:

- Элементы классов **кортежей** — это свойства с именами `Item1`, `Item2`и т. д. В Visual Basic кортежах и типах **ValueTuple** элементы кортежа являются полями.

- Нельзя присваивать осмысленные имена элементам экземпляра **кортежа** или экземпляра **ValueTuple** . Visual Basic позволяет назначать имена, которые сообщают значение полей.

- Свойства экземпляра **кортежа** доступны только для чтения; кортежи являются неизменяемыми. В Visual Basic кортежах и типах **ValueTuple** поля кортежей доступны для чтения и записи. кортежи являются изменяемыми.

- Универсальные типы **кортежей** являются ссылочными типами. Использование этих типов **кортежей** означает выделение объектов. В критических путях это может заметно влиять на производительность приложения. Visual Basic кортежи и типы **ValueTuple** являются типами значений.

Методы расширения в классе <xref:System.TupleExtensions> упрощают преобразование между Visual Basicными кортежами и объектами **кортежей** .NET. Метод **тотупле** преобразует кортеж Visual Basic в объект **кортежа** .NET, а метод **товалуетупле** преобразует объект **кортежа** .NET в кортеж Visual Basic.

В следующем примере создается кортеж, преобразуется в объект **кортежа** .NET и преобразуется обратно в Visual Basic кортеж. Затем в примере сравнивается этот кортеж с исходным, чтобы убедиться, что он равен.

[!code-vb[Convert](../../../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple2.vb#1)]

## <a name="see-also"></a>См. также

- [Справочник по языку Visual Basic](index.md)
