---
title: Вызов свойства или метода с помощью строкового имени
ms.date: 07/20/2015
helpviewer_keywords:
- passing operators [Visual Basic]
- strings [Visual Basic], passing new operators as
- objects [Visual Basic], setting properties
- setting properties, object properties at run time
- method calls [Visual Basic], strings
- methods [Visual Basic], calling with string names
- calling methods [Visual Basic], string names
- properties [Visual Basic], setting at run time
- CallByName function
ms.assetid: 79a7b8b4-b8c7-4ad8-aca8-12a9a2b32f03
ms.openlocfilehash: cb584f0dfbd905ca071f9a86b1eab231f3017538
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74345211"
---
# <a name="calling-a-property-or-method-using-a-string-name-visual-basic"></a>Вызов свойства или метода с помощью строкового имени (Visual Basic)
В большинстве случаев можно обнаружить свойства и методы объекта во время разработки и написать код для их обработки. Однако в некоторых случаях вам не известно о свойствах и методах объекта заранее, или вам может потребоваться гибкость, позволяющая пользователю указывать свойства или выполнять методы во время выполнения.  
  
## <a name="callbyname-function"></a>Функция CallByName  
 Рассмотрим, например, клиентское приложение, которое оценивает выражения, вводимых пользователем, передавая оператор в COM-компонент. Предположим, что вы постоянно добавляете новые функции в компонент, требующий новых операторов. При использовании методов доступа к стандартным объектам необходимо перекомпилировать и повторно распространить клиентское приложение, прежде чем оно сможет использовать новые операторы. Чтобы избежать этого, можно использовать функцию `CallByName` для передачи новых операторов в виде строк без изменения приложения.  
  
 Функция `CallByName` позволяет использовать строку для указания свойства или метода во время выполнения. Сигнатура для функции `CallByName` выглядит следующим образом:  
  
 *Результат* = `CallByName`(*Object*, *ProcedureName*, *каллтипе*, *arguments*())  
  
 Первый аргумент, *объект*, принимает имя объекта, с которым вы хотите работать. Аргумент *ProcedureName* принимает строку, содержащую имя метода или процедуры свойства, которые необходимо вызвать. Аргумент *каллтипе* принимает константу, представляющую тип вызываемой процедуры: метод (`Microsoft.VisualBasic.CallType.Method`), свойство read (`Microsoft.VisualBasic.CallType.Get`) или набор свойств (`Microsoft.VisualBasic.CallType.Set`). Аргумент *arguments* , который является необязательным, принимает массив типа `Object`, который содержит аргументы для процедуры.  
  
 В текущем решении можно использовать `CallByName` с классами, но чаще всего они используются для доступа к COM-объектам или объектам из сборок .NET Framework.  
  
 Предположим, что вы добавили ссылку на сборку, содержащую класс с именем `MathClass`, который содержит новую функцию с именем `SquareRoot`, как показано в следующем коде:  
  
 [!code-vb[VbVbalrOOP#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#53)]  
  
 Приложение может использовать элементы управления "текстовое поле" для управления тем, какой метод будет вызываться, и его аргументы. Например, если `TextBox1` содержит вычисляемое выражение, а `TextBox2` используется для ввода имени функции, можно использовать следующий код для вызова функции `SquareRoot` в выражении в `TextBox1`:  
  
 [!code-vb[VbVbalrOOP#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#54)]  
  
 Если ввести "64" в `TextBox1`, "SquareRoot" в `TextBox2`, а затем вызвать процедуру `CallMath`, вычисляется квадратный корень числа в `TextBox1`. Код в примере вызывает функцию `SquareRoot` (которая принимает строку, содержащую выражение, которое должно быть оценено как обязательный аргумент) и возвращает значение "8" в `TextBox1` (квадратный корень из 64). Конечно, если пользователь вводит недопустимую строку в `TextBox2`, если строка содержит имя свойства вместо метода или если метод имел дополнительный обязательный аргумент, возникает ошибка времени выполнения. Необходимо добавить надежный код обработки ошибок при использовании `CallByName`, чтобы предвидеть эти или любые другие ошибки.  
  
> [!NOTE]
> Хотя функция `CallByName` может быть полезной в некоторых случаях, необходимо оценить ее полезность относительно влияния на производительность — использование `CallByName` для вызова процедуры немного медленнее, чем вызов с поздним связыванием. При вызове функции, которая вызывается многократно, например внутри цикла, `CallByName` может сильно влиять на производительность.  
  
## <a name="see-also"></a>См. также

- <xref:Microsoft.VisualBasic.Interaction.CallByName%2A>
- [Определение типа объекта](../../../../visual-basic/programming-guide/language-features/early-late-binding/determining-object-type.md)
