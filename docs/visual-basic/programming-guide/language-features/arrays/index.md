---
title: Массивы в Visual Basic
ms.date: 12/06/2017
f1_keywords:
- vb.Array
helpviewer_keywords:
- arrays [Visual Basic]
- Visual Basic, arrays
ms.assetid: dbf29737-b589-4443-bee6-a27588d9c67e
ms.openlocfilehash: f8bd0f3eed8599f7f9e316df8274e8204a69c48f
ms.sourcegitcommit: 35316b768394e56087483cde93f854ba607b63bc
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/26/2018
ms.locfileid: "52297456"
---
# <a name="arrays-in-visual-basic"></a>Массивы в Visual Basic

Массив — это набор значений, которые называются *элементы*, которая логически связаны друг с другом. Например массив может содержать число учеников в каждом классе школы; Каждый элемент массива представляет число учеников в одном классе. Аналогичным образом массив может состоять из оценок учащихся для класса; Каждый элемент массива является один уровень.

Это возможно отдельные переменные для хранения всех элементов данных. Например, если наше приложение анализирует оценок учащихся, можно использовать отдельную переменную для каждого учащегося, такие как `englishGrade1`, `englishGrade2`и т. д. Такой подход имеет три основные ограничения:

- Нам нужно знать во время разработки, точно сколько оценок, нам нужно обработать.
- Обработкой большого количества уровней быстро становится слишком громоздким. В свою очередь, это делает гораздо более вероятно, иметь серьезные неполадки приложения.
- Это трудно поддерживать. Каждый новый корпоративного класса, который мы добавим требует, что приложение можно изменить, повторной компиляции и повторного развертывания.

С помощью массива, можно ссылаться на эти связанные значения по тем же именем и использовать число, которое называется *индекс* или *индекс* для идентификации отдельного элемента по его позиции в массиве. Индексы массива в диапазоне от 0 на единицу меньше, чем общее число элементов в массиве. При использовании Visual Basic синтаксис для определения размера массива, необходимо указать наибольшего индекса, не общее число элементов в массиве. Вы можете работать с массив как единое и возможность выполнять итерацию его элементы избавляет от необходимости знать точно сколько элементов во время разработки.

Несколько простых примеров перед подробным описанием:

```vb
' Declare a single-dimension array of 5 numbers.
Dim numbers(4) As Integer

'Declare a single-dimension array and set its 4 values.
Dim numbers = New Integer() {1, 2, 4, 8}

' Change the size of an existing array to 16 elements and retain the current values.
ReDim Preserve numbers(15)

' Redefine the size of an existing array and reset the values.
ReDim numbers(15)

' Declare a 6 x 6 multidimensional array.
Dim matrix(5, 5) As Double

' Declare a 4 x 3 multidimensional array and set array element values.
Dim matrix = New Integer(3, 2) {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}}

' Declare a jagged array
Dim sales()() As Double = New Double(11)() {}
```

## <a name="array-elements-in-a-simple-array"></a>Элементы простого массива

Давайте создадим массив, именуемый `students` для хранения число учеников в каждом классе школы. Индексы элементов находятся в диапазоне от 0 до 6. Используя этот массив проще, чем объявлять семь отдельных переменных.

На следующем рисунке показано `students` массива. Для каждого элемента массива:

- индекс элемента представляет школьный класс (индекс 0 представляет детский сад);

- значение, содержащееся в элементе, представляет число учеников в этом классе.

![Изображение массива, отображающее количество студентов](../../language-features/arrays/media/arrayexampleschool.gif "ArrayExampleSchool") элементов массива «students»

Следующий пример содержит код Visual Basic, который создает и использует массив:

[!code-vb[simple-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/simple-array.vb)]

Пример выполняет три действия:

- Объявляет `students` массив в семь элементов. Номер `6` в массиве объявление указывает последнего индекса в массиве; это одна меньше, чем число элементов в массиве.
- Он назначает значения для каждого элемента в массиве. Элементы массива осуществляется с помощью имени массива, включая индекс отдельного элемента в скобках.
- В ней перечислены каждого значения в массиве. В примере используется [ `For` ](../../../language-reference/statements/for-next-statement.md) инструкцию, чтобы получить доступ к каждому элементу массива по номеру индекса.

`students` Массива в предыдущем примере используется одномерный массив, так как оно использует один индекс. Массив, который использует более чем одного индекса называется *многомерные*. Дополнительные сведения см. в оставшейся части этой статьи и [Array Dimensions in Visual Basic](../../language-features/arrays/array-dimensions.md).

## <a name="creating-an-array"></a>Создание массива

Размер массива можно определить несколькими способами:

- Можно указать размер при объявлении массива:

  [!code-vb[creating1](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#1)]

- Можно использовать `New` предложение, чтобы указать размер массива, при его создании:

  [!code-vb[creating2](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#2)]

Если у вас есть существующий массив, можно переопределить его размер с помощью [ `Redim` ](../../../language-reference/statements/redim-statement.md) инструкции. Можно указать, что `Redim` инструкции сохранить значения, содержащиеся в массиве, или можно указать, что он создаст пустой массив. В приведенном ниже примере показаны различные варианты использования оператора `Redim` для изменения размера существующего массива.

[!code-vb[redimensioning](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#3)]

Дополнительные сведения см. в разделе [оператор ReDim](../../../language-reference/statements/redim-statement.md).

## <a name="storing-values-in-an-array"></a>Сохранение значений в массиве

К любой позиции в массиве можно получить доступ, используя индекс типа `Integer`. Вы можете сохранять и извлекать значения массива, ссылаясь на позицию в нем с помощью индекса, заключенного в скобки. Индексы для многомерных массивов разделяются запятыми (,). Для каждого измерения массива требуется один индекс.

Приведенный ниже показаны некоторые операторы, которые хранят и извлекают значения в массивах.

[!code-vb[store-and-retrieve](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/store-and-retrieve.vb)]

## <a name="populating-an-array-with-array-literals"></a>Заполнение массива с помощью литералов массива

С помощью литерала массива, в то же время его создания можно заполнить массив с начальным набором значений. Литерал массива состоит из списка разделенных запятыми значений, заключенных в фигурные скобки (`{}`).

При создании массива с помощью литерала массива можно либо указать тип массива, либо использовать определение типа для задания типа массива. В следующем примере оба варианта.

[!code-vb[create-with-literals](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#4)]

При использовании вывода типа тип массива определяется *главным типом* в список литеральных значений. Главным типом является тип, к которому могут быть расширены все другие типы в массиве. Если такой уникальный тип нельзя определить, то главным будет тип, до которого можно сузить все другие типы массива. Если ни один из указанных уникальных типов нельзя определить, главным типом будет `Object`. Например, если список значений для литерала массива содержит значения типов `Integer`, `Long`и `Double`, результирующий массив будет иметь тип `Double`. Так как `Integer` и `Long` расширяются только до `Double`, `Double` является главным типом. Для получения дополнительной информации см. [Widening and Narrowing Conversions](../../language-features/data-types/widening-and-narrowing-conversions.md).

> [!NOTE]
> Вывод типа можно использовать только для массивов, которые определены как локальные переменные в члена типа. Если отсутствует определение явный тип, массивы, определенные с помощью литералов массива на уровне класса имеют тип `Object[]`. Дополнительные сведения см. в разделе [вывод локального типа](../variables/local-type-inference.md).

Обратите внимание, что в предыдущем примере определяется `values` как массив объектов типа `Double` несмотря на то, что все литералы массива имеют тип `Integer`. Вы можете создать этот массив, поскольку значений в литерале массива могут быть расширены `Double` значения.

Можно также создать и заполнить многомерного массива с помощью *вложенные литералы массива*. Вложенные литералы массива должен иметь несколько измерений, результирующему массиву. В следующем примере создается двухмерный массив целых чисел с помощью вложенных литералов массива.

[!code-vb[nested-array-literals](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#5)]

При использовании вложенных литералов массива для создания и заполнения массива, если количество элементов в вложенные литералы массива не совпадают, возникает ошибка. Ошибка также возникает в том случае, если вы явно объявить переменную массива иметь различное количество измерений, чем литералы массива.

Так же, как для одномерных массивов, можно полагаться на определение типа при создании многомерного массива с помощью вложенных литералов массива. Выведенный тип является главным типом для всех значений всех литералов массива все уровень вложенности. В следующем примере создается двухмерный массив типа `Double[,]` из значения, которые относятся к типу `Integer` и `Double`.

[!code-vb[nested-type-inference](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#6)]

Дополнительные примеры можно найти в статье [How to: Initialize an Array Variable in Visual Basic](../../language-features/arrays/how-to-initialize-an-array-variable.md) (Практическое руководство. Инициализация переменной массива в Visual Basic).

## <a name="iterating-through-an-array"></a>Перебор массива

При переборе массива вы доступ к каждому элементу в массиве от наименьшего индекса и заканчивая самым верхним или от самого высокого до самого низкого. Как правило, использовать [для... Следующий оператор](../../../language-reference/statements/for-next-statement.md) или [для каждого... Следующий оператор](../../../language-reference/statements/for-each-next-statement.md) для перебора элементов в массиве. Если вы не знаете верхние границы массива, можно вызвать <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> метод для получения наивысшее значение индекса. Несмотря на то, что почти является наименьшее значение индекса всегда равно 0, можно вызвать <xref:System.Array.GetLowerBound%2A?displayProperty=nameWithType> метод для получения наименьшее значение индекса.

Следующий пример перебор одномерного массива с помощью [ `For...Next` ](../../../language-reference/statements/for-next-statement.md) инструкции.

[!code-vb[iterate-one-dimensional-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate1d.vb)]

Следующий пример перебор многомерного массива с помощью [ `For...Next` ](../../../language-reference/statements/for-next-statement.md) инструкции. Метод <xref:System.Array.GetUpperBound%2A> имеет параметр, который определяет измерение. `GetUpperBound(0)` Возвращает наибольший индекс первого измерения, и `GetUpperBound(1)` Возвращает наибольший индекс во втором измерении.

[!code-vb[iterate-two-dimensional-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate2d.vb)]

В следующем примере используется [для каждого... Следующий оператор](../../../language-reference/statements/for-each-next-statement.md)для перебора одномерного массива и двумерным массивом.

[!code-vb[iterate-for-each-next](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate-for-each-next.vb)]

## <a name="array-size"></a>Размер массива

Размер массива является произведением длин всех его измерений. Он представляет собой общее число элементов, в данный момент содержащихся в массиве.  Например в следующем примере объявляется двумерный массив с четырьмя элементами в каждом измерении. Как видно из примера, размер массива равен 16 (или (3 + 1) * (3 + 1).

[!code-vb[array-size](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/array-size.vb)]

> [!NOTE]
> В этом рассказе о размер массива не применяется к массивы массивов. Сведения о массивов массивов и определения размера массива массивов, см. в разделе [ступенчатые массивы](#jagged-arrays) раздел.

Размер массива можно определить с помощью свойства <xref:System.Array.Length%2A?displayProperty=nameWithType>. Длину каждого измерения многомерного массива можно найти с помощью <xref:System.Array.GetLength%2A?displayProperty=nameWithType> метод.

Можно изменять размер переменной массива можно назначить новый объект массива к нему, или с помощью [ `ReDim` инструкции](../../../language-reference/statements/redim-statement.md) инструкции. В следующем примере используется `ReDim` инструкцию, чтобы изменить это 100-элементный массив к массиву 51-элемент.

[!code-vb[resize-an-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/array-size2.vb)]

Существует ряд особенностей, о которых следует помнить при работе с размером массива.

|||
|---|---|
|Длина измерения|Индекс каждого измерения начинается с 0, это означает, что он диапазоне от 0 до верхней границы. Таким образом длина данного измерения является один больше его объявленной верхней границы этого измерения.|
|Ограничения длины|Длина каждого измерения массива ограничена максимальное значение `Integer` тип данных, который является <xref:System.Int32.MaxValue?displayProperty=nameWithType> или (2 ^ 31) - 1. Однако общий размер массива также ограничен доступной памятью в системе. Если вы попытаетесь инициализировать массив, размер которого превышает объем доступной памяти, среда выполнения создает <xref:System.OutOfMemoryException>.|
|Размер и размер элемента|Размер массива не зависит от типа его элементов. Размер всегда представляет общее число элементов, не число байтов, занимаемое в памяти.|
|Затраты памяти|Небезопасно делать какие-либо предположения относительно способа хранения массива в памяти. Хранение зависит от разрядности платформы, поэтому один и тот же массив может занимать больше памяти в 64-разрядных системах, чем в 32-разрядных. В зависимости от конфигурации системы при инициализации массива среда CLR может использовать такие способы хранения, как упаковка элементов максимально близко друг к другу или выравнивание всех элементов по естественным аппаратным границам памяти. Кроме того, массив нуждается в хранении служебной информации, и размер этой информации возрастает при добавлении каждого измерения.|

## <a name="the-array-type"></a>Тип массива

Каждый массив имеет тип данных, который отличается от типа данных его элементов. Не существует единого типа данных, подходящего для всех массивов. Вместо этого тип данных массива определяется числом измерений ( *рангом*) массива и типом данных его элементов. Две переменные массивов имеют те же данные типа, только если они имеют тот же ранг, и их элементы имеют одинаковый тип данных. Длины измерений массива не влияют на тип данных массива.

Каждый массив наследуется от класса <xref:System.Array?displayProperty=nameWithType>, и вы можете объявить переменную типа `Array`, но не можете создать массив типа `Array`. Например несмотря на то, что в следующем коде объявляется `arr` переменную типа `Array` и вызывает <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType> метод для создания экземпляра массива, тип массива оказывается Object [].

[!code-vb[array-class](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/array-class.vb)]

Кроме того, [оператор ReDim`Array` не может работать с переменной, объявленной с типом ](../../../language-reference/statements/redim-statement.md). По этим причинам и целях строгой типизации рекомендуется объявлять каждый массив как конкретный тип.

Выяснить тип данных массива или его элементов можно несколькими способами.

- Можно вызвать <xref:System.Object.GetType%2A> метод для переменной, чтобы получить <xref:System.Type> , представляющий тип времени выполнения переменной. Объект <xref:System.Type> содержит подробные сведения в своих свойствах и методах.
- Можно передать переменную <xref:Microsoft.VisualBasic.Information.TypeName%2A> функцию для получения `String` с имя типа времени выполнения.

В следующем примере вызывается оба `GetType` метод и `TypeName` функцию, чтобы определить тип массива. Тип массива — `Byte(,)`. Обратите внимание, что <xref:System.Type.BaseType%2A?displayProperty=nameWithType> свойство также указывает, что базовый тип массива байтов <xref:System.Array> класса.

[!code-vb[array-type](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/array-type.vb)]

## <a name="arrays-as-return-values-and-parameters"></a>Массивы как возвращаемые значения и параметры

Чтобы вернуть массив из процедуры `Function`, укажите тип данных массива и число измерений в качестве типа возвращаемого значения [оператора Function](../../../language-reference/statements/function-statement.md). Внутри функции объявите локальную переменную массива с тем же числом измерений и типом данных. В [оператор Return](../../../language-reference/statements/return-statement.md) включите локальную переменную массива без скобок.

Чтобы задать массив в качестве параметра процедуры `Sub` или `Function` , определите параметр как массив с указанными типом данных и количеством измерений. В вызове процедуры передайте переменную массива с тем же типом данных и количеством измерений.

В следующем примере `GetNumbers` возвращает `Integer()`, одномерный массив типа `Integer`. Процедура `ShowNumbers` принимает аргумент `Integer()` .

[!code-vb[return-value-and-params](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/return-values-and-params.vb)]

В следующем примере `GetNumbersMultiDim` возвращает `Integer(,)`, двухмерный массив типа `Integer`.  Процедура `ShowNumbersMultiDim` принимает аргумент `Integer(,)` .

[!code-vb[multidimensional-return-value](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/return-values-and-params-2d.vb)]

## <a name="jagged-arrays"></a>Массивы массивов

Иногда структура данных в приложении является двухмерной, но не прямоугольной. Например можно использовать массив для хранения данных о высокой температуре каждого дня месяца. Первого измерения массива, представляющее месяц, но во втором измерении представляет количество дней, и число дней в месяц не универсальный код. Объект *массив массивов*, также называемый *массив массивов*, предназначен для таких сценариев. Массив массивов — это массив, элементы которого также являются массивами. Массив массивов и каждый элемент в нем могут иметь одно или несколько измерений.

В следующем примере используется массив месяцев, каждый элемент которого представляет собой массив дней. В примере используется массив массивов, поскольку в разных месяцах различное количество дней.  В примере показано создание массива массивов, присвоения значений и получение и отображение его значения.

[!code-vb[jagged-arrays](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged.vb)]

Предыдущий пример присваивает значения массива массивов на основе элемента с помощью `For...Next` цикла. Можно также назначить значения к элементам массива массивов с помощью вложенных литералов массива. Однако попытка использовать вложенные литералы массива (например, ```Dim valuesjagged = {{1, 2}, {2, 3, 4}}```) возникает ошибка компилятора [BC30568](../../../,,/../misc/bc30568.md). Чтобы исправить эту ошибку, необходимо заключите внутренние литералы массива в круглые скобки. Круглые скобки заставляют вычисляемое выражение литерала массива, а полученные значения используются со внешним литералом массива, как показано в следующем примере.

[!code-vb[jagged-array-initialization](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged-assign.vb)]

Массив массивов используется одномерный массив, элементы которого содержат массивов. Таким образом <xref:System.Array.Length%2A?displayProperty=nameWithType> свойство и `Array.GetLength(0)` метод возвращает число элементов в одномерном массиве, и `Array.GetLength(1)` вызывает <xref:System.IndexOutOfRangeException> так, как массив массивов не является многомерным. Количество элементов в каждом подмассиве определяется путем получения значения каждого подмассива <xref:System.Array.Length%2A?displayProperty=nameWithType> свойство. Следующий пример иллюстрирует способ определить количество элементов в массиве массивов.

[!code-vb[jagged-array-size](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged-length.vb)]

## <a name="zero-length-arrays"></a>Массивы нулевой длины

Visual Basic различает неинициализированный массив (массив, значение которого равно `Nothing`) и *массив нулевой длины* или пустой массив (массив, не содержит элементов.) Неинициализированный массив — это приложения, не была распределена элементам или все значения, назначенного ему его. Пример:

```vb
Dim arr() As String
```

Массив нулевой длины объявлен с имеют измерение -1. Пример:

```vb
Dim arrZ(-1) As String
```

Массив нулевой длины может потребоваться создать в указанных ниже случаях.

- Без риска <xref:System.NullReferenceException> исключение, код должен получить доступ к членам <xref:System.Array> класс, например <xref:System.Array.Length%2A> или <xref:System.Array.Rank%2A>, или вызов функции Visual Basic, такие как <xref:Microsoft.VisualBasic.Information.UBound%2A>.

- Вы хотите сохранить простой код, не выполняя проверку `Nothing` как особый случай.

- Код взаимодействует с интерфейсом API, который требует передачи массива нулевой длины в одну или несколько процедур или возвращает массив нулевой длины из одной или нескольких процедур.

## <a name="splitting-an-array"></a>Разделение массив

В некоторых случаях может потребоваться разделить массив на несколько массивов. Это включает в себя определение точки или точек, в которых массив предназначен для разбиения, а затем spitting массива в двух или более отдельных массива.

> [!NOTE]
> В этом разделе не рассматривается Разделение одной строки в массив строк на основе некоторых разделителя. Сведения о разделение строки, см. в разделе <xref:System.String.Split%2A?displayProperty=nameWithType> метод.

Приведены наиболее общие критерии для разделения массив.

- Количество элементов в массиве. Например можно разбить на ряд примерно равные части больше, чем указанное число элементов массива. Для этой цели можно использовать значение, возвращенное либо <xref:System.Array.Length%2A?displayProperty=nameWithType> или <xref:System.Array.GetLength%2A?displayProperty=nameWithType> метод.

- Значение элемента, который служит в качестве разделителя, который указывает, где должны разбиваться массива. Можно искать конкретное значение путем вызова <xref:System.Array.FindIndex%2A?displayProperty=nameWithType> и <xref:System.Array.FindLastIndex%2A?displayProperty=nameWithType> методы.

Определив индекс или индексы, в которых должна быть разбита в массиве, затем можно создать отдельные массивы, вызвав <xref:System.Array.Copy%2A?displayProperty=nameWithType> метод.

Следующий пример разделяет массив на два массива приблизительно одинакового размера. (Если нечетное число элементов массива, первый массив содержит один элемент больше, чем второй.)

[!code-vb[splitting-an-array-by-length](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/split1.vb)]

Следующий пример разделяет массив строк, в зависимости от наличия элемента, значение которого равно «zzz», который служит в качестве разделителя массивов два массива. Новые массивы не включают элемент, содержащий разделитель.

[!code-vb[splitting-an-array-by-delimiter](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/split2.vb)]

## <a name="joining-arrays"></a>Объединение массивов

Можно также объединять несколько массивов в один массив большего размера. Чтобы сделать это, можно также использовать <xref:System.Array.Copy%2A?displayProperty=nameWithType> метод.

> [!NOTE]
> В этом разделе не рассматривается присоединение массив строк в одну строку. Сведения о соединении массив строк, см. в разделе <xref:System.String.Join%2A?displayProperty=nameWithType> метод.

Перед копированием элементы каждого массива в новый массив, необходимо сначала убедиться, что при инициализации массива, чтобы он был достаточно большим, чтобы accompodate новый массив. Это можно сделать одним из двух способов.

- Используйте [ `ReDim Preserve` ](../../../language-reference/statements/redim-statement.md) инструкцию, чтобы динамически расширяться массива, прежде чем добавлять новые элементы к нему. Это самый простой способ, но его может вызвать снижение производительности и чрезмерного потребления памяти при копировании больших массивов.
- Вычислить общее число элементов, необходимых для нового большого массива, а затем добавить в него элементы каждого исходного массива.

В следующем примере во втором подходе используется для добавления четырех массивов с использованием десять элементов в единый массив.

[!code-vb[joining-an-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/join.vb)]

Так как в этом случае исходные массивы все невелики, мы можем также динамически расширить массив мы будем добавлять элементы каждого нового массива к нему. Эту задачу решает следующий код.

[!code-vb[joining-an-array-dynamically](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/join2.vb)]

## <a name="collections-as-an-alternative-to-arrays"></a>Коллекции как альтернатива массивам

Массивы удобнее всего использовать для создания фиксированного числа строго типизированных объектов и работы с ними. Коллекции предоставляют более гибкий способ работы с группами объектов. В отличие от массивов, который требует явного изменения размера массива с [ `ReDim` инструкции](../../../language-reference/statements/redim-statement.md), коллекции увеличиваться и уменьшаться динамически при необходимости изменения приложения.

При использовании `ReDim` для размерность массива, Visual Basic создает новый массив и освобождает предыдущий. Это занимает время выполнения. Таким образом Если количество элементов, которым вы работаете с изменяется часто или нельзя предсказать максимальное число необходимых элементов, обычно будет получить более высокую производительность с помощью коллекции.

Некоторые коллекции допускают назначение ключа любому объекту, который добавляется в коллекцию, чтобы в дальнейшем можно было быстро извлечь связанный с ключом объект из коллекции.

Если коллекция содержит элементы только одного типа данных, можно использовать один из классов в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType> . Универсальная коллекция обеспечивает строгую типизацию, так что в нее нельзя добавить другие типы данных.

Более подробную информацию о коллекциях см. в статье [Коллекции](../../concepts/collections.md).

## <a name="related-topics"></a>См. также

|Термин|Определение|
|----------|----------------|
|[Array Dimensions in Visual Basic](../../language-features/arrays/array-dimensions.md)|Объяснение ранга и измерений в массиве.|
|[How to: Initialize an Array Variable in Visual Basic](../../language-features/arrays/how-to-initialize-an-array-variable.md) (Практическое руководство. Инициализация переменной массива в Visual Basic)|Описывается заполнение массивов начальными значениями.|
|[How to: Sort An Array in Visual Basic](../../language-features/arrays/how-to-sort-an-array.md) (Практическое руководство. Сортировка массива в Visual Basic)|Показано, как сортировать элементы массива в алфавитном порядке.|
|[Практическое руководство. Присвоение одного массива другому](../../language-features/arrays/how-to-assign-one-array-to-another-array.md)|Описываются правила и действия для присвоения массива другой переменной массива.|
|[Устранение неполадок, связанных с массивами](../../language-features/arrays/troubleshooting-arrays.md)|Рассматриваются некоторые общие проблемы, возникающие при работе с массивами.|

## <a name="see-also"></a>См. также

- <xref:System.Array?displayProperty=nameWithType>
- [Оператор Dim](../../../language-reference/statements/dim-statement.md)
- [Оператор reDim](../../../language-reference/statements/redim-statement.md)
