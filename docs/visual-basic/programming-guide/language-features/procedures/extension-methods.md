---
title: Методы расширения
ms.date: 07/20/2015
f1_keywords:
- vb.ExtensionMethods
helpviewer_keywords:
- extending data types [Visual Basic]
- extension methods [Visual Basic]
ms.assetid: b8020aae-374d-46a9-bcb7-8cc2390b93b6
ms.openlocfilehash: a88756fce9137f89db1b6b8b007d528e98381830
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74341173"
---
# <a name="extension-methods-visual-basic"></a>Методы расширения (Visual Basic)

Методы расширения позволяют разработчикам добавлять пользовательские функции к типам данных, которые уже определены без создания нового производного типа. Методы расширения позволяют написать метод, который может вызываться, как если бы он был методом экземпляра существующего типа.

## <a name="remarks"></a>Заметки

Метод расширения может быть только `Sub` процедурой или `Function`ой процедурой. Невозможно определить свойство, поле или событие расширения. Все методы расширения должны быть помечены атрибутом расширения `<Extension>` из пространства имен <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> и должны быть определены в [модуле](../../../language-reference/statements/module-statement.md). Если метод расширения определен за пределами модуля, Visual Basic компилятор создает ошибку [BC36551](../../../misc/bc36551.md), "методы расширения могут быть определены только в модулях".

Первый параметр в определении метода расширения указывает тип данных, который расширяет метод. При выполнении метода первый параметр привязывается к экземпляру типа данных, который вызывает метод.

Атрибут `Extension` можно применить только к Visual Basic [`Module`](../../../language-reference/statements/module-statement.md), [`Sub`](../../../language-reference/statements/sub-statement.md)или [`Function`](../../../language-reference/statements/function-statement.md). Если применить его к `Class` или `Structure`, компилятор Visual Basic создает ошибку [BC36550](../../../language-reference/error-messages/extension-attribute-can-be-applied-only-to-module-sub-or-function-declarations.md), атрибут "Extension" может применяться только к объявлениям "Module", "" или "Function".

## <a name="example"></a>Пример

В следующем примере определяется расширение `Print` для <xref:System.String>ного типа данных. Метод использует `Console.WriteLine` для вывода строки. Параметр метода `Print`, `aString`, устанавливает, что метод расширяет класс <xref:System.String>.

[!code-vb[VbVbalrExtensionMethods#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/StringExtensions.vb#1)]

Обратите внимание, что определение метода расширения помечено атрибутом расширения `<Extension()>`. Маркировка модуля, в котором определен метод, является необязательной, но каждый метод расширения должен быть помечен. чтобы получить доступ к атрибуту расширения, необходимо импортировать <xref:System.Runtime.CompilerServices>.

Методы расширения могут объявляться только внутри модулей. Как правило, модуль, в котором определен метод расширения, не совпадает с модулем, в котором он вызывается. Вместо этого модуль, содержащий метод расширения, импортируется, если требуется, чтобы перевести его в область. После того как модуль, содержащий `Print`, находится в области, метод можно вызвать так, как если бы он был обычным методом экземпляра, не принимающим аргументов, например `ToUpper`:

[!code-vb[VbVbalrExtensionMethods#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class1.vb#2)]

Следующий пример, `PrintAndPunctuate`, также является расширением для <xref:System.String>, на этот раз определенное с двумя параметрами. Первый параметр, `aString`, устанавливает, что метод расширения расширяет <xref:System.String>. Второй параметр, `punc`, должен быть строкой знаков препинания, которая передается в качестве аргумента при вызове метода. Метод отображает строку, за которой следуют знаки пунктуации.

[!code-vb[VbVbalrExtensionMethods#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class2.vb#3)]

Метод вызывается путем отправки строкового аргумента для `punc`: `example.PrintAndPunctuate(".")`

В следующем примере показаны `Print` и `PrintAndPunctuate` определен и вызывается. <xref:System.Runtime.CompilerServices> импортируется в модуль определения, чтобы обеспечить доступ к атрибуту расширения.

```vb
Imports System.Runtime.CompilerServices

Module StringExtensions

    <Extension()>
    Public Sub Print(aString As String)
        Console.WriteLine(aString)
    End Sub

    <Extension()>
    Public Sub PrintAndPunctuate(aString As String, punc As String)
        Console.WriteLine(aString & punc)
    End Sub
End Module
```

Далее методы расширения переносятся в область и называются:

```vb
Imports ConsoleApplication2.StringExtensions

Module Module1

    Sub Main()
        Dim example As String = "Example string"
        example.Print()

        example = "Hello"
        example.PrintAndPunctuate(".")
        example.PrintAndPunctuate("!!!!")
    End Sub
End Module
```

Все, что необходимо для выполнения этих или аналогичных методов расширения, заключается в том, что они находятся в области. Если модуль, содержащий метод расширения, находится в области видимости, он отображается в IntelliSense и может быть вызван как обычный метод экземпляра.

Обратите внимание, что при вызове методов для первого параметра не отправляется ни один аргумент. Параметр `aString` в предыдущих определениях метода привязан к `example`, экземпляр `String`, который вызывает их. Компилятор будет использовать `example` в качестве аргумента, отправляемого в первый параметр.

Если метод расширения вызывается для объекта, для которого задано значение `Nothing`, метод расширения выполняется. Это не относится к обычным методам экземпляра. Можно явно проверить наличие `Nothing` в методе расширения.

## <a name="types-that-can-be-extended"></a>Типы, которые могут быть расширены

Можно определить метод расширения для большинства типов, которые могут быть представлены в списке параметров Visual Basic, включая следующие:

- Классы (ссылочные типы)
- Структуры (типы значений)
- Интерфейсы
- Делегаты
- Аргументы ByRef и ByVal
- Параметры универсального метода
- Массивы

Поскольку первый параметр указывает тип данных, который расширяет метод расширения, он является обязательным и не может быть необязательным. По этой причине `Optional` параметры и параметры `ParamArray` не могут быть первым параметром в списке параметров.

Методы расширения не рассматриваются в позднем связывании. В следующем примере инструкция `anObject.PrintMe()` вызывает исключение <xref:System.MissingMemberException>, то же самое исключение отображается, если было удалено второе определение метода расширения `PrintMe`.

[!code-vb[VbVbalrExtensionMethods#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class6.vb#9)]

## <a name="best-practices"></a>Рекомендации

Методы расширения предоставляют удобный и мощный способ расширения существующего типа. Тем не менее, чтобы использовать их успешно, необходимо учитывать некоторые моменты. Эти рекомендации относятся главным образом к авторам библиотек классов, но они могут повлиять на любое приложение, использующее методы расширения.

Чаще всего методы расширения, добавляемые к несобственным типам, более уязвимы, чем методы расширения, добавляемые к управляемым типам. В несобственных классах могут возникать некоторые вещи, которые могут повлиять на методы расширения.

- Если существует любой доступный член экземпляра, имеющий сигнатуру, совместимую с аргументами в вызывающей инструкции, без сужающих преобразований из аргумента в параметр, метод экземпляра будет использоваться в качестве предпочтений любому методу расширения. Таким образом, если в какой-то момент в классе добавляется соответствующий метод экземпляра, существующий член расширения, который вы используете, может стать недоступным.

- Автор метода расширения не может препятствовать написанию другими программистами конфликтующих методов расширения, которые могут иметь приоритет над исходным расширением.

- Надежность можно повысить, поместив методы расширения в собственное пространство имен. Потребители библиотеки могут добавить пространство имен или исключить ее, или выбрать пространства имен отдельно от остальной части библиотеки.

- Расширение интерфейсов может быть более безопасным, чем расширение классов, особенно если вы не владеете интерфейсом или классом. Изменение интерфейса влияет на каждый класс, реализующий его. Таким образом, автор может снизить вероятность добавления или изменения методов в интерфейсе. Однако если класс реализует два интерфейса, у которых есть методы расширения с одинаковой сигнатурой, то ни один из методов расширения не виден.

- Расширьте наиболее конкретный тип, который можно. В иерархии типов при выборе типа, от которого наследуются многие другие типы, существуют уровни возможностей для введения методов экземпляра или других методов расширения, которые могут мешать работе.

## <a name="extension-methods-instance-methods-and-properties"></a>Методы расширения, методы экземпляров и свойства

Если метод экземпляра в области имеет сигнатуру, совместимую с аргументами вызывающей инструкции, метод экземпляра выбирается в качестве предпочтений любому методу расширения. Метод экземпляра имеет приоритет, даже если метод расширения лучше соответствует. В следующем примере `ExampleClass` содержит метод экземпляра с именем `ExampleMethod` с одним параметром типа `Integer`. Метод расширения `ExampleMethod` расширяет `ExampleClass`и имеет один параметр типа `Long`.

[!code-vb[VbVbalrExtensionMethods#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class4.vb#4)]

Первый вызов `ExampleMethod` в следующем коде вызывает метод расширения, так как `arg1` `Long` и совместим только с параметром `Long` в методе расширения. Второй вызов `ExampleMethod` имеет `Integer`ный аргумент `arg2`и вызывает метод экземпляра.

[!code-vb[VbVbalrExtensionMethods#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class4.vb#5)]

Теперь измените типы данных параметров в двух методах:

[!code-vb[VbVbalrExtensionMethods#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class5.vb#6)]

На этот раз код в `Main` вызывает метод экземпляра в обоих случаях. Это происходит потому, что как `arg1`, так и `arg2` имеют расширяющее преобразование для `Long`, а метод экземпляра имеет приоритет над методом расширения в обоих случаях.

[!code-vb[VbVbalrExtensionMethods#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Class5.vb#7)]

Поэтому метод расширения не может заменить существующий метод экземпляра. Однако, если метод расширения имеет то же имя, что и метод экземпляра, но подписи не конфликтуют, доступ к обоим методам возможен. Например, если класс `ExampleClass` содержит метод с именем `ExampleMethod`, который не принимает аргументы, методы расширения с тем же именем, но с разными сигнатурами разрешены, как показано в следующем коде.

[!code-vb[VbVbalrExtensionMethods#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExtensionMethods/VB/Module3.vb#8)]

Результат выполнения этого кода выглядит следующим образом:

```console
Extension method
Instance method
```

Ситуация упрощается с помощью свойств: Если метод расширения имеет то же имя, что и свойство класса, который он расширяет, метод расширения не будет виден и к нему нельзя получить доступ.

## <a name="extension-method-precedence"></a>Приоритет метода расширения

Если два метода расширения, имеющие идентичные сигнатуры, находятся в области видимости и доступны, будет вызван один из них с более высоким приоритетом. Приоритет метода расширения основан на механизме, который используется для приведения метода в область. В следующем списке показана иерархия очередностью, от самого высокого до самого низкого.

1. Методы расширения, определенные в текущем модуле.

2. Методы расширения, определенные внутри типов данных в текущем пространстве имен или на любом из его родителей, с дочерними пространствами имен с более высоким приоритетом, чем у родительских пространств имен.

3. Методы расширения, определенные внутри любых импортов типов в текущем файле.

4. Методы расширения, определенные в любом импорте пространства имен в текущем файле.

5. Методы расширения, определенные внутри любых импортов типа на уровне проекта.

6. Методы расширения, определенные внутри любых импортов пространства имен на уровне проекта.

Если приоритет не позволяет устранить неоднозначность, можно использовать полное имя, чтобы указать вызываемый метод. Если метод `Print` в предыдущем примере определен в модуле с именем `StringExtensions`, полное имя будет `StringExtensions.Print(example)` вместо `example.Print()`.

## <a name="see-also"></a>См. также

- <xref:System.Runtime.CompilerServices>
- <xref:System.Runtime.CompilerServices.ExtensionAttribute>
- [Методы расширения](../../../../csharp/programming-guide/classes-and-structs/extension-methods.md)
- [Оператор Module](../../../language-reference/statements/module-statement.md)
- [Параметры и аргументы процедуры](procedure-parameters-and-arguments.md)
- [Необязательные параметры](optional-parameters.md)
- [Массивы параметров](parameter-arrays.md)
- [Обзор атрибутов](../../concepts/attributes/index.md)
- [Область в Visual Basic](../declared-elements/scope.md)
