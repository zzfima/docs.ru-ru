---
title: Процедуры устранения неполадок
ms.date: 07/20/2015
helpviewer_keywords:
- troubleshooting Visual Basic, procedures
- procedures [Visual Basic], troubleshooting
- Visual Basic code, procedures
- troubleshooting procedures
- procedures [Visual Basic], about procedures
ms.assetid: 525721e8-2e02-4f75-b5d8-6b893462cf2b
ms.openlocfilehash: 8d4c4929e299efb12d283492a101c18ae794110b
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2019
ms.locfileid: "74352517"
---
# <a name="troubleshooting-procedures-visual-basic"></a>Процедуры устранения неполадок (Visual Basic)

На этой странице перечислены некоторые распространенные проблемы, которые могут возникнуть при работе с процедурами.  
  
## <a name="returning-an-array-type-from-a-function-procedure"></a>Возвращение типа массива из процедуры функции

Если `Function` процедура возвращает тип данных массива, то нельзя использовать имя `Function` для хранения значений в элементах массива. Если вы попытаетесь сделать это, компилятор интерпретирует его как вызов `Function`. Следующий пример приводит к возникновению ошибок компилятора:
  
```vb
Function AllOnes(n As Integer) As Integer()
   For i As Integer = 1 To n - 1  
      ' The following statement generates a COMPILER ERROR.  
      AllOnes(i) = 1  
   Next  

   ' The following statement generates a COMPILER ERROR.  
   Return AllOnes()  
End Function
```

Инструкция `AllOnes(i) = 1` создает ошибку компилятора, так как она вызывает `AllOnes` с аргументом неверного типа данных (скалярный `Integer` вместо массива `Integer`). Инструкция `Return AllOnes()` создает ошибку компилятора, так как она вызывает `AllOnes` без аргументов.  
  
 **Правильный подход:** Чтобы иметь возможность изменять элементы возвращаемого массива, определите внутренний массив как локальную переменную. Следующий пример компилирует без ошибок:

 [!code-vb[VbVbcnProcedures#66](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#66)]

## <a name="argument-not-modified-by-procedure-call"></a>Аргумент не изменен вызовом процедуры

Если вы хотите разрешить процедуре изменять программный элемент, лежащий в основе аргумента в вызывающем коде, необходимо передать его по ссылке. Но процедура может обращаться к элементам аргумента ссылочного типа, даже если она передается по значению.

- **Базовая переменная**. Чтобы разрешить процедуре заменить значение самого базового элемента переменной, процедура должна объявить параметр [ByRef](../../../language-reference/modifiers/byref.md). Кроме того, вызывающий код не должен заключать аргумент в круглые скобки, так как это переопределит механизм передачи `ByRef`.

- **Элементы ссылочного типа**. При объявлении параметра [ByVal](../../../language-reference/modifiers/byval.md)процедура не может изменить сам базовый элемент переменной. Однако если аргумент является ссылочным типом, процедура может изменить члены объекта, на который он указывает, даже если она не может заменить значение переменной. Например, если аргумент является переменной массива, процедура не может присвоить ей новый массив, но может изменить один или несколько его элементов. Измененные элементы отражаются в базовой переменной массива вызывающего кода.

В следующем примере определяются две процедуры, которые принимают переменную массива по значению и работают с ее элементами. Процедура `increase` просто добавляет по одному для каждого элемента. Процедура `replace` присваивает новый массив параметру `a()` а затем добавляет его к каждому элементу. Однако переназначение не влияет на базовую переменную массива в вызывающем коде, так как `a()` объявлена как `ByVal`.

[!code-vb[VbVbcnProcedures#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#35)]

[!code-vb[VbVbcnProcedures#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#38)]

В следующем примере выполняется вызов `increase` и `replace`.

[!code-vb[VbVbcnProcedures#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#37)]
  
Первый вызов `MsgBox` выводит "после увеличения (n): 11, 21, 31, 41". Поскольку `n` является ссылочным типом, `increase` может изменять его члены, даже если он передается `ByVal`.

Во втором вызове `MsgBox` отображается "After Replace (n): 11, 21, 31, 41". Поскольку `n` передается `ByVal`, `replace` не может изменить переменную `n`, назначив ей новый массив. Когда `replace` создает новый экземпляр массива `k` и присваивает его локальной переменной `a`, он теряет ссылку на `n`, переданный вызывающим кодом. При увеличении числа членов `a`затрагивается только локальный `k` массива.

**Правильный подход:** Чтобы иметь возможность изменять сам базовый элемент переменной, передайте его по ссылке. В следующем примере показано изменение в объявлении `replace`, которое позволяет заменить один массив другим в вызывающем коде:

[!code-vb[VbVbcnProcedures#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#64)]

## <a name="unable-to-define-an-overload"></a>Не удалось определить перегрузку

Если необходимо определить перегруженную версию процедуры, необходимо использовать то же имя, но другую сигнатуру. Если компилятор не может отличить объявление от перегрузки с той же сигнатурой, выдается ошибка.

*Сигнатура* процедуры определяется именем процедуры и списком параметров. Каждая перегрузка должна иметь то же имя, что и все остальные перегрузки, но должна отличаться от всех, хотя бы в одном из других компонентов сигнатуры. Дополнительные сведения см. в разделе [Procedure Overloading](./procedure-overloading.md).

Следующие элементы, даже если они относятся к списку параметров, не являются компонентами сигнатуры процедуры:

- Ключевые слова модификаторов процедур, такие как `Public`, `Shared`и `Static`.
- Имена параметров.
- Ключевые слова модификаторов параметров, такие как `ByRef` и `Optional`.
- Тип данных возвращаемого значения (за исключением оператора преобразования).

Невозможно перегрузить процедуру, изменив только один или несколько предыдущих элементов.

**Правильный подход:** Чтобы иметь возможность определить перегрузку процедуры, необходимо изменить сигнатуру. Поскольку необходимо использовать одно и то же имя, необходимо изменить число, порядок или типы данных параметров. В универсальной процедуре можно изменить количество параметров типа. В операторе преобразования ([Функция CType](../../../language-reference/functions/ctype-function.md)) можно изменить тип возвращаемого значения.

### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a>Разрешение перегрузки с необязательными и аргументами ParamArray

При перегрузке процедуры с одним или несколькими [необязательными](../../../language-reference/modifiers/optional.md) параметрами или параметром [ParamArray](../../../language-reference/modifiers/paramarray.md) необходимо избегать дублирования каких-либо *неявных перегрузок*. Дополнительные сведения см. [в разделе рекомендации по перегрузке процедур](./considerations-in-overloading-procedures.md).

## <a name="calling-the-wrong-version-of-an-overloaded-procedure"></a>Вызов неверной версии перегруженной процедуры

Если процедура имеет несколько перегруженных версий, необходимо ознакомиться со всеми их списками параметров и понять, как Visual Basic разрешает вызовы между перегрузками. В противном случае можно вызвать перегрузку, отличную от предполагаемой.

Если вы определили, какую перегрузку нужно вызвать, обратите внимание на следующие правила.

- Укажите правильное число аргументов и в правильном порядке.  
- В идеале аргументы должны иметь те же типы данных, что и соответствующие параметры. В любом случае тип данных каждого аргумента должен быть расширен до соответствующего параметра. Это справедливо даже в том случае, если для [Option-Statement](../../../language-reference/statements/option-strict-statement.md) задано значение `Off`. Если перегрузка требует какого-либо суженного преобразования из списка аргументов, то эта перегрузка не может вызываться.
- Если указать аргументы, требующие расширения, сделайте их типы данных максимально близкими к соответствующим типам данных параметров. Если две или более перегрузки принимают типы данных аргумента, компилятор разрешает вызов перегрузки, которая вызывает для наименьшего объема расширяющего значения.

Можно уменьшить вероятность несоответствия типов данных с помощью ключевого слова преобразования [функции CType](../../../language-reference/functions/ctype-function.md) при подготовке аргументов.

### <a name="overload-resolution-failure"></a>Сбой разрешения перегрузки

При вызове перегруженной процедуры компилятор пытается устранить все перегрузки, кроме одной. Если он будет выполнен, он разрешает вызов этой перегрузки. Если он исключает все перегрузки или не может уменьшить подходящие перегрузки для одного кандидата, выдается ошибка.

В следующем примере показан процесс разрешения перегрузки.

[!code-vb[VbVbcnProcedures#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#62)]

[!code-vb[VbVbcnProcedures#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#63)]
  
При первом вызове компилятор удаляет первую перегрузку, поскольку тип первого аргумента (`Short`) ограничивается типом соответствующего параметра (`Byte`). Затем он исключает третью перегрузку, поскольку каждый тип аргумента во второй перегрузке (`Short` и `Single`) расширяется до соответствующего типа в третьей перегрузке (`Integer` и `Single`). Вторая перегрузка требует меньшего расширения, поэтому компилятор использует его для вызова.

Во втором вызове компилятор не может исключить ни одну из перегрузок на основе понижающие. Он исключает третью перегрузку по той же причине, что и при первом вызове, так как она может вызвать вторую перегрузку с меньшим расширением типов аргументов. Однако компилятор не может выполнить разрешение между первой и второй перегрузками. Каждый из них имеет один определенный тип параметра, который расширяется до соответствующего типа в другом (`Byte` для `Short`, но `Single` в `Double`). Поэтому компилятор создает ошибку разрешения перегрузки.

**Правильный подход:** Чтобы иметь возможность вызывать перегруженную процедуру без неоднозначности, используйте [функцию CType](../../../language-reference/functions/ctype-function.md) для сопоставления типов данных аргумента с типами параметров. В следующем примере показан вызов `z`, который вызывает принудительное разрешение для второй перегрузки.

[!code-vb[VbVbcnProcedures#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnProcedures/VB/Class1.vb#65)]

### <a name="overload-resolution-with-optional-and-paramarray-arguments"></a>Разрешение перегрузки с необязательными и аргументами ParamArray

Если две перегрузки процедуры имеют идентичные сигнатуры, за исключением того, что последний параметр объявлен как [Optional](../../../language-reference/modifiers/optional.md) в одном и [ParamArray](../../../language-reference/modifiers/paramarray.md) в другой, компилятор разрешает вызов этой процедуры в соответствии с ближайшим соответствием. Дополнительные сведения см. в разделе [Overload Resolution](./overload-resolution.md).

## <a name="see-also"></a>См. также

- [Процедуры](index.md)
- [Подпрограммы](sub-procedures.md)
- [Процедуры функций](function-procedures.md)
- [Процедуры свойств](property-procedures.md)
- [Процедуры операторов](operator-procedures.md)
- [Параметры и аргументы процедуры](procedure-parameters-and-arguments.md)
- [Перегрузка процедур](procedure-overloading.md)
- [Вопросы, связанные с перегрузкой процедур](considerations-in-overloading-procedures.md)
- [Разрешение перегрузки](overload-resolution.md)
