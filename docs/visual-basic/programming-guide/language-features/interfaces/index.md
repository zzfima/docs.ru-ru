---
title: "Интерфейсы (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "2015-07-20"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.topic: "article"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "интерфейсы"
  - "интерфейсы [Visual Basic]"
  - "интерфейсы, Visual Basic"
  - "код Visual Basic, интерфейсы"
ms.assetid: 61b06674-12c9-430b-be68-cc67ecee1f5b
caps.latest.revision: 11
author: "stevehoag"
ms.author: "shoag"
caps.handback.revision: 11
---
# Интерфейсы (Visual Basic)
[!INCLUDE[vs2017banner](../../../../visual-basic/includes/vs2017banner.md)]

*Интерфейсы* определяют свойства, методы и события, которые можно реализовать в классах.  Интерфейсы позволяют определить функции в виде небольших групп тесно связанных свойств, методов и событий. Это снижает число проблем совместимости, так как можно создавать усовершенствованные реализации интерфейсов без изменения существующего кода.  Вы можете добавлять новые функции в любое время с помощью дополнительных интерфейсов и реализаций.  
  
 Далее представлены другие причины, из\-за которых вам может потребоваться использовать интерфейсы вместо наследования классов.  
  
-   Интерфейсы более удобны в ситуациях, в которых приложениям требуется множество возможно несвязанных типов объектов для предоставления определенных возможностей.  
  
-   Интерфейсы более гибкие, чем базовые классы, так как вы можете определить одну реализацию, в которой можно реализовать несколько интерфейсов.  
  
-   Интерфейсы предпочтительнее в случаях, в которых нет необходимости наследовать реализацию базового класса.  
  
-   Интерфейсы полезны, когда невозможно использовать наследование класса.  Например, структуры не могут наследовать от классов, но они могут реализовывать интерфейсы.  
  
## Объявление интерфейсов  
 Определения интерфейса заключаются в операторы `Interface` и `End Interface`.  После оператора `Interface` можно добавить необязательный оператор `Inherits`, в котором указывается один или несколько наследуемых интерфейсов.  Операторы `Inherits` должны предшествовать всем другим операторам в объявлении, за исключением комментариев.  Остальными операторами в определении интерфейса должны быть `Event`, `Sub`, `Function`, `Property`, `Interface`, `Class`, `Structure` и `Enum`.  Интерфейсы не могут содержать код реализаций или операторы, связанные с кодом реализации, такие как `End Sub` и `End Property`.  
  
 В пространстве имен операторы интерфейса по умолчанию относятся к типу `Friend`, но также их можно явно объявить как `Public` или `Friend`.  Интерфейсы, определенные в классах, модулях, интерфейсах и структурах по умолчанию объявлены как `Public`, но их также можно явно объявить как `Public`, `Friend`, `Protected` и `Private`.  
  
> [!NOTE]
>  Ключевое слово `Shadows` может применяться ко всем элементам интерфейса.  Ключевое слово `Overloads` слово может применяться к операторам `Sub`, `Function`, и `Property`, объявленным в определении интерфейса.  Кроме того, операторы `Property` могут содержать модификаторы `Default`, `ReadOnly` и `WriteOnly`.  Другие модификаторы \(`Public`, `Private`, `Friend`, `Protected`, `Shared`, `Overrides`, `MustOverride` и `Overridable`\) не разрешены.  Подробнее: [Контексты объявления и уровни доступа по умолчанию](../../../../visual-basic/language-reference/statements/declaration-contexts-and-default-access-levels.md).  
  
 Например, в следующем примере кода определяется интерфейс с одной функцией, одним свойством и одним событием.  
  
 [!code-vb[VbVbalrOOP#17](../../../../visual-basic/misc/codesnippet/visualbasic/VbVbalrOOP/OOP.vb#17)]  
  
## Реализация интерфейсов  
 Зарезервированное слово [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb-md.md)] `Implements` используется двумя способами.  Оператор `Implements` означает, что класс или структура реализуют интерфейс.  Ключевое слово `Implements` указывает, что элемент класса или структуры реализует определенный элемент интерфейса.  
  
### Оператор Implements  
 Если класс или структура реализует один или несколько интерфейсов, они должны содержать оператор `Implements` сразу после оператора `Class` или `Structure`.  Оператору `Implements` требуется разделенный запятыми список интерфейсов, которые должны быть реализованы с помощью класса.  Структура или класс должны реализовать все элементы интерфейса с помощью ключевого слова `Implements`.  
  
### Ключевое слово Implements  
 Ключевому слову `Implements` требуется разделенный запятыми список элементов интерфейса, которые необходимо реализовать.  Как правило, указывается только один элемент интерфейса, но можно указать несколько элементов.  Спецификация элемента интерфейса состоит из имени интерфейса, которое должно быть указано в операторе implements внутри класса, точки и имени реализуемой функции\-члена, свойства или события.  В имени элемента, который реализует элемент интерфейса, может использоваться любой допустимый идентификатор — к нему не применяется соглашение `InterfaceName_MethodName`, используемое в более ранних версиях [!INCLUDE[vbprvb](../../../../csharp/programming-guide/concepts/linq/includes/vbprvb-md.md)].  
  
 Например, в следующем примере кода показано, как объявить подпрограмму с именем `Sub1`, в которой реализуется метод интерфейса:  
  
 [!code-vb[VbVbalrOOP#69](../../../../visual-basic/misc/codesnippet/visualbasic/VbVbalrOOP/OOP.vb#69)]  
  
 Типы параметров и возвращаемые типы элемента реализации должны соответствовать объявлению свойства или элемента в интерфейсе.  Наиболее распространенный способ реализации элемента интерфейса — использование элемента с таким же, как у интерфейса, именем, как показано в предыдущем примере.  
  
 Для объявления реализации метода интерфейса можно использовать любые атрибуты, которые допустимы в объявлении метода экземпляра, включая `Overloads`, `Overrides`, `Overridable`, `Public`, `Private`, `Protected`, `Friend`, `Protected Friend`, `MustOverride`, `Default` и `Static`.  Атрибут `Shared` недопустим, поскольку он определяет класс, а не метод экземпляра.  
  
 С помощью `Implements` можно также написать один метод, который реализует несколько методов, определенных в интерфейсе, как показано в следующем примере:  
  
 [!code-vb[VbVbalrOOP#70](../../../../visual-basic/misc/codesnippet/visualbasic/VbVbalrOOP/OOP.vb#70)]  
  
 Закрытый элемент можно использовать для реализации члена интерфейса.  Если закрытый член реализует член интерфейса, этот элемент становится доступен через интерфейс, хотя он недоступен напрямую через переменные класса.  
  
### Примеры реализации интерфейсов  
 Классы, реализующие интерфейс, должны реализовать все свойства, методы и события.  
  
 В примере ниже определены два интерфейса.  Второй интерфейс, `Interface2`, наследует `Interface1` и определяет дополнительное свойство и метод.  
  
 [!code-vb[VbVbalrOOP#39](../../../../visual-basic/misc/codesnippet/visualbasic/VbVbalrOOP/OOP.vb#39)]  
  
 В следующем примере реализуется `Interface1`, интерфейс, определенный в предыдущем примере:  
  
 [!code-vb[VbVbalrOOP#40](../../../../visual-basic/misc/codesnippet/visualbasic/VbVbalrOOP/OOP.vb#40)]  
  
 В последнем примере реализуется `Interface2`, включающий метод, унаследованный от `Interface1`:  
  
 [!code-vb[VbVbalrOOP#41](../../../../visual-basic/misc/codesnippet/visualbasic/VbVbalrOOP/OOP.vb#41)]  
  
 Можно реализовать свойство только для чтения со свойством, доступным для чтения и записи \(т. е. не нужно объявлять его свойством только для чтения в классе реализации\).  В реализации интерфейса должны быть по крайней мере реализованы элементы, которые объявляются интерфейсом, но можно обеспечить дополнительные возможности, например разрешить запись свойства.  
  
## См. также  
  
|Заголовок|Описание|  
|---------------|--------------|  
|[Пошаговое руководство. Создание и реализация интерфейсов](../../../../visual-basic/programming-guide/language-features/interfaces/walkthrough-creating-and-implementing-interfaces.md)|Содержит подробные процедуры, которые помогут вам определить и реализовать собственный интерфейс.|  
|[Вариативность в универсальных интерфейсах](../Topic/Variance%20in%20Generic%20Interfaces%20\(C%23%20and%20Visual%20Basic\).md)|В этом разделе описываются ковариация и контрвариация в универсальных интерфейсах, а также представлен список вариативных универсальных интерфейсов платформы .NET Framework.|