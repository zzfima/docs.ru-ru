---
title: "Различия между сокрытием и переопределением (Visual Basic) | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-visual-basic"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "VB"
helpviewer_keywords: 
  - "переопределение, в сравнении с затенением"
  - "затенение, в сравнении с переопределением"
ms.assetid: 2d014a0b-7630-407d-8f4e-24bd87987923
caps.latest.revision: 24
caps.handback.revision: 24
author: "stevehoag"
ms.author: "shoag"
manager: "wpickett"
---
# Различия между сокрытием и переопределением (Visual Basic)
[!INCLUDE[vs2017banner](../../../../csharp/includes/vs2017banner.md)]

При определении класса, который наследуется от базового класса, иногда требуется переопределить один или несколько элементов базового класса в производном классе.  Для этой цели используются переобъявление и переопределение.  
  
## Сравнение  
 И сокрытие, и переопределение используются при наследовании производного класса от базового. И то и другое замещает один объявленный элемент другим.  Но между этими двумя понятиями существуют значительные различия.  
  
 Следующая таблица представляет собой сравнение переобъявления и переопределения.  
  
||||  
|-|-|-|  
|Точка сравнения|Затенение|Переопределение|  
|Назначение|Защищает от последующей модификации базового класса, при которой включается уже определенный в производном классе член|Достижение полиморфизма за счет определения другой реализации процедуры или свойства с той же последовательностью вызова <sup>1</sup>|  
|Переопределяемый элемент|Объявленный элемент любого типа|Только процедура \(`Function`, `Sub` или `Operator`\) или свойство|  
|Переопределяющий элемент|Объявленный элемент любого типа|Только процедура или свойство с такой же последовательностью вызова <sup>1</sup>|  
|Уровень доступа для переопределения элемента|Любой уровень доступа|Невозможно изменить уровень доступа переопределяемого элемента|  
|Возможность чтения и записи переопределяющего элемента|В любой комбинации|Нельзя изменить возможность чтения и записи переопределяемого свойства|  
|Управление переопределением|Базовый класс элемента не может применять или запрещать переобъявление|Элемент базового класса может указывать `MustOverride`, `NotOverridable` или `Overridable`|  
|Использование ключевых слов|Рекомендуется использовать `Shadows` в производном классе. Если не указан ни `Shadows`, ни `Overrides`, то предполагается `Shadows`<sup>2</sup>|`Overridable` или `MustOverride` является обязательным в базовом классе. `Overrides` является обязательным в производном классе|  
|Наследование переопределяющих элементов классами, производными от производного класса|Переобъявляющий элемент наследуется последующими производными классами. Переобъявляемый элемент остается скрытым<sup>3</sup>|Переопределяющий элемент наследуется производными классами. Переопределяемый элемент остается переопределенным|  
  
 <sup>1</sup> *Последовательность вызова* состоит из типа элемента \(`Function`, `Sub`, `Operator` или `Property`\), имени, списка параметров и типа возвращаемого значения.  Нельзя переопределить процедуру свойством и наоборот.  Нельзя переопределить процедуру одного типа \(`Function`, `Sub` или `Operator`\) процедурой другого типа.  
  
 <sup>2</sup> Если не указан либо `Shadows`, либо `Overrides`, компилятор выдает предупреждающее сообщение, помогающее убедиться в том, какой типа переопределения требуется использовать.  Если проигнорировать предупреждение, используется механизм переобъявления.  
  
 <sup>3</sup> Если переопределяющий элемент оказывается недоступным в последующем производном классе, переобъявление не наследуется.  Например, если переобъявляющий элемент объявлен как `Private`, класс, полученный из производного класса, наследует первоначальный элемент вместо переобъявляющего.  
  
## Рекомендации  
 Переопределение обычно используется в следующих случаях:  
  
-   При определении полиморфизма производных классов.  
  
-   Требуется обеспечить принудительное использование компилятором идентичных типов элементов и последовательностей вызова.  
  
 Переобъявление обычно используется в следующих случаях:  
  
-   Предполагается, что базовый класс может быть изменен, и может быть определен элемент с аналогичным вашему элементу именем.  
  
-   Требуется свобода изменения типа элемента или последовательности вызова.  
  
## См. также  
 [Ссылки на объявленные элементы](../../../../visual-basic/programming-guide/language-features/declared-elements/references-to-declared-elements.md)   
 [Сокрытие в Visual Basic](../../../../visual-basic/programming-guide/language-features/declared-elements/shadowing.md)   
 [Практическое руководство. Сокрытие переменной с тем же именем, что и ваша переменная](../../../../visual-basic/programming-guide/language-features/declared-elements/how-to-hide-a-variable-with-the-same-name-as-your-variable.md)   
 [Практическое руководство. Сокрытие наследуемой переменной](../../../../visual-basic/programming-guide/language-features/declared-elements/how-to-hide-an-inherited-variable.md)   
 [Практическое руководство. Доступ к переменной, скрытой производным классом](../../../../visual-basic/programming-guide/language-features/declared-elements/how-to-access-a-variable-hidden-by-a-derived-class.md)   
 [Shadows](../../../../visual-basic/language-reference/modifiers/shadows.md)   
 [Overrides](../../../../visual-basic/language-reference/modifiers/overrides.md)