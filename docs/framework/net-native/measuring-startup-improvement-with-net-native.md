---
title: Измерение улучшения запуска с машинным кодом .NET
ms.date: 03/30/2017
ms.assetid: c4d25b24-9c1a-4b3e-9705-97ba0d6c0289
ms.openlocfilehash: 453159c3fd0590a1ed549bb7e6f8c171aac7d064
ms.sourcegitcommit: 7e2128d4a4c45b4274bea3b8e5760d4694569ca1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/14/2020
ms.locfileid: "75937739"
---
# <a name="measuring-startup-improvement-with-net-native"></a>Измерение улучшения запуска с машинным кодом .NET
.NET Native значительно улучшает время запуска приложений. Это улучшение особенно заметно на портативных устройствах малой мощности, а также при сложных приложениях. Этот раздел поможет вам приступить к работе с основным инструментарием, который необходим для измерения данного улучшения запуска.  
  
 Для облегчения анализа производительности, платформа.NET Framework и Windows используют платформу трассировки событий для Windows (ETW), которая позволяет приложениям уведомлять средства для работы при возникновении событий. Затем можно использовать инструмент PerfView для просмотра и анализа событий ЕТW. В этом разделе объясняется, как:  
  
- Использовать класс <xref:System.Diagnostics.Tracing.EventSource> для порождения событий.  
  
- Использовать PerfView для сбора событий.  
  
- Использовать PerfView для отображения событий.  
  
## <a name="using-eventsource-to-emit-events"></a>Использование EventSource для порождения событий  
 <xref:System.Diagnostics.Tracing.EventSource>предоставляет базовый класс для создания настраиваемого поставщика событий. Как правило, создается подкласс <xref:System.Diagnostics.Tracing.EventSource> и методы `Write*` помещаются в оболочку с вашими собственными методами событий. Обычно используется единый шаблон для каждого <xref:System.Diagnostics.Tracing.EventSource>.  
  
 Например, в следующем примере класс может использоваться для измерения двух характеристик производительности:  
  
- времени до вызова конструктора класса `App`.  
  
- времени до вызова конструктора класса `MainPage`.  
  
 [!code-csharp[ProjectN_ETW#1](../../../samples/snippets/csharp/VS_Snippets_CLR/projectn_etw/cs/etw1.cs#1)]  
  
 Здесь необходимо обратить внимание на несколько моментов. Во-первых, создается единственный элемент в `AppEventSource.Log`. Этот экземпляр будет использоваться для ведения журналов. Во-вторых, каждый метод событий имеет <xref:System.Diagnostics.Tracing.EventAttribute>. Это позволяет средствам для работы связать индекс метода <xref:System.Diagnostics.Tracing.EventSource.WriteEvent%2A> с методом, который был вызван на `AppEventSource`.  
  
 Обратите внимание, что эти события являются чисто иллюстративными. Большая часть кода приложения будет выполняться после этих событий. Следует понимать, какие события в коде соответствуют взаимодействию с пользователем, измерять их и улучшить их показатели. Кроме того, сами события заносят в журнал только один экземпляр за все время. Часто бывает полезно иметь пару начала и окончания событий для каждой операции. При проверке запуска приложения в качестве события запуска, как правило, используется событие "Process/Start" (Запуск процесса), которое порождает операционная система.  
  
 Например, предположим, что создается программа чтения RSS-каналов. Несколько интересных мест для занесения событий в журнал:  
  
- При первом отображении главной страницы.  
  
- При десериализации старой истории RSS из локального хранилища.  
  
- Когда приложение начинает синхронизацию новых историй.  
  
- Когда приложение завершило синхронизацию новых историй.  
  
 Инструментировать приложения очень просто: достаточно вызвать соответствующий метод в производном классе. С помощью `AppEventSource` из предыдущего примера можно инструментировать приложение следующим образом:  
  
 [!code-csharp[ProjectN_ETW#2](../../../samples/snippets/csharp/VS_Snippets_CLR/projectn_etw/cs/etw2.cs#2)]  
  
 После инструментирования приложения можно приступить к сбору событий.  
  
## <a name="gathering-events-with-perfview"></a>Сбор событий с PerfView  
 PerfView использует события ЕТW для облегчения выполнения всех видов анализа производительности приложения. Это средство также содержит графический интерфейс настройки, который позволяет включать и выключать ведение журнала для различных типов событий. Средство PerfView предоставляется бесплатно. Его можно скачать из [Центра загрузки Майкрософт](https://www.microsoft.com/download/details.aspx?id=28567). Дополнительные сведения см. в [обучающих видеороликах по PerfView](https://channel9.msdn.com/Series/PerfView-Tutorial).  
  
> [!NOTE]
> PerfView не может использоваться для сбора событий в системах ARM. Для сбора событий в системах ARM, используйте средство записи производительности Windows (WPR). Дополнительные сведения см. в [записи в блоге Вэнса Моррисона](https://docs.microsoft.com/archive/blogs/vancem/collecting-etwperfview-data-on-an-windows-rt-winrt-arm-surface-device).  
  
 PerfView также можно вызвать из командной строки. Чтобы занести в журнал только события своего поставщика, откройте окно командной строки и введите команду:  
  
```console
perfview -KernelEvents:Process -OnlyProviders:*MyCompany-MyApp collect outputFile   
```  
  
 Здесь:  
  
 `-KernelEvents:Process`  
 Указывает, что вам необходимо знать, когда процесс запускается и останавливается. Для приложения необходимо событие Process/Start, чтобы оно могло быть вычтено из времени других событий.  
  
 `-OnlyProviders:*MyCompany-MyApp`  
 Отключает других поставщиков, которые PerfView включает по умолчанию и включает поставщика MyCompany MyApp.  (Звездочка означает, что это <xref:System.Diagnostics.Tracing.EventSource>.)  
  
 `collect outputFile`  
 Указывает, что необходимо начать сбор и сохранение данных outputFile.etl.zip.  
  
 Выполнение приложения после запуска PerfView. Есть несколько моментов, которые необходимо помнить при запуске приложения.  
  
- Используйте построение выпуска, а не отладочное построение. Отладочные построения часто содержат проверку дополнительных ошибок и ошибок обработки кода, в результате чего приложение будет работать медленнее, чем ожидалось.  
  
- Выполнение приложений с подключенным отладчиком влияет на  его производительность.  
  
- Windows использует несколько стратегий кэширования, чтобы ускорить время запуска приложения. Если ваше приложение кэшировано в памяти и его не нужно загружать с диска, оно запускается быстрее. Для обеспечения согласованности, запустите и закройте приложение несколько раз перед его измерением.  
  
 После запуска приложения и завершения сбора данных о событиях в PerfView нажмите кнопку **Остановить сбор**. Как правило, следует остановить сбор перед закрытием приложения, чтобы не получить посторонних событий. Тем не менее, если измеряется быстродействия завершения работы или приостановки, будет необходимо продолжить сбор.  
  
## <a name="displaying-the-events"></a>Отображение событий  
 Чтобы просмотреть уже собранные события, откройте созданный файл .etl или. etl.zip в PerfView и нажмите кнопку **События**. К этому моменту ETW уже соберет информацию о большом количестве событий, в том числе о событиях из других процессов. Чтобы сузить ваш анализ на определенных измерениях, заполните следующие текстовые поля в представлении событий:  
  
- В поле **Фильтр процесса** укажите имя приложения (без ".exe").  
  
- В поле **Фильтр типов событий** укажите `Process/Start | MyCompany-MyApp`. Это задает фильтр событий из MyCompany MyApp и события Windows Kernel/Process/Start (Ядро/процесс/запуск).  
  
 Выберите все события, указанные в области слева (CTRL+A), и нажмите клавишу **ВВОД**. Теперь можно будет видеть метки времени каждого события. Эти метки времени измеряются относительно начала трассировки, поэтому следует вычесть время каждого события из времени запуска процесса, чтобы определить время, прошедшее с момента запуска. При использовании Ctrl + щелчок для выбора двух меток времени, вы увидите, что разница между ними отображается в строке состояния в нижней части страницы. Это позволяет легко увидеть время, прошедшее между любыми двумя событиями, на экране (включая запуск процесса). Можно открыть контекстное меню представления и выбрать различные полезные параметры, например, экспорт в файлы CSV или открытие Microsoft Excel для сохранения или обработки данных.  
  
 Повторяя процедуру для исходного приложения и версии, созданной с помощью цепочки инструментов .NET Native, можно сравнить разницу в производительности.   .NET Native приложения обычно запускаются быстрее, чем non-.NET собственные приложения. Если вы заинтересованы в более глубокой информации, то PerfView также может определить части кода, на выполнение которых уходит больше всего времени. Дополнительные сведения см. в [руководствах по PerfView](https://channel9.msdn.com/Series/PerfView-Tutorial) или в [записи в блоге Вэнса Моррисона](https://docs.microsoft.com/archive/blogs/vancem/publication-of-the-perfview-performance-analysis-tool).  
  
## <a name="see-also"></a>См. также:

- <xref:System.Diagnostics.Tracing.EventSource>
