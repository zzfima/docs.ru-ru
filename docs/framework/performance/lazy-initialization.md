---
title: Отложенная инициализация
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 54776304e484fc7f1db2c56b102034ed0e8650c0
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73130320"
---
# <a name="lazy-initialization"></a>Отложенная инициализация
*Отложенная инициализация* объекта означает, что его создание откладывается до первого использования. (В этом разделе термины « *ленивая» инициализация* и « *ленивое» создание экземпляра* являются синонимами.) Отложенная инициализация в основном используется для повышения производительности, предотвращения непроизводительна вычислений и сокращения требований к памяти программы. Ниже приведены наиболее распространенные сценарии.  
  
- При наличии объекта, создание которого требует много ресурсов и который, возможно, не будет использоваться программой. Например, предположим, что в памяти находится объект `Customer`, у которого есть свойство `Orders`, содержащее большой массив объектов `Order`, инициализация которых требует подключения к базе данных. Если пользователь никогда не отображает массив Orders и не использует его данные в расчетах, то нет смысла использовать системную память или такты процессора для создания этого массива. Используя `Lazy<Orders>`, чтобы объявить отложенную инициализацию объекта `Orders`, можно избежать расхода системных ресурсов на неиспользуемый объект.  
  
- При наличии объекта, требующее много ресурсов создание которого желательно отложить до завершения других ресурсоемких операций. Например, пусть программа во время запуска загружает несколько экземпляров объекта, но только часть из них требуется сразу. Можно повысить быстродействие программы при запуске, отложив инициализацию временно ненужных объектов до того, как они понадобятся.  
  
 Хотя вы можете написать свой код для выполнения отложенной инициализации, вместо этого рекомендуется использовать тип <xref:System.Lazy%601>. Тип <xref:System.Lazy%601> и связанные с ним типы также поддерживают безопасность потоков и обеспечивают согласованную политику распространения исключений.  
  
 В таблице ниже приведены типы, предоставляемые в .NET Framework версии 4 для поддержки отложенной инициализации в различных сценариях.  
  
|Type|Описание|  
|----------|-----------------|  
|<xref:System.Lazy%601>|Класс-оболочка, предоставляющий семантику отложенной инициализации для любого типа из библиотеки классов или пользовательского типа.|  
|<xref:System.Threading.ThreadLocal%601>|Похож на тип <xref:System.Lazy%601> за исключением того, что предоставляет семантику отложенной инициализации на основе локального потока. У каждого потока есть доступ к собственному уникальному значению.|  
|<xref:System.Threading.LazyInitializer>|Предоставляет расширенные методы `static` (`Shared` в Visual Basic) для отложенной инициализации объектов без дополнительных издержек для класса.|  
  
## <a name="basic-lazy-initialization"></a>Базовая отложенная инициализация  
 Чтобы определить тип с отложенной инициализацией, например `MyType`, используйте `Lazy<MyType>` (`Lazy(Of MyType)` в Visual Basic), как показано в следующем примере. Если в конструктор <xref:System.Lazy%601> не передается делегат, при первом доступе к свойству значения заключенный в оболочку тип создается с помощью <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>. Если у типа нет конструктора без параметров, возникает исключение времени выполнения.  
  
 В следующем примере предполагается, что `Orders` — это класс, содержащий массив объектов `Order`, извлекаемых из базы данных. Объект `Customer` содержит экземпляр `Orders`, но в зависимости от действий пользователя данные из объекта `Orders` могут и не понадобиться.  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 Можно также передать делегат в конструктор <xref:System.Lazy%601>, вызывающий во время создания особую перегруженную версию конструктора для заключенного в оболочку типа, и выполнить любые другие действия, необходимые для инициализации, как показано в следующем примере.  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 После создания объекта Lazy экземпляр `Orders` не создается до первого доступа к свойству <xref:System.Lazy%601.Value%2A> переменной Lazy. При первом доступе заключенный в оболочку тип создается, возвращается и сохраняется для любого использования в будущем.  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 Объект <xref:System.Lazy%601> всегда возвращает тот же объект или то же значение, которые использовались для его инициализации. Следовательно, свойство <xref:System.Lazy%601.Value%2A> доступно только для чтения. Если в свойстве <xref:System.Lazy%601.Value%2A> хранится ссылочный тип, нельзя присвоить этому свойству новый объект. (Однако можно изменить значения его устанавливаемых общих полей и свойств.) Если <xref:System.Lazy%601.Value%2A> сохраняет тип значения, изменить его значение нельзя. Тем не менее можно создать новую переменную, вызвав конструктор переменной еще раз с новыми аргументами.  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 Новый экземпляр с отложенной инициализацией, как и предыдущий, не будет инициализировать `Orders` до первого обращения к его свойству <xref:System.Lazy%601.Value%2A>.  
  
### <a name="thread-safe-initialization"></a>Потокобезопасная инициализация  
 По умолчанию объекты <xref:System.Lazy%601> являются потокобезопасными. То есть если конструктор не задает тип потокобезопасности, создаваемые им объекты <xref:System.Lazy%601> являются потокобезопасными. В сценариях с несколькими потоками первый поток, обращающийся к свойству <xref:System.Lazy%601.Value%2A> потокобезопасного объекта <xref:System.Lazy%601>, инициализирует его для всех последующих случаев доступа из всех потоков, и все потоки совместно используют одни и те же данные. Следовательно, неважно, какой поток инициализирует объект, и состояния гонки являются мягкими.  
  
> [!NOTE]
> Можно повысить эту устойчивость к ошибкам путем кэширования исключений. Дополнительные сведения см. в следующем разделе [Исключения в объектах с отложенной инициализацией](lazy-initialization.md#ExceptionsInLazyObjects).  
  
 В приведенном ниже примере показано, что один и тот же экземпляр `Lazy<int>` обладает одним и тем же значением для трех отдельных потоков.  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 Если для каждого потока требуются собственные данные, используйте тип <xref:System.Threading.ThreadLocal%601>, описанный в этом разделе ранее.  
  
 Некоторые конструкторы <xref:System.Lazy%601> обладают логическим параметром с именем `isThreadSafe`, используемым для определения того, будет ли свойство <xref:System.Lazy%601.Value%2A> доступно из нескольких потоков. Если предполагается, что свойство будет доступно только из одного потока, передайте значение `false`, чтобы получить небольшой выигрыш в быстродействии. Если предполагается доступ к свойству из нескольких потоков, передайте значение `true`, чтобы указать экземпляру <xref:System.Lazy%601> на необходимость правильно обрабатывать состояния гонки, в которых один поток создает исключение во время инициализации.  
  
 Некоторые конструкторы <xref:System.Lazy%601> имеют параметр <xref:System.Threading.LazyThreadSafetyMode> с именем `mode`. Эти конструкторы предоставляют дополнительный режим потокобезопасности. В приведенной ниже таблице показано, как на потокобезопасность объекта <xref:System.Lazy%601> влияют параметры конструктора, задающие потокобезопасность. Каждый конструктор имеет не более одного такого параметра.  
  
|Потокобезопасность объекта|Параметр `LazyThreadSafetyMode` `mode`|Логический параметр `isThreadSafe`|Без параметров потокобезопасности|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|Полностью потокобезопасный; только один поток пытается инициализировать значение в определенный момент времени.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Да.|  
|Не является потокобезопасным.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Неприменимо.|  
|Полностью потокобезопасный; потоки состязаются за право инициализации значения.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Неприменимо.|Неприменимо.|  
  
 Как показано в таблице, указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для параметра `mode` равносильно указанию `true` для параметра `isThreadSafe`, а указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> равносильно указанию `false`.  
  
 При указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> допускается, чтобы несколько потоков пытались инициализировать экземпляр <xref:System.Lazy%601>. Только один поток может выиграть это состязание, и все другие потоки получают значение, которое было инициализировано успешным потоком. Если во время инициализации в потоке создается исключение, этот поток не получает значение, установленное успешным потоком. Исключения не кэшируются, поэтому повторная попытка доступа к свойству <xref:System.Lazy%601.Value%2A> может привести к успешной инициализации. Это отличается от способа обработки исключений в других режимах, которые описаны в следующем разделе. Дополнительные сведения см. в описании перечисления <xref:System.Threading.LazyThreadSafetyMode>.  
  
<a name="ExceptionsInLazyObjects"></a>   
## <a name="exceptions-in-lazy-objects"></a>Исключения в объектах с отложенной инициализацией  
 Как упоминалось выше, объект <xref:System.Lazy%601> всегда возвращает тот же объект или то же значение, которые использовались для его инициализации, следовательно, свойство <xref:System.Lazy%601.Value%2A> доступно только для чтения. Если включено кэширование исключений, эта неизменность также распространяется на поведение исключений. Если в отложенно инициализированном объекте включено кэширование исключений и вызывается исключение из метода инициализации при первом доступе к свойству <xref:System.Lazy%601.Value%2A>, то это же исключение создается при каждой последующей попытке доступа к свойству <xref:System.Lazy%601.Value%2A>. Другими словами, конструктор заключенного в оболочку типа никогда не вызывается повторно даже в сценариях с несколькими потоками. Следовательно, объект <xref:System.Lazy%601> не может создавать исключение при одной попытке доступа и возвращать значение при последующих попытках доступа.  
  
 Кэширование исключений включено, если используется какой-либо конструктор <xref:System.Lazy%601?displayProperty=nameWithType>, принимающий метод инициализации (параметр `valueFactory`); например, оно включено при использовании конструктора `Lazy(T)(Func(T))`. Если конструктор также принимает значение <xref:System.Threading.LazyThreadSafetyMode> (параметр `mode`), укажите <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> или <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Указание метода инициализации включает кэширование исключений для этих двух режимов. Метод инициализации может быть очень простым. Например, он может вызвать конструктор без параметров для `T`: `new Lazy<Contents>(() => new Contents(), mode)` в C#или `New Lazy(Of Contents)(Function() New Contents())` в Visual Basic. Если вы используете конструктор <xref:System.Lazy%601?displayProperty=nameWithType>, который не указывает метод инициализации, исключения, вызываемые конструктором без параметров для `T`, не кэшируются. Дополнительные сведения см. в описании перечисления <xref:System.Threading.LazyThreadSafetyMode>.  
  
> [!NOTE]
> Если создается объект <xref:System.Lazy%601> с параметром конструктора `isThreadSafe`, установленным в значение `false`, или с параметром конструктора `mode`, установленным в значение <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, обращаться к объекту <xref:System.Lazy%601> необходимо из одного потока или обеспечить свою собственную синхронизацию. Это относится ко всем аспектам объекта, включая кэширование исключений.  
  
 Как отмечалось в предыдущем разделе, объекты <xref:System.Lazy%601>, созданные путем указания <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, обрабатывают исключения иначе. В случае с <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> за инициализацию экземпляра <xref:System.Lazy%601> могут конкурировать несколько потоков. В этом случае исключения не кэшируются, и попытки доступа к свойству <xref:System.Lazy%601.Value%2A> могут продолжаться до успешной инициализации.  
  
 В приведенной ниже таблице описывается способ, которым конструкторы <xref:System.Lazy%601> управляют кэшированием исключений.  
  
|Конструктор|Потокобезопасный режим|Использует метод инициализации|Исключения кэшируются|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|Lazy(T)()|(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)|Нет|Нет|  
|Lazy(T)(Func(T))|(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)|Да|Да|  
|Lazy(T)(Boolean)|`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) или `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)|Нет|Нет|  
|Lazy(T)(Func(T), Boolean)|`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) или `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)|Да|Да|  
|Lazy(T)(LazyThreadSafetyMode)|Указывается пользователем|Нет|Нет|  
|Lazy(T)(Func(T), LazyThreadSafetyMode)|Указывается пользователем|Да|Нет, если пользователь задает <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; в остальных случаях — да.|  
  
## <a name="implementing-a-lazy-initialized-property"></a>Реализация свойства с отложенной инициализацией  
 Для реализации открытого свойства с помощью отложенной инициализации определите резервное поле свойства как <xref:System.Lazy%601> и верните свойство <xref:System.Lazy%601.Value%2A> из метода доступа `get` этого свойства.  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 Свойство <xref:System.Lazy%601.Value%2A> доступно только для чтения, следовательно, у свойства, предоставляющего его, нет метода доступа `set`. Если требуется свойство для чтения и записи, резервируемое объектом <xref:System.Lazy%601>, метод доступа `set` должен создать объект <xref:System.Lazy%601> и присвоить его резервному хранилищу. Метод доступа `set` должен создать лямбда-выражение, возвращающее новое значение свойства, которое было передано методу доступа `set`, и передать это лямбда-выражение конструктору нового объекта <xref:System.Lazy%601>. Следующее обращение к свойству <xref:System.Lazy%601.Value%2A> вызовет инициализацию нового объекта <xref:System.Lazy%601>, и его свойство <xref:System.Lazy%601.Value%2A> после этого будет возвращать новое значение, присвоенное этому свойству. Эта сложная структура требуется для сохранения средств защиты многопоточности, встроенных в <xref:System.Lazy%601>. В противном случае методам доступа к свойству пришлось бы кэшировать первое значение, возвращаемое свойством <xref:System.Lazy%601.Value%2A>, и изменять только кэшированное значение, а вам пришлось бы писать для этого собственный потокобезопасный код. Из-за дополнительных инициализаций, необходимых для свойства чтения и записи, резервируемого объектом <xref:System.Lazy%601>, производительность может стать неприемлемой. Более того, в зависимости от конкретного сценария может потребоваться дополнительная координация, чтобы избежать состояний гонки между методами задания и получения значений.  
  
## <a name="thread-local-lazy-initialization"></a>Локальная по отношению к потоку отложенная инициализация  
 В некоторых сценариях с несколькими потоками может понадобиться, чтобы каждый поток работал со своими собственными закрытыми данными. Такие данные называются *локальными по отношению к потоку*. В .NET Framework версии 3.5 и предыдущих версий можно было применить к статической переменной атрибут `ThreadStatic`, чтобы сделать ее локальной по отношению к потоку. Однако использование атрибута `ThreadStatic` может привести к скрытым ошибкам. Например, даже основные операторы инициализации могут привести к инициализации переменной только для первого обратившегося к ней потока, как показано в приведенном ниже примере.  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 Во всех остальных потоках переменная будет инициализирована своим значением по умолчанию (нулем). В качестве альтернативы в .NET Framework версии 4 можно использовать тип <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>, чтобы создать локальную по отношению к потоку переменную на основе экземпляра, инициализируемую во всех потоках с помощью предоставленного вами делегата <xref:System.Action%601>. В приведенном ниже примере во всех потоках, обращающихся к счетчику `counter`, начальное значение этого счетчика будет равно 1.  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <xref:System.Threading.ThreadLocal%601> заключает свой объект в оболочку в основном так же, как и <xref:System.Lazy%601>, с перечисленными ниже важными различиями.  
  
- Каждый поток инициализирует локальную по отношению к потоку переменную, используя собственные закрытые данные, недоступные другим потокам.  
  
- Свойство <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> доступно для чтения и записи и может быть изменено любое количество раз. Это может повлиять на распространение исключений. Так, одна операция `get` может создать исключение, а следующая — успешно инициализировать значение.  
  
- Если делегат для инициализации не предоставлен, <xref:System.Threading.ThreadLocal%601> будет инициализировать соответствующий заключенный в оболочку тип, используя значение по умолчанию для этого типа. В этом отношении <xref:System.Threading.ThreadLocal%601> согласуется с атрибутом <xref:System.ThreadStaticAttribute>.  
  
 В приведенном ниже примере показано, как каждый поток, обращающийся к экземпляру `ThreadLocal<int>`, получает собственную уникальную копию данных.  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a>Локальные по отношению к потоку переменные в методах Parallel.For и ForEach  
 При использовании метода <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> или метода <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> для параллельной итерации источников данных можно применить перегруженные версии со встроенной поддержкой локальных по отношению к потоку данных. В этих методах локальность по отношению к потоку достигается с помощью локальных делегатов, используемых для создания данных, доступа к ним и их очистки. Дополнительные сведения см. в разделах [Практическое руководство. Написание цикла Parallel.For с локальными переменными потока](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) и [Практическое руководство. Написание цикла Parallel.ForEach с локальными переменными раздела](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a>Использование отложенной инициализации для сценариев с низкими издержками  
 Если необходимо использовать отложенную инициализацию для большого числа объектов, может оказаться, что заключение каждого объекта в оболочку <xref:System.Lazy%601> требует слишком много памяти или вычислительных ресурсов. Либо могут предъявляться строгие требования к предоставлению отложенной инициализации. В таких случаях можно использовать методы `static` (`Shared` в Visual Basic) класса <xref:System.Threading.LazyInitializer?displayProperty=nameWithType>, чтобы выполнить отложенную инициализацию каждого объекта, не заключая его в экземпляр <xref:System.Lazy%601>.  
  
 В приведенном ниже примере предполагается, что вместо заключения в оболочку всего объекта `Orders` в одном объекте <xref:System.Lazy%601> выполняется отложенная инициализация отдельных объектов `Order` только в случае их необходимости.  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 В этом примере обратите внимание на то, что процедура инициализации вызывается для каждой итерации цикла. В сценариях с несколькими потоками первый поток, вызывающий процедуру инициализации, определяет значение, которое будет доступно всем потокам. Последующие потоки также вызывают процедуру инициализации, но их результаты не используются. Если этот вид возможного состояния гонки является недопустимым, используйте перегруженную версию типа <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType>, которой передается логический аргумент и объект синхронизации.  
  
## <a name="see-also"></a>См. также

- [Основы управляемых потоков](../../standard/threading/managed-threading-basics.md)
- [Потоки и работа с потоками](../../standard/threading/threads-and-threading.md)
- [Библиотека параллельных задач (TPL)](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [Практическое руководство. Неактивная инициализация объектов](how-to-perform-lazy-initialization-of-objects.md)
