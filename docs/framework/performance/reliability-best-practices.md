---
title: Рекомендации по обеспечению надежности
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: bd51ea1b79ac1dbd89a862f3961cc8508a87f301
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75715972"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="d6b8c-102">Рекомендации по обеспечению надежности</span><span class="sxs-lookup"><span data-stu-id="d6b8c-102">Reliability Best Practices</span></span>

<span data-ttu-id="d6b8c-103">Приведенные здесь рекомендации по обеспечению надежности относятся преимущественно к SQL Server, однако вы можете руководствоваться ими при работе с любыми размещенными серверными приложениями.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-103">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="d6b8c-104">Очень важно не допустить утечки ресурсов и отключения на таких серверах, как SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-104">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="d6b8c-105">Однако добиться этого с помощью кода возврата для каждого метода, который изменяет состояние объекта, не удастся.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-105">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="d6b8c-106">Целью здесь не является написание абсолютно надежного управляемого кода, который будет обеспечивать восстановление после любых ошибок в любом месте с кодом возврата.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-106">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="d6b8c-107">Это слишком трудоемкая задача с минимальными шансами на успех.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-107">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="d6b8c-108">Общеязыковая среда выполнения (CLR) не дает полных гарантий того, что написание управляемого кода будет простым.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-108">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="d6b8c-109">Обратите внимание, что в отличие от ASP.NET в SQL Server задействуется только один процесс, который невозможно использовать повторно без отключения базы данных на недопустимо долгое время.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-109">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="d6b8c-110">При столь слабых гарантиях в условиях выполнения в одном процессе надежность обеспечивается, когда это необходимо, за счет завершения потоков или повторного использования доменов приложений, а также эффективного контроля за отсутствием утечек ресурсов операционной системы, таких как дескрипторы или память.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-110">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="d6b8c-111">Даже при столь простом ограничении важнейшими требованиями к надежности являются следующие:</span><span class="sxs-lookup"><span data-stu-id="d6b8c-111">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="d6b8c-112">Не допускайте утечки ресурсов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-112">Never leak operating system resources.</span></span>

- <span data-ttu-id="d6b8c-113">Выявите все управляемые блоки любых форм в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-113">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="d6b8c-114">Не нарушайте общее состояние общего для нескольких приложений домена, что необходимо для эффективного повторного использования <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-114">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="d6b8c-115">Несмотря на теоретическую возможность написать управляемый код для обработки исключений <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> и <xref:System.OutOfMemoryException>, требовать от разработчиков создания настолько надежного кода для всего приложения неразумно.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-115">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="d6b8c-116">Поэтому специализированные исключения приводят к завершению выполняющегося потока. Если при этом завершающий работу поток редактировал общее состояние, то есть устанавливал блокировку, выполняется выгрузка <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-116">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="d6b8c-117">При завершении метода, который редактирует общее состояние, возможно повреждение состояния, поскольку в этом случае невозможно написать надежный код возврата для обновления общего состояния.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-117">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="d6b8c-118">В версии .NET Framework 2.0 требования к надежности предъявляет только SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-118">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="d6b8c-119">Если ваша сборка будет выполняться на сервере SQL Server, необходимо написать код для обеспечения надежности для всех ее частей, в том числе для отдельных функций, которые будут отключены при выполнении в базе данных.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-119">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="d6b8c-120">Это обязательно, поскольку модуль анализа кода проверяет код на уровне сборки и не может отличить отключенный код.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-120">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="d6b8c-121">При программировании для SQL Server также необходимо учитывать, что сервер SQL Server выполняется в рамках одного процесса, а для высвобождения всех ресурсов, включая память и дескрипторы операционной системы, реализуется возможность повторного использования <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-121">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="d6b8c-122">В коде возврата нельзя полагаться на методы завершения, деструкторы или блоки `try/finally`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-122">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="d6b8c-123">Гарантировать их вызов или работу без прерывания невозможно.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-123">They might be interrupted or not called.</span></span>

<span data-ttu-id="d6b8c-124">Асинхронные исключения могут возникать в самых разных местах и практически в любой инструкции машинного кода, например: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> и <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-124">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="d6b8c-125">В SQL управляемые библиотеки необязательно выполняются в потоках Win32 и могут находиться в волокнах.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-125">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="d6b8c-126">Безопасно изменять общее состояние на уровне процесса или общего для нескольких приложений домена крайне сложно, и при возможности следует всегда избегать этого.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-126">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="d6b8c-127">В SQL Server нередко встречаются ситуации, связанные с нехваткой памяти.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-127">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="d6b8c-128">Если размещенные в SQL Server библиотеки некорректно обновляют свое общее состояние, высока вероятность того, что код не восстановится до тех пор, пока не будет перезапущена база данных.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-128">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="d6b8c-129">Кроме того, в крайних случаях это может привести к сбою процесса SQL Server и вынужденной перезагрузке базы данных.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-129">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="d6b8c-130">Перезагрузка базы данных может привести к отключению веб-сайта и, соответственно, отрицательно сказаться на уровне доступности и общей эффективности деятельности компании.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-130">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="d6b8c-131">Медленная утечка ресурсов операционной системы, например памяти или дескрипторов, может в конечном итоге привести к сбою сервера при выделении дескрипторов, восстановление после которого будет невозможно. Также может постепенно снижаться производительность сервера, в результате чего ухудшается степень доступности приложений заказчика.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-131">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="d6b8c-132">Очевидно, такого развития событий необходимо избежать.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-132">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="d6b8c-133">Правила рекомендаций</span><span class="sxs-lookup"><span data-stu-id="d6b8c-133">Best practice rules</span></span>

<span data-ttu-id="d6b8c-134">Во вступлении к этой статье внимание акцентируется на том, что необходимо выявлять при проверке управляемого кода, выполняемого на сервере, чтобы повысить стабильность и надежность работы платформы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-134">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="d6b8c-135">Эти проверки настоятельно рекомендуется выполнять во всех случаях, однако при работе с сервером они абсолютно необходимы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-135">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="d6b8c-136">В случае взаимоблокировки или ограниченности ресурсов SQL Server прекратит выполнение потока или демонтирует <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-136">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="d6b8c-137">В этом случае гарантированно будет выполняться только код возврата, который находится в области ограниченного выполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="d6b8c-137">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="d6b8c-138">Используйте SafeHandle, чтобы избежать утечек ресурсов</span><span class="sxs-lookup"><span data-stu-id="d6b8c-138">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="d6b8c-139">При выгрузке <xref:System.AppDomain> нельзя полагаться на блоки `finally` или методы завершения, поэтому важно полностью абстрагировать доступ ко всем ресурсам операционной системы, используя класс <xref:System.Runtime.InteropServices.SafeHandle> вместо <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef> и других аналогичных классов.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-139">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="d6b8c-140">Благодаря этому среда CLR может отслеживать и закрывать используемые дескрипторы даже в случае демонтажа <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-140">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="d6b8c-141">Класс <xref:System.Runtime.InteropServices.SafeHandle> будет использовать критический метод завершения, который будет выполняться в среде CLR при любых обстоятельствах.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-141"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="d6b8c-142">Дескриптор операционной системы хранится в дескрипторе SafeHandle с момента создания и вплоть до момента высвобождения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-142">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="d6b8c-143">Утечка дескриптора невозможна, поскольку исключение <xref:System.Threading.ThreadAbortException> не может возникнуть ни в какой момент.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-143">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="d6b8c-144">Кроме того, при вызове неуправляемого кода будет подсчитываться число ссылок на дескриптор, что позволит более точно отслеживать время существования дескриптора и предотвращать проблемы безопасности, связанные с состоянием гонки между `Dispose` и методом, который в настоящий момент использует этот дескриптор.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-144">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="d6b8c-145">Для большинства классов, которые в настоящий момент используют метод завершения для простой очистки дескриптора операционной системы, метод завершения больше не потребуется.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-145">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="d6b8c-146">Вместо этого метод завершения будет размещаться в производном от <xref:System.Runtime.InteropServices.SafeHandle> классе.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-146">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="d6b8c-147">Обратите внимание, что <xref:System.Runtime.InteropServices.SafeHandle> не является заменой для <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-147">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="d6b8c-148">При этом по-прежнему сохраняются риски состязания за ресурсы и преимущества в производительности, связанные с явным высвобождением ресурсов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-148">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="d6b8c-149">Необходимо помнить, что блоки `finally`, которые явно высвобождают ресурсы, могут выполняться не до конца.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-149">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="d6b8c-150"><xref:System.Runtime.InteropServices.SafeHandle> позволяет реализовать собственный метод <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, который выполняет операции по высвобождению дескриптора, то есть передает состояние в подпрограмму высвобождения дескриптора операционной системы или высвобождает набор дескрипторов в рамках цикла.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-150"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="d6b8c-151">В среде CLR выполнение этого метода гарантируется.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-151">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="d6b8c-152">Ответственность за то, чтобы дескриптор высвобождался при любых обстоятельствах, возлагается на разработчика реализации <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-152">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="d6b8c-153">В противном случае возможна утечка дескриптора, что часто влечет за собой утечку связанных с ним собственных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-153">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="d6b8c-154">Таким образом, важно структурировать производные от <xref:System.Runtime.InteropServices.SafeHandle> классы так, чтобы для реализации <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> не требовалось выделение каких-либо ресурсов, которые могут быть недоступны в момент вызова.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-154">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="d6b8c-155">Обратите внимание, что методы, которые могут завершаться сбоем в реализации <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, допускается выполнять при условии, что в коде реализованы обработка таких ситуаций отказа и выполнение контракта на высвобождение собственного дескриптора.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-155">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="d6b8c-156">Для отладки в <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> предусмотрено возвращаемое значение типа <xref:System.Boolean>, которому присваивается значение `false` при возникновении неустранимой ошибки, которая препятствует высвобождению ресурса.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-156">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="d6b8c-157">В этом случае активируется помощник по отладке управляемого кода [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) (если он включен), который способствует выявлению проблемы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-157">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="d6b8c-158">При этом никакого другого воздействия на среду выполнения не оказывается. <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> не вызывается повторно для того же ресурса, в результате чего происходит утечка дескриптора.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-158">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="d6b8c-159"><xref:System.Runtime.InteropServices.SafeHandle> нельзя использовать в некоторых контекстах.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-159"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="d6b8c-160">Поскольку метод <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> может выполняться в потоке метода завершения <xref:System.GC>, любые дескрипторы, которые требуется высвобождать в конкретном потоке, не должны помещаться в <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-160">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="d6b8c-161">Вызываемые оболочки времени выполнения (RCW) в среде CLR очищаются без использования дополнительного кода.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-161">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="d6b8c-162">Если вы используете вызовы неуправляемого кода для обработки COM-объекта как `IUnknown*` или <xref:System.IntPtr>, в коде необходимо использовать вызываемые оболочки времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-162">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="d6b8c-163">Класс <xref:System.Runtime.InteropServices.SafeHandle> в этом случае не подходит, поскольку метод высвобождения неуправляемого кода может обращаться к управляемому коду.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-163"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-164">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-164">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-165">Используйте <xref:System.Runtime.InteropServices.SafeHandle> для инкапсуляции ресурсов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-165">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="d6b8c-166">Не используйте <xref:System.Runtime.InteropServices.HandleRef> или поля типа <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-166">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="d6b8c-167">Убедитесь, что не нужно запускать методы завершения, чтобы предотвратить утечку ресурсов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-167">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="d6b8c-168">Тщательно проверьте методы завершения и убедитесь, что даже если они не выполняются, утечка критических ресурсов операционной системы отсутствует.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-168">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="d6b8c-169">В отличие от обычной выгрузки <xref:System.AppDomain>, при которой приложение выполняется в стабильном состоянии или завершается работа сервера (например, SQL Server), при неожиданной выгрузке <xref:System.AppDomain> завершение объектов не производится.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-169">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="d6b8c-170">Убедитесь, что при неожиданной выгрузке не происходит утечка ресурсов, поскольку в этом случае невозможно гарантировать корректность приложения, однако необходимо обеспечить целостность сервера.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-170">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="d6b8c-171">Используйте <xref:System.Runtime.InteropServices.SafeHandle> для высвобождения любых ресурсов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-171">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="d6b8c-172">Убедитесь, что для предотвращения утечки ресурсов операционной системы не нужно запускать предложения finally.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-172">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="d6b8c-173">Выполнение предложений `finally` вне областей ограниченного выполнения (CER) не гарантируется, в связи с чем разработчики библиотек не должны полагаться на код в блоке `finally` для высвобождения неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-173">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="d6b8c-174">В таких случаях рекомендуется использовать <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-174">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-175">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-175">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-176">Для очистки ресурсов операционной системы используйте <xref:System.Runtime.InteropServices.SafeHandle> вместо `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-176">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="d6b8c-177">Не используйте <xref:System.IntPtr>. Вместо этого для инкапсуляции ресурсов следует использовать <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-177">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="d6b8c-178">Если предложение finally все же необходимо выполнять, поместите его в область ограниченного выполнения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-178">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="d6b8c-179">Все блокировки должны проходить через существующий управляемый код блокировки</span><span class="sxs-lookup"><span data-stu-id="d6b8c-179">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="d6b8c-180">Среде CLR необходимо знать, когда код находится в состоянии блокировки, поскольку в этом случае вместо простого прерывания потока выполняется демонтаж <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-180">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="d6b8c-181">Опасность прерывания потока связана с тем, что используемые в нем данные могут оставаться в несогласованном состоянии.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-181">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="d6b8c-182">Соответственно, потребуется повторное использование всего <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-182">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="d6b8c-183">Если наличие блокировки не определено, это может привести к возникновению взаимоблокировок и получению некорректных результатов.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-183">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="d6b8c-184">Для определения областей блокировки используйте методы <xref:System.Threading.Thread.BeginCriticalRegion%2A> и <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-184">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="d6b8c-185">Эти статические методы класса <xref:System.Threading.Thread> применяются только к текущему потоку и помогают предотвратить ситуации, когда один поток редактирует счетчик блокировок другого.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-185">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="d6b8c-186">В <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.Exit%2A> это уведомление CLR реализовано во встроенной форме, в связи с чем рекомендуется использовать их, а также [оператор lock](../../csharp/language-reference/keywords/lock-statement.md), который использует эти методы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-186"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="d6b8c-187">Эти методы должны вызываться другими механизмами блокировки, такими как спин-блокировки или <xref:System.Threading.AutoResetEvent>, для уведомления среды CLR о переходе в критическую секцию.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-187">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="d6b8c-188">Эти методы не принимают блокировки и лишь уведомляют среду CLR о том, что код выполняется в критической секции, в связи с чем в случае прерывания потока общее состояние может быть несогласованным.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-188">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="d6b8c-189">Эти методы подсчета блокировок необходимо использовать в том случае, если вы определили собственный тип блокировки, например настраиваемый класс <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-189">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-190">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-190">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-191">Пометьте и определите все блокировки, используя <xref:System.Threading.Thread.BeginCriticalRegion%2A> и <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-191">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="d6b8c-192">Не используйте <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A> и <xref:System.Threading.Interlocked.Decrement%2A> в цикле.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-192">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="d6b8c-193">Не выполняйте вызов неуправляемого кода вариантов этих методов для Win32.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-193">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="d6b8c-194">Не используйте <xref:System.Threading.Thread.Sleep%2A> в цикле.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-194">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="d6b8c-195">Не используйте изменяемые поля.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-195">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="d6b8c-196">Код очистки должен находиться в блоке finally или catch, а не после блока catch</span><span class="sxs-lookup"><span data-stu-id="d6b8c-196">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="d6b8c-197">Код очистки никогда не должен располагаться после блока `catch`. Он должен находиться внутри блоков `finally` или `catch`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-197">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="d6b8c-198">Это стандартная рекомендация.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-198">This should be a normal good practice.</span></span> <span data-ttu-id="d6b8c-199">В большинстве случаев следует использовать блок `finally`, поскольку он выполняет один и тот же код и при возникновении исключения, и при переходе к концу блока `try` в обычном режиме.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-199">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="d6b8c-200">При возникновении непредвиденного исключения, например <xref:System.Threading.ThreadAbortException>, код очистки не выполняется.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-200">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="d6b8c-201">В идеальном случае все неуправляемые ресурсы, очистка которых должна выполняться в блоке `finally`, следует заключать в <xref:System.Runtime.InteropServices.SafeHandle>, чтобы предотвратить утечки.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-201">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="d6b8c-202">Обратите внимание, что для эффективного высвобождения объектов, включая и дескрипторы, можно использовать ключевое слово `using` в C#.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-202">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="d6b8c-203">Несмотря на то, что при повторном использовании <xref:System.AppDomain> очистка может выполняться в потоке метода завершения, по-прежнему важно правильно выбрать место, где будет размещаться код очистки.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-203">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="d6b8c-204">Обратите внимание, что если поток получает асинхронное исключение и при этом не удерживает блокировку, среда CLR пытается завершить сам поток, не используя <xref:System.AppDomain> повторно.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-204">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="d6b8c-205">Если ресурсы в конечном итоге гарантированно высвобождаются, это увеличивает объем доступных ресурсов и позволяет оптимизировать управление их временем существования.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-205">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="d6b8c-206">Если дескриптор файла не закрывается явно при обработке какой-либо ошибки, дождитесь, пока он будет высвобожден с помощью метода завершения <xref:System.Runtime.InteropServices.SafeHandle>. Если не выполнить этот метод завершения, при следующем запуске кода попытка получить доступ к тому же файлу может завершиться сбоем.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-206">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="d6b8c-207">По этой причине рекомендуется убедиться, что код очистки существует и правильно работает, обеспечивая более быстрое и эффективное восстановление после сбоев. Тем не менее делать это необязательно.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-207">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-208">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-208">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-209">Код очистки после блока `catch` должен находиться в блоке `finally`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-209">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="d6b8c-210">Размещайте вызовы для высвобождения в блоке finally.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-210">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="d6b8c-211">Блоки `catch` должны завершаться операторами throw или rethrow.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-211">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="d6b8c-212">За некоторыми исключениями (например, в коде, обнаруживающем возможность установления сетевого подключения, в котором могут возникать самые разнообразные исключения), в любом коде, где требуется перехватывать некоторое число исключений, в обычных обстоятельствах следует указывать на необходимость проверки успешного выполнения кода.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-212">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="d6b8c-213">Необходимо устранить Изменяемое общее состояние на уровне процесса между доменами приложений или использовать область ограниченного выполнения</span><span class="sxs-lookup"><span data-stu-id="d6b8c-213">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="d6b8c-214">Как было указано во вступительной части этой статьи, крайне сложно написать управляемый код, который сможет надежно отслеживать общее состояние на уровне процесса между доменами приложений.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-214">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="d6b8c-215">Общее состояние на уровне процесса — это структура данных любого вида, которая совместно используется разными доменами приложений в коде Win32, в среде CLR или в управляемом коде посредством удаленного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-215">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="d6b8c-216">При этом очень сложно корректно реализовать любое изменяемое общее состояние в управляемом коде, а статическое общее состояние следует реализовывать с большой осторожностью.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-216">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="d6b8c-217">В случае с общим состоянием на уровне процесса или компьютера необходимо найти способ устранить его или использовать область ограниченного выполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="d6b8c-217">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="d6b8c-218">Обратите внимание, что любая библиотека, общее состояние которой не определено и не исправлено, может привести к сбою ведущего приложения (например, SQL Server), которое требует чистой выгрузки <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-218">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="d6b8c-219">Если в коде используется COM-объект, следует избегать совместного использования такого объекта между доменами приложений.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-219">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="d6b8c-220">Блокировки не работают на уровне процесса или между доменами приложений.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-220">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="d6b8c-221">В прошлом для создания глобальных блокировок процессов использовались <xref:System.Threading.Monitor.Enter%2A> и [оператор lock](../../csharp/language-reference/keywords/lock-statement.md).</span><span class="sxs-lookup"><span data-stu-id="d6b8c-221">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="d6b8c-222">Например, это происходит при блокировке гибких классов <xref:System.AppDomain>, таких как экземпляры <xref:System.Type> из не являющихся общими сборок, объекты <xref:System.Threading.Thread>, интернированные строки, а также некоторые строки, совместно используемые между доменами приложений посредством удаленного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-222">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="d6b8c-223">Теперь эти блокировки не реализуются на уровне процесса.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-223">These locks are no longer process-wide.</span></span>  <span data-ttu-id="d6b8c-224">Чтобы определить наличие блокировки на уровне процесса между доменами, выясните, использует ли код в блокировке какой-либо внешний постоянный ресурс, например файл на диске или базу данных.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-224">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="d6b8c-225">Обратите внимание, что блокировка внутри <xref:System.AppDomain> может привести к проблемам в том случае, если защищенный код использует внешний ресурс. Это связано с тем, что такой код может одновременно выполняться в нескольких доменах приложений.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-225">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="d6b8c-226">Это может приводить к проблемам при записи в один файл журнала или привязке к сокету для всего процесса.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-226">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="d6b8c-227">В связи с этими изменениями не существует простого способа выполнить глобальную блокировку процесса с использованием управляемого кода, кроме подхода с применением именованного мьютекса <xref:System.Threading.Mutex> или экземпляра <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-227">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="d6b8c-228">Создайте код, который не будет одновременно выполняться в двух доменах приложений, либо используйте классы <xref:System.Threading.Mutex> или <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-228">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="d6b8c-229">Если изменить существующий код нельзя, не используйте для синхронизации именованный мьютекс Win32, поскольку при работе в режиме волокон не гарантируется, что получать и высвобождать такой мьютекс будет один и тот же поток операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-229">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="d6b8c-230">Используйте класс <xref:System.Threading.Mutex> или именованные объекты <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent> или <xref:System.Threading.Semaphore> для синхронизации блокировки кода поддерживаемым средой CLR способом вместо того, чтобы использовать для этого неуправляемый код.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-230">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="d6b8c-231">Избегайте использования блокировки lock(typeof(MyType))</span><span class="sxs-lookup"><span data-stu-id="d6b8c-231">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="d6b8c-232">Проблемы могут быть связаны с частными и открытыми объектами <xref:System.Type> в общих сборках, где все домены приложений используют одну копию кода.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-232">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="d6b8c-233">Для общих сборок существует только один экземпляр <xref:System.Type> на процесс. Это значит, что несколько доменов приложений используют один и тот же экземпляр <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-233">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="d6b8c-234">Блокировка <xref:System.Type> применяется ко всему процессу, а не только к <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-234">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="d6b8c-235">Если один <xref:System.AppDomain> блокирует <xref:System.Type>, то в случае неожиданного прерывания потока блокировка не будет снята.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-235">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="d6b8c-236">Это может привести к взаимоблокировкам других доменов приложений.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-236">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="d6b8c-237">Чтобы реализовать рекомендуемый способ блокировки в статических методах, необходимо добавить в код статический внутренний объект синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-237">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="d6b8c-238">Его можно инициализировать в конструкторе класса (если такой есть), однако показанный ниже способ инициализации не допускается:</span><span class="sxs-lookup"><span data-stu-id="d6b8c-238">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="d6b8c-239">Чтобы получить заблокированный объект в случае блокировки, используйте свойство `InternalSyncObject`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-239">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="d6b8c-240">Если в конструкторе класса был инициализирован внутренний объект синхронизации, использовать это свойство не нужно.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-240">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="d6b8c-241">Код для двойной проверки инициализации блокировки должен иметь следующий вид:</span><span class="sxs-lookup"><span data-stu-id="d6b8c-241">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="d6b8c-242">Примечание о блокировке (это)</span><span class="sxs-lookup"><span data-stu-id="d6b8c-242">A note about lock(this)</span></span>

<span data-ttu-id="d6b8c-243">Как правило, блокировка отдельного общедоступного объекта допускается.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-243">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="d6b8c-244">Тем не менее для одноэлементного объекта, который может привести к взаимоблокировке всей подсистемы, рекомендуется также использовать приведенный выше шаблон разработки.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-244">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="d6b8c-245">Например, блокировка одного объекта <xref:System.Security.SecurityManager> может привести к взаимоблокировке в <xref:System.AppDomain>, в результате чего весь <xref:System.AppDomain> будет непригоден для использования.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-245">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="d6b8c-246">Блокировать общедоступные объекты такого типа не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-246">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="d6b8c-247">Тем не менее в большинстве случаев при блокировке отдельных коллекций или массивов проблем не возникает.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-247">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-248">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-248">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-249">Не блокируйте типы, которые могут использоваться между доменами приложений или не имеют строгой идентификации.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-249">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="d6b8c-250">Не вызывайте <xref:System.Threading.Monitor.Enter%2A> для <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread> или любых объектов, производных от <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-250">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="d6b8c-251">Удалите GC. Вызовы KeepAlive</span><span class="sxs-lookup"><span data-stu-id="d6b8c-251">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="d6b8c-252">В существующем коде <xref:System.GC.KeepAlive%2A> чаще всего не используется или используется не там, где это необходимо.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-252">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="d6b8c-253">После преобразования в <xref:System.Runtime.InteropServices.SafeHandle> классам не нужно вызывать <xref:System.GC.KeepAlive%2A>, поскольку предполагается, что они не имеют собственного метода завершения и используют <xref:System.Runtime.InteropServices.SafeHandle> для завершения дескрипторов операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-253">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="d6b8c-254">Несмотря на пренебрежимо малое снижение производительности при сохранении вызова <xref:System.GC.KeepAlive%2A>, понимание того, что вызов <xref:System.GC.KeepAlive%2A> необходим или достаточен для решения проблемы со временем существования, которая более не существует, делает код более сложным в обслуживании.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-254">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="d6b8c-255">Однако при использовании COM-взаимодействия в коде по-прежнему требуются вызываемые оболочки времени выполнения (RCW) среды CLR, <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-255">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-256">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-256">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-257">Удалите <xref:System.GC.KeepAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-257">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="d6b8c-258">Использование атрибута Хостпротектион</span><span class="sxs-lookup"><span data-stu-id="d6b8c-258">Use the HostProtection Attribute</span></span>

<span data-ttu-id="d6b8c-259">Атрибут защиты ведущего приложения <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) позволяет использовать декларативные операции безопасности для определения требований ведущего приложения к защите. Это позволяет ведущему приложению запретить даже полностью доверенному коду вызывать некоторые методы, которые не поддерживаются таким ведущим приложением, например <xref:System.Environment.Exit%2A> или <xref:System.Windows.Forms.MessageBox.Show%2A> для SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-259">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="d6b8c-260">Атрибут защиты ведущего приложения действует только для неуправляемых приложений, на которых размещена среда CLR и реализована защита ведущего приложения, например для SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-260">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="d6b8c-261">Если этот атрибут применен, операция безопасности приводит к созданию запроса ссылки на основе ресурсов ведущего приложения, доступ к которым предоставляет класс или метод.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-261">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="d6b8c-262">Если код выполняется в клиентском приложении или на сервере без защиты ведущего приложения, этот атрибут не обнаруживается и, соответственно, не применяется.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-262">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d6b8c-263">Этот атрибут используется для применения правил специальной модели программирования ведущих приложений, а не в целях безопасности.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-263">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="d6b8c-264">Несмотря на то, что запрос ссылки используется для проверки на соответствие требованиям модели программирования, <xref:System.Security.Permissions.HostProtectionAttribute> не является разрешением безопасности.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-264">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="d6b8c-265">Если ведущее приложение не имеет требований к модели программирования, запрос ссылки не выполняется.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-265">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="d6b8c-266">Этот атрибут определяет следующее:</span><span class="sxs-lookup"><span data-stu-id="d6b8c-266">This attribute identifies the following:</span></span>

- <span data-ttu-id="d6b8c-267">Методы и классы, которые не соответствуют требованиям модели программирования ведущих приложений, но в остальном являются безопасными.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-267">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="d6b8c-268">Методы и классы, которые не соответствуют требованиям модели программирования ведущих приложений и могут привести к дестабилизации управляемого сервером пользовательского кода.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-268">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="d6b8c-269">Методы и классы, которые не соответствуют требованиям модели программирования ведущих приложений и могут привести к дестабилизации самого процесса сервера.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-269">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="d6b8c-270">Если создаваемая библиотека классов будет вызываться приложениями, которые могут выполняться в среде с защитой ведущих приложений, следует применять этот атрибут к членам, которые предоставляют доступ к категориям ресурсов <xref:System.Security.Permissions.HostProtectionResource>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-270">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="d6b8c-271">Члены библиотеки классов .NET Framework с этим атрибутом реализуют проверку только непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-271">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="d6b8c-272">Аналогичное поведение следует реализовывать и для собственных членов библиотеки.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-272">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="d6b8c-273">Дополнительные сведения об атрибуте защиты ведущего приложения см. в разделе <xref:System.Security.Permissions.HostProtectionAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-273">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-274">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-274">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-275">Для SQL Server все методы, реализующие синхронизацию или работу с потоками, должны определяться с использованием атрибута защиты ведущего приложения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-275">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="d6b8c-276">К ним относятся методы, которые совместно используют состояние, синхронизируются или управляют внешними процессами.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-276">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="d6b8c-277">На SQL Server влияют такие значения <xref:System.Security.Permissions.HostProtectionResource>, как <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization> и <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-277">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="d6b8c-278">Тем не менее с использованием атрибута защиты ведущего приложения необходимо определять любой метод, который предоставляет <xref:System.Security.Permissions.HostProtectionResource>, а не только методы, которые используют ресурсы, влияющие на SQL.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-278">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="d6b8c-279">Не блокируйте неопределенное время в неуправляемый код</span><span class="sxs-lookup"><span data-stu-id="d6b8c-279">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="d6b8c-280">Использование блокировки в неуправляемом коде вместо управляемого может стать причиной атаки типа "отказ в обслуживании", поскольку в этом случае среде CLR не удастся прервать поток.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-280">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="d6b8c-281">Из-за заблокированного потока среда CLR не сможет выгрузить <xref:System.AppDomain>, не используя некоторые крайне небезопасные операции.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-281">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="d6b8c-282">Блокирование с помощью примитива синхронизации Windows — это четкий пример того, что мы не можем разрешить.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-282">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="d6b8c-283">Блокирование в вызове `ReadFile` на сокете следует избегать, если это возможно. в идеале, API Windows должен предоставить механизм для операции, например, для истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-283">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="d6b8c-284">В идеальном случае любой метод, вызывающий машинный код, должен использовать вызов Win32 с обоснованным конечным временем ожидания.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-284">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="d6b8c-285">Если время ожидания может задаваться пользователем, следует запретить установку неограниченного времени ожидания без наличия особых разрешений безопасности.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-285">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="d6b8c-286">Как правило, если метод выполняет блокировку более 10 секунд, следует использовать версию с поддержкой времени ожидания или реализовать дополнительную поддержку среды CLR.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-286">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="d6b8c-287">Ниже приведены некоторые примеры проблемных API.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-287">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="d6b8c-288">Анонимные и именованные каналы могут создаваться с поддержкой времени ожидания. Тем не менее в коде необходимо гарантировать защиту от вызовов `CreateNamedPipe` или `WaitNamedPipe` с NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-288">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="d6b8c-289">Кроме того, непредвиденная блокировка может возникать даже в том случае, если указано время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-289">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="d6b8c-290">Вызов `WriteFile` для анонимного канала устанавливает блокировку до тех пор, пока не будут записаны все байты. В этом случае, если в буфере содержатся непрочитанные данные, вызов `WriteFile` будет удерживать блокировку до тех пор, пока модуль чтения не освободит достаточно места в буфере канала.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-290">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="d6b8c-291">Для работы с сокетами всегда следует использовать API, которые учитывают механизм времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-291">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-292">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-292">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-293">Блокировка без учета времени ожидания в неуправляемом коде приводит к атаке типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="d6b8c-293">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="d6b8c-294">Не выполняйте вызовы неуправляемого кода для `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects` и `MsgWaitForMultipleObjectsEx`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-294">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="d6b8c-295">Не используйте NMPWAIT_WAIT_FOREVER.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-295">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="d6b8c-296">Выявление функций, зависящих от STA</span><span class="sxs-lookup"><span data-stu-id="d6b8c-296">Identify any STA-Dependent features</span></span>

<span data-ttu-id="d6b8c-297">Определите код, в котором используются однопотоковые подразделения (STA) модели COM.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-297">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="d6b8c-298">В процессе SQL Server однопотоковые подразделения отключены.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-298">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="d6b8c-299">Для SQL Server необходимо отключить функции, которые зависят от `CoInitialize`, такие как счетчики производительности или буфер обмена.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-299">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="d6b8c-300">Обеспечение доступности методов завершения для проблем синхронизации</span><span class="sxs-lookup"><span data-stu-id="d6b8c-300">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="d6b8c-301">В будущих версиях платформы .NET Framework может существовать несколько потоков методов завершения. Это значит, что методы завершения для разных экземпляров одного типа могут выполняться параллельно.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-301">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="d6b8c-302">Они не обязаны быть полностью потокобезопасными, поскольку использование сборщика мусора гарантирует, что для конкретного экземпляра объекта метод завершения будет выполняться только в одном потоке.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-302">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="d6b8c-303">Тем не менее в коде методов завершения должны исключаться состояния гонки или взаимоблокировки при одновременном выполнении для нескольких разных экземпляров объектов.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-303">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="d6b8c-304">При использовании любого внешнего состояния (например, запись в файл журнала) в методе завершения должны обрабатываться возможные проблемы с потоками.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-304">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="d6b8c-305">Реализация потокобезопасности не должна полагаться исключительно на функции завершения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-305">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="d6b8c-306">Не используйте для хранения состояния в потоке метода завершения локальное по отношению к потоку хранилище (как управляемое, так и собственное).</span><span class="sxs-lookup"><span data-stu-id="d6b8c-306">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-307">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-307">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-308">В методах завершения не должны присутствовать проблемы, связанные с синхронизацией.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-308">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="d6b8c-309">Не используйте в методе завершения статическое изменяемое состояние.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-309">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="d6b8c-310">По возможности избегайте использования неуправляемой памяти</span><span class="sxs-lookup"><span data-stu-id="d6b8c-310">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="d6b8c-311">Как и в случае с дескрипторами операционной системы, при работе с неуправляемой памятью возможны утечки.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-311">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="d6b8c-312">Если возможно, попробуйте использовать память в стеке с помощью [stackalloc](../../csharp/language-reference/operators/stackalloc.md) или закрепленного управляемого объекта, например [оператора fixed](../../csharp/language-reference/keywords/fixed-statement.md) или <xref:System.Runtime.InteropServices.GCHandle> с использованием byte[].</span><span class="sxs-lookup"><span data-stu-id="d6b8c-312">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="d6b8c-313">В конечном итоге, они будут очищены с помощью <xref:System.GC>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-313">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="d6b8c-314">Тем не менее, если вам необходимо выделить неуправляемую память, рекомендуется заключать операции выделения памяти в класс, который является производным от <xref:System.Runtime.InteropServices.SafeHandle>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-314">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="d6b8c-315">Обратите внимание, что <xref:System.Runtime.InteropServices.SafeHandle> не подходит как минимум в одном случае.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-315">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="d6b8c-316">Для вызовов методов COM, которые выделяют или высвобождают память, чаще всего одна библиотека DLL выделяет память с помощью `CoTaskMemAlloc`, после чего другая библиотека DLL высвобождает эту память, используя `CoTaskMemFree`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-316">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="d6b8c-317">В таких случаях использовать <xref:System.Runtime.InteropServices.SafeHandle> не следует, поскольку это приведет к попытке привязать срок существования неуправляемой памяти к сроку существования <xref:System.Runtime.InteropServices.SafeHandle>, тогда как он должен управляться другой библиотекой DLL.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-317">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="d6b8c-318">Проверка всех применений catch (Exception)</span><span class="sxs-lookup"><span data-stu-id="d6b8c-318">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="d6b8c-319">Блоки catch, которые перехватывают все исключения вместо одного конкретного, теперь также могут перехватывать асинхронные исключения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-319">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="d6b8c-320">Проверьте каждый блок catch(Exception) и убедитесь, что не пропущен важный код высвобождения ресурсов или возврата, а в самом блоке catch отсутствуют потенциально некорректные функции обработки <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException> или <xref:System.OutOfMemoryException>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-320">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="d6b8c-321">Обратите внимание, что этот код может записывать информацию в журнал или использовать определенные допущения, связанные с видимостью только некоторых исключений или наличием единственной причины сбоя при возникновении исключения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-321">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="d6b8c-322">Для работы с <xref:System.Threading.ThreadAbortException> эти допущения может потребоваться обновить.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-322">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="d6b8c-323">Везде, где перехватываются все исключения, рекомендуется реализовать перехват исключений конкретного типа, которые могут возникать в указанном месте (например, исключений <xref:System.FormatException> из методов форматирования строк).</span><span class="sxs-lookup"><span data-stu-id="d6b8c-323">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="d6b8c-324">Это позволяет предотвратить выполнение блока catch для непредвиденных исключений и гарантировать отсутствие в коде ошибок, скрываемых в результате перехвата таких исключений.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-324">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="d6b8c-325">В большинстве случаев не следует обрабатывать исключения в коде библиотеки (такая необходимость может свидетельствовать об определенных недостатках в вызываемом коде).</span><span class="sxs-lookup"><span data-stu-id="d6b8c-325">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="d6b8c-326">Иногда для вывода дополнительных данных требуется перехватить одно исключение и вызвать исключение другого типа.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-326">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="d6b8c-327">В этом случае следует использовать вложенные исключения, сохраняя сведения о фактической причине сбоя в свойстве <xref:System.Exception.InnerException%2A> нового исключения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-327">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-328">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-328">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-329">Проверьте все блоки catch в управляемом коде, которые перехватывают все объекты или исключения.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-329">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="d6b8c-330">В C#это означает, что помечается как `catch` {}, так и `catch(Exception)` {}.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-330">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="d6b8c-331">Рекомендуется как можно точнее указывать тип исключения или тщательно проверить код на корректность поведения при перехвате исключения непредвиденного типа.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-331">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="d6b8c-332">Не думайте, что управляемый поток является потоком Win32 — это волокно</span><span class="sxs-lookup"><span data-stu-id="d6b8c-332">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="d6b8c-333">Вы можете использовать управляемое локальное по отношению к потоку хранилище, однако нельзя использовать аналогичное неуправляемое хранилище или предполагать, что код будет снова выполняться в текущем потоке операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-333">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="d6b8c-334">Не изменяйте такие параметры, как языковой стандарт потока.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-334">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="d6b8c-335">Не вызывайте `InitializeCriticalSection` или `CreateMutex` посредством вызова неуправляемого кода, поскольку в этом случае устанавливать и снимать блокировку должен один и тот же поток операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-335">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="d6b8c-336">Поскольку при работе с волокнами этого нет, в SQL нельзя напрямую использовать мьютексы и критические секции Win32.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-336">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="d6b8c-337">Обратите внимание, что управляемый класс <xref:System.Threading.Mutex> не решает эти проблемы, связанные со сходством потоков.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-337">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="d6b8c-338">Вы можете безопасно использовать большую часть состояния управляемого объекта <xref:System.Threading.Thread>, включая управляемое локальное по отношению к потоку хранилище и текущий языковой стандарт пользовательского интерфейса потока.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-338">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="d6b8c-339">Кроме того, вы можете использовать <xref:System.ThreadStaticAttribute>, в результате чего значение существующей статической переменной будет доступно только текущему управляемому потоку (это один из способов реализовать локальное по отношению к волокну хранилище в среде CLR).</span><span class="sxs-lookup"><span data-stu-id="d6b8c-339">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="d6b8c-340">Из-за ограничений модели программирования при работе в SQL изменять текущий языковой стандарт потока нельзя.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-340">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-341">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-341">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-342">SQL Server работает в режиме волокон. Не используйте локальное по отношению к потоку хранилище.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-342">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="d6b8c-343">Не рекомендуется выполнять вызовы неуправляемого кода для `TlsAlloc`, `TlsFree`, `TlsGetValue` и `TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="d6b8c-343">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="d6b8c-344">Разрешить SQL Server обработку олицетворения</span><span class="sxs-lookup"><span data-stu-id="d6b8c-344">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="d6b8c-345">Поскольку олицетворение реализуется на уровне потока, а SQL может работать в режиме волокон, в управляемом коде не должно осуществляться олицетворение пользователей и не должны использоваться вызовы `RevertToSelf`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-345">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-346">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-346">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-347">Обработку олицетворения должен осуществлять SQL Server.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-347">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="d6b8c-348">Не используйте `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx` или `SetThreadToken`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-348">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="d6b8c-349">Не вызывайте поток:: Suspend</span><span class="sxs-lookup"><span data-stu-id="d6b8c-349">Do not call Thread::Suspend</span></span>

<span data-ttu-id="d6b8c-350">Несмотря на кажущуюся простоту реализации, приостановка потока может привести к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-350">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="d6b8c-351">Если поток, удерживающий блокировку, приостанавливается другим потоком, который затем пытается получить ту же блокировку, возникает взаимоблокировка.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-351">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="d6b8c-352">Метод <xref:System.Threading.Thread.Suspend%2A> может взаимодействовать с безопасностью, загрузкой класса, удаленным взаимодействием и отражением.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-352"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="d6b8c-353">Правило анализа кода</span><span class="sxs-lookup"><span data-stu-id="d6b8c-353">Code analysis rule</span></span>

<span data-ttu-id="d6b8c-354">Не вызывайте <xref:System.Threading.Thread.Suspend%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-354">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="d6b8c-355">Рекомендуется использовать реальный примитив синхронизации вместо <xref:System.Threading.Semaphore> или <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-355">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="d6b8c-356">Защита критически важных операций с помощью областей ограниченного выполнения и контрактов надежности</span><span class="sxs-lookup"><span data-stu-id="d6b8c-356">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="d6b8c-357">При выполнении сложной операции, которая обновляет общее состояние или должна детерминированно завершаться полным успехом или сбоем, используйте в целях защиты ограниченную область выполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="d6b8c-357">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="d6b8c-358">Таким образом, выполнение кода гарантируется во всех случаях, даже при неожиданном прерывании потока или выгрузки <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-358">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="d6b8c-359">Ограниченная область выполнения представляет собой отдельный блок `try/finally`, непосредственно перед которым выполняется вызов <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-359">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="d6b8c-360">В этом случае JIT-компилятор получает инструкции подготовить весь код в блоке finally до того, как будет выполнен код в блоке `try`.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-360">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="d6b8c-361">Таким образом, код в блоке finally будет построен и выполнен в любом случае.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-361">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="d6b8c-362">В ограниченных областях выполнения пустые блоки `try` практически не используются.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-362">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="d6b8c-363">С помощью ограниченных областей выполнения можно реализовать защиту от асинхронного прерывания потоков и исключений, связанных с нехваткой памяти.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-363">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="d6b8c-364">В разделе <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> показана форма ограниченной области выполнения, которая дополнительно обрабатывает случаи переполнения стека для кода большой глубины.</span><span class="sxs-lookup"><span data-stu-id="d6b8c-364">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="d6b8c-365">См. также:</span><span class="sxs-lookup"><span data-stu-id="d6b8c-365">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="d6b8c-366">Программирование SQL Server и атрибуты защиты ведущего приложения</span><span class="sxs-lookup"><span data-stu-id="d6b8c-366">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
