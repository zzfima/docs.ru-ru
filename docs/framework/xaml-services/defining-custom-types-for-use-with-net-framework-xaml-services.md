---
title: Определение пользовательских типов для использования со службами XAML .NET Framework
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 7437add6795c1bb7f8a59807ebfc51dc2d0f987f
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/12/2019
ms.locfileid: "73972022"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a>Определение пользовательских типов для использования со службами XAML .NET Framework
При определении пользовательских типов, которые являются бизнес-объектами или типами, не имеющими зависимости от конкретных платформ, можно следовать определенным рекомендациям по XAML. При соблюдении этих рекомендаций .NET Framework службы XAML и их средства чтения и записи XAML могут обнаружить характеристики XAML вашего типа и предоставить ему соответствующее представление в потоке узлов XAML, используя систему типов XAML. В этом разделе описываются рекомендации по определениям типов, определениям членов и присвоению атрибутов типов или членов в среде CLR.  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a>Шаблоны конструктора и определения типов для XAML  
 Для создания экземпляра в виде объектного элемента в XAML пользовательский класс должен удовлетворять следующим требованиям.  
  
- Пользовательский класс должен быть открытым и должен предоставлять открытый конструктор без параметров. (Примечания о структурах см. в следующем разделе.)  
  
- Пользовательский класс не должен быть вложенным классом. Дополнительный "точка" в пути Full-Name делает деление класса-пространства неоднозначным и влияет на другие функции XAML, такие как вложенные свойства.  
  
 Если объект может быть создан как объектный элемент, созданный объект может заполнить форму элемента свойства любых свойств, которые принимают объект в качестве базового типа.  
  
 При включении преобразователя значений можно по-прежнему предоставлять значения объектов для типов, которые не соответствуют этим критериям. Дополнительные сведения см. в разделе [преобразователи типов и расширения разметки для XAML](type-converters-and-markup-extensions-for-xaml.md).  
  
### <a name="structures"></a>Структуры  
 Структуры всегда могут быть построены в XAML, по определению среды CLR. Это обусловлено тем, что компилятор CLR неявно создает конструктор без параметров для структуры. Этот конструктор инициализирует все значения свойств значениями по умолчанию.  
  
 В некоторых случаях поведение конструирования по умолчанию для структуры не желательно. Это может быть вызвано тем, что структура предназначена для заполнения значений и концептуально работает как объединение. Как объединение, содержащиеся значения могут иметь взаимоисключающие интерпретации, поэтому ни одно из его свойств не может быть задано. Примером такой структуры в словаре WPF является <xref:System.Windows.GridLength>. Такие структуры должны реализовывать преобразователь типов, чтобы значения можно было выразить в форме атрибутов с помощью строковых соглашений, которые создают различные интерпретации или режимы значений структуры. Структура должна также предоставлять аналогичное поведение для построения кода с помощью конструктора без параметров.  
  
### <a name="interfaces"></a>интерфейсов,  
 Интерфейсы можно использовать в качестве базовых типов элементов. Система типов XAML проверяет присваиваемый список и ждет, что объект, предоставленный в качестве значения, может быть назначен интерфейсу. Не существует концепции того, как интерфейс должен быть представлен как тип XAML, если соответствующий назначаемый тип поддерживает требования к конструкции XAML.  
  
### <a name="factory-methods"></a>Фабричные методы  
 Заводские методы являются функцией XAML 2009. Они изменяют принцип XAML, в котором объекты должны иметь конструкторы без параметров. В этом разделе не описаны заводские методы. См. раздел [Директива x:FactoryMethod](x-factorymethod-directive.md).  
  
## <a name="enumerations"></a>Перечисления  
 Перечисления имеют поведение преобразования собственного типа XAML. Имена констант перечисления, указанные в XAML, разрешаются для базового типа перечисления и возвращают значение перечисления в средство записи объектов XAML.  
  
 XAML поддерживает использование флагов для перечислений с применением <xref:System.FlagsAttribute>. Дополнительные сведения см. [в разделе Подробное описание синтаксиса XAML](../wpf/advanced/xaml-syntax-in-detail.md). ([Подробное описание синтаксиса XAML](../wpf/advanced/xaml-syntax-in-detail.md) написано для аудитории WPF, но большая часть информации в этом разделе ОТНОСИТСЯ к XAML, который не относится к конкретной реализующей платформе.)  
  
## <a name="member-definitions"></a>Определения элементов  
 Типы могут определять элементы для использования XAML. Типы, определяющие элементы, которые используются XAML, могут использоваться, даже если этот конкретный тип не может использоваться в XAML. Это возможно благодаря наследованию CLR. До тех пор, пока какой-либо тип, наследующий член, поддерживает использование XAML в качестве типа, а член поддерживает использование XAML для базового типа или имеет доступ к собственному синтаксису XAML, этот член может использоваться в XAML.  
  
### <a name="properties"></a>Свойства  
 Если вы определяете свойства как общедоступное свойство CLR с помощью стандартных шаблонов методов доступа CLR `get` и `set` и ключевых слов, соответствующих языку, система типов XAML может сообщить о свойстве в качестве члена с соответствующей информацией, предоставленной для свойств <xref:System.Xaml.XamlMember>, таких как <xref:System.Xaml.XamlMember.IsReadPublic%2A> и <xref:System.Xaml.XamlMember.IsWritePublic%2A>.  
  
 Определенные свойства могут включать текстовый синтаксис, применяя <xref:System.ComponentModel.TypeConverterAttribute>. Дополнительные сведения см. в разделе [преобразователи типов и расширения разметки для XAML](type-converters-and-markup-extensions-for-xaml.md).  
  
 В отсутствие текстового синтаксиса или преобразования машинного кода XAML, а также при отсутствии дальнейших косвенных обращений, таких как использование расширения разметки, тип свойства (<xref:System.Xaml.XamlMember.TargetType%2A> в системе типов XAML) должен иметь возможность возвращать экземпляр в средство записи объектов XAML, рассматривая целевой тип как тип CLR.  
  
 Если используется XAML 2009, [расширение разметки x:Reference](x-reference-markup-extension.md) можно использовать для предоставления значений, если предыдущие рекомендации не выполняются. Однако это является более частью проблемы использования, чем проблемы с определением типа.  
  
### <a name="events"></a>события  
 Если вы определяете события как общедоступное событие CLR, система типов XAML может сообщить о событии как члену с <xref:System.Xaml.XamlMember.IsEvent%2A> как `true`. Связывание обработчиков событий выходит за рамки .NET Framework возможностей служб XAML. Это оставлено конкретным платформам и реализациям.  
  
### <a name="methods"></a>Методы  
 Встроенный код для методов не является возможностью XAML по умолчанию. В большинстве случаев не следует напрямую ссылаться на члены методов из XAML, а роль методов в XAML — предоставить поддержку для конкретных шаблонов XAML. [Директива x:FactoryMethod](x-factorymethod-directive.md) является исключением.  
  
### <a name="fields"></a>Поля  
 Рекомендации по проектированию среды CLR не допустают нестатических полей. Для статических полей доступ к значениям статических полей можно получить только с помощью [расширения разметки x:Static](x-static-markup-extension.md). в этом случае не выполняется никаких специальных действий в определении CLR для предоставления поля для использования в [x:Static](x-static-markup-extension.md) .  
  
## <a name="attachable-members"></a>Присоединяемые члены  
 Присоединяемые члены предоставляются XAML через шаблон метода доступа для определяющего типа. Сам определяющий тип не обязательно должен быть доступен для использования в XAML как объект. На самом деле, распространенным шаблоном является объявление класса службы, роль которого заключается в том, чтобы присоединить присоединяемый член и реализовать соответствующие поведения, но не обслуживает другие функции, такие как представление пользовательского интерфейса. В следующих разделах местозаполнитель *PropertyName* представляет имя присоединяемого члена. Это имя должно быть допустимым в [грамматике имяxaml](xamlname-grammar.md).  
  
 Соблюдайте осторожность при конфликтах имен между этими шаблонами и другими методами типа. Если существует элемент, совпадающий с одним из шаблонов, он может быть интерпретирован обработчиком XAML как присоединяемый путь использования члена, даже если это не ваша цель.  
  
#### <a name="the-getpropertyname-accessor"></a>Метод доступа ИмяСвойства  
 Сигнатура для метода доступа `Get`*ИмяСвойства* должна быть следующей.  
  
 `public static object Get` *ИмяСвойства* `(object` `target` `)`  
  
- Объект `target` можно указать как более конкретный тип в реализации. Его можно использовать для определения области использования присоединяемого члена; использование за пределами предполагаемой области действия приведет к созданию недопустимых исключений приведения, которые затем выводятся в результате ошибки синтаксического анализа XAML. Имя параметра `target` не является обязательным, но с именем `target` по соглашению в большинстве реализаций.  
  
- Возвращаемое значение можно указать как более конкретный тип в реализации.  
  
 Для поддержки текстового синтаксиса с поддержкой <xref:System.ComponentModel.TypeConverter> для присоединяемого элемента примените <xref:System.ComponentModel.TypeConverterAttribute> к методу доступа `Get`*PropertyName* . Применение к `get` вместо `set` может показаться неинтуитивным; Однако это соглашение может поддерживать концепцию присоединяемых членов только для чтения, которые являются сериализуемыми, что полезно в сценариях конструктора.  
  
#### <a name="the-setpropertyname-accessor"></a>Метод доступа Сетпропертинаме  
 Сигнатура для метода доступа set*PropertyName* должна иметь следующее значение:  
  
 `public static void Set` *ИмяСвойства* `(object` `target` `, object` `value` `)`  
  
- Объект `target` может быть указан в реализации в качестве более конкретного типа с той же логикой и последствиями, как описано в предыдущем разделе.  
  
- Объект `value` можно указать как более конкретный тип в реализации.  
  
 Помните, что значение этого метода является входными данными, поступающими от использования XAML, обычно в форме атрибута. В форме атрибута должна быть поддержка преобразователя значений для текстового синтаксиса, и атрибут для метода доступа `Get`*PropertyName* .  
  
### <a name="attachable-member-stores"></a>Хранилища присоединяемых членов  
 Методы доступа обычно недостаточно для предоставления средств для размещения значений присоединяемых членов в графе объектов, а также для извлечения значений из графа объектов и их правильной сериализации. Чтобы обеспечить эту функциональность, объекты `target` в предыдущих сигнатурах метода доступа должны иметь возможность хранить значения. Механизм хранения должен соответствовать принципу присоединяемого члена, который прикрепляется к целевым объектам, в которых присоединяемый элемент отсутствует в списке членов. .NET Framework службы XAML предоставляют метод реализации для присоединяемых хранилищ членов через API-интерфейсы <xref:System.Xaml.IAttachedPropertyStore> и <xref:System.Xaml.AttachablePropertyServices>. <xref:System.Xaml.IAttachedPropertyStore> используется модулями записи XAML для обнаружения реализации хранилища и должна быть реализована в типе, который является `target` методов доступа. Статические <xref:System.Xaml.AttachablePropertyServices> интерфейсы API используются в теле методов доступа и ссылаются на присоединяемый член по его <xref:System.Xaml.AttachableMemberIdentifier>.  
  
## <a name="xaml-related-clr-attributes"></a>Связанные с XAML атрибуты среды CLR  
 Правильное присвоение атрибутов типам, членам и сборкам важно для передачи сведений о системе типов XAML .NET Framework службам XAML. Это уместно, если вы планируете использовать типы для систем XAML, которые непосредственно основаны на .NET Framework средств чтения XAML служб XAML и модулях записи XAML, или если вы определили или используете платформу, использующую XAML, основанную на этих средствах чтения и записи XAML.  
  
 Список всех атрибутов, связанных с XAML, которые относятся к поддержке XAML пользовательских типов, см. в разделе связанные с XAML [атрибуты среды CLR для пользовательских типов и библиотек](xaml-related-clr-attributes-for-custom-types-and-libraries.md).  
  
## <a name="usage"></a>Использование  
 Для использования пользовательских типов необходимо, чтобы автор разметки сопоставлял префикс для сборки и пространство имен CLR, которое содержит пользовательский тип. Эта процедура не описана в этом разделе.  
  
## <a name="access-level"></a>Уровень доступа  
 XAML предоставляет средства для загрузки и создания экземпляров типов, имеющих `internal` уровня доступа. Эта возможность предоставляется, чтобы пользовательский код мог определять собственные типы, а затем создавать экземпляры этих классов из разметки, которая также является частью одной и той же области пользовательского кода.  
  
 Примером из WPF является каждый раз, когда пользовательский код определяет <xref:System.Windows.Controls.UserControl>, предназначенный для оптимизации поведения пользовательского интерфейса, но не как часть любого возможного механизма расширения, который может быть подразумеваемым объявлением вспомогательного класса с `public` уровнем доступа. Такие <xref:System.Windows.Controls.UserControl> могут быть объявлены с `internal` доступом, если резервный код компилируется в ту же сборку, из которой он ссылается как на тип XAML.  
  
 Для приложения, которое загружает XAML в режиме полного доверия и использует <xref:System.Xaml.XamlObjectWriter>, Загрузка классов с уровнем доступа `internal` всегда включена.  
  
 Для приложения, которое загружает XAML в режиме частичного доверия, можно управлять характеристиками уровня доступа с помощью <xref:System.Xaml.Permissions.XamlAccessLevel> API. Кроме того, механизмы отсрочки (например, система шаблонов WPF) должны иметь возможность распространять любые разрешения уровня доступа и сохранять их для выполнения в конечном итоге. Это осуществляется внутренним образом путем передачи сведений о <xref:System.Xaml.Permissions.XamlAccessLevel>.  
  
### <a name="wpf-implementation"></a>Реализация WPF  
 XAML WPF использует модель доступа с частичным доверием, где при загрузке BAML в режиме частичного доверия доступ ограничен <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> для сборки, являющейся источником BAML. Для РБП WPF использует <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> как механизм передачи сведений об уровне доступа.  
  
 В терминологии WPF XAML *внутренний тип* — это тип, определяемый той же сборкой, которая также включает ссылающийся XAML. Такой тип можно сопоставить с помощью пространства имен XAML, которое намеренно опускает сборку = часть сопоставления, например `xmlns:local="clr-namespace:WPFApplication1"`.  Если BAML ссылается на внутренний тип, а этот тип имеет `internal` уровень доступа, то для сборки создается `GeneratedInternalTypeHelper` класс. Если вы хотите избежать `GeneratedInternalTypeHelper`, необходимо использовать уровень доступа `public` или понести соответствующий класс в отдельную сборку и сделать ее зависимой.  
  
## <a name="see-also"></a>См. также

- [Относящиеся к XAML атрибуты среды CLR для пользовательских типов и библиотек](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [Службы XAML](index.md)
