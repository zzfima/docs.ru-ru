---
title: Общее представление о понятиях и структурах потока узлов XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: 2c8093c3ef497bd836427f71098e62626f228e24
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/07/2019
ms.locfileid: "73733390"
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="a7e9c-102">Общее представление о понятиях и структурах потока узлов XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-102">Understanding XAML Node Stream Structures and Concepts</span></span>

<span data-ttu-id="a7e9c-103">Средства чтения и записи XAML, реализованные в службах XAML .NET Framework, основаны на принципе проектирования потока узлов XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-103">XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="a7e9c-104">Поток узлов XAML — это концептуальное представление набора узлов XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="a7e9c-105">В этом концептуальном представлении обработчик XAML проходит по структуре связей узлов в XAML поочередно.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="a7e9c-106">В каждый момент времени в открытом потоке узлов XAML существует только одна текущая запись или текущая позиция, и многие аспекты API сообщают только информацию, доступную из этой позиции.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="a7e9c-107">Текущий узел в потоке узлов XAML можно описать как объект, член или значение.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="a7e9c-108">Рассматривая XAML как поток узлов XAML, средства чтения XAML могут взаимодействовать со средствами записи XAML и позволять программе просматривать содержимое потока узлов XAML, взаимодействовать с ним или изменять его во время функционирования пути загрузки или пути сохранения, использующего XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="a7e9c-109">Структура API средства чтения и записи XAML и концепция потока узлов XAML аналогичны предыдущим проектам и концепциям модуля чтения и записи, таким как XML-модель DOM (DOM) и классы <xref:System.Xml.XmlReader> и <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the XML Document Object Model (DOM) and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="a7e9c-110">В этом разделе рассматриваются концепции потока узлов XAML и описывается, как можно создавать подпрограммы, взаимодействующие с представлениями XAML на уровне узлов XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

<a name="loading_into_a_xaml_reader"></a>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="a7e9c-111">Загрузка XAML в средство чтения XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="a7e9c-112">Базовый класс <xref:System.Xaml.XamlReader> не объявляет конкретный метод загрузки исходного XAML в средство чтения XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="a7e9c-113">Вместо этого метод загрузки, включая общие характеристики и ограничения его источника входных данных для XAML, объявляет и реализует производный класс.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="a7e9c-114">Например, класс <xref:System.Xaml.XamlObjectReader> читает граф объектов, начиная с источника входных данных одного объекта, который представляет корень или базу.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="a7e9c-115">Затем класс <xref:System.Xaml.XamlObjectReader> создает поток узлов XAML из этого графа объектов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="a7e9c-116">Наиболее показательным подклассом <xref:System.Xaml.XamlReader> , задаваемым службами XAML .NET Framework, является <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-116">The most prominent .NET Framework XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="a7e9c-117">Подкласс<xref:System.Xaml.XamlXmlReader> загружает исходный XAML либо непосредственно, путем загрузки текстового файла через поток или путь к файлу, либо косвенно — через связанный класс средства чтения, такой как <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="a7e9c-118">Класс <xref:System.Xaml.XamlReader> можно рассматривать как содержащий весь источник входных данных XAML после его загрузки.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="a7e9c-119">Однако базовый API <xref:System.Xaml.XamlReader> разработан таким образом, чтобы средство чтения взаимодействовало с одним узлом XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="a7e9c-120">После первой загрузки первый обнаруженный узел является корнем XAML и его начальным объектом.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="a7e9c-121">Концепция потока узлов XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="a7e9c-122">Если вам в целом более знакома модель DOM, представление в виде дерева или подход на основе запроса в отношении доступа к XML-технологиям, то удобнее всего объяснить поток узлов XAML следующим образом.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-122">If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="a7e9c-123">Представьте себе загруженный XAML в виде модели DOM или дерева, где каждый возможный узел полностью развернут, а затем представлен в линейной форме.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="a7e9c-124">При переходе по узлам вы можете проходить «в» уровни или «из» уровней, которые относятся к модели DOM, но поток узлов XAML явно не отслеживается, так как эти понятия уровней не относятся к потоку узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="a7e9c-125">Поток узлов имеет «текущую» позицию, но пока вы самостоятельно не сохраните другие части потока как ссылки, любой аспект потока узлов, кроме текущего положения узла, находится вне поля зрения за пределами окна просмотра.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="a7e9c-126">Существенное преимущество концепции потока узлов XAML заключается в том, что при проходе по всему потоку узла будет гарантированно обработано все представление XAML; не нужно беспокоиться, что запрос, операция DOM или какой-либо другой нелинейный способ обработки информации пропустит часть представления XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="a7e9c-127">По этой причине представление потока узлов XAML идеально подходит как для соединения средств чтения и записи XAML, так и для построения системы, в которой можно вставить собственный процесс, выполняемый между этапами чтения и записи операции обработки XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="a7e9c-128">Во многих случаях порядок узлов в потоке узлов XAML намеренно оптимизируется или изменяется средствами чтения XAML по сравнению с тем порядком, который может отображаться в исходном тексте, двоичном объекте или графе объекта.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="a7e9c-129">Это поведение предусмотрено для обеспечения архитектуры обработки XAML, в которой средства записи XAML никогда не оказываются в позиции, где они должны переходить «назад» в потоке узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="a7e9c-130">В идеале все операции записи XAML должны быть способны выполняться на основе контекста схемы и текущей позиции в потоке узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

<a name="a_basic_reading_node_loop"></a>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="a7e9c-131">Основной цикл узлов чтения</span><span class="sxs-lookup"><span data-stu-id="a7e9c-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="a7e9c-132">Основной цикл узлов чтения для анализа потока узлов XAML включает следующие концепции.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="a7e9c-133">Применительно к циклам узлов, рассматриваемым в этом разделе, предположим, что вы читаете понятный для пользователя текстовый файл XAML с помощью <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="a7e9c-134">Ссылки в этом разделе относятся к конкретному API цикла узлов XAML, реализуемому <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="a7e9c-135">Убедитесь, что вы не находитесь в конце потока узлов XAML (проверьте <xref:System.Xaml.XamlXmlReader.IsEof%2A>, или используйте возвращаемое значение <xref:System.Xaml.XamlXmlReader.Read%2A> ).</span><span class="sxs-lookup"><span data-stu-id="a7e9c-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="a7e9c-136">Если вы находитесь в конце потока, то текущий узел отсутствует и следует выйти.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="a7e9c-137">Проверьте, какой тип узла предоставляет в настоящий момент поток узлов XAML, путем вызова <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="a7e9c-138">Если имеется связанное средство записи объектов XAML, которое подключено напрямую, то на этом этапе обычно вызывается метод <xref:System.Xaml.XamlWriter.WriteNode%2A> .</span><span class="sxs-lookup"><span data-stu-id="a7e9c-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="a7e9c-139">В зависимости от типа <xref:System.Xaml.XamlNodeType> , возвращенного для текущего узла или текущей записи, вызовите один из следующих объектов, чтобы получить сведения о содержимом узла.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="a7e9c-140">Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.StartMember> или <xref:System.Xaml.XamlNodeType.EndMember>вызовите <xref:System.Xaml.XamlXmlReader.Member%2A> , чтобы получить сведения <xref:System.Xaml.XamlMember> о члене.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="a7e9c-141">Обратите внимание, что этот член может быть <xref:System.Xaml.XamlDirective>, и поэтому не обязательно является стандартно определяемым членом предыдущего объекта.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-141">Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="a7e9c-142">Например, примененная к объекту директива `x:Name` отображается как член XAML, свойство <xref:System.Xaml.XamlMember.IsDirective%2A> которого имеет значение true, свойство <xref:System.Xaml.XamlMember.Name%2A> этого члена имеет значение `Name`, а другие свойства указывают, что эта директива находится в пространстве имен XAML языка XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="a7e9c-143">Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.StartObject> или <xref:System.Xaml.XamlNodeType.EndObject>вызовите <xref:System.Xaml.XamlXmlReader.Type%2A> , чтобы получить сведения <xref:System.Xaml.XamlType> об объекте.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="a7e9c-144">Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.Value>вызовите <xref:System.Xaml.XamlXmlReader.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="a7e9c-145">Узел имеет значение только в том случае, если он является простейшим выражением значения для члена или текстом инициализации объекта (однако следует иметь в виду поведение преобразования типов, как описано в следующем разделе этой статьи).</span><span class="sxs-lookup"><span data-stu-id="a7e9c-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="a7e9c-146">Для типа <xref:System.Xaml.XamlXmlReader.NodeType%2A> объекта <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>вызовите <xref:System.Xaml.XamlXmlReader.Namespace%2A> , чтобы получить сведения о пространстве имен для узла пространства имен.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="a7e9c-147">Вызовите метод <xref:System.Xaml.XamlXmlReader.Read%2A> , чтобы средство чтения XAML перешло к следующему узлу в потоке узлов XAML, и повторите эти действия.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="a7e9c-148">Поток узлов XAML, предоставляемый средствами чтения XAML служб XAML .NET Framework, всегда обеспечивает полный глубокий просмотр всех возможных узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-148">The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="a7e9c-149">Типичные методы управления потоком для цикла узлов XAML включают определение текста в цикле `while (reader.Read())`и переключение на <xref:System.Xaml.XamlXmlReader.NodeType%2A> в каждой точке узла в цикле узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="a7e9c-150">Если поток узлов находится в конце файла, текущий узел имеет значение null.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="a7e9c-151">В следующем примере показан простейший цикл, использующий средства чтения и записи.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="a7e9c-152">Этот простой пример цикла узлов XAML пути загрузки прозрачно связывает средство чтения XAML и средство записи XAML, выполняя то же самое, что выполняется при использовании метода <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a7e9c-153">Но затем эта базовая структура расширяется для применения в сценарии чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="a7e9c-154">Далее приведены некоторые возможные сценарии.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="a7e9c-155">Переключиться в <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="a7e9c-156">Выполнять разные действия в зависимости от того, какой узел читается.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="a7e9c-157">Не вызывать метод <xref:System.Xaml.XamlWriter.WriteNode%2A> во всех случаях.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="a7e9c-158">Вызывать метод <xref:System.Xaml.XamlWriter.WriteNode%2A> только в некоторых случаях <xref:System.Xaml.XamlXmlReader.NodeType%2A> .</span><span class="sxs-lookup"><span data-stu-id="a7e9c-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="a7e9c-159">В пределах логики для конкретного типа узла анализировать особенности этого узла и работать с ними.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="a7e9c-160">Например, вы можете записать только объекты, которые берутся из определенного пространства имен XAML, а затем удалить или задержать все объекты не из этого пространства имен XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-160">For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="a7e9c-161">Вы также можете удалить или иным образом повторно обработать все директивы XAML, которые не поддерживаются вашей системой XAML, в рамках обработки элементов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="a7e9c-162">Определить пользовательский объект <xref:System.Xaml.XamlObjectWriter> , который переопределяет методы `Write*` , возможно, выполняя сопоставление типов, обходящее контекст схемы XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="a7e9c-163">Создать объект <xref:System.Xaml.XamlXmlReader> для использования контекста схемы XAML не по умолчанию, чтобы настроенные различия в поведении XAML использовались как средством чтения, так и средством записи.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="a7e9c-164">Доступ к XAML за рамками концепции цикла узлов</span><span class="sxs-lookup"><span data-stu-id="a7e9c-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="a7e9c-165">Помимо цикла узлов XAML существуют и другие способы работы с представлением XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="a7e9c-166">Например, может существовать  средство чтения XAML, которое может читать индексированный узел, в частности обращаться к узлам напрямую с помощью директивы `x:Name`, `x:Uid`или используя другие идентификаторы.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="a7e9c-167">Службы XAML .NET Framework не обеспечивают полную реализацию, но предоставляют рекомендуемый шаблон с помощью служб и типов поддержки.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-167">.NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="a7e9c-168">Дополнительные сведения см. в разделах <xref:System.Xaml.IXamlIndexingReader> и <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

<a name="working_with_the_current_node"></a>

## <a name="working-with-the-current-node"></a><span data-ttu-id="a7e9c-169">Работа с текущим узлом</span><span class="sxs-lookup"><span data-stu-id="a7e9c-169">Working with the Current Node</span></span>

<span data-ttu-id="a7e9c-170">В большинстве сценариев, использующих цикл узлов XAML, выполняется не только чтение узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="a7e9c-171">В большинстве сценариев обрабатывается текущий узел, а затем каждый узел по одному передается в реализацию <xref:System.Xaml.XamlWriter>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="a7e9c-172">В типичном сценарии пути загрузки <xref:System.Xaml.XamlXmlReader> создает поток узлов XAML; узлы XAML обрабатываются в соответствии с заданной логикой и контекстом схемы XAML; затем узлы передаются в <xref:System.Xaml.XamlObjectWriter>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="a7e9c-173">Затем вы интегрируете полученный граф объектов в свое приложение или структуру.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="a7e9c-174">В типичном сценарии пути сохранения <xref:System.Xaml.XamlObjectReader> читает граф объектов; отдельные узлы XAML обрабатываются; затем <xref:System.Xaml.XamlXmlWriter> выдает сериализованный результат в виде текстового файла XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="a7e9c-175">Главное заключается в том, что оба пути и сценария подразумевают работу только с одним узлом XAML в каждый момент времени, и узлы XAML доступны для стандартной обработки, которая определяется системой типов XAML и API служб XAML .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="a7e9c-176">Фреймы и область</span><span class="sxs-lookup"><span data-stu-id="a7e9c-176">Frames and Scope</span></span>

<span data-ttu-id="a7e9c-177">Цикл узлов XAML проходит по потоку узлов XAML линейным образом.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="a7e9c-178">Поток узлов углубляется в объекты, в члены, которые содержат другие объекты, и т. д.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="a7e9c-179">Часто бывает удобно отслеживать область в потоке узлов XAML путем реализации концепции фрейма и стека.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="a7e9c-180">В частности, это справедливо для случая активной настройки потока узла при нахождении в нем.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="a7e9c-181">Поддержка кадра и стека, реализуемая в рамках логики цикла узлов, может учитывать области `StartObject` (или `GetObject`) и `EndObject` по мере углубления в структуру узлов XAML, если рассматривать структуру с точки зрения модели DOM.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

<a name="traversing_and_entering_object_nodes"></a>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="a7e9c-182">Обход узлов объекта и вход в них</span><span class="sxs-lookup"><span data-stu-id="a7e9c-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="a7e9c-183">Первым узлом в потоке узлов при его открытии средством чтения XAML является узел начального объекта корневого объекта.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="a7e9c-184">По определению этот объект всегда является узлом одного объекта и не имеет одноранговых узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="a7e9c-185">В любом реальном примере XAML корневой объект определяется с одним или несколькими свойствами, содержащими дополнительные объекты, и эти свойства имеют узлы-члены.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="a7e9c-186">В свою очередь, узлы-члены могут иметь один или несколько узлов-объектов или вместо этого заканчиваться в узле значения.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="a7e9c-187">Корневой объект обычно определяет области имен XAML, которые синтаксически назначаются как атрибуты в текстовой разметке XAML, но соответствуют типу узла `Namescope` в представлении потока узлов XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="a7e9c-188">Рассмотрим следующий пример XAML (это произвольный XAML, не реализуемый существующими типами в платформе .NET Framework).</span><span class="sxs-lookup"><span data-stu-id="a7e9c-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).</span></span> <span data-ttu-id="a7e9c-189">Предполагается, что в этой объектной модели `FavorCollection` является `List<T>` объектов `Favor`, `Balloon` и `NoiseMaker` , которые могут быть присвоены `Favor`, свойство `Balloon.Color` поддерживается объектом `Color` аналогично тому, как в WPF цвета задаются при помощи известных названий цветов, а объект `Color` поддерживает преобразователь типов для синтаксиса атрибутов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="a7e9c-190">Разметка XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-190">XAML markup</span></span>|<span data-ttu-id="a7e9c-191">Итоговый поток узлов XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="a7e9c-192">`Namespace` для `Party`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="a7e9c-193">`StartObject` для `Party`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="a7e9c-194">`StartMember` для `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="a7e9c-195">`StartObject` для неявного объекта `FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="a7e9c-196">Узел`StartMember` для свойства неявных элементов `FavorCollection` .</span><span class="sxs-lookup"><span data-stu-id="a7e9c-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="a7e9c-197">`StartObject` для `Balloon`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="a7e9c-198">`StartMember` для `Color`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="a7e9c-199">`Value` для строки значения атрибута `"Red"`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="a7e9c-200">`EndMember` для `Color`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="a7e9c-201">`StartMember` для `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="a7e9c-202">`Value` для строки значения атрибута `"True"`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="a7e9c-203">`EndMember` для `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="a7e9c-204">`EndObject` для `Balloon`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="a7e9c-205">`StartObject` для `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="a7e9c-206">`StartMember` для `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="a7e9c-207">`Value` для строки значения инициализации `"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="a7e9c-208">`EndMember` для `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="a7e9c-209">`EndObject` для `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="a7e9c-210">Узел`EndMember` для свойства неявных элементов `FavorCollection` .</span><span class="sxs-lookup"><span data-stu-id="a7e9c-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="a7e9c-211">`EndObject` для неявного объекта `FavorCollection`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="a7e9c-212">`EndMember` для `Favors`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="a7e9c-213">`EndObject` для `Party`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="a7e9c-214">В потоке узлов XAML можно рассчитывать на следующее поведение.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="a7e9c-215">Если узел `Namespace` существует, он добавляется в поток непосредственно перед объектом `StartObject` , который объявил пространство имен XAML с помощью `xmlns`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="a7e9c-216">Давайте снова взглянем на предыдущую таблицу с XAML и примером потока узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="a7e9c-217">Обратите внимание, как, по всей видимости, будут перемещены узлы `StartObject` и `Namespace` по сравнению с их объявленными позициями в разметке текста.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="a7e9c-218">Это типичное представление поведения, в котором узлы пространства имен всегда отображаются перед узлом, к которому они имеют отношение в потоке узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="a7e9c-219">Смысл этой конструкции заключается в том, что сведения о пространстве имен, необходимые для средств записи объектов, должны быть известны до того, как средство записи объекта попытается выполнить сопоставление типов или другую обработку объекта.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="a7e9c-220">Помещение сведений о пространстве имен XAML перед его областью применения в потоке облегчает обработку потока узлов в представленном порядке.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="a7e9c-221">По этой причине в большинстве случаев реального использования разметки существует один или несколько узлов `Namespace` , которые читаются первыми при обходе узлов с начала, а не с объекта `StartObject` корня.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="a7e9c-222">За узлом `StartObject` может следовать `StartMember`, `Value`или непосредственно `EndObject`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="a7e9c-223">За ним никогда не следует сразу же другой `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="a7e9c-224">За `StartMember` может следовать `StartObject`, `Value`или непосредственно `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="a7e9c-225">За ним может следовать `GetObject`, для членов, в которых значение должно быть получено из существующего значения родительского объекта, а не из `StartObject` , который может создавать экземпляр нового значения.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="a7e9c-226">За ним также может следовать узел `Namespace` , который относится к следующему `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="a7e9c-227">За ним никогда не следует сразу же другой `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="a7e9c-228">Узел `Value` представляет само значение; это не EndValue.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="a7e9c-229">За ним может следовать только `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="a7e9c-230">Текст инициализации XAML объекта, который может использоваться конструкцией, не приводит к структуре «Объект-значение».</span><span class="sxs-lookup"><span data-stu-id="a7e9c-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="a7e9c-231">Вместо этого создается выделенный узел для члена с именем `_Initialization` ,</span><span class="sxs-lookup"><span data-stu-id="a7e9c-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="a7e9c-232">и этот узел члена содержит строку значения инициализации.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="a7e9c-233">Если он существует, то `_Initialization` всегда является первым `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="a7e9c-234">Член`_Initialization` может быть определен в некоторых представлениях служб XAML при помощи области имен XAML языка XAML, чтобы уточнить, что `_Initialization` не является заданным свойством в резервных типах.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="a7e9c-235">Комбинация «Член-значение» представляет настройку атрибута значения.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="a7e9c-236">В конечном итоге возможно включение преобразователя значений в обработку этого значения, и значение представляет собой простую строку.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="a7e9c-237">Однако это не вычисляется до тех пор, пока средство записи объектов XAML не обработает этот поток узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="a7e9c-238">Средство записи объектов XAML обрабатывает необходимый контекст схемы XAML, сопоставление системы типов и другую поддержку, необходимую для преобразований значений.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="a7e9c-239">За узлом `EndMember` может следовать узел `StartMember` для последующего члена или узел `EndObject` для владельца этого члена.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="a7e9c-240">За узлом `EndObject` может следовать узел `EndMember` .</span><span class="sxs-lookup"><span data-stu-id="a7e9c-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="a7e9c-241">За ним может также следовать узел `StartObject` для случаев, когда эти объекты являются одноранговыми узлами в элементах коллекции.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="a7e9c-242">Кроме того, за ним может следовать узел `Namespace` , который относится к следующему `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="a7e9c-243">В исключительном случае закрытия всего потока узлов за объектом `EndObject` корня не следует ничего; средство чтения достигает конца файла, и метод <xref:System.Xaml.XamlReader.Read%2A> возвращает значение `false`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

<a name="value_converters_and_the_xaml_node_stream"></a>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="a7e9c-244">Преобразователи значений и поток узлов XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="a7e9c-245">Преобразователь значений — это общий термин для расширения разметки, преобразователя типов (включая сериализаторы значений) или другого выделенного класса, указанного как преобразователь значений в системе типов XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="a7e9c-246">В потоке узлов XAML использование преобразователя типов и использование расширения разметки имеют совершенно разные представления.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="a7e9c-247">Преобразователи значений в потоке узлов XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="a7e9c-248">Набор атрибутов, который в конечном итоге приводит к использованию преобразователя типов, сообщается в поток узлов XAML как значение члена.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="a7e9c-249">Поток узлов XAML не пытается создать экземпляр объекта преобразователя типов и передать ему значение.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="a7e9c-250">Использование реализации преобразования преобразователя типов требует вызова контекста схемы XAML и использования его для сопоставления типов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="a7e9c-251">Даже для определения того, какой класс преобразователя типов следует использовать для обработки значения, косвенно требуется контекст схемы языка XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="a7e9c-252">При использовании контекста схемы XAML по умолчанию эти сведения можно получить из системы типов XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="a7e9c-253">Если сведения класса преобразователя типов на уровне потока узлов XAML требуются до подключения к средству записи XAML, их можно получить из сведений <xref:System.Xaml.XamlMember> устанавливаемого члена.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="a7e9c-254">Однако в противном случае входные данные преобразователя типов должны быть сохранены в потоке узлов XAML в виде простого значения до того, как будет выполняться оставшаяся часть операций, которым требуется система сопоставления типов и контекст схемы XAML, например создание объекта средством записи объекта XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="a7e9c-255">Например, рассмотрим следующую структуру определения класса и использования для него XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="a7e9c-256">Текстовое представление потока узлов XAML для данного использования можно выразить следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a7e9c-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="a7e9c-257">`StartObject` с <xref:System.Xaml.XamlType> , представляющий `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="a7e9c-258">`StartMember` с <xref:System.Xaml.XamlMember> , представляющий `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="a7e9c-259">Узел`Value` с текстовой строкой "`8x8`"</span><span class="sxs-lookup"><span data-stu-id="a7e9c-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="a7e9c-260">`EndMember` , соответствующий `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="a7e9c-261">`EndObject` , соответствующий `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="a7e9c-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="a7e9c-262">Обратите внимание, что в этом потоке узлов отсутствует экземпляр преобразователя типов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="a7e9c-263">Однако вы можете получить сведения о преобразователе типов, вызвав <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> в <xref:System.Xaml.XamlMember> для `BoardSize`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="a7e9c-264">При наличии допустимого контекста схемы XAML можно также вызвать методы преобразователя, получив экземпляр из <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="a7e9c-265">Расширения разметки в потоке узлов XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="a7e9c-266">Об использовании расширения разметки сообщается в поток узлов XAML как об узле объекта в члене, где объект представляет экземпляр расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="a7e9c-267">Таким образом, использование расширения разметки более явно представлено в представлении потока узлов, чем использование преобразователя типов, и содержит больше сведений.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="a7e9c-268">Сведения<xref:System.Xaml.XamlMember> могут ничего не сообщать о расширении разметки, поскольку его использование зависит от ситуации и меняется в каждом возможном случае разметки; оно не является выделенным и неявным согласно типу или члену, как в случае с преобразователями типов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="a7e9c-269">Представление потока узлов расширений разметки как узлов объектов происходит даже в случае, когда использование расширения разметки было сделано в форме атрибута в текстовой разметке XAML (что происходит часто).</span><span class="sxs-lookup"><span data-stu-id="a7e9c-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="a7e9c-270">Использование расширения разметки с применением явных форм элементов объектов интерпретируется таким же образом.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="a7e9c-271">Внутри узла объекта расширения разметки могут находиться члены этого расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="a7e9c-272">Представление потока узлов XAML сохраняет использование этого расширения разметки, будь это использование позиционного параметра или использование с помощью явно указанных параметров.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="a7e9c-273">При использовании позиционного параметра поток узлов XAML содержит заданное на уровне языка XAML свойство `_PositionalParameters` , регистрирующее это использование.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="a7e9c-274">Это свойство является универсальным <xref:System.Collections.Generic.List%601> с ограничением <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="a7e9c-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="a7e9c-275">Это ограничение является объектом, а не строкой, поскольку предположительно использование позиционного параметра может содержать в себе вложенные использования расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="a7e9c-276">Для доступа к позиционным параметрам из использования можно выполнить итерацию по списку и применять индексаторы для отдельных значений списка.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="a7e9c-277">При использовании именованных параметров каждый именованный параметр представляется как узел члена с этим именем в потоке узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="a7e9c-278">Значения членов не обязательно являются строками, поскольку может использоваться вложенное расширение разметки.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="a7e9c-279">`ProvideValue` из расширения разметки еще не вызывался.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="a7e9c-280">Однако он вызывается при подключении средства чтения XAML и средства записи XAML, чтобы вызывался `WriteEndObject` в узле расширения разметки при его исследовании в потоке узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="a7e9c-281">По этой причине обычно требуется доступ к тому же контексту схемы XAML, который использовался бы для формирования графа объектов в пути загрузки.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="a7e9c-282">В противном случае `ProvideValue` из любого расширения разметки может вызывать здесь исключения, поскольку не имеет доступа к ожидаемым службам.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="a7e9c-283">Члены, заданные на уровне XAML и XML, в потоке узлов XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="a7e9c-284">Определенные члены введены в поток узлов XAML из-за определений и соглашений средства чтения XAML, вместо того чтобы использовать явный поиск или построение <xref:System.Xaml.XamlMember> .</span><span class="sxs-lookup"><span data-stu-id="a7e9c-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="a7e9c-285">Часто эти члены являются директивами XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="a7e9c-286">В некоторых случаях это действие чтения XAML, вводящее директиву в поток узлов XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="a7e9c-287">Иными словами, в исходном тексте входного кода XAML не было явно указано директива Member, но средство чтения XAML вставляет директиву для удовлетворения структурного соглашения XAML и сообщает сведения в потоке узлов XAML, прежде чем эта информация будет потеряна.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="a7e9c-288">В следующем списке отмечены все случаи, в которых средство чтения XAML, как ожидается, вводит узел члена директивы XAML, и как этот узел члена идентифицируется в реализациях служб XAML .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.</span></span>

- <span data-ttu-id="a7e9c-289">**Текст инициализации для узла объекта.** Имя этого узла члена — `_Initialization`, он представляет собой директиву XAML и определен в пространстве имен XAML языка XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="a7e9c-290">Вы можете получить для него статическую сущность из <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="a7e9c-291">**Позиционные параметры для расширения разметки.** Имя этого узла члена — `_PositionalParameters`, и он определен в пространстве имен XAML языка XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="a7e9c-292">Он всегда содержит универсальный список объектов, каждый из которых является позиционным параметром, предварительно отделенным по символу-разделителю `,` , как представлено во входных данных XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="a7e9c-293">Вы можете получить статическую сущность для директивы позиционных параметров из <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="a7e9c-294">**Неизвестное содержимое.** Имя этого узла члена — `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="a7e9c-295">Строго говоря, это директива <xref:System.Xaml.XamlDirective>, которая определяется в пространстве имен XAML языка XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="a7e9c-296">Эта директива используется как сигнальная метка в случаях, когда в элементе объекта XAML имеется содержимое в исходном XAML, но никакое свойство содержимого невозможно определить в рамках текущего доступного контекста схемы XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="a7e9c-297">Такой случай можно обнаружить в потоке узлов XAML, проверив члены с именем `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="a7e9c-298">Если в потоке узлов XAML пути загрузки никакие другие действия не выполняются, вызывается <xref:System.Xaml.XamlObjectWriter> по умолчанию при попытке `WriteEndObject` , когда в каком-либо объекте обнаруживается член `_UnknownContent` .</span><span class="sxs-lookup"><span data-stu-id="a7e9c-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="a7e9c-299">Объект <xref:System.Xaml.XamlXmlWriter> по умолчанию не вызывается и рассматривает этот член как неявный.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="a7e9c-300">Вы можете получить статическую сущность для `_UnknownContent` из <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="a7e9c-301">**Свойство коллекции коллекции:** Несмотря на то что резервный тип CLR класса коллекции, используемого для XAML, обычно имеет выделенное именованное свойство, содержащее элементы коллекции, это свойство неизвестно системе типов XAML до резервного разрешения типов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="a7e9c-302">Вместо этого поток узлов XAML вводит заполнитель `Items` в качестве члена типа коллекции XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="a7e9c-303">В реализации служб XAML .NET Framework имя этой директивы/члена в потоке узлов — `_Items`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-303">In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`.</span></span> <span data-ttu-id="a7e9c-304">Константу для этой директивы можно получить из <xref:System.Xaml.XamlLanguage.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="a7e9c-305">Обратите внимание, что поток узлов XAML может содержать свойство Items с элементами, которые не могут быть проанализированы на основе разрешения резервных типов и контекста схемы XAML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="a7e9c-306">Например, примененная к объекту директива</span><span class="sxs-lookup"><span data-stu-id="a7e9c-306">For example,</span></span>

- <span data-ttu-id="a7e9c-307">**Члены, определенные в XML.** Определенные в XML члены `xml:base`, `xml:lang` и `xml:space` сообщаются как директивы XAML с именами `base`, `lang`и `space` в реализациях служб XAML .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="a7e9c-308">Их пространство имен — это пространство имен XML `http://www.w3.org/XML/1998/namespace`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="a7e9c-309">Константы для каждого из них можно получить из <xref:System.Xaml.XamlLanguage>.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="a7e9c-310">Порядок узлов</span><span class="sxs-lookup"><span data-stu-id="a7e9c-310">Node Order</span></span>

<span data-ttu-id="a7e9c-311">В некоторых случаях <xref:System.Xaml.XamlXmlReader> изменяет порядок узлов XAML в потоке узлов XAML по сравнению с порядком, в котором эти узлы отображаются при просмотре в разметке или при обработке в виде XML.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="a7e9c-312">Это делается для упорядочения узлов таким образом, чтобы средство записи <xref:System.Xaml.XamlObjectWriter> могло обрабатывать этот поток узлов в режиме только вперед.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="a7e9c-313">В службах XAML .NET Framework средство чтения XAML изменяет порядок узлов, не оставляя эту задачу средству записи XAML, в целях оптимизации производительности для потребителей средства записи объектов XAML в потоке узлов.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-313">In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="a7e9c-314">Некоторые директивы предназначены специально в целях предоставления дополнительных сведений для создания объекта из элемента объекта.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="a7e9c-315">Это директивы `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="a7e9c-316">Средства чтения  XAML служб XAML .NET Framework пытаются разместить эти директивы в качестве первых членов в потоке узлов, следующем за `StartObject`объекта, по причинам, которые разъясняются в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-316">The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="a7e9c-317">Поведение XamlObjectWriter и порядок узлов</span><span class="sxs-lookup"><span data-stu-id="a7e9c-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="a7e9c-318">`StartObject` в <xref:System.Xaml.XamlObjectWriter> не обязательно сигнализирует средству записи объектов XAML немедленно создать экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="a7e9c-319">XAML включает несколько функций языка, позволяющих инициализировать объект с дополнительными входными данными, а также не полагаться полностью на вызов конструктора без параметров для создания начального объекта и только после этого установки свойств.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="a7e9c-320">Эти возможности включают <xref:System.Windows.Markup.XamlDeferLoadAttribute>; текст инициализации; [x: TypeArguments](x-typearguments-directive.md); позиционные параметры расширения разметки; фабричные методы и связанные узлы [x: Arguments](x-arguments-directive.md) (XAML 2009 г.).</span><span class="sxs-lookup"><span data-stu-id="a7e9c-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](x-arguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="a7e9c-321">В каждом из этих случаев фактическое создание объекта задерживается, а поскольку поток узлов переупорядочивается, средство записи объектов XAML может рассчитывать на поведение фактического создания экземпляра при обнаружении начального члена, не представляющего собой директиву построения для данного типа объекта.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-321">Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="a7e9c-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="a7e9c-322">GetObject</span></span>

<span data-ttu-id="a7e9c-323">`GetObject` представляет узел XAML, где вместо создания нового объекта средство записи объектов XAML должно получать значение содержащегося свойства объекта.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="a7e9c-324">Типичный случай, где узел `GetObject` обнаруживается в потоке узлов XAML для объекта коллекции или объекта словаря, когда содержащее свойство умышленно предназначено только для чтения в объектной модели резервного типа.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="a7e9c-325">В этом сценарии коллекция или словарь часто создаются и инициализируются (обычно пустыми) логикой инициализации типа-владельца.</span><span class="sxs-lookup"><span data-stu-id="a7e9c-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="a7e9c-326">См. также</span><span class="sxs-lookup"><span data-stu-id="a7e9c-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="a7e9c-327">Службы XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="a7e9c-328">Пространства имен языка XAML</span><span class="sxs-lookup"><span data-stu-id="a7e9c-328">XAML Namespaces</span></span>](xaml-namespaces-for-net-framework-xaml-services.md)
