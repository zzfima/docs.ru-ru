---
title: Эквивалентность типов и внедренные типы взаимодействия
ms.date: 03/30/2017
helpviewer_keywords:
- type equivalence
- embedded interop types
- primary interop assemblies,not necessary in CLR version 4
- NoPIA
ms.assetid: 78892eba-2a58-4165-b4b1-0250ee2f41dc
ms.openlocfilehash: ee9d2d94d62f262ef61edc66ce915e1227532d67
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73126394"
---
# <a name="type-equivalence-and-embedded-interop-types"></a><span data-ttu-id="c983c-102">Эквивалентность типов и внедренные типы взаимодействия</span><span class="sxs-lookup"><span data-stu-id="c983c-102">Type equivalence and embedded interop types</span></span>

<span data-ttu-id="c983c-103">Начиная с .NET Framework 4, среда CLR поддерживает внедрение сведений о типах COM непосредственно в управляемые сборки и не требует получения управляемыми сборками сведений о типах COM из сборок взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="c983c-103">Beginning with the .NET Framework 4, the common language runtime supports embedding type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="c983c-104">Так как внедренные сведения о типах включают в себя только типы и члены, которые действительно используются в управляемой сборке, в двух управляемых сборках могут быть очень разные представления одного типа COM.</span><span class="sxs-lookup"><span data-stu-id="c983c-104">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="c983c-105">Все управляемые сборки имеют разные объекты <xref:System.Type> для обозначения представления типа COM.</span><span class="sxs-lookup"><span data-stu-id="c983c-105">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="c983c-106">Среда CLR поддерживает эквивалентность типов между этими разными представлениями для интерфейсов, структур, перечислений и делегатов.</span><span class="sxs-lookup"><span data-stu-id="c983c-106">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>

<span data-ttu-id="c983c-107">Эквивалентность типов означает, что COM-объект, передаваемый из одной управляемой сборки в другую, можно привести к соответствующему управляемому типу в принимающей сборке.</span><span class="sxs-lookup"><span data-stu-id="c983c-107">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span>

> [!NOTE]
> <span data-ttu-id="c983c-108">Эквивалентность типов и внедренные типы взаимодействия упрощают развертывание приложений и надстроек, использующих COM-компоненты, так как с приложениями не требуется развертывать сборки взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="c983c-108">Type equivalence and embedded interop types simplify the deployment of applications and add-ins that use COM components, because it is not necessary to deploy interop assemblies with the applications.</span></span> <span data-ttu-id="c983c-109">Разработчикам общих COM-компонентов по-прежнему нужно создавать основные сборки взаимодействия, если необходимо, чтобы компоненты можно было использовать в более ранних версиях платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c983c-109">Developers of shared COM components still have to create primary interop assemblies (PIAs) if they want their components to be used by earlier versions of the .NET Framework.</span></span>

## <a name="type-equivalence"></a><span data-ttu-id="c983c-110">Эквивалентность типов</span><span class="sxs-lookup"><span data-stu-id="c983c-110">Type equivalence</span></span>

 <span data-ttu-id="c983c-111">Эквивалентность типов COM поддерживается для интерфейсов, структур, перечислений и делегатов.</span><span class="sxs-lookup"><span data-stu-id="c983c-111">Equivalence of COM types is supported for interfaces, structures, enumerations, and delegates.</span></span> <span data-ttu-id="c983c-112">Типы COM определяются как эквивалентные, если выполняются указанные ниже условия.</span><span class="sxs-lookup"><span data-stu-id="c983c-112">COM types qualify as equivalent if all of the following are true:</span></span>

- <span data-ttu-id="c983c-113">Оба типа относятся либо к интерфейсам, либо к структурам, либо к перечислениям, либо к делегатам.</span><span class="sxs-lookup"><span data-stu-id="c983c-113">The types are both interfaces, or both structures, or both enumerations, or both delegates.</span></span>

- <span data-ttu-id="c983c-114">Типы имеют одинаковые удостоверения, как описано в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="c983c-114">The types have the same identity, as described in the next section.</span></span>

- <span data-ttu-id="c983c-115">Оба типа пригодны для использования эквивалентности типов, как описано в разделе об [определении типов COM для эквивалентности типов](#marking-com-types-for-type-equivalence).</span><span class="sxs-lookup"><span data-stu-id="c983c-115">Both types are eligible for type equivalence, as described in the [Marking COM types for type equivalence](#marking-com-types-for-type-equivalence) section.</span></span>

### <a name="type-identity"></a><span data-ttu-id="c983c-116">Удостоверение типа</span><span class="sxs-lookup"><span data-stu-id="c983c-116">Type identity</span></span>

<span data-ttu-id="c983c-117">Два типа считаются имеющими одинаковое удостоверение, когда их области и идентификаторы совпадают, другими словами, если каждый из них имеет атрибут <xref:System.Runtime.InteropServices.TypeIdentifierAttribute> и эти два атрибута имеют одинаковые свойства <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Scope%2A> и <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Identifier%2A>.</span><span class="sxs-lookup"><span data-stu-id="c983c-117">Two types are determined to have the same identity when their scopes and identities match, in other words, if they each have the <xref:System.Runtime.InteropServices.TypeIdentifierAttribute> attribute, and the two attributes have matching <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Scope%2A> and <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Identifier%2A> properties.</span></span> <span data-ttu-id="c983c-118">Сравнение <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Scope%2A> выполняется с учетом регистра.</span><span class="sxs-lookup"><span data-stu-id="c983c-118">The comparison for <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Scope%2A> is case-insensitive.</span></span>

<span data-ttu-id="c983c-119">Если у типа нет атрибута <xref:System.Runtime.InteropServices.TypeIdentifierAttribute> или атрибут <xref:System.Runtime.InteropServices.TypeIdentifierAttribute> не определяет область и идентификатор, то определение эквивалентности типа все же возможно:</span><span class="sxs-lookup"><span data-stu-id="c983c-119">If a type does not have the <xref:System.Runtime.InteropServices.TypeIdentifierAttribute> attribute, or if it has a <xref:System.Runtime.InteropServices.TypeIdentifierAttribute> attribute that does not specify scope and identifier, the type can still be considered for equivalence as follows:</span></span>

- <span data-ttu-id="c983c-120">Для интерфейсов вместо свойства <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Scope%2A?displayProperty=nameWithType> используется значение <xref:System.Runtime.InteropServices.GuidAttribute>, а вместо свойства <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Identifier%2A?displayProperty=nameWithType> используется свойство <xref:System.Type.FullName%2A?displayProperty=nameWithType> (то есть имя типа, включая пространство имен).</span><span class="sxs-lookup"><span data-stu-id="c983c-120">For interfaces, the value of the <xref:System.Runtime.InteropServices.GuidAttribute> is used instead of the <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Scope%2A?displayProperty=nameWithType> property, and the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property (that is, the type name, including the namespace) is used instead of the <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Identifier%2A?displayProperty=nameWithType> property.</span></span>

- <span data-ttu-id="c983c-121">Для структур, перечислений и делегатов вместо свойства <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Scope%2A> используется атрибут <xref:System.Runtime.InteropServices.GuidAttribute> содержащей сборки, а вместо свойства <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Identifier%2A> используется свойство <xref:System.Type.FullName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c983c-121">For structures, enumerations, and delegates, the <xref:System.Runtime.InteropServices.GuidAttribute> of the containing assembly is used instead of the <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Scope%2A> property, and the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property is used instead of the <xref:System.Runtime.InteropServices.TypeIdentifierAttribute.Identifier%2A> property.</span></span>

### <a name="marking-com-types-for-type-equivalence"></a><span data-ttu-id="c983c-122">Пометка типов COM для эквивалентности типов</span><span class="sxs-lookup"><span data-stu-id="c983c-122">Marking COM types for type equivalence</span></span>

 <span data-ttu-id="c983c-123">Тип можно пометить как допустимый для эквивалентности типов двумя способами.</span><span class="sxs-lookup"><span data-stu-id="c983c-123">You can mark a type as eligible for type equivalence in two ways:</span></span>

- <span data-ttu-id="c983c-124">Примените к типу атрибут <xref:System.Runtime.InteropServices.TypeIdentifierAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c983c-124">Apply the <xref:System.Runtime.InteropServices.TypeIdentifierAttribute> attribute to the type.</span></span>

- <span data-ttu-id="c983c-125">Сделайте тип типом импорта COM.</span><span class="sxs-lookup"><span data-stu-id="c983c-125">Make the type a COM import type.</span></span> <span data-ttu-id="c983c-126">Интерфейс является типом импорта COM, если у него есть атрибут <xref:System.Runtime.InteropServices.ComImportAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c983c-126">An interface is a COM import type if it has the <xref:System.Runtime.InteropServices.ComImportAttribute> attribute.</span></span> <span data-ttu-id="c983c-127">Интерфейсы, структуры, перечисления или делегаты являются типами импорта COM, если сборка, в которой они заданы, имеет атрибут <xref:System.Runtime.InteropServices.ImportedFromTypeLibAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c983c-127">An interface, structure, enumeration, or delegate is a COM import type if the assembly in which it is defined has the <xref:System.Runtime.InteropServices.ImportedFromTypeLibAttribute> attribute.</span></span>

## <a name="see-also"></a><span data-ttu-id="c983c-128">См. также</span><span class="sxs-lookup"><span data-stu-id="c983c-128">See also</span></span>

- <xref:System.Type.IsEquivalentTo%2A>
- <span data-ttu-id="c983c-129">[Using COM Types in Managed Code](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/3y76b69k(v=vs.100)) (Использование COM-типов в управляемом коде)</span><span class="sxs-lookup"><span data-stu-id="c983c-129">[Using COM Types in Managed Code](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/3y76b69k(v=vs.100))</span></span>
- [<span data-ttu-id="c983c-130">Импорт библиотеки типов в виде сборки</span><span class="sxs-lookup"><span data-stu-id="c983c-130">Importing a Type Library as an Assembly</span></span>](importing-a-type-library-as-an-assembly.md)
