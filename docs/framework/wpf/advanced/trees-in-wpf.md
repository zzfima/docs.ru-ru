---
title: Деревья
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 696772da1ebee405493f2ff0e1481daf93d08ec7
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187023"
---
# <a name="trees-in-wpf"></a>Деревья в WPF
Во многих технологиях элементы и компоненты организованы в форме древовидной структуры, и разработчики могут напрямую управлять узлами объекта в дереве, чтобы повлиять на визуализацию или поведение приложения. В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] часто используется несколько метафор древовидных структур, чтобы определить отношения между программными элементами. Для большей части WPF разработчики могут создать приложение в коде или определить части приложения в XAML и при этом концептуально думать о метафоре дерева объектов, но для этого им потребуется вызвать определенный интерфейс API или использовать конкретную разметку, а не интерфейс API управления деревом некоторых общих объектов, какой можно использовать в XML DOM. WPF предоставляет два класса помощника, которые обеспечивают <xref:System.Windows.LogicalTreeHelper> <xref:System.Windows.Media.VisualTreeHelper>вид метафоры дерева, и . Термины "логическое дерево" и "визуальное дерево" также используются в документации WPF, поскольку эти же деревья помогают понять поведение определенных ключевых функций WPF. Эта тема определяет, что представляет собой визуальное дерево и логическое дерево, обсуждает, <xref:System.Windows.LogicalTreeHelper> как <xref:System.Windows.Media.VisualTreeHelper>такие деревья соотносятся с общей концепцией дерева объекта, а также вводит и s.  

<a name="element_tree"></a>
## <a name="trees-in-wpf"></a>Деревья в WPF  
 Самой полной древовидной структурой в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является дерево объектов. При определении страницы приложения в [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] и последующей загрузке [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] древовидная структура создается на основе отношений вложенности элементов в разметке. При определении приложения или части приложения в коде древовидная структура создается в зависимости от того, как присваиваются значения свойствам, которые реализуют модель содержимого для данного объекта. В [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] существует два способа концептуализации и передачи в открытый интерфейс API полного дерева объектов: в виде логического дерева и в виде визуального дерева. Различия между логическими деревьями и визуальными деревьями не всегда важны, но иногда они могут вызвать проблемы с некоторыми подсистемами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и повлиять на изменения, внесенные в разметку или код.  
  
 Несмотря на то, что управление логическим деревом или визуальным деревом не всегда происходит напрямую, понимание концепций взаимодействия деревьев позволяет понять WPF как технологию. Рассмотрение WPF как некоторой метафоры дерева также важно для понимания того, как в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] осуществляется наследование свойств и маршрутизация событий.  
  
> [!NOTE]
> Поскольку дерево объектов — это более широкое понятие, чем фактический интерфейс API, еще одним способом представить себе концепцию является граф объекта. На практике отношения между объектами можно наблюдать во время выполнения, когда метафора дерева разделяется. Тем не менее, особенно в пользовательском интерфейсе, определенном XAML, метафора дерева достаточно релевантна, и в большей части документации WPF используется термин "дерево объекта" при ссылке на это общее понятие.  
  
<a name="logical_tree"></a>
## <a name="the-logical-tree"></a>Логическое дерево  
 В [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] содержимое добавляется в элементы пользовательского интерфейса путем задания свойств объектов, которые поддерживают эти элементы. Например, вы добавляете <xref:System.Windows.Controls.ListBox> элементы в <xref:System.Windows.Controls.ItemsControl.Items%2A> элемент управления, манипулируя его свойством. Делая это, вы размещаете элементы в <xref:System.Windows.Controls.ItemCollection> то, что значение <xref:System.Windows.Controls.ItemsControl.Items%2A> свойства. Аналогичным образом, чтобы <xref:System.Windows.Controls.DockPanel>добавить объекты <xref:System.Windows.Controls.Panel.Children%2A> к , вы манипулируете его значение свойства. Здесь вы добавляете объекты в <xref:System.Windows.Controls.UIElementCollection>. Для примера кода [см. Как: Добавить элемент динамически.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100))  
  
 В [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], когда вы размещаете список <xref:System.Windows.Controls.ListBox> элементов <xref:System.Windows.Controls.DockPanel>в или <xref:System.Windows.Controls.ItemsControl.Items%2A> элементы управления или других элементов uI в , вы также используете и <xref:System.Windows.Controls.Panel.Children%2A> свойства, явно или косвенно, как в следующем примере.  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 Если бы этот XAML обрабатывался как XML в объектной модели документов, и если бы были включены теги, закомментированные как неявные (были бы допустимы), полученное дерево XML DOM включало бы элементы для `<ListBox.Items>` и другие неявные элементы. Но XAML не выполняет такую обработку при чтении разметки и записи в объекты, полученный граф объекта не включает `ListBox.Items` в буквальном смысле. Однако у <xref:System.Windows.Controls.ListBox> него `Items` есть свойство с <xref:System.Windows.Controls.ItemCollection>именем, которое содержит , и это инициализировано, <xref:System.Windows.Controls.ItemCollection> но пусто, когда <xref:System.Windows.Controls.ListBox> XAML обрабатывается. Затем каждый элемент элемент атмера ребенка, который существует как содержимое для, <xref:System.Windows.Controls.ListBox> добавляется в <xref:System.Windows.Controls.ItemCollection> вызовы parser. `ItemCollection.Add` Этот пример обработки XAML в дереве объектов на первый взгляд похож на пример, в котором созданное дерево объектов, по сути, является логическим деревом.  
  
 Тем не менее, логическое дерево — это не весь график объекта, который существует для uI-разбивки приложения во время выполнения, даже с помощью неявных элементов синтаксиса XAML. Основной причиной этого являются визуальные эффекты и шаблоны. Например, рассмотрим <xref:System.Windows.Controls.Button>. Логическое дерево <xref:System.Windows.Controls.Button> сообщает объект, `Content`а также его строку. Но в дереве объектов времени выполнения имеется больше сведений об этой кнопке. В частности, кнопка появляется на экране <xref:System.Windows.Controls.Button> только так, как она делает, потому что был применен определенный шаблон управления. Визуальные эффекты, полученные из прикладного <xref:System.Windows.Controls.Border> шаблона (например, шаблон, определяемый темно-серым вокруг кнопки визуального цвета), не регистрируются в логическом дереве, даже если вы смотрите на логическое дерево во время выполнения (например, обработка вхнужного события из видимого uI и чтение логического дерева). Чтобы найти визуальные элементы шаблона, необходимо проверить визуальное дерево.  
  
 Дополнительные сведения о сопоставлении синтаксиса [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] с созданным графом объекта и неявным синтаксисом в XAML см. в разделе [Подробное описание синтаксиса XAML](xaml-syntax-in-detail.md) или [Общие сведения о языке XAML (WPF)](xaml-overview-wpf.md).  
  
<a name="tree_property_inheritance_event_routing"></a>
### <a name="the-purpose-of-the-logical-tree"></a>Назначение логического дерева  
 Логическое дерево существует для того, чтобы модели содержимого имели возможность пройти по своим доступным дочерним объектам, а также для их расширяемости. Кроме того, логическое дерево предоставляет оболочку для некоторых уведомлений, например при загрузке всех объектов логического дерева. По существу, логическое дерево является подобием графа объекта времени выполнения на уровне оболочки, исключающего визуальные элементы, но подходит для большинства операций запросов для собственной композиции приложения времени выполнения.  
  
 Кроме того, как статические, так и динамические ссылки <xref:System.Windows.FrameworkElement.Resources%2A> на ресурсы решаются, просматривая логическое дерево <xref:System.Windows.FrameworkElement> для <xref:System.Windows.FrameworkContentElement>коллекций `Resources` на исходном <xref:System.Windows.ResourceDictionary>объекте запроса, а затем продолжая логическое дерево и проверяя каждое (или) значение, содержащее, возможно, содержащий этот ключ. Логическое дерево используется для просмотра ресурсов при наличии логического дерева и визуального дерева. Дополнительные сведения о словарях ресурсов и поиске см. в разделе [Общие сведения о ресурсах](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
<a name="composition"></a>
### <a name="composition-of-the-logical-tree"></a>Композиция логического дерева  
 Логическое дерево определяется на уровне рамок WPF, что означает, что базовый элемент <xref:System.Windows.FrameworkElement> WPF, наиболее актуальный для логических операций дерева, является <xref:System.Windows.FrameworkContentElement>либо. Однако, как вы можете видеть, если вы на самом деле <xref:System.Windows.LogicalTreeHelper> используете <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>API, логическое дерево иногда содержит узлы, которые не являются либо . Например, логическое дерево <xref:System.Windows.Controls.TextBlock.Text%2A> сообщает <xref:System.Windows.Controls.TextBlock>значение, которое является строкой.  
  
<a name="override_logical_tree"></a>
### <a name="overriding-the-logical-tree"></a>Переопределение логического дерева  
 Расширенные авторы управления могут переопределить логическое дерево, переопределив несколько AI, которые определяют, как общая модель объекта или содержимого добавляет или удаляет объекты в логическом древе. Пример переопределения логического дерева содержится в разделе [Переопределение логического дерева](how-to-override-the-logical-tree.md).  
  
<a name="pvi"></a>
### <a name="property-value-inheritance"></a>Наследование значения свойства  
 Наследование значения свойств действует через гибридное дерево. Фактические метаданные, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> содержащие свойство, позволяющее <xref:System.Windows.FrameworkPropertyMetadata> наследовать имущество, — это класс уровня рамочной системы WPF. Таким образом, как родитель, который держит исходное значение, так <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>и объект ребенка, который наследует это значение должно быть или, и они оба должны быть частью какого-то логического дерева. Однако для существующих свойств WPF, поддерживающих наследование свойств, наследование значений свойств способно принять промежуточный объект, которого нет в логическом дереве. Как правило, это распространяется на элементы шаблона, использующие все унаследованные значения свойств, заданные как в экземпляре, который является шаблоном, так и на более высоких уровнях композиции уровня страницы и, следовательно, выше в логическом дереве. Чтобы наследование значений свойств осуществлялось согласованно в таких пределах, наследуемое свойство должно быть зарегистрировано как вложенное свойство, кроме того, необходимо следовать этому шаблону, если требуется определить пользовательское свойство зависимостей с поведением наследования свойств. Точное дерево, используемое для наследования свойств, не может быть полностью предсказано вспомогательным служебным методом класса даже во время выполнения. Дополнительные сведения см. в разделе [Наследование значения свойства](property-value-inheritance.md).  
  
<a name="two_trees"></a>
## <a name="the-visual-tree"></a>Визуальное дерево  
 В дополнение к концепции логического дерева в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] также существует концепция визуального дерева. Визуальное дерево описывает структуру визуальных объектов, представленных базовым <xref:System.Windows.Media.Visual> классом. При написании шаблона для элемента управления следует определить или переопределить визуальное дерево, применяемое для данного элемента управления. Визуальное дерево также представляет интерес для разработчиков, заинтересованных в контроле рисования на нижнем уровне по соображениям производительности и оптимизации. Слабым местом визуального дерева как части программирования стандартных приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] является то, что маршруты событий для перенаправленного события в большинстве случаев проходят по визуальному дереву, а не по логическому. Эта тонкость поведения перенаправленного события может быть не очевидна, если вы не являетесь автором элемента управления. Маршрутизация событий по визуальному дереву позволяет элементам управления, которые реализуют композицию на визуальном уровне, обрабатывать события или создавать установщики событий.  
  
<a name="trees_content"></a>
## <a name="trees-content-elements-and-content-hosts"></a>Деревья, элементы содержимого и узлы содержимого  
 Элементы содержимого (классы, которые вытекают из <xref:System.Windows.ContentElement>) не являются частью визуального дерева; они не наследуют <xref:System.Windows.Media.Visual> и не имеют визуального представления. Для того, чтобы отобраться <xref:System.Windows.ContentElement> в ui вообще, необходимо разместить <xref:System.Windows.Media.Visual> в хосте контента, который является одновременно и логическим участником дерева. Обычно такой объект <xref:System.Windows.FrameworkElement>является . Можно представить сайт содержимого в качестве "обозревателя" содержимого, который выбирает способ отображения содержимого в пределах области экрана, управляемой сайтом. При размещении содержимого оно может стать участником некоторых процессов дерева, которые обычно связаны с визуальным деревом. Как правило, класс <xref:System.Windows.FrameworkElement> хоста включает <xref:System.Windows.ContentElement> код реализации, который добавляет любое размещение в маршрут события через подузлы логического дерева содержимого, даже если размещенный контент не является частью истинного визуального дерева. Это необходимо для <xref:System.Windows.ContentElement> того, чтобы может источник маршрутизатированных событий, которые направляются к любому элементу, кроме самого себя.  
  
<a name="tree_traversal"></a>
## <a name="tree-traversal"></a>Прохождение по дереву  
 Класс <xref:System.Windows.LogicalTreeHelper> предоставляет <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>и <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> методы для логического обхода дерева. В большинстве случаев не следует проходить по логическому дереву существующих элементов управления, так как эти элементы управления почти всегда предоставляют свои логические дочерние элементы в качестве выделенного свойства коллекции, которое поддерживает доступ к коллекции, например `Add`, индексатор и т. д. Обход дерева — это в основном сценарий, который используется авторами управления, которые предпочитают не выходить из предполагаемых шаблонов управления, таких как <xref:System.Windows.Controls.ItemsControl> или <xref:System.Windows.Controls.Panel> где свойства коллекции уже определены, и которые намерены предоставить свою собственную поддержку свойств коллекции.  
  
 Визуальное дерево также поддерживает класс помощников для <xref:System.Windows.Media.VisualTreeHelper>визуального обхода дерева, . Визуальное дерево не подвергается так удобно через контроль <xref:System.Windows.Media.VisualTreeHelper> ные свойства, поэтому класс является рекомендуемым способом обхода визуального дерева, если это необходимо для вашего сценария программирования. Дополнительные сведения см. в разделе [Общие сведения об отрисовке графики в WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
> [!NOTE]
> Иногда необходимо проверять визуальное дерево применяемого шаблона. Необходимо соблюдать осторожность при использовании этого метода. Даже если вы пересекаете визуальное дерево для управления, где вы определяете шаблон, потребители вашего управления всегда могут изменить шаблон, установив <xref:System.Windows.Controls.Control.Template%2A> свойство на экземплярах, и даже конечный пользователь может влиять на прикладной шаблон, изменив тему системы.  
  
<a name="routes"></a>
## <a name="routes-for-routed-events-as-a-tree"></a>Маршруты для маршрутизируемых событий как "дерево"  
 Как уже отмечалось ранее, маршрут любого заданного перенаправленного события проходит по одному предопределенному пути дерева, представляющего собой гибрид представлений визуального и логического деревьев. Маршрут события может проходить как по восходящей, так и по нисходящий в пределах дерева в зависимости от того, имеет ли перенаправленное событие нисходящую или восходящую маршрутизацию. Концепция маршрута события не имеет непосредственного вспомогательного класса, который может быть использован для "прохода" маршрута события независимо от вызова фактически перенаправленного события. Существует класс, который представляет <xref:System.Windows.EventRoute>маршрут, но методы этого класса, как правило, только для внутреннего использования.  
  
<a name="resourcesandtrees"></a>
## <a name="resource-dictionaries-and-trees"></a>Словари и деревья ресурсов  
 Поиск по словарю ресурсов для всех `Resources`, определенных на странице, обычно проходит по логическому дереву. Объекты, которые не входят в логическое дерево, могут ссылаться на ресурсы с ключом, но последовательность поиска ресурса начинается с той точки, где объект подключен к логическому дереву. В WPF, только логические узлы дерева могут иметь `Resources` <xref:System.Windows.ResourceDictionary>свойство, которое содержит, поэтому нет <xref:System.Windows.ResourceDictionary>никакой пользы в обходвизуального дерева ищет ключевые ресурсы от .  
  
 В то же время поиск ресурсов также можно расширить за пределы логического дерева. Для разметки приложения поиск ресурсов можно затем продолжить в словарях ресурсов на уровне приложений, поддержке тем и значениях системы, на которые ссылаются как на статические свойства или ключи. Сами темы также могут ссылаться на системные значения вне логического дерева тем, если ссылки на ресурсы являются динамическими. Дополнительные сведения о словарях ресурсов и логике поиска см. в разделе [Ресурсы XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).  
  
## <a name="see-also"></a>См. также раздел

- [Общие сведения о входных данных](input-overview.md)
- [Общие сведения об отрисовке графики в WPF](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [Общие сведения о перенаправленных событиях](routed-events-overview.md)
- [Инициализация для элементов типа Object вне дерева объектов](initialization-for-object-elements-not-in-an-object-tree.md)
- [Архитектура WPF](wpf-architecture.md)
