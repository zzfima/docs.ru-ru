---
title: Подробное описание синтаксиса XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: f2c3aab20dc5bcf9b0f9f7053323ccd7a04443cc
ms.sourcegitcommit: bd4fa78f5a46133efdead1bc692a9aa2811d7868
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/23/2018
ms.locfileid: "42755055"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="aef4e-102">Подробное описание синтаксиса XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="aef4e-103">В этом разделе определяются термины, которые используются для описания элементов синтаксиса XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="aef4e-104">Эти термины часто используются в оставшейся части этой документации, в документации по WPF, в частности, так и для других платформ, использующих XAML или основные понятия XAML, включаемые поддержки языка XAML на уровне System.Xaml.</span><span class="sxs-lookup"><span data-stu-id="aef4e-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="aef4e-105">Этот раздел расширяет базовую терминологию, представленную в разделе [Обзор XAML (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).</span></span>  
  

  
<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="aef4e-106">В спецификации языка XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="aef4e-107">Синтаксическая терминология XAML, заданные здесь также определяется или на которые существуют ссылки в спецификации языка XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="aef4e-108">XAML — это язык на основе XML и ниже или расширяет структурным правилам XML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="aef4e-109">Некоторые термины общий или основан на терминологии, используемой при описании языка XML или объектную модель документа XML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="aef4e-110">Дополнительные сведения о спецификации языка XAML, скачайте [ \[MS-XAML\] ](http://go.microsoft.com/fwlink/?LinkId=114525) из центра загрузки Майкрософт.</span><span class="sxs-lookup"><span data-stu-id="aef4e-110">For more information about the XAML language specification, download [\[MS-XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="aef4e-111">XAML и среда CLR</span><span class="sxs-lookup"><span data-stu-id="aef4e-111">XAML and CLR</span></span>  
 <span data-ttu-id="aef4e-112">XAML — это язык разметки.</span><span class="sxs-lookup"><span data-stu-id="aef4e-112">XAML is a markup language.</span></span> <span data-ttu-id="aef4e-113">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], Как следует из названия, обеспечивает выполнение среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="aef4e-113">The [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="aef4e-114">XAML по себе не является одним из распространенных языков, которые напрямую используется средой выполнения CLR.</span><span class="sxs-lookup"><span data-stu-id="aef4e-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="aef4e-115">Вместо этого можно считать из XAML поддержкой свою собственную систему типов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="aef4e-116">Конкретной системе синтаксического анализа XAML, который используется платформой WPF основана на среде CLR и системы типов среды CLR.</span><span class="sxs-lookup"><span data-stu-id="aef4e-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="aef4e-117">Типы XAML сопоставляются с типами среды CLR для создания представления времени выполнения при синтаксическом анализе XAML для WPF.</span><span class="sxs-lookup"><span data-stu-id="aef4e-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="aef4e-118">По этой причине в оставшейся части обсуждения синтаксиса в этом документе будут включены ссылки на системе типов CLR, несмотря на то, что эквивалентный синтаксис обсуждения в спецификации языка XAML — нет.</span><span class="sxs-lookup"><span data-stu-id="aef4e-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="aef4e-119">(На уровне спецификации языка XAML, типы XAML могут быть сопоставлены для любой другой системе типов, которого не нужно быть среды CLR, но это потребует создания и использования разных средства синтаксического анализа XAML.)</span><span class="sxs-lookup"><span data-stu-id="aef4e-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="aef4e-120">Члены типов и наследование классов</span><span class="sxs-lookup"><span data-stu-id="aef4e-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="aef4e-121">Свойства и события, что они отображаются как члены XAML [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , часто наследуются от базовых типов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="aef4e-122">Например, рассмотрим следующий пример: `<Button Background="Blue" .../>`.</span><span class="sxs-lookup"><span data-stu-id="aef4e-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="aef4e-123"><xref:System.Windows.Controls.Control.Background%2A> Является свойство не сразу же объявленного на <xref:System.Windows.Controls.Button> класса, если вы посмотрите на определение класса, результаты отражения или документации по.</span><span class="sxs-lookup"><span data-stu-id="aef4e-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="aef4e-124">Вместо этого <xref:System.Windows.Controls.Control.Background%2A> наследуется от базового <xref:System.Windows.Controls.Control> класса.</span><span class="sxs-lookup"><span data-stu-id="aef4e-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="aef4e-125">Поведение наследования класса [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] элементы XAML, это существенно отличается от схемы-интерпретации XML-разметку.</span><span class="sxs-lookup"><span data-stu-id="aef4e-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="aef4e-126">Наследование классов может стать сложной задачей, особенно в том случае, если промежуточные базовые классы являются абстрактными, или при использовании интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="aef4e-127">Это одна из причин, набор элементов XAML и их допустимых атрибутов получается сложный для представления точно и полностью с помощью типов схемы, которые обычно используются для [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] программирования, таких как формат DTD или XSD.</span><span class="sxs-lookup"><span data-stu-id="aef4e-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format.</span></span> <span data-ttu-id="aef4e-128">Другая причина заключается в возможности расширения и функции сопоставления типов языка XAML сам препятствуют полноте представления допустимых типов и членов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="aef4e-129">Синтаксис объектных элементов</span><span class="sxs-lookup"><span data-stu-id="aef4e-129">Object Element Syntax</span></span>  
 <span data-ttu-id="aef4e-130">*Синтаксис элемента объекта* приведен синтаксис разметки XAML, который создает экземпляр класса среды CLR или структуры путем объявления элемента XML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="aef4e-131">Этот синтаксис похож на синтаксис элемента других языков разметки, такие как HTML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="aef4e-132">Синтаксис объектных элементов начинается с левой угловой скобки (\<), а затем немедленно имя типа класса или структуры, создание экземпляров.</span><span class="sxs-lookup"><span data-stu-id="aef4e-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="aef4e-133">Ноль или более пробелов можно следовать имя типа и ноль или более атрибутов также могут объявляться с одним или несколькими пробелами, отделяя каждое имя атрибута элемента объекта = пару «значение».</span><span class="sxs-lookup"><span data-stu-id="aef4e-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="aef4e-134">Наконец одно из следующих должен иметь значение true:</span><span class="sxs-lookup"><span data-stu-id="aef4e-134">Finally, one of the following must be true:</span></span>  
  
-   <span data-ttu-id="aef4e-135">Элемент и тег должны быть закрыты с косой черты (/), после чего сразу правой угловой скобки (>).</span><span class="sxs-lookup"><span data-stu-id="aef4e-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
-   <span data-ttu-id="aef4e-136">Открывающий тег должен выполнять правой угловой скобки (>).</span><span class="sxs-lookup"><span data-stu-id="aef4e-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="aef4e-137">Другие элементы объектов, свойств элементов или внутренний текст, можно выполнить в открывающий тег.</span><span class="sxs-lookup"><span data-stu-id="aef4e-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="aef4e-138">Точно какое содержимое может содержаться здесь обычно ограничивается объектной модели элемента.</span><span class="sxs-lookup"><span data-stu-id="aef4e-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="aef4e-139">Эквивалентный закрывающий тег для элемента объекта необходимо также существуют в правильной вложенности и балансировать нагрузку с других открывающей и закрывающей парой тегов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="aef4e-140">XAML в соответствии с реализацией .NET содержит набор правил, которые сопоставляют элементы объекта с типами, атрибуты свойств или событий и пространства имен XAML среды CLR и сборки.</span><span class="sxs-lookup"><span data-stu-id="aef4e-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="aef4e-141">WPF и .NET Framework, элементы объекта XAML сопоставляются с [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] типов, как определено в ссылочных сборках, а атрибуты сопоставляются члены этих типов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-141">For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="aef4e-142">При ссылке на тип среды CLR в XAML, у вас есть доступ к наследуемые члены этого типа также.</span><span class="sxs-lookup"><span data-stu-id="aef4e-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="aef4e-143">Например, ниже приведен синтаксис объектных элементов, который создает новый экземпляр класса <xref:System.Windows.Controls.Button> класса, а также задает <xref:System.Windows.FrameworkElement.Name%2A> атрибут и значение для этого атрибута:</span><span class="sxs-lookup"><span data-stu-id="aef4e-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="aef4e-144">Ниже приведен синтаксис объектных элементов, которая также включает синтаксиса свойства содержимого XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="aef4e-145">Внутренний текст, содержащийся в будет использоваться для задания <xref:System.Windows.Controls.TextBox> свойства содержимого XAML, <xref:System.Windows.Controls.TextBox.Text%2A>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="aef4e-146">Модели содержимого</span><span class="sxs-lookup"><span data-stu-id="aef4e-146">Content Models</span></span>  
 <span data-ttu-id="aef4e-147">Класс может поддерживать использование в качестве элемента объекта XAML с точки зрения синтаксиса, но этот элемент будет работать должным образом в приложении или на странице только при ее размещении в ожидаемое положение в целом содержимого дерева модели или элемент.</span><span class="sxs-lookup"><span data-stu-id="aef4e-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="aef4e-148">Например <xref:System.Windows.Controls.MenuItem> следует обычно размещаться только как дочерний <xref:System.Windows.Controls.Primitives.MenuBase> производного класса, такие как <xref:System.Windows.Controls.Menu>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="aef4e-149">Содержимое модели для определенных элементов описаны как часть "Примечания" на страницах класса для элементов управления и других [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] классы, которые можно использовать в качестве элементов XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="aef4e-150">Свойств объектных элементов</span><span class="sxs-lookup"><span data-stu-id="aef4e-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="aef4e-151">Свойства в XAML задаются с помощью разнообразных возможных синтаксисов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="aef4e-152">Какой синтаксис может использоваться для конкретного свойства будет зависеть от базовых характеристик системы тип свойства, которое устанавливается.</span><span class="sxs-lookup"><span data-stu-id="aef4e-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="aef4e-153">Задавая значения свойств, добавляемый функции и характеристики объектов, которые существуют в графе объекта, время выполнения.</span><span class="sxs-lookup"><span data-stu-id="aef4e-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="aef4e-154">Начальное состояние объекта, созданного из элемента объекта основан на поведение конструктора по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="aef4e-154">The initial state of the created object from a object element is based on the default constructor behavior.</span></span> <span data-ttu-id="aef4e-155">Как правило приложение будет использовать отличные от полностью экземпляр по умолчанию для любого объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="aef4e-156">Синтаксис атрибутов (свойства)</span><span class="sxs-lookup"><span data-stu-id="aef4e-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="aef4e-157">Синтаксис атрибутов — это синтаксис разметки XAML, который задает значение для свойства путем объявления атрибута в элементе существующего объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="aef4e-158">Имя атрибута должно соответствовать имени элемента среды CLR, свойства класса, поддерживающего соответствующий элемент объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="aef4e-159">Имя атрибута следует оператор присваивания (=).</span><span class="sxs-lookup"><span data-stu-id="aef4e-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="aef4e-160">Значение атрибута должно быть строкой, заключенной в кавычки.</span><span class="sxs-lookup"><span data-stu-id="aef4e-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aef4e-161">Разные кавычки можно использовать для размещения литеральный символ кавычки в атрибут.</span><span class="sxs-lookup"><span data-stu-id="aef4e-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="aef4e-162">Для экземпляра одинарные кавычки можно использовать как средство для объявления строка, содержащая символ двойной кавычки внутри него.</span><span class="sxs-lookup"><span data-stu-id="aef4e-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="aef4e-163">Используются одинарные или двойные кавычки, следует ли использовать пары открывающих и закрывающих строки значения атрибута.</span><span class="sxs-lookup"><span data-stu-id="aef4e-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="aef4e-164">Доступны также escape-последовательности и другие методы для обойти ограничения, накладываемые любой отдельный синтаксис XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="aef4e-165">См. в разделе [сущности знаков XML и XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-165">See [XML Character Entities and XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md).</span></span>  
  
 <span data-ttu-id="aef4e-166">Чтобы задать с помощью синтаксиса атрибутов, свойство должен быть открытым и доступным для записи.</span><span class="sxs-lookup"><span data-stu-id="aef4e-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="aef4e-167">Значение свойства в системе резервных типов должен быть типом значения или должен быть ссылочный тип, который можно создать экземпляр или ссылается на обработчик XAML, обратившись к соответствующему резервного типа.</span><span class="sxs-lookup"><span data-stu-id="aef4e-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="aef4e-168">Для событий WPF XAML событие, которое указывается как имя атрибута должен быть открытым и иметь открытый делегат.</span><span class="sxs-lookup"><span data-stu-id="aef4e-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="aef4e-169">Свойства или события, необходимо быть членом класса или структуры, экземпляр которого создается, содержащего элемента объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="aef4e-170">Обработка значений атрибутов</span><span class="sxs-lookup"><span data-stu-id="aef4e-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="aef4e-171">Строковое значение, содержащееся в открывающие и закрывающие кавычки, обрабатывается обработчиком XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="aef4e-172">Режим обработки по умолчанию для свойств, определяется тип базового свойства среды CLR.</span><span class="sxs-lookup"><span data-stu-id="aef4e-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="aef4e-173">Значение атрибута заполняется одним из следующих значений, используя этот порядок обработки:</span><span class="sxs-lookup"><span data-stu-id="aef4e-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1.  <span data-ttu-id="aef4e-174">Если обработчик XAML обнаруживает фигурную скобку или объектный элемент, производный от <xref:System.Windows.Markup.MarkupExtension>, то расширение разметки, на которую указывает ссылка, вычисляется раньше, вместо того, чтобы обработка значения как строка и объект, возвращаемый в расширение разметки используется в качестве значение.</span><span class="sxs-lookup"><span data-stu-id="aef4e-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="aef4e-175">Во многих случаях объект, возвращенный расширение разметки будет ссылаться на существующий объект или выражение, вычисление которого откладывается до времени выполнения и не является объектом с вновь созданным экземпляром.</span><span class="sxs-lookup"><span data-stu-id="aef4e-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2.  <span data-ttu-id="aef4e-176">Если свойство объявлено с атрибутами <xref:System.ComponentModel.TypeConverter>, или тип значения этого свойства объявлен с атрибутами <xref:System.ComponentModel.TypeConverter>, строковое значение атрибута отправляется в преобразователь типа в качестве входных данных преобразования, и преобразователь вернет новый экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3.  <span data-ttu-id="aef4e-177">Если не <xref:System.ComponentModel.TypeConverter>, выполняется попытка прямого преобразования в тип свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="aef4e-178">Последним уровнем является прямое преобразование значение собственного средства синтаксического анализа между типы-примитивы языка XAML, или проверка имен именованных констант в перечислении (средство синтаксического анализа. затем обращается к совпадающие значения).</span><span class="sxs-lookup"><span data-stu-id="aef4e-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="aef4e-179">Перечисление значений атрибутов</span><span class="sxs-lookup"><span data-stu-id="aef4e-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="aef4e-180">Перечисления в XAML действительности обрабатываются средства синтаксического анализа XAML, а члены перечисления должны быть заданы путем указания имени строки в одной из именованных констант перечисления.</span><span class="sxs-lookup"><span data-stu-id="aef4e-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="aef4e-181">Для значений перечисления nonflag собственное поведение является обработки строки значения атрибута и разрешить его в одно из значений перечисления.</span><span class="sxs-lookup"><span data-stu-id="aef4e-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="aef4e-182">Перечисление не указан в формате *перечисления*. *Значение*, как это делается в коде.</span><span class="sxs-lookup"><span data-stu-id="aef4e-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="aef4e-183">Вместо этого указать только *значение*, и *перечисления* определяется по типу свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="aef4e-184">При указании атрибута в *перечисления*. *Значение* формы, он будет разрешаться правильно.</span><span class="sxs-lookup"><span data-stu-id="aef4e-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="aef4e-185">Для флагового перечисления на основе поведения <xref:System.Enum.Parse%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="aef4e-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="aef4e-186">Можно указать несколько значений для флагового перечисления, все значения разделены запятыми.</span><span class="sxs-lookup"><span data-stu-id="aef4e-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="aef4e-187">Тем не менее нельзя объединять значения перечисления, которые не являются flagwise.</span><span class="sxs-lookup"><span data-stu-id="aef4e-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="aef4e-188">Например, нельзя использовать синтаксис с запятой для начала создания <xref:System.Windows.Trigger> , выступающий в несколько условий перечисления nonflag:</span><span class="sxs-lookup"><span data-stu-id="aef4e-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="aef4e-189">В WPF редки флагового перечисления, которые поддерживают атрибуты, которые можно задать в XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="aef4e-190">Тем не менее, одно перечисление является <xref:System.Windows.Media.StyleSimulations>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="aef4e-191">Может например, используется синтаксис с разделителями запятыми флагового атрибутов для примера, приведенного в разделе «Примечания» для изменения <xref:System.Windows.Documents.Glyphs> класса; `StyleSimulations = "BoldSimulation"` может стать `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span><span class="sxs-lookup"><span data-stu-id="aef4e-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="aef4e-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> является другим свойством, где можно указать несколько значений перечисления.</span><span class="sxs-lookup"><span data-stu-id="aef4e-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="aef4e-193">Тем не менее, это свойство может быть особый случай, так как <xref:System.Windows.Input.ModifierKeys> перечисление поддерживает собственный тип преобразователя.</span><span class="sxs-lookup"><span data-stu-id="aef4e-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="aef4e-194">Преобразователь типов для модификаторов использует знак плюс (+) в качестве разделителя, а не запятая (,).</span><span class="sxs-lookup"><span data-stu-id="aef4e-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="aef4e-195">Это преобразование поддерживает традиционный синтаксис представления сочетания клавиш в программировании Microsoft Windows, например «Ctrl + Alt».</span><span class="sxs-lookup"><span data-stu-id="aef4e-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="aef4e-196">Свойства и ссылки на имя члена события</span><span class="sxs-lookup"><span data-stu-id="aef4e-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="aef4e-197">При указании атрибута можно ссылаться на любое свойство или событие, которое существует в качестве члена типа среды CLR, когда экземпляр для содержащего элемента объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="aef4e-198">Или можно ссылаться на вложенное свойство или событие, независимо от содержащего элемента объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="aef4e-199">(Вложенные свойства обсуждаются в следующем разделе).</span><span class="sxs-lookup"><span data-stu-id="aef4e-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="aef4e-200">Также можно задать имя любого события из любого объекта, доступного через пространство имен по умолчанию с помощью *typeName*. *событие* частично проверенное имя; этот синтаксис поддерживает присоединение обработчиков для перенаправленных событий, где обработчик предназначен для обработки перенаправления событий из дочерних элементов, но родительский элемент не имеет это событие в своей таблице элементов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="aef4e-201">Этот синтаксис похож на синтаксис вложенного события, но события не является true присоединенное событие.</span><span class="sxs-lookup"><span data-stu-id="aef4e-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="aef4e-202">Вместо этого вы ссылаетесь на событие с полным именем.</span><span class="sxs-lookup"><span data-stu-id="aef4e-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="aef4e-203">Дополнительные сведения см. в разделе [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-203">For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="aef4e-204">В некоторых случаях имена свойств иногда предоставляются в качестве значения атрибута, а не имя атрибута.</span><span class="sxs-lookup"><span data-stu-id="aef4e-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="aef4e-205">Имя этого свойства может также включать квалификаторы, такие как свойство, указанное в виде *Тип_владельца*. *dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="aef4e-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="aef4e-206">Этот сценарий характерен при написании стили или шаблоны в XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="aef4e-207">Правила обработки имен свойств, предоставленных в качестве значения атрибута отличаются и управляются по типу свойства, задаваемого или поведением, определенного WPF подсистем.</span><span class="sxs-lookup"><span data-stu-id="aef4e-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="aef4e-208">Дополнительные сведения см. в разделе [Стилизация и использование шаблонов](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-208">For details, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="aef4e-209">Другой вариант использования для имен свойств — Если значение атрибута описывает отношение свойство свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="aef4e-210">Эта функция используется для привязки данных и раскадровки целей и обеспечивается <xref:System.Windows.PropertyPath> класс и его преобразователя.</span><span class="sxs-lookup"><span data-stu-id="aef4e-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="aef4e-211">Более полное описание семантики поиска, см. в разделе [синтаксис PropertyPath XAML](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="aef4e-212">Синтаксис элемента свойства</span><span class="sxs-lookup"><span data-stu-id="aef4e-212">Property Element Syntax</span></span>  
 <span data-ttu-id="aef4e-213">*Синтаксис элемента свойства* является синтаксисом, который отличается от правил для элементов в базовом синтаксисе XML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="aef4e-214">В формате XML значение атрибута является де-факто является строкой, с единственным возможным вариантом используется формат кодировки строки.</span><span class="sxs-lookup"><span data-stu-id="aef4e-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="aef4e-215">В XAML можно назначить другие элементы объекта в качестве значения свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="aef4e-216">Эта возможность обеспечивается синтаксиса элемента свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="aef4e-217">Вместо свойства, указанного как атрибут в теге элемента, свойство задается с помощью элемента открывающий тег в *сочетание elementTypeName*. *propertyName* формы, значение свойства, указанного в, а затем закрывается элемент свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="aef4e-218">В частности, этот синтаксис начинается с левой угловой скобки (\<), а затем немедленно имя типа класса или структуры, содержащийся в синтаксис элемента свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="aef4e-219">Это сопровождается сразу следует точка (.), затем по имени свойства, затем правой угловой скобки (>).</span><span class="sxs-lookup"><span data-stu-id="aef4e-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="aef4e-220">Как и в случае с синтаксисом атрибута, это свойство должно существовать в объявленный открытые члены указанного типа.</span><span class="sxs-lookup"><span data-stu-id="aef4e-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="aef4e-221">Значение, присваиваемое свойству, содержащийся в элементе свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="aef4e-222">Как правило значение задается как один или несколько элементов объекта, поскольку указание объектов как значений — это сценарий, синтаксис элемента свойства предназначен адрес.</span><span class="sxs-lookup"><span data-stu-id="aef4e-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="aef4e-223">Наконец, эквивалентный закрывающий тег, указав те же *сочетание elementTypeName*. *propertyName* сочетание должно быть указано в правильном вложении и балансе с другими тегами элемента.</span><span class="sxs-lookup"><span data-stu-id="aef4e-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="aef4e-224">Например, ниже приведен синтаксис элемента свойства для <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="aef4e-225">Значение в элементе свойства также может быть задано как внутренний текст, в случаях, когда тип свойства, который указывается как примитивный тип значения, такие как <xref:System.String>, или перечисление, где указано имя.</span><span class="sxs-lookup"><span data-stu-id="aef4e-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="aef4e-226">Эти два способа использования довольно редки, так как каждый из этих случаев также может использовать более простой синтаксис атрибута.</span><span class="sxs-lookup"><span data-stu-id="aef4e-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="aef4e-227">Один из сценариев для заполнения элемента свойства со строкой — для свойств, которые не являются свойства содержимого XAML, но по-прежнему используются для представления текста пользовательского интерфейса и определенный символ пробела элементы, такие как символ перевода строки, необходимых в тексте пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="aef4e-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="aef4e-228">Синтаксис атрибута не может сохранять символ перевода строки, но синтаксис элемента свойства может, до тех пор, пока активен существенные пробелы (Дополнительные сведения см. в разделе [обработки в XAML пробелов](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md)).</span><span class="sxs-lookup"><span data-stu-id="aef4e-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md)).</span></span> <span data-ttu-id="aef4e-229">Еще один сценарий, чтобы [x: Uid Directive](../../../../docs/framework/xaml-services/x-uid-directive.md) могут применяться к элементу свойство, отметив тем самым значение как значение, которое должно быть локализовано в WPF выходных данных BAML или с помощью других методов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-229">Another scenario is so that [x:Uid Directive](../../../../docs/framework/xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="aef4e-230">Элемент свойства не представлен в логическом дереве WPF.</span><span class="sxs-lookup"><span data-stu-id="aef4e-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="aef4e-231">Элемент свойства — это лишь отдельный синтаксис для установки свойства, а не является элементом, который имеет экземпляр или резервный объект.</span><span class="sxs-lookup"><span data-stu-id="aef4e-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="aef4e-232">(Дополнительные сведения о логическом дереве, см. в разделе [деревья в WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md).)</span><span class="sxs-lookup"><span data-stu-id="aef4e-232">(For details on the logical tree concept, see [Trees in WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="aef4e-233">Для свойств, поддерживающих синтаксис элемента и атрибута и свойство двумя типами синтаксиса обычно имеют один и тот же результат, несмотря на то, что тонкостей, таких как обработка пробельных символов может немного отличаться от синтаксиса.</span><span class="sxs-lookup"><span data-stu-id="aef4e-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="aef4e-234">Синтаксис коллекции</span><span class="sxs-lookup"><span data-stu-id="aef4e-234">Collection Syntax</span></span>  
 <span data-ttu-id="aef4e-235">Спецификация XAML требует реализаций обработчиков XAML для идентификации свойств, где тип значения является коллекция.</span><span class="sxs-lookup"><span data-stu-id="aef4e-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="aef4e-236">Общая реализация обработчика XAML в .NET основан на управляемом коде и средой CLR, и он определяет типы коллекций с помощью одного из следующих:</span><span class="sxs-lookup"><span data-stu-id="aef4e-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
-   <span data-ttu-id="aef4e-237">Введите реализует <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="aef4e-238">Введите реализует <xref:System.Collections.IDictionary>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
-   <span data-ttu-id="aef4e-239">Тип является производным от <xref:System.Array> (Дополнительные сведения о массивах в XAML см. в разделе [расширение разметки x: Array](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="aef4e-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="aef4e-240">Если тип свойства является коллекцией, затем выведенный тип коллекции не требуется указывать в разметке в качестве объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="aef4e-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="aef4e-241">Вместо этого элементы, которые должны стать элементами коллекции, указываются как дочерние элементы элемента свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="aef4e-242">Каждый такой элемент вычисляется для объекта во время загрузки и добавить в коллекцию, вызвав метод `Add` метод неявной коллекции.</span><span class="sxs-lookup"><span data-stu-id="aef4e-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="aef4e-243">Например <xref:System.Windows.Style.Triggers%2A> свойство <xref:System.Windows.Style> принимает специализированный тип коллекции <xref:System.Windows.TriggerCollection>, который реализует <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="aef4e-244">Это не обязательно создавать <xref:System.Windows.TriggerCollection> объектного элемента в разметке.</span><span class="sxs-lookup"><span data-stu-id="aef4e-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="aef4e-245">Вместо этого укажите один или несколько <xref:System.Windows.Trigger> элементы как элементы в `Style.Triggers` элемента свойства, где <xref:System.Windows.Trigger> (или производного класса) — это тип, ожидаемый тип элемента для строго типизированным и неявное <xref:System.Windows.TriggerCollection>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="aef4e-246">Свойство может быть типом коллекции и свойства содержимого XAML для этого типа и производных типов, как описано в следующем разделе этой статьи.</span><span class="sxs-lookup"><span data-stu-id="aef4e-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="aef4e-247">Элемент неявной коллекции создает элемент в представлении логического дерева, несмотря на то, что он не отображается в разметке как элемент.</span><span class="sxs-lookup"><span data-stu-id="aef4e-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="aef4e-248">Обычно конструктор родительского типа выполняет создание экземпляра для коллекции, который является одним из его свойств и изначально пустая коллекция становится частью дерева объектов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aef4e-249">Универсальные интерфейсы списка и словаря (<xref:System.Collections.Generic.IList%601> и <xref:System.Collections.Generic.IDictionary%602>) не поддерживаются для обнаружения коллекции.</span><span class="sxs-lookup"><span data-stu-id="aef4e-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="aef4e-250">Тем не менее, можно использовать <xref:System.Collections.Generic.List%601> класса в качестве базового класса, так как он реализует <xref:System.Collections.IList> напрямую, или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, так как он реализует <xref:System.Collections.IDictionary> напрямую.</span><span class="sxs-lookup"><span data-stu-id="aef4e-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="aef4e-251">На страницах Справочник по .NET для типов коллекции этот синтаксис с намеренным заменяют объектного элемента для коллекции иногда отмечен в разделах синтаксиса XAML как неявного синтаксиса коллекции.</span><span class="sxs-lookup"><span data-stu-id="aef4e-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="aef4e-252">За исключением корневого элемента, каждый элемент объекта в файле XAML, который является вложенной как дочерний элемент другого элемента, подходит ли элемент, который является один или оба из следующих случаев: член неявного свойства коллекции своего родительского элемента , либо элемент, который задает значение свойства содержимого XAML для родительского элемента (XAML-содержимого, свойств, которые будут рассматриваться в следующем разделе).</span><span class="sxs-lookup"><span data-stu-id="aef4e-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="aef4e-253">Другими словами связь родительских и дочерних элементов в разметке страницы действительно является один объект в корне, и каждый элемент объекта ниже корня является одним экземпляром, который предоставляет значение свойства родительского объекта, или один из элементов в пределах столбца lection, который также является значение свойства типа "коллекция" родительского элемента.</span><span class="sxs-lookup"><span data-stu-id="aef4e-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="aef4e-254">Эта концепция единой корневой с XML и часто закрепляется в поведении API-интерфейсы, такие как Загрузка XAML <xref:System.Windows.Markup.XamlReader.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="aef4e-255">Ниже приведен синтаксис с элементом объекта для коллекции (<xref:System.Windows.Media.GradientStopCollection>) задан явным образом.</span><span class="sxs-lookup"><span data-stu-id="aef4e-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="aef4e-256">Обратите внимание на то, что не всегда можно явно объявить коллекции.</span><span class="sxs-lookup"><span data-stu-id="aef4e-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="aef4e-257">Например, попытка объявить <xref:System.Windows.TriggerCollection> явным образом в ранее показанном <xref:System.Windows.Style.Triggers%2A> пример завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="aef4e-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="aef4e-258">Явного объявления коллекции необходимо, что класс коллекции должен поддерживать конструктор по умолчанию, и <xref:System.Windows.TriggerCollection> не имеет конструктора по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="aef4e-258">Explicitly declaring the collection requires that the collection class must support a default constructor, and <xref:System.Windows.TriggerCollection> does not have a default constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="aef4e-259">Свойства содержимого XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-259">XAML Content Properties</span></span>  
 <span data-ttu-id="aef4e-260">Синтаксис содержимого XAML является синтаксисом, который действует только на классы, которые задают <xref:System.Windows.Markup.ContentPropertyAttribute> как часть объявления их класса.</span><span class="sxs-lookup"><span data-stu-id="aef4e-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="aef4e-261"><xref:System.Windows.Markup.ContentPropertyAttribute> Ссылается на имя свойства, которое является свойством содержимого для данного типа элементов (включая производные классы).</span><span class="sxs-lookup"><span data-stu-id="aef4e-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="aef4e-262">При обработке процессором XAML, все дочерние элементы или внутренний текст, найденные между открывающим и закрывающим тегами элемента объекта назначается в качестве значения свойства содержимого XAML для этого объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="aef4e-263">Вы можете задать явные элементы свойства для свойства содержимого, но такое использование обычно не показано в разделах синтаксиса XAML в справочнике по .NET.</span><span class="sxs-lookup"><span data-stu-id="aef4e-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="aef4e-264">Явные/verbose метод имеет случайное значение для ясности в разметке или стиль разметки, но обычно целью свойства содержимого является упрощение разметки, чтобы элементы, интуитивно связанные как родители потомки могут быть вложенными напрямую.</span><span class="sxs-lookup"><span data-stu-id="aef4e-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="aef4e-265">Теги элемента свойства для других свойств в элементе не заданы как «содержимое» в строгом определение языка XAML; они обрабатываются в порядке обработки средство синтаксического анализа XAML и не считаются «содержимое».</span><span class="sxs-lookup"><span data-stu-id="aef4e-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="aef4e-266">Значения свойств содержимого XAML должны быть непрерывными</span><span class="sxs-lookup"><span data-stu-id="aef4e-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="aef4e-267">Значение свойства содержимого XAML должно быть задано полностью до или после любых других элементов свойств данного объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="aef4e-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="aef4e-268">Это верно, является ли значение свойства содержимого XAML указывается как строка или как один или несколько объектов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="aef4e-269">Например следующая разметка не выполняет анализ:</span><span class="sxs-lookup"><span data-stu-id="aef4e-269">For example, the following markup does not parse:</span></span>  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="aef4e-270">Это неверно, так как этот синтаксис после внесения явные с использованием синтаксиса элемента свойства для свойства содержимого, то свойство content будет задано дважды:</span><span class="sxs-lookup"><span data-stu-id="aef4e-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="aef4e-271">Аналогично неверным примером является, если свойство содержимого представляет собой коллекцию, и дочерние элементы смешиваются с свойств элементов:</span><span class="sxs-lookup"><span data-stu-id="aef4e-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="aef4e-272">Объединение свойства содержимого и синтаксиса коллекции</span><span class="sxs-lookup"><span data-stu-id="aef4e-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="aef4e-273">Чтобы принять более, чем элементов объекта в качестве содержимого, тип свойства содержимого обязательно должен быть типом коллекции.</span><span class="sxs-lookup"><span data-stu-id="aef4e-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="aef4e-274">Как и в синтаксис элемента свойства для типов коллекций, обработчик XAML должен идентифицировать типы, которые являются типами коллекций.</span><span class="sxs-lookup"><span data-stu-id="aef4e-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="aef4e-275">Если элемент имеет свойство содержимого XAML и тип свойства содержимого XAML является коллекцией, неявный тип коллекции не нужно указывать в разметке в качестве объектного элемента и свойства содержимого XAML необходимо указать как el свойство правления.</span><span class="sxs-lookup"><span data-stu-id="aef4e-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="aef4e-276">Таким образом, видимая модель содержимого в разметке теперь могут иметь более одного дочернего элемента, назначенных в качестве содержимого.</span><span class="sxs-lookup"><span data-stu-id="aef4e-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="aef4e-277">Ниже приведен синтаксис содержимого <xref:System.Windows.Controls.Panel> производного класса.</span><span class="sxs-lookup"><span data-stu-id="aef4e-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="aef4e-278">Все <xref:System.Windows.Controls.Panel> производные классы установить свойство содержимого XAML, чтобы быть <xref:System.Windows.Controls.Panel.Children%2A>, что требует значение типа <xref:System.Windows.Controls.UIElementCollection>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="aef4e-279">Обратите внимание, что ни элемент свойства для <xref:System.Windows.Controls.Panel.Children%2A> ни элемент для <xref:System.Windows.Controls.UIElementCollection> необходим в разметке.</span><span class="sxs-lookup"><span data-stu-id="aef4e-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="aef4e-280">Это средство разработки XAML, чтобы рекурсивно содержащиеся элементы, определяющие [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] являются более интуитивно понятным образом представлены в виде дерева вложенных элементов с немедленного родительских и дочерних элементов элемента, не содержит промежуточных тегов элементов свойства или Коллекция объектов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="aef4e-281">На самом деле <xref:System.Windows.Controls.UIElementCollection> нельзя задавать явным образом в разметку как объектный элемент, намеренно.</span><span class="sxs-lookup"><span data-stu-id="aef4e-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="aef4e-282">Так как является предназначен для использования только в качестве неявной коллекции, <xref:System.Windows.Controls.UIElementCollection> не предоставляет открытый конструктор по умолчанию и таким образом, не может быть создан в качестве объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="aef4e-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public default constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="aef4e-283">Совместное использование свойств элементов и элементов объекта в объект со свойством содержимого</span><span class="sxs-lookup"><span data-stu-id="aef4e-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="aef4e-284">В спецификации XAML объявляет, что обработчик XAML может применить объектные элементы, которые используются для заполнения свойства содержимого XAML в элементе объекта должны быть непрерывными что не могут смешиваться.</span><span class="sxs-lookup"><span data-stu-id="aef4e-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="aef4e-285">Это ограничение, запрещающее смешивание элементов свойств и содержимого, обеспечивается [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] процессоры XAML.</span><span class="sxs-lookup"><span data-stu-id="aef4e-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="aef4e-286">Дочерний элемент объекта может иметь как первый немедленно разметка внутри элемента объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="aef4e-287">Затем можно ввести свойств элементов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-287">Then you can introduce property elements.</span></span> <span data-ttu-id="aef4e-288">Или можно указать один или несколько свойств элементов содержимого, а затем дополнительные элементы свойств.</span><span class="sxs-lookup"><span data-stu-id="aef4e-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="aef4e-289">Но после элемента свойства следует за содержимым, нельзя добавлять последующее содержимое, можно добавить только свойств элементов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="aef4e-290">Это содержимое и свойства элемента заказа требование не применяется к внутренний текст, используемый в качестве содержимого.</span><span class="sxs-lookup"><span data-stu-id="aef4e-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="aef4e-291">Тем не менее это по-прежнему хорошего стиля разметки для сохранения внутреннего текста смежными, так как значащий пробел будет трудно обнаружить визуально в разметке, если элементы свойств смешиваются с внутренним текстом.</span><span class="sxs-lookup"><span data-stu-id="aef4e-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="aef4e-292">Пространства имен языка XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-292">XAML Namespaces</span></span>  
 <span data-ttu-id="aef4e-293">Ни один из предыдущих примеров синтаксиса указано пространство имен XAML, отличном от пространства имен XAML по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="aef4e-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="aef4e-294">В обычных [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложений, пространство имен XAML по умолчанию установлено значение [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] пространства имен.</span><span class="sxs-lookup"><span data-stu-id="aef4e-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="aef4e-295">Можно указывать пространства имен XAML, отличном от пространства имен XAML по умолчанию и по-прежнему использовать аналогичный синтаксис.</span><span class="sxs-lookup"><span data-stu-id="aef4e-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="aef4e-296">Но затем, в любом где именуется класс, который недоступен в пространстве имен XAML по умолчанию, имя этого класса должны начинаться с префикса пространства имен XAML как сопоставляются с соответствующим пространством имен CLR.</span><span class="sxs-lookup"><span data-stu-id="aef4e-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="aef4e-297">Например `<custom:Example/>` является синтаксис объектных элементов для создания экземпляра `Example` класса, где пространство имен CLR, содержащее этот класс (и, возможно, данные внешней сборке, содержащей резервные типы) был ранее сопоставлен `custom` префикс.</span><span class="sxs-lookup"><span data-stu-id="aef4e-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="aef4e-298">Дополнительные сведения о пространствах имен XAML см. в разделе [пространства имен XAML и сопоставление пространств имен для WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="aef4e-299">Расширения разметки</span><span class="sxs-lookup"><span data-stu-id="aef4e-299">Markup Extensions</span></span>  
 <span data-ttu-id="aef4e-300">XAML определяет программирования сущность, которая позволяет выйти за рамки обычной обработки процессором XAML строковых атрибутов или элементов объектов и откладывает обработку на вспомогательный класс расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="aef4e-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="aef4e-301">Символ, который определяет расширение разметки для обработчика XAML, при использовании синтаксиса атрибутов, открывающая фигурная скобка ({}), следуют любой символ, отличный от закрывающую фигурную скобку (}).</span><span class="sxs-lookup"><span data-stu-id="aef4e-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="aef4e-302">Первая строка, следующая открывающая фигурная скобка должна ссылаться на класс, который предоставляет определенное расширение поведения, где ссылки можно пропустить подстроку «Extension», если эта подстрока является частью истинного имени класса.</span><span class="sxs-lookup"><span data-stu-id="aef4e-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="aef4e-303">После этого может использоваться один пробел, и затем каждый последующий знак используется в качестве входных данных реализации расширения, вплоть до появления закрывающую фигурную скобку.</span><span class="sxs-lookup"><span data-stu-id="aef4e-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="aef4e-304">В реализации XAML в .NET используется <xref:System.Windows.Markup.MarkupExtension> абстрактного класса в качестве основы для всех расширений разметки, поддерживаемых [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , а также других платформ или технологий.</span><span class="sxs-lookup"><span data-stu-id="aef4e-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="aef4e-305">Расширения разметки, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] специально реализует часто предназначены для создания ссылок на другие существующие объекты или для предоставления отложенных ссылок на объекты, на которые будет вычисляться во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="aef4e-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="aef4e-306">Например, простая привязка данных WPF выполняется путем указания `{Binding}` расширения разметки вместо значения, которое обычно принимает определенное свойство.</span><span class="sxs-lookup"><span data-stu-id="aef4e-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="aef4e-307">Большинство расширений разметки WPF включает синтаксис атрибута для свойств, где синтаксис атрибута бы в противном случае невозможно.</span><span class="sxs-lookup"><span data-stu-id="aef4e-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="aef4e-308">Например <xref:System.Windows.Style> объект — довольно сложный тип, содержащий ряд вложенных объектов и свойств.</span><span class="sxs-lookup"><span data-stu-id="aef4e-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="aef4e-309">Стили в WPF обычно определяются как ресурс в <xref:System.Windows.ResourceDictionary>и затем указываются с помощью одного из двух расширений разметки WPF, запрашивающих ресурс.</span><span class="sxs-lookup"><span data-stu-id="aef4e-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="aef4e-310">Расширение разметки откладывает вычисление значения свойства для поиска ресурсов и обеспечивает предоставление значения <xref:System.Windows.FrameworkElement.Style%2A> свойство, тип <xref:System.Windows.Style>в атрибут синтаксис, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="aef4e-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="aef4e-311">Здесь `StaticResource` идентифицирует <xref:System.Windows.StaticResourceExtension> класс, предоставляющий реализации расширения разметки.</span><span class="sxs-lookup"><span data-stu-id="aef4e-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="aef4e-312">Следующая строка `MyStyle` используется в качестве входных данных для не по умолчанию <xref:System.Windows.StaticResourceExtension> конструктор, где параметр, принимаемый из строки расширения объявляет запрашиваемый <xref:System.Windows.ResourceKey>.</span><span class="sxs-lookup"><span data-stu-id="aef4e-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="aef4e-313">`MyStyle` должен быть [x: Key](../../../../docs/framework/xaml-services/x-key-directive.md) значение <xref:System.Windows.Style> , определенный как ресурс.</span><span class="sxs-lookup"><span data-stu-id="aef4e-313">`MyStyle` is expected to be the [x:Key](../../../../docs/framework/xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="aef4e-314">[Расширение разметки StaticResource](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) использования запросов использования ресурсов для предоставления <xref:System.Windows.Style> значение свойства через логику поиска статических ресурсов во время загрузки.</span><span class="sxs-lookup"><span data-stu-id="aef4e-314">The [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="aef4e-315">Подробнее о расширениях разметки см. в разделе [Расширения разметки и XAML WPF](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="aef4e-316">Ссылка расширения разметки и другие XAML, программирование функций, включенных в общей реализации .NET XAML, см. в разделе [пространства имен XAML (x:) Возможности языка](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md).</span></span> <span data-ttu-id="aef4e-317">WPF-расширениях разметки см. в разделе [расширения XAML WPF](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-317">For WPF-specific markup extensions, see [WPF XAML Extensions](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="aef4e-318">Вложенные свойства</span><span class="sxs-lookup"><span data-stu-id="aef4e-318">Attached Properties</span></span>  
 <span data-ttu-id="aef4e-319">Присоединенные свойства являются понятием программирования, представленным в XAML, при котором свойства можно во владении и определением определенного типа, но установлен в качестве атрибутов или свойств элементов для любого элемента.</span><span class="sxs-lookup"><span data-stu-id="aef4e-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="aef4e-320">Основной сценарий что присоединенные свойства предназначены для является разрешение дочерним элементам в структуре разметки для передачи сведений в родительском элементе без необходимости сложного распределения объектной модели для всех элементов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="aef4e-321">И наоборот можно использовать вложенные свойства родительскими элементами для передачи сведений дочерних элементов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="aef4e-322">Дополнительные сведения о назначении вложенных свойств и создании собственных присоединенных свойств см. в разделе [зависимостей](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="aef4e-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="aef4e-323">Вложенные свойства используют синтаксис, который внешне напоминает синтаксис элемента свойства, в котором также указывается *typeName*. *propertyName* сочетания.</span><span class="sxs-lookup"><span data-stu-id="aef4e-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="aef4e-324">Однако имеется два важных отличия.</span><span class="sxs-lookup"><span data-stu-id="aef4e-324">There are two important differences:</span></span>  
  
-   <span data-ttu-id="aef4e-325">Можно использовать *typeName*. *propertyName* сочетания даже при задании присоединенное свойство через синтаксис атрибутов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="aef4e-326">Присоединенные свойства являются единственным вариантом, если уточнение имени свойства является обязательным в синтаксис атрибутов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
-   <span data-ttu-id="aef4e-327">Можно также использовать синтаксис элемента свойства для присоединенных свойств.</span><span class="sxs-lookup"><span data-stu-id="aef4e-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="aef4e-328">Однако для обычного синтаксиса элемента свойства *typeName* указать, является элементом объекта, содержащим элемент свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="aef4e-329">Если вы ссылаетесь на вложенное свойство, то *typeName* — это класс, который определяет присоединенное свойство, не содержащий его элемент объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="aef4e-330">Вложенные события</span><span class="sxs-lookup"><span data-stu-id="aef4e-330">Attached Events</span></span>  
 <span data-ttu-id="aef4e-331">Прикрепленные события – это другой понятие программирования, представленное в XAML, где события могут быть определены с помощью определенных типов, но могут быть присоединены обработчики для любого объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="aef4e-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="aef4e-332">В реализации WOF часто тип, который определяет присоединенное событие является статическим типом, определяющим службу, и иногда эти присоединенные события предоставляются с помощью псевдонимов перенаправленных событий в типах, которые предоставляют службу.</span><span class="sxs-lookup"><span data-stu-id="aef4e-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="aef4e-333">Обработчики для присоединенных событий указываются с помощью синтаксиса атрибутов.</span><span class="sxs-lookup"><span data-stu-id="aef4e-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="aef4e-334">Как с помощью присоединенных событий, синтаксис атрибута расширен для присоединенных событий Разрешить *typeName*. *eventName* использования, где *typeName* — это класс, предоставляющий `Add` и `Remove` методы доступа обработчика событий для присоединенного события инфраструктуры, и *eventName* является именем события.</span><span class="sxs-lookup"><span data-stu-id="aef4e-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="aef4e-335">Составляющие корневого элемента XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="aef4e-336">В следующей таблице показаны типичные XAML корневого элемента, отображающее определенные атрибуты корневого элемента:</span><span class="sxs-lookup"><span data-stu-id="aef4e-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="aef4e-337">Открытие объектного элемента корневого элемента</span><span class="sxs-lookup"><span data-stu-id="aef4e-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="aef4e-338">Значение по умолчанию ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) пространства имен XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="aef4e-339">Пространство имен XAML языка XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="aef4e-340">Объявление разделяемого класса, который подключается к любой кода разметки, определенные для разделяемого класса</span><span class="sxs-lookup"><span data-stu-id="aef4e-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="aef4e-341">Конец для корневого элемента объекта.</span><span class="sxs-lookup"><span data-stu-id="aef4e-341">End of object element for the root.</span></span> <span data-ttu-id="aef4e-342">Объект еще не закрыт, потому что элемент содержит дочерние элементы</span><span class="sxs-lookup"><span data-stu-id="aef4e-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="aef4e-343">Данные об использовании необязательно и нежелательные XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="aef4e-344">В следующих разделах описаны случаи использования XAML, которые технически поддерживаются процессорами XAML, однако создают уровень детализации или другие эстетически проблемы, мешающие XAML-файлов, оставшихся в удобное для восприятия, когда к разработке приложений, содержащих источники XAML .</span><span class="sxs-lookup"><span data-stu-id="aef4e-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when your develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="aef4e-345">Необязательное использование элемента свойства</span><span class="sxs-lookup"><span data-stu-id="aef4e-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="aef4e-346">Необязательное использование элемента свойства относится явное объявление свойств содержимого элементов, обработчик XAML рассматривает как неявные.</span><span class="sxs-lookup"><span data-stu-id="aef4e-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="aef4e-347">Например, при объявлении содержимое <xref:System.Windows.Controls.Menu>, вы можете явно объявить <xref:System.Windows.Controls.ItemsControl.Items%2A> коллекцию <xref:System.Windows.Controls.Menu> как `<Menu.Items>` тега элемента свойства и поместить каждый <xref:System.Windows.Controls.MenuItem> в `<Menu.Items>`, а чем использование неявных поведение обработчика XAML, все дочерние элементы <xref:System.Windows.Controls.Menu> должно быть <xref:System.Windows.Controls.MenuItem> и помещаются в <xref:System.Windows.Controls.ItemsControl.Items%2A> коллекции.</span><span class="sxs-lookup"><span data-stu-id="aef4e-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="aef4e-348">Иногда необязательное использование помогает визуально уточнить структуру объектов, представленных в разметке.</span><span class="sxs-lookup"><span data-stu-id="aef4e-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="aef4e-349">Или иногда использовании явные свойства элемента можно избежать разметки, технически функциональной, но визуально вызывает путаницу, таких как вложенные расширения разметки в значении атрибута.</span><span class="sxs-lookup"><span data-stu-id="aef4e-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="aef4e-350">Полный typeName.memberName указанием атрибуты</span><span class="sxs-lookup"><span data-stu-id="aef4e-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="aef4e-351">*TypeName*. *имя пользователя* форме атрибут фактически работает более универсально, чем просто перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="aef4e-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="aef4e-352">В остальных случаях эта форма является избыточной, но следует избегать, для поддержания стиля разметки и удобства чтения.</span><span class="sxs-lookup"><span data-stu-id="aef4e-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="aef4e-353">В следующем примере каждое из трех ссылок на <xref:System.Windows.Controls.Control.Background%2A> атрибут полностью эквивалентны:</span><span class="sxs-lookup"><span data-stu-id="aef4e-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="aef4e-354">`Button.Background` работает, поскольку полный поиск этого свойства в <xref:System.Windows.Controls.Button> успешно (<xref:System.Windows.Controls.Control.Background%2A> унаследованного от элемента управления) и <xref:System.Windows.Controls.Button> объектного элемента класса или базового класса.</span><span class="sxs-lookup"><span data-stu-id="aef4e-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="aef4e-355">`Control.Background` работает, потому что <xref:System.Windows.Controls.Control> класс фактически определяет <xref:System.Windows.Controls.Control.Background%2A> и <xref:System.Windows.Controls.Control> является <xref:System.Windows.Controls.Button> базового класса.</span><span class="sxs-lookup"><span data-stu-id="aef4e-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="aef4e-356">Тем не менее следующие *typeName*. *имя пользователя* пример формы, не работает и таким образом маркерами комментария:</span><span class="sxs-lookup"><span data-stu-id="aef4e-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="aef4e-357"><xref:System.Windows.Controls.Label> другой класс, производный из <xref:System.Windows.Controls.Control>, и если вы указали `Label.Background` в <xref:System.Windows.Controls.Label> объектного элемента, это использование могло бы работать.</span><span class="sxs-lookup"><span data-stu-id="aef4e-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="aef4e-358">Тем не менее так как <xref:System.Windows.Controls.Label> не класса или базового класса <xref:System.Windows.Controls.Button>, заданное поведение обработчика XAML является последующее `Label.Background` как присоединенное свойство.</span><span class="sxs-lookup"><span data-stu-id="aef4e-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="aef4e-359">`Label.Background` не является доступным вложенным свойством, и такое использование не удается.</span><span class="sxs-lookup"><span data-stu-id="aef4e-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="aef4e-360">baseTypeName.memberName свойств элементов</span><span class="sxs-lookup"><span data-stu-id="aef4e-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="aef4e-361">В аналогичный способ как *typeName*. *имя пользователя* форма работает для синтаксиса атрибутов *Имя_базового_типа*. *имя пользователя* работает для синтаксиса элемента свойства.</span><span class="sxs-lookup"><span data-stu-id="aef4e-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="aef4e-362">Например следующий синтаксис работает:</span><span class="sxs-lookup"><span data-stu-id="aef4e-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="aef4e-363">Здесь элемент свойства задан как `Control.Background` несмотря на то, что содержится в элементе свойства `Button`.</span><span class="sxs-lookup"><span data-stu-id="aef4e-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="aef4e-364">Но так же, как *typeName*. *имя пользователя* формы для атрибутов, *Имя_базового_типа*. *имя пользователя* находится в плохом стиле в разметке, и ее следует избегать.</span><span class="sxs-lookup"><span data-stu-id="aef4e-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="aef4e-365">См. также</span><span class="sxs-lookup"><span data-stu-id="aef4e-365">See Also</span></span>  
 [<span data-ttu-id="aef4e-366">Общие сведения о языке XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="aef4e-366">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="aef4e-367">Возможности пространства имен языка XAML (x:)</span><span class="sxs-lookup"><span data-stu-id="aef4e-367">XAML Namespace (x:) Language Features</span></span>](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)  
 [<span data-ttu-id="aef4e-368">Расширения XAML WPF</span><span class="sxs-lookup"><span data-stu-id="aef4e-368">WPF XAML Extensions</span></span>](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)  
 [<span data-ttu-id="aef4e-369">Общие сведения о свойствах зависимости</span><span class="sxs-lookup"><span data-stu-id="aef4e-369">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="aef4e-370">TypeConverters и XAML</span><span class="sxs-lookup"><span data-stu-id="aef4e-370">TypeConverters and XAML</span></span>](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md)  
 [<span data-ttu-id="aef4e-371">Код XAML и пользовательские классы для WPF</span><span class="sxs-lookup"><span data-stu-id="aef4e-371">XAML and Custom Classes for WPF</span></span>](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)
