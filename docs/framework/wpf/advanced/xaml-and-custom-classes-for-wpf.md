---
title: XAML и пользовательские классы
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: 4cd0ba7fa03d2578f4477c3ccf53188fbbea2dbd
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186262"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="b71da-102">Код XAML и пользовательские классы для WPF</span><span class="sxs-lookup"><span data-stu-id="b71da-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="b71da-103">XAML как реализованный в общих языковых системах времени выполнения (CLR) поддерживает возможность определения пользовательского класса или структуры на любом общем языке выполнения языка (CLR), а затем получить доступ к этому классу с помощью разметки XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="b71da-104">В одном файле разметки можно использовать сочетание определенных в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] типов и пользовательских типов, обычно сопоставляя пользовательские типы с префиксом пространства имен XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="b71da-105">В этом разделе обсуждаются требования, которым должен соответствовать пользовательский класс, чтобы его можно было использовать в качестве элемента XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="b71da-106">Пользовательские классы в приложениях или сборках</span><span class="sxs-lookup"><span data-stu-id="b71da-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="b71da-107">Пользовательские классы, используемые в XAML, можно определить двумя способами: в коде программной части или другом коде, который создает основное приложение [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], или как класс в отдельной сборке, например как исполняемый файл или библиотеку DLL, используемые в качестве библиотеки классов.</span><span class="sxs-lookup"><span data-stu-id="b71da-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="b71da-108">Каждый из этих подходов имеет определенные преимущества и недостатки.</span><span class="sxs-lookup"><span data-stu-id="b71da-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="b71da-109">Преимуществом создания библиотеки классов является то, что все подобные пользовательские классы могут совместно использоваться несколькими различными приложениями.</span><span class="sxs-lookup"><span data-stu-id="b71da-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="b71da-110">Отдельная библиотека также облегчает управление версиями приложений и упрощает создание класса, который предполагается использовать в качестве корневого элемента на странице XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="b71da-111">Преимущество определения пользовательских классов в приложении состоит в том, что этот способ является относительно простым и сводит к минимуму проблемы развертывания и тестирования, возникающие при введении отдельных сборок за пределами главного исполняемого файла приложения.</span><span class="sxs-lookup"><span data-stu-id="b71da-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="b71da-112">Независимо от того, определены ли пользовательские классы в одной или разных сборках, они должны быть распределены между пространством имен CLR и пространством имен XML, чтобы их можно было использовать в XAML в качестве элементов.</span><span class="sxs-lookup"><span data-stu-id="b71da-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="b71da-113">См. раздел [Пространства имен XAML и сопоставление пространств имен для WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="b71da-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="b71da-114">Требования к пользовательскому классу как элементу XAML</span><span class="sxs-lookup"><span data-stu-id="b71da-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="b71da-115">Чтобы можно было создавать экземпляр класса в качестве объектного элемента, класс должен удовлетворять указанным ниже требованиям.</span><span class="sxs-lookup"><span data-stu-id="b71da-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="b71da-116">Пользовательский класс должен быть открытым и должен поддерживать открытый конструктор по умолчанию (без параметров).</span><span class="sxs-lookup"><span data-stu-id="b71da-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="b71da-117">(Примечания о структурах см. в следующем разделе.)</span><span class="sxs-lookup"><span data-stu-id="b71da-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="b71da-118">Пользовательский класс не должен быть вложенным.</span><span class="sxs-lookup"><span data-stu-id="b71da-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="b71da-119">Вложенные классы и "точка" в их общем синтаксисе использования в среде CLR конфликтуют с другими функциями [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и XAML, такими как присоединенные свойства.</span><span class="sxs-lookup"><span data-stu-id="b71da-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="b71da-120">В дополнение к разрешению синтаксиса объектных элементов определение объекта также разрешает синтаксис элемента свойства для всех других открытых свойств, которые принимают объект в качестве типа значения.</span><span class="sxs-lookup"><span data-stu-id="b71da-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="b71da-121">Это происходит потому, что экземпляр объекта теперь может быть создан в качестве объектного элемента и может заполнить значение элемента свойства.</span><span class="sxs-lookup"><span data-stu-id="b71da-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="b71da-122">Структуры</span><span class="sxs-lookup"><span data-stu-id="b71da-122">Structures</span></span>  
 <span data-ttu-id="b71da-123">Структуры, которые вы определяете как пользовательские типы, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] всегда могут быть построены в XAML в . Это происходит потому, что компиляторы CLR неявно создают беспараметрыный конструктор для структуры, которая инициализирует все значения свойств для своих по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="b71da-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="b71da-124">В некоторых случаях поведение конструктора по умолчанию или использование объектных элементов для структуры является нежелательным.</span><span class="sxs-lookup"><span data-stu-id="b71da-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="b71da-125">Это возможно в тех случаях, когда структура используется для заполнения значений и функционирует в качестве объединения, в котором хранятся взаимоисключающие значения, и поэтому ни одному из свойств нельзя присвоить значение.</span><span class="sxs-lookup"><span data-stu-id="b71da-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="b71da-126">Примером [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] такой структуры <xref:System.Windows.GridLength>является .</span><span class="sxs-lookup"><span data-stu-id="b71da-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="b71da-127">Как правило, в таких структурах необходимо реализовать преобразователь типов, чтобы значения можно было представить в виде атрибутов, используя преобразования строк для создания различных интерпретаций или режимов значений структуры.</span><span class="sxs-lookup"><span data-stu-id="b71da-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="b71da-128">Структура должна также подвергать аналогичное поведение для построения кода через непараметрбезный конструктор.</span><span class="sxs-lookup"><span data-stu-id="b71da-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="b71da-129">Требования к свойствам пользовательского класса как атрибутам XAML</span><span class="sxs-lookup"><span data-stu-id="b71da-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="b71da-130">Свойства должны ссылаться на повысь-тип (например, примитивный), или использовать класс для типа, который имеет либо безпаралистов конструктора или специальный преобразователь типа, к которым может получить доступ процессор XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="b71da-131">В реализации CLR XAML процессоры XAML либо находят такие преобразователи <xref:System.ComponentModel.TypeConverterAttribute> через родную поддержку примитивов языка, либо применяя к типу или участнику в определениях резервного типа</span><span class="sxs-lookup"><span data-stu-id="b71da-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="b71da-132">Помимо этого, свойство может ссылаться на абстрактный тип класса или интерфейс.</span><span class="sxs-lookup"><span data-stu-id="b71da-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="b71da-133">Для абстрактных классов или интерфейсов ожидаемый результат синтаксического анализа XAML заключается в том, что значение свойства должно быть заполнено практическими экземплярами класса, которые реализуют интерфейс, или экземплярами типов, которые являются производными от абстрактного класса.</span><span class="sxs-lookup"><span data-stu-id="b71da-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="b71da-134">Свойства могут объявляться в абстрактном классе, но могут быть заданы только в практических классах, производных от абстрактных классов.</span><span class="sxs-lookup"><span data-stu-id="b71da-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="b71da-135">Это связано с тем, что для создания элемента объекта для класса вообще требуется непосильным для нее конструктор в классе.</span><span class="sxs-lookup"><span data-stu-id="b71da-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="b71da-136">Синтаксис атрибута с поддержкой TypeConverter</span><span class="sxs-lookup"><span data-stu-id="b71da-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="b71da-137">Если поддерживается выделенный преобразователь типов атрибутов на уровне класса, то применяемый тип преобразования включает синтаксис атрибута для любого свойства, для которого необходимо создать экземпляр этого типа.</span><span class="sxs-lookup"><span data-stu-id="b71da-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="b71da-138">Преобразователь типа не позволяет использовать элемент объекта типа; только наличие беспараметрыного конструктора для этого типа позволяет использовать элемент объекта.</span><span class="sxs-lookup"><span data-stu-id="b71da-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="b71da-139">Таким образом, свойства, разрешенные преобразователем типов, обычно не используются в синтаксисе свойств, если только сам тип не поддерживает синтаксис объектных элементов.</span><span class="sxs-lookup"><span data-stu-id="b71da-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="b71da-140">Исключением из этого является указание синтаксиса элемента свойства при наличии элемента свойства, содержащего строку.</span><span class="sxs-lookup"><span data-stu-id="b71da-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="b71da-141">Это использование действительно существенно эквивалентно использованию синтаксиса атрибутов, и такое использование не является обычным явлением, если нет необходимости в более надежной обработке значения атрибута с белым пространством.</span><span class="sxs-lookup"><span data-stu-id="b71da-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="b71da-142">Например, ниже показано использование элемента свойства, который принимает строку, а использование атрибута эквивалентно.</span><span class="sxs-lookup"><span data-stu-id="b71da-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="b71da-143">Примеры свойств, где синтаксис атрибута разрешен, но синтаксис элемента свойства, содержащего <xref:System.Windows.Input.Cursor> элемент объекта, запрещен через XAML, представляют собой различные свойства, которые принимают тип.</span><span class="sxs-lookup"><span data-stu-id="b71da-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="b71da-144">Класс <xref:System.Windows.Input.Cursor> имеет специальный преобразователь <xref:System.Windows.Input.CursorConverter>типа, но не предоставляет <xref:System.Windows.FrameworkElement.Cursor%2A> беспараметрыный конструктор, поэтому свойство <xref:System.Windows.Input.Cursor> может быть установлено только через синтаксис атрибута, даже если фактический тип является эталонным типом.</span><span class="sxs-lookup"><span data-stu-id="b71da-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="b71da-145">Преобразователь типа каждого свойства</span><span class="sxs-lookup"><span data-stu-id="b71da-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="b71da-146">В качестве альтернативы само свойство может объявлять преобразователь типов на уровне свойств.</span><span class="sxs-lookup"><span data-stu-id="b71da-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="b71da-147">Это позволяет "мини-язык", который мгновенно объекты типа свойства входящие, путем обработки входящих значений <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> строки атрибута в качестве ввода для операции на основе соответствующего типа.</span><span class="sxs-lookup"><span data-stu-id="b71da-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="b71da-148">Обычно это делается для предоставления удобного метода доступа, а не как единственное средство для задания свойства в XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="b71da-149">Тем не менее, можно также использовать преобразователи типа для атрибутов, где вы хотите использовать существующие типы CLR, которые не поставляют ни без параметра конструктора, ни приписываемого преобразователя типа.</span><span class="sxs-lookup"><span data-stu-id="b71da-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="b71da-150">Примерами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API являются определенные <xref:System.Globalization.CultureInfo> свойства, которые принимают тип.</span><span class="sxs-lookup"><span data-stu-id="b71da-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="b71da-151">В этом [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] случае использовалсуществующий тип <xref:System.Globalization.CultureInfo> рамочного microsoft .NET для более эффективного решения сценариев <xref:System.Globalization.CultureInfo> совместимости и миграции, которые использовались в более ранних версиях фректов, но тип не поддерживал необходимые конструкторы или конверсию типа типа, чтобы быть пригодным для использования в качестве значения свойства XAML напрямую.</span><span class="sxs-lookup"><span data-stu-id="b71da-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="b71da-152">При каждом предоставлении свойства, использующего XAML (особенно в том случае, если вы являетесь автором элемента управления), настоятельно рекомендуем резервировать это свойство с помощью свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="b71da-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="b71da-153">Это особенно верно, если [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] вы используете существующую реализацию процессора XAML, потому что вы можете улучшить производительность с помощью <xref:System.Windows.DependencyProperty> поддержки.</span><span class="sxs-lookup"><span data-stu-id="b71da-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="b71da-154">Свойство зависимости предоставит возможности системы свойств для данного свойства, которые пользователи ожидают от доступного в XAML свойства.</span><span class="sxs-lookup"><span data-stu-id="b71da-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="b71da-155">В число этих возможностей входят анимация, привязка данных и поддержка стилей.</span><span class="sxs-lookup"><span data-stu-id="b71da-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="b71da-156">Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="b71da-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="b71da-157">Написание и установка атрибутов преобразователя типов</span><span class="sxs-lookup"><span data-stu-id="b71da-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="b71da-158">Иногда вам нужно будет <xref:System.ComponentModel.TypeConverter> написать пользовательский класс, чтобы обеспечить преобразование типа для вашего типа свойства.</span><span class="sxs-lookup"><span data-stu-id="b71da-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="b71da-159">Для получения инструкций о том, как получить и создать преобразователь типа, <xref:System.ComponentModel.TypeConverterAttribute>который может поддерживать xAML обычаи, и как применять , см. [TypeConverters и XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="b71da-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="b71da-160">Требования к синтаксису атрибутов обработчиков событий XAML пользовательского класса</span><span class="sxs-lookup"><span data-stu-id="b71da-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="b71da-161">Чтобы быть пригодным для работы в качестве события CLR, событие должно быть выставлено как публичное событие на классе, который поддерживает беспараметрыный конструктор, или на абстрактном классе, где событие может быть доступно на производных классах.</span><span class="sxs-lookup"><span data-stu-id="b71da-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="b71da-162">Для удобного использования в качестве маршрутного события событие CLR `add` `remove` должно реализовать явные и методы, которые добавляют и удаляют обработчики для подписи события CLR и направляют эти обработчики в <xref:System.Windows.UIElement.AddHandler%2A> методы. <xref:System.Windows.UIElement.RemoveHandler%2A></span><span class="sxs-lookup"><span data-stu-id="b71da-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="b71da-163">Эти методы добавляют или удаляют обработчики из хранилища обработчиков перенаправленных событий экземпляра, к которому присоединено событие.</span><span class="sxs-lookup"><span data-stu-id="b71da-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b71da-164">Можно регистрировать обработчиков непосредственно для <xref:System.Windows.UIElement.AddHandler%2A>маршрутных событий с помощью, и намеренно не определить событие CLR, которое разоблачает маршрутизируемое событие.</span><span class="sxs-lookup"><span data-stu-id="b71da-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="b71da-165">Обычно это не рекомендуется, так как событие не включит синтаксис атрибута XAML для подключения обработчиков и результирующий класс предложит менее прозрачное представление XAML возможностей этого типа.</span><span class="sxs-lookup"><span data-stu-id="b71da-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>
## <a name="writing-collection-properties"></a><span data-ttu-id="b71da-166">Написание свойств коллекции</span><span class="sxs-lookup"><span data-stu-id="b71da-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="b71da-167">Свойства, принимающие тип коллекции, имеют синтаксис XAML, который позволяет определять объекты, добавляемые в коллекцию.</span><span class="sxs-lookup"><span data-stu-id="b71da-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="b71da-168">Этот синтаксис имеет две важные функции.</span><span class="sxs-lookup"><span data-stu-id="b71da-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="b71da-169">Объект, являющийся объектом коллекции, необязательно определять в синтаксисе объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="b71da-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="b71da-170">Присутствие этого типа коллекции подразумевается всякий раз, когда в XAML указывается свойство, принимающее тип коллекции.</span><span class="sxs-lookup"><span data-stu-id="b71da-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="b71da-171">Дочерние элементы свойства коллекции в разметке обрабатываются для того, чтобы они стали элементами коллекции.</span><span class="sxs-lookup"><span data-stu-id="b71da-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="b71da-172">Обычно доступ кода к элементам коллекции осуществляется через методы списка или словаря, такие как `Add`, или через индексатор.</span><span class="sxs-lookup"><span data-stu-id="b71da-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="b71da-173">Но синтаксис XAML не поддерживает методы или индексаторы. (Исключением является версия XAML 2009, которая поддерживает методы, но ее применение ограничивает возможные способы использования WPF. См. раздел [Возможности языка XAML 2009](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md).)</span><span class="sxs-lookup"><span data-stu-id="b71da-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="b71da-174">Коллекции, очевидно, являются очень общим требованием для построения дерева элементов, и требуется какой-нибудь способ заполнения этих коллекций в декларативном XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="b71da-175">Таким образом, дочерние элементы свойства коллекции обрабатываются путем добавления их в коллекцию, которая является значением типа свойства коллекции.</span><span class="sxs-lookup"><span data-stu-id="b71da-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="b71da-176">Реализация служб XAML в .NET Framework и, следовательно, процессор XAML WPF используют указанное ниже определение того, что составляет свойство коллекции.</span><span class="sxs-lookup"><span data-stu-id="b71da-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="b71da-177">Тип свойства должен реализовывать один из следующих интерфейсов:</span><span class="sxs-lookup"><span data-stu-id="b71da-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="b71da-178">Реализовывать объект <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="b71da-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="b71da-179">Реализации <xref:System.Collections.IDictionary> или общий<xref:System.Collections.Generic.IDictionary%602>эквивалент ( ).</span><span class="sxs-lookup"><span data-stu-id="b71da-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="b71da-180">Полученные <xref:System.Array> данные (для получения дополнительной информации о массивах в XAML, см. [x:Array Markup Extension.)](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)</span><span class="sxs-lookup"><span data-stu-id="b71da-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="b71da-181">Реализует <xref:System.Windows.Markup.IAddChild> (интерфейс, определяемый). [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]</span><span class="sxs-lookup"><span data-stu-id="b71da-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="b71da-182">Каждый из этих типов в среде CLR имеет метод `Add`, который используется процессором XAML для добавления элементов в базовую коллекцию при создании графа объекта.</span><span class="sxs-lookup"><span data-stu-id="b71da-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b71da-183">Общие `List` и `Dictionary` интерфейсы<xref:System.Collections.Generic.IList%601> <xref:System.Collections.Generic.IDictionary%602>(и ) не поддерживаются [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] для обнаружения сбора процессором XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="b71da-184">Тем не менее, <xref:System.Collections.Generic.List%601> вы можете использовать класс в <xref:System.Collections.IList> качестве <xref:System.Collections.Generic.Dictionary%602> базового класса, потому <xref:System.Collections.IDictionary> что он реализует сятворный напрямую или в качестве базового класса, потому что он реализуется напрямую.</span><span class="sxs-lookup"><span data-stu-id="b71da-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="b71da-185">При объявлении свойства, принимающего коллекцию, будьте осторожны при инициализации значения свойства в новых экземплярах типа.</span><span class="sxs-lookup"><span data-stu-id="b71da-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="b71da-186">Если свойство не реализуется как свойство зависимости, то со свойством достаточно использовать резервное поле, вызывающее конструктор типа коллекции.</span><span class="sxs-lookup"><span data-stu-id="b71da-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="b71da-187">Если свойство является свойством зависимости, то может потребоваться инициализация свойства коллекции как части конструктора типа по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="b71da-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="b71da-188">Это обусловлено тем, что свойство зависимости принимает значение по умолчанию из метаданных и обычно нежелательно, чтобы начальное значение свойства коллекции было статической общей коллекцией.</span><span class="sxs-lookup"><span data-stu-id="b71da-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="b71da-189">Экземпляр коллекции должен иметься для каждого экземпляра содержащего типа.</span><span class="sxs-lookup"><span data-stu-id="b71da-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="b71da-190">Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="b71da-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="b71da-191">Вы можете реализовать пользовательский тип коллекции для свойства коллекции.</span><span class="sxs-lookup"><span data-stu-id="b71da-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="b71da-192">Из-за неявной обработки свойств коллекции тип пользовательского сбора не должен предоставлять конструктор без параметров для того, чтобы использоваться в XAML неявно.</span><span class="sxs-lookup"><span data-stu-id="b71da-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="b71da-193">Тем не менее, можно дополнительно предоставить безпараметр конструктор для типа коллекции.</span><span class="sxs-lookup"><span data-stu-id="b71da-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="b71da-194">Это может оказаться целесообразным.</span><span class="sxs-lookup"><span data-stu-id="b71da-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="b71da-195">Если вы не предоставите конструктор без параметров, вы не можете прямо объявить коллекцию элементом объекта.</span><span class="sxs-lookup"><span data-stu-id="b71da-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="b71da-196">Некоторые разработчики разметки могут предпочесть просмотр явной коллекции в качестве стиля разметки.</span><span class="sxs-lookup"><span data-stu-id="b71da-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="b71da-197">Кроме того, без параметров конструктор может упростить требования к инициализации при создании новых объектов, которые используют тип коллекции в качестве значения свойства.</span><span class="sxs-lookup"><span data-stu-id="b71da-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="b71da-198">Объявление свойств содержимого XAML</span><span class="sxs-lookup"><span data-stu-id="b71da-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="b71da-199">Язык XAML определяет концепцию свойства содержимого [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b71da-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="b71da-200">Каждый класс, используемый в синтаксисе объекта, может иметь только одно свойство содержимого XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="b71da-201">Чтобы объявить свойство свойством содержания XAML <xref:System.Windows.Markup.ContentPropertyAttribute> для вашего класса, примените его как часть определения класса.</span><span class="sxs-lookup"><span data-stu-id="b71da-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="b71da-202">Укажите в атрибуте имя предполагаемого <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> свойства содержимого XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="b71da-203">Свойство указывается как строка по имени, а <xref:System.Reflection.PropertyInfo>не как конструкция отражения, такие как .</span><span class="sxs-lookup"><span data-stu-id="b71da-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="b71da-204">Можно определить свойство коллекции как свойство содержимого XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="b71da-205">Это отражается на использовании этого свойства, так как объектный элемент может иметь один или несколько дочерних элементов без промежуточных объектных элементов коллекции или тегов элементов свойства.</span><span class="sxs-lookup"><span data-stu-id="b71da-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="b71da-206">Эти элементы затем рассматриваются как значение для свойства содержимого XAML и добавляются к резервному экземпляру коллекции.</span><span class="sxs-lookup"><span data-stu-id="b71da-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="b71da-207">Некоторые существующие свойства содержимого XAML используют тип свойства `Object`.</span><span class="sxs-lookup"><span data-stu-id="b71da-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="b71da-208">Это позволяет свойство содержимого XAML, которое <xref:System.String> может принимать примитивные значения, такие как, а также с одним значением эталонного объекта.</span><span class="sxs-lookup"><span data-stu-id="b71da-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="b71da-209">Если следовать этой модели, то тип будет отвечать как за определение типа, так и за обработку возможных типов.</span><span class="sxs-lookup"><span data-stu-id="b71da-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="b71da-210">Типичная причина <xref:System.Object> для типа содержимого заключается в поддержке как простого средства добавления содержимого объекта в строку (которая получает обработку презентации по умолчанию), так и передовые средства добавления содержимого объекта, которое определяет непо умолчанию презентацию, так и дополнительные данные.</span><span class="sxs-lookup"><span data-stu-id="b71da-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>
## <a name="serializing-xaml"></a><span data-ttu-id="b71da-211">Сериализация XAML</span><span class="sxs-lookup"><span data-stu-id="b71da-211">Serializing XAML</span></span>  
 <span data-ttu-id="b71da-212">В некоторых сценариях (например, если вы являетесь автором элемента управления) следует убедиться в том, что любое представление объекта, которое может быть создано в XAML, также может быть сериализовано обратно в эквивалентную разметку XAML.</span><span class="sxs-lookup"><span data-stu-id="b71da-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="b71da-213">Требования к сериализации не описываются в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="b71da-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="b71da-214">См. разделы [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md) и [Дерево элементов и сериализация](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="b71da-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b71da-215">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="b71da-215">See also</span></span>

- [<span data-ttu-id="b71da-216">Обзор XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="b71da-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="b71da-217">Пользовательские свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="b71da-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="b71da-218">Общие сведения о разработке элементов управления</span><span class="sxs-lookup"><span data-stu-id="b71da-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="b71da-219">Общие сведения о базовых элементах</span><span class="sxs-lookup"><span data-stu-id="b71da-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="b71da-220">Загрузка кода XAML и свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="b71da-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
