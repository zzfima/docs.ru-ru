---
title: Код XAML и пользовательские классы для WPF
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: f6709cad76ff05c3134c8430b36d5f34019b03ca
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54606586"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="f8ecb-102">Код XAML и пользовательские классы для WPF</span><span class="sxs-lookup"><span data-stu-id="f8ecb-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="f8ecb-103">Реализация языка XAML в платформах [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] поддерживает возможность определения пользовательского класса или структуры на любом языке [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] и последующего доступа к этому классу с помощью разметки XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-103">XAML as implemented in [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] frameworks supports the ability to define a custom class or structure in any [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language, and then access that class using XAML markup.</span></span> <span data-ttu-id="f8ecb-104">В одном файле разметки можно использовать сочетание определенных в [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] типов и пользовательских типов, обычно сопоставляя пользовательские типы с префиксом пространства имен XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="f8ecb-105">В этом разделе обсуждаются требования, которым должен соответствовать пользовательский класс, чтобы его можно было использовать в качестве элемента XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  
  
 
  
<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="f8ecb-106">Пользовательские классы в приложениях или сборках</span><span class="sxs-lookup"><span data-stu-id="f8ecb-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="f8ecb-107">Пользовательские классы, используемые в XAML, можно определить двумя способами: в коде программной части или другом коде, который создает основное приложение [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], или как класс в отдельной сборке, например как исполняемый файл или библиотеку DLL, используемые в качестве библиотеки классов.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="f8ecb-108">Каждый из этих подходов имеет определенные преимущества и недостатки.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
-   <span data-ttu-id="f8ecb-109">Преимуществом создания библиотеки классов является то, что все подобные пользовательские классы могут совместно использоваться несколькими различными приложениями.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="f8ecb-110">Отдельная библиотека также облегчает управление версиями приложений и упрощает создание класса, который предполагается использовать в качестве корневого элемента на странице XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
-   <span data-ttu-id="f8ecb-111">Преимущество определения пользовательских классов в приложении состоит в том, что этот способ является относительно простым и сводит к минимуму проблемы развертывания и тестирования, возникающие при введении отдельных сборок за пределами главного исполняемого файла приложения.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
-   <span data-ttu-id="f8ecb-112">Независимо от того, определены ли пользовательские классы в одной или разных сборках, они должны быть распределены между пространством имен CLR и пространством имен XML, чтобы их можно было использовать в XAML в качестве элементов.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="f8ecb-113">См. раздел [Пространства имен XAML и сопоставление пространств имен для WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="f8ecb-114">Требования к пользовательскому классу как элементу XAML</span><span class="sxs-lookup"><span data-stu-id="f8ecb-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="f8ecb-115">Чтобы можно было создавать экземпляр класса в качестве объектного элемента, класс должен удовлетворять указанным ниже требованиям.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="f8ecb-116">Пользовательский класс должен быть открытым и должен поддерживать открытый конструктор по умолчанию (без параметров).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="f8ecb-117">(Примечания о структурах см. в следующем разделе.)</span><span class="sxs-lookup"><span data-stu-id="f8ecb-117">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="f8ecb-118">Пользовательский класс не должен быть вложенным.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="f8ecb-119">Вложенные классы и "точка" в их общем синтаксисе использования в среде CLR конфликтуют с другими функциями [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и XAML, такими как присоединенные свойства.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="f8ecb-120">В дополнение к разрешению синтаксиса объектных элементов определение объекта также разрешает синтаксис элемента свойства для всех других открытых свойств, которые принимают объект в качестве типа значения.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="f8ecb-121">Это происходит потому, что экземпляр объекта теперь может быть создан в качестве объектного элемента и может заполнить значение элемента свойства.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="f8ecb-122">Структуры</span><span class="sxs-lookup"><span data-stu-id="f8ecb-122">Structures</span></span>  
 <span data-ttu-id="f8ecb-123">Структуры, определяемые как настраиваемые типы, всегда следует создавать в XAML в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Причина заключается в том, что компиляторы [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] неявным образом создают для структуры конструктор по умолчанию, который инициализирует все свойства со значениями по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] compilers implicitly create a default constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="f8ecb-124">В некоторых случаях поведение конструктора по умолчанию или использование объектных элементов для структуры является нежелательным.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="f8ecb-125">Это возможно в тех случаях, когда структура используется для заполнения значений и функционирует в качестве объединения, в котором хранятся взаимоисключающие значения, и поэтому ни одному из свойств нельзя присвоить значение.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="f8ecb-126">Объект [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Примером такой структуры является <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="f8ecb-127">Как правило, в таких структурах необходимо реализовать преобразователь типов, чтобы значения можно было представить в виде атрибутов, используя преобразования строк для создания различных интерпретаций или режимов значений структуры.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="f8ecb-128">Структура также должна реализовывать аналогичное поведение для конструкции кода с помощью конструктора, не являющегося конструктором по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-128">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="f8ecb-129">Требования к свойствам пользовательского класса как атрибутам XAML</span><span class="sxs-lookup"><span data-stu-id="f8ecb-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="f8ecb-130">Свойства должны ссылаться на тип, передаваемый по значению (такой как примитив), или использовать класс для типа, имеющего конструктор по умолчанию или преобразователь выделенного типа, к которому может получить доступ процессор XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a default constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="f8ecb-131">В реализации XAML среды CLR процессоры XAML находят такие преобразователи с помощью собственной поддержки примитивов языка либо путем применения <xref:System.ComponentModel.TypeConverterAttribute> для типа или члена в определениях резервных типов.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="f8ecb-132">Помимо этого, свойство может ссылаться на абстрактный тип класса или интерфейс.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="f8ecb-133">Для абстрактных классов или интерфейсов ожидаемый результат синтаксического анализа XAML заключается в том, что значение свойства должно быть заполнено практическими экземплярами класса, которые реализуют интерфейс, или экземплярами типов, которые являются производными от абстрактного класса.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="f8ecb-134">Свойства могут объявляться в абстрактном классе, но могут быть заданы только в практических классах, производных от абстрактных классов.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="f8ecb-135">Это объясняется тем, что для создания объектного элемента для класса в целом требуется открытый конструктор по умолчанию в классе.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-135">This is because creating the object element for the class at all requires a public default constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="f8ecb-136">Синтаксис атрибута с поддержкой TypeConverter</span><span class="sxs-lookup"><span data-stu-id="f8ecb-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="f8ecb-137">Если поддерживается выделенный преобразователь типов атрибутов на уровне класса, то применяемый тип преобразования включает синтаксис атрибута для любого свойства, для которого необходимо создать экземпляр этого типа.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="f8ecb-138">Преобразователь типа не включает использование объектного элемента типа — только наличие конструктора по умолчанию для данного типа разрешает использование объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-138">A type converter does not enable object element usage of the type; only the presence of a default constructor for that type enables object element usage.</span></span> <span data-ttu-id="f8ecb-139">Таким образом, свойства, разрешенные преобразователем типов, обычно не используются в синтаксисе свойств, если только сам тип не поддерживает синтаксис объектных элементов.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="f8ecb-140">Исключением из этого является указание синтаксиса элемента свойства при наличии элемента свойства, содержащего строку.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="f8ecb-141">Это использование действительно фактически эквивалентна использованию синтаксиса атрибута и такое использование не часто, если не существует потребность в более надежную обработку пробела значение атрибута.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="f8ecb-142">Например, ниже показано использование элемента свойства, который принимает строку, а использование атрибута эквивалентно.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="f8ecb-143">Примерами свойств, где синтаксис атрибута разрешен, но синтаксис элемента свойства, содержащего объектный элемент, запрещен XAML являются различные свойства, принимающие <xref:System.Windows.Input.Cursor> типа.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="f8ecb-144"><xref:System.Windows.Input.Cursor> Класс имеет выделенный преобразователь типа <xref:System.Windows.Input.CursorConverter>, но не предоставляет конструктор по умолчанию, поэтому <xref:System.Windows.FrameworkElement.Cursor%2A> свойство может устанавливаться только через синтаксис атрибута, даже если фактический <xref:System.Windows.Input.Cursor> тип является ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a default constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="f8ecb-145">Преобразователь типа каждого свойства</span><span class="sxs-lookup"><span data-stu-id="f8ecb-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="f8ecb-146">В качестве альтернативы само свойство может объявлять преобразователь типов на уровне свойств.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="f8ecb-147">Это позволяет «мини-язык», который создает объекты типа встроенного свойства путем обработки входящих строковых значений атрибута в качестве входных данных для <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> операции на основе соответствующего типа.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="f8ecb-148">Обычно это делается для предоставления удобного метода доступа, а не как единственное средство для задания свойства в XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="f8ecb-149">Кроме того, можно также применять преобразователь типов для атрибутов, если необходимо использовать существующие типы [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], которые не предоставляют конструктор по умолчанию или преобразователь типов атрибутов.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-149">However, it is also possible to use type converters for attributes where you want to use existing [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] types that do not supply either a default constructor or an attributed type converter.</span></span> <span data-ttu-id="f8ecb-150">Примеры из [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API являются некоторые свойства, которые принимают <xref:System.Globalization.CultureInfo> типа.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="f8ecb-151">В этом случае [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] используется текущей платформы Microsoft .NET Framework <xref:System.Globalization.CultureInfo> тип для лучшей совместимости и сценариев миграции, которые использовались в предыдущих версиях платформ, но <xref:System.Globalization.CultureInfo> тип не поддерживает необходимые конструкторы или преобразование типов на уровне типа, чтобы использоваться в качестве значения свойства XAML напрямую.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="f8ecb-152">При каждом предоставлении свойства, использующего XAML (особенно в том случае, если вы являетесь автором элемента управления), настоятельно рекомендуем резервировать это свойство с помощью свойства зависимости.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="f8ecb-153">Это особенно верно в случае, если используется существующая [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] реализация обработчика XAML, так как можно повысить производительность с помощью <xref:System.Windows.DependencyProperty> резервного.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="f8ecb-154">Свойство зависимости предоставит возможности системы свойств для данного свойства, которые пользователи ожидают от доступного в XAML свойства.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="f8ecb-155">В число этих возможностей входят анимация, привязка данных и поддержка стилей.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="f8ecb-156">Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) и [Загрузка кода XAML и свойства зависимостей](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-156">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) and [XAML Loading and Dependency Properties](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="f8ecb-157">Написание и установка атрибутов преобразователя типов</span><span class="sxs-lookup"><span data-stu-id="f8ecb-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="f8ecb-158">Иногда нужно будет написать собственный <xref:System.ComponentModel.TypeConverter> производного класса, чтобы предоставить преобразование для типа свойства.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="f8ecb-159">Инструкции по наследованию и созданию преобразователя типов, поддерживающего использование XAML, и способах применения <xref:System.ComponentModel.TypeConverterAttribute>, см. в разделе [TypeConverters и XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="f8ecb-160">Требования к синтаксису атрибутов обработчиков событий XAML пользовательского класса</span><span class="sxs-lookup"><span data-stu-id="f8ecb-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="f8ecb-161">Чтобы событие можно было использовать в качестве события [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)], оно должно быть предоставлено в качестве открытого события класса, поддерживающего конструктор по умолчанию, или абстрактного класса, где событие может быть доступно в производных классах.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-161">To be usable as a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, the event must be exposed as a public event on a class that supports a default constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="f8ecb-162">Чтобы использоваться как перенаправленное событие, ваш [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] событие должно явным образом реализовывать `add` и `remove` методы, которые добавляют и удаляют обработчики для [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] сигнатуры события и направляют эти обработчики в <xref:System.Windows.UIElement.AddHandler%2A>и <xref:System.Windows.UIElement.RemoveHandler%2A> методы.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-162">In order to be used conveniently as a routed event, your [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event should implement explicit `add` and `remove` methods, which add and remove handlers for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="f8ecb-163">Эти методы добавляют или удаляют обработчики из хранилища обработчиков перенаправленных событий экземпляра, к которому присоединено событие.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f8ecb-164">Можно регистрировать обработчики непосредственно для перенаправленных событий с помощью <xref:System.Windows.UIElement.AddHandler%2A>и намеренно не определять [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] событие, которое предоставляет перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that exposes the routed event.</span></span> <span data-ttu-id="f8ecb-165">Обычно это не рекомендуется, так как событие не включит синтаксис атрибута XAML для подключения обработчиков и результирующий класс предложит менее прозрачное представление XAML возможностей этого типа.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="f8ecb-166">Написание свойств коллекции</span><span class="sxs-lookup"><span data-stu-id="f8ecb-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="f8ecb-167">Свойства, принимающие тип коллекции, имеют синтаксис XAML, который позволяет определять объекты, добавляемые в коллекцию.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="f8ecb-168">Этот синтаксис имеет две важные функции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-168">This syntax has two notable features.</span></span>  
  
-   <span data-ttu-id="f8ecb-169">Объект, являющийся объектом коллекции, необязательно определять в синтаксисе объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="f8ecb-170">Присутствие этого типа коллекции подразумевается всякий раз, когда в XAML указывается свойство, принимающее тип коллекции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
-   <span data-ttu-id="f8ecb-171">Дочерние элементы свойства коллекции в разметке обрабатываются для того, чтобы они стали элементами коллекции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="f8ecb-172">Обычно доступ кода к элементам коллекции осуществляется через методы списка или словаря, такие как `Add`, или через индексатор.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="f8ecb-173">Но синтаксис XAML не поддерживает методы или индексаторы (исключение: XAML 2009 может поддерживать методы, но с помощью XAML 2009 ограничивает возможные способы использования WPF; см. в разделе [возможности языка XAML 2009](../../../../docs/framework/xaml-services/xaml-2009-language-features.md)).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../../docs/framework/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="f8ecb-174">Коллекции, очевидно, являются очень общим требованием для построения дерева элементов, и требуется какой-нибудь способ заполнения этих коллекций в декларативном XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="f8ecb-175">Таким образом, дочерние элементы свойства коллекции обрабатываются путем добавления их в коллекцию, которая является значением типа свойства коллекции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="f8ecb-176">Реализация служб XAML в .NET Framework и, следовательно, процессор XAML WPF используют указанное ниже определение того, что составляет свойство коллекции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="f8ecb-177">Тип свойства должен реализовывать один из следующих интерфейсов:</span><span class="sxs-lookup"><span data-stu-id="f8ecb-177">The property type of the property must implement one of the following:</span></span>  
  
-   <span data-ttu-id="f8ecb-178">Реализует <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-178">Implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="f8ecb-179">Реализует <xref:System.Collections.IDictionary> или универсальный эквивалент (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
-   <span data-ttu-id="f8ecb-180">Является производным от <xref:System.Array> (Дополнительные сведения о массивах в XAML см. в разделе [расширение разметки x: Array](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="f8ecb-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span></span>  
  
-   <span data-ttu-id="f8ecb-181">Реализует <xref:System.Windows.Markup.IAddChild> (интерфейс определяется [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="f8ecb-182">Каждый из этих типов в среде CLR имеет метод `Add`, который используется процессором XAML для добавления элементов в базовую коллекцию при создании графа объекта.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f8ecb-183">Универсальный `List` и `Dictionary` интерфейсы (<xref:System.Collections.Generic.IList%601> и <xref:System.Collections.Generic.IDictionary%602>) не поддерживаются при обнаружении коллекций [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] процессор XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="f8ecb-184">Тем не менее, можно использовать <xref:System.Collections.Generic.List%601> класса в качестве базового класса, так как он реализует <xref:System.Collections.IList> напрямую, или <xref:System.Collections.Generic.Dictionary%602> как базовый класс, так как он реализует <xref:System.Collections.IDictionary> напрямую.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="f8ecb-185">При объявлении свойства, принимающего коллекцию, будьте осторожны при инициализации значения свойства в новых экземплярах типа.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="f8ecb-186">Если свойство не реализуется как свойство зависимости, то со свойством достаточно использовать резервное поле, вызывающее конструктор типа коллекции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="f8ecb-187">Если свойство является свойством зависимости, то может потребоваться инициализация свойства коллекции как части конструктора типа по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="f8ecb-188">Это обусловлено тем, что свойство зависимости принимает значение по умолчанию из метаданных и обычно нежелательно, чтобы начальное значение свойства коллекции было статической общей коллекцией.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="f8ecb-189">Экземпляр коллекции должен иметься для каждого экземпляра содержащего типа.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="f8ecb-190">Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-190">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="f8ecb-191">Вы можете реализовать пользовательский тип коллекции для свойства коллекции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="f8ecb-192">Из-за неявной обработки свойства коллекции пользовательскому типу коллекции не требуется предоставлять конструктор по умолчанию, который будет использоваться в XAML неявно.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-192">Because of implicit collection property treatment, the custom collection type does not need to provide a default constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="f8ecb-193">Однако при необходимости можно предоставить конструктор по умолчанию для типа коллекции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-193">However, you can optionally provide a default constructor for the collection type.</span></span> <span data-ttu-id="f8ecb-194">Это может оказаться целесообразным.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="f8ecb-195">Если не предоставить конструктор по умолчанию, невозможно будет явно объявить коллекцию в качестве объектного элемента.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-195">Unless you do provide a default constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="f8ecb-196">Некоторые разработчики разметки могут предпочесть просмотр явной коллекции в качестве стиля разметки.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="f8ecb-197">Кроме того, конструктор по умолчанию может уменьшить требования к инициализации при создании объектов, использующих тип коллекций в качестве значения свойства.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-197">Also, a default constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="f8ecb-198">Объявление свойств содержимого XAML</span><span class="sxs-lookup"><span data-stu-id="f8ecb-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="f8ecb-199">Язык XAML определяет концепцию свойства содержимого [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="f8ecb-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="f8ecb-200">Каждый класс, используемый в синтаксисе объекта, может иметь только одно свойство содержимого XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="f8ecb-201">Чтобы объявить свойство в качестве свойства содержимого XAML для класса, примените <xref:System.Windows.Markup.ContentPropertyAttribute> как часть определения класса.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="f8ecb-202">Укажите имя предполагаемого свойства содержимого XAML как <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> в атрибуте.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="f8ecb-203">Свойство задается как строка по имени, не как конструкция отражения таких как <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="f8ecb-204">Можно определить свойство коллекции как свойство содержимого XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="f8ecb-205">Это отражается на использовании этого свойства, так как объектный элемент может иметь один или несколько дочерних элементов без промежуточных объектных элементов коллекции или тегов элементов свойства.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="f8ecb-206">Эти элементы затем рассматриваются как значение для свойства содержимого XAML и добавляются к резервному экземпляру коллекции.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="f8ecb-207">Некоторые существующие свойства содержимого XAML используют тип свойства `Object`.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="f8ecb-208">Это позволяет XAML, содержимого, свойство, которое может принимать как простые значения, такие как <xref:System.String> так и значение ссылки на объект.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="f8ecb-209">Если следовать этой модели, то тип будет отвечать как за определение типа, так и за обработку возможных типов.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="f8ecb-210">Типичной причиной <xref:System.Object> содержимого типа является поддержка как простых средств добавления содержимого объекта в виде строки (которая получает обработку представления по умолчанию) или улучшенных средств для добавления содержимого объекта, который задает нестандартное представление или Дополнительные данные.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="f8ecb-211">Сериализация XAML</span><span class="sxs-lookup"><span data-stu-id="f8ecb-211">Serializing XAML</span></span>  
 <span data-ttu-id="f8ecb-212">В некоторых сценариях (например, если вы являетесь автором элемента управления) следует убедиться в том, что любое представление объекта, которое может быть создано в XAML, также может быть сериализовано обратно в эквивалентную разметку XAML.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="f8ecb-213">Требования к сериализации не описываются в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="f8ecb-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="f8ecb-214">См. разделы [Общие сведения о разработке элементов управления](../../../../docs/framework/wpf/controls/control-authoring-overview.md) и [Дерево элементов и сериализация](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="f8ecb-214">See [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md) and [Element Tree and Serialization](../../../../docs/framework/wpf/advanced/element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f8ecb-215">См. также</span><span class="sxs-lookup"><span data-stu-id="f8ecb-215">See also</span></span>
- [<span data-ttu-id="f8ecb-216">Общие сведения о языке XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="f8ecb-216">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)
- [<span data-ttu-id="f8ecb-217">Пользовательские свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="f8ecb-217">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)
- [<span data-ttu-id="f8ecb-218">Общие сведения о разработке элементов управления</span><span class="sxs-lookup"><span data-stu-id="f8ecb-218">Control Authoring Overview</span></span>](../../../../docs/framework/wpf/controls/control-authoring-overview.md)
- [<span data-ttu-id="f8ecb-219">Общие сведения о базовых элементах</span><span class="sxs-lookup"><span data-stu-id="f8ecb-219">Base Elements Overview</span></span>](../../../../docs/framework/wpf/advanced/base-elements-overview.md)
- [<span data-ttu-id="f8ecb-220">Загрузка кода XAML и свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="f8ecb-220">XAML Loading and Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/xaml-loading-and-dependency-properties.md)
