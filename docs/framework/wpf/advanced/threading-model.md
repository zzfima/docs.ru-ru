---
title: "Модель потоков"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
caps.latest.revision: "33"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: f0badceeb9ce085dc68fce2c59ec6c42877f2622
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/22/2017
---
# <a name="threading-model"></a><span data-ttu-id="5a624-102">Модель потоков</span><span class="sxs-lookup"><span data-stu-id="5a624-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="5a624-103"> призвана помочь разработчикам избежать трудностей при разработке потоков.</span><span class="sxs-lookup"><span data-stu-id="5a624-103"> is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="5a624-104">Таким образом, большинство [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] разработчикам не требуется писать интерфейс, использующий более одного потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="5a624-105">Поскольку многопотоковые программы являются сложными и трудно отлаживаемыми, их следует избегать, если существуют однопоточные решения.</span><span class="sxs-lookup"><span data-stu-id="5a624-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="5a624-106">Независимо от того, насколько хорошо разработана, однако нет [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework никогда не сможете предоставить однопоточное решение для каждого типа задач.</span><span class="sxs-lookup"><span data-stu-id="5a624-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="5a624-107">поставляется закрыть, но по-прежнему существуют ситуации, когда несколько потоков улучшают [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] скорость реагирования или производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="5a624-107"> comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="5a624-108">После рассмотрения некоторых основных материалов в данном документе рассматриваются подобные ситуации и в завершение обсуждаются некоторые более подробные сведения.</span><span class="sxs-lookup"><span data-stu-id="5a624-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  
  

  
> [!NOTE]
>  <span data-ttu-id="5a624-109">В этом разделе обсуждаются потоки с помощью <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> метод асинхронных вызовов.</span><span class="sxs-lookup"><span data-stu-id="5a624-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="5a624-110">Вы также можете асинхронных вызовов, вызвав <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> метод, который будет принимать <xref:System.Action> или <xref:System.Func%601> как параметр.</span><span class="sxs-lookup"><span data-stu-id="5a624-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="5a624-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> Возвращает <xref:System.Windows.Threading.DispatcherOperation> или <xref:System.Windows.Threading.DispatcherOperation%601>, который имеет <xref:System.Windows.Threading.DispatcherOperation.Task%2A> свойства.</span><span class="sxs-lookup"><span data-stu-id="5a624-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="5a624-112">Можно использовать `await` ключевого слова with либо <xref:System.Windows.Threading.DispatcherOperation> или связанного <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="5a624-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="5a624-113">Если необходимо подождать синхронно <xref:System.Threading.Tasks.Task> , возвращаемый <xref:System.Windows.Threading.DispatcherOperation> или <xref:System.Windows.Threading.DispatcherOperation%601>, вызовите <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> метода расширения.</span><span class="sxs-lookup"><span data-stu-id="5a624-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="5a624-114">Вызов <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> приведет к взаимоблокировке.</span><span class="sxs-lookup"><span data-stu-id="5a624-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="5a624-115">Дополнительные сведения об использовании <xref:System.Threading.Tasks.Task> для выполнения асинхронных операций, в разделе параллелизм задач.</span><span class="sxs-lookup"><span data-stu-id="5a624-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="5a624-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> Метод также имеет перегрузки, использующие <xref:System.Action> или <xref:System.Func%601> как параметр.</span><span class="sxs-lookup"><span data-stu-id="5a624-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="5a624-117">Можно использовать <xref:System.Windows.Threading.Dispatcher.Invoke%2A> вызывает метод, чтобы сделать синхронный путем передачи делегата, <xref:System.Action> или <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="5a624-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="5a624-118">Общие сведения и Dispatcher</span><span class="sxs-lookup"><span data-stu-id="5a624-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="5a624-119">Как правило [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложения запускаются с двумя потоками: один для обработки отрисовки и другой — для управления [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5a624-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="5a624-120">Поток отрисовки эффективно выполняется скрыто в фоновом режиме при [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток получает входные данные, обрабатывает события, выводит изображение на экран и выполняет код приложения.</span><span class="sxs-lookup"><span data-stu-id="5a624-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="5a624-121">Большинство приложений используют один [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток, несмотря на то, что в некоторых ситуациях лучше использовать несколько.</span><span class="sxs-lookup"><span data-stu-id="5a624-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="5a624-122">Позже это будет рассмотрено на примере.</span><span class="sxs-lookup"><span data-stu-id="5a624-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="5a624-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Поток очереди рабочих элементов внутри объекта, называемого <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5a624-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="5a624-124">Объект <xref:System.Windows.Threading.Dispatcher> выбирает рабочие элементы на основе приоритетов и выполняет каждый из них до завершения.</span><span class="sxs-lookup"><span data-stu-id="5a624-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="5a624-125">Каждый [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток должен иметь по крайней мере один <xref:System.Windows.Threading.Dispatcher>и каждая <xref:System.Windows.Threading.Dispatcher> может выполнять рабочие элементы только в одном потоке.</span><span class="sxs-lookup"><span data-stu-id="5a624-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="5a624-126">Условием для построения быстро реагирующих, понятных приложений является максимальное повышение <xref:System.Windows.Threading.Dispatcher> пропускную способность за счет небольших рабочих элементов.</span><span class="sxs-lookup"><span data-stu-id="5a624-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="5a624-127">Этот способ элементы никогда не устаревают <xref:System.Windows.Threading.Dispatcher> очереди, ожидающих обработки.</span><span class="sxs-lookup"><span data-stu-id="5a624-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="5a624-128">Любая задержка между входными данными и ответами может разочаровать пользователя.</span><span class="sxs-lookup"><span data-stu-id="5a624-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="5a624-129">Как в таком случае [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложения должны обрабатывать большие операции?</span><span class="sxs-lookup"><span data-stu-id="5a624-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="5a624-130">Что если код включает большие вычисления или требуется запрос к базе данных на удаленном сервере?</span><span class="sxs-lookup"><span data-stu-id="5a624-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="5a624-131">Как правило, ответ-большие операции в отдельном потоке, оставляя [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток для обслуживания элементов в <xref:System.Windows.Threading.Dispatcher> очереди.</span><span class="sxs-lookup"><span data-stu-id="5a624-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="5a624-132">После завершения большой операции, она может передать результат обратно [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток для отображения.</span><span class="sxs-lookup"><span data-stu-id="5a624-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="5a624-133">Исторически [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] позволяет [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] элементов, доступная только для потока, который создал их.</span><span class="sxs-lookup"><span data-stu-id="5a624-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="5a624-134">Это означает, что фоновый поток, отвечающий за некоторую длительную задачу, не может обновить текстовое поле при своем завершении.</span><span class="sxs-lookup"><span data-stu-id="5a624-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="5a624-135">Это делается, чтобы обеспечить целостность [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] компонентов.</span><span class="sxs-lookup"><span data-stu-id="5a624-135"> does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="5a624-136">Список может выглядеть странно, если его содержимое обновляется фоновым потоком в процессе отображения.</span><span class="sxs-lookup"><span data-stu-id="5a624-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="5a624-137"> имеет встроенный механизм взаимного исключения, который осуществляет эту координацию.</span><span class="sxs-lookup"><span data-stu-id="5a624-137"> has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="5a624-138">Большинство классов в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] являются производными от <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="5a624-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="5a624-139">При создании <xref:System.Windows.Threading.DispatcherObject> хранит ссылку на <xref:System.Windows.Threading.Dispatcher> связанный с текущим выполняемым потоком.</span><span class="sxs-lookup"><span data-stu-id="5a624-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="5a624-140">В результате <xref:System.Windows.Threading.DispatcherObject> связывается с потоком, который его создал.</span><span class="sxs-lookup"><span data-stu-id="5a624-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="5a624-141">Во время выполнения программы <xref:System.Windows.Threading.DispatcherObject> может вызвать свой открытый <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="5a624-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="5a624-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>проверяет <xref:System.Windows.Threading.Dispatcher> связанный с текущим потоком и сравнивает его <xref:System.Windows.Threading.Dispatcher> сохраняется во время создания ссылки.</span><span class="sxs-lookup"><span data-stu-id="5a624-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="5a624-143">Если они не совпадают, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> приводит к возникновению исключения.</span><span class="sxs-lookup"><span data-stu-id="5a624-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="5a624-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>предназначен для вызова в начале каждого метода, принадлежащего к <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="5a624-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="5a624-145">Если только один поток может изменить [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], как фоновые потоки взаимодействуют с пользователем?</span><span class="sxs-lookup"><span data-stu-id="5a624-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="5a624-146">Фоновый поток может запросить [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток, чтобы выполнять операции от его имени.</span><span class="sxs-lookup"><span data-stu-id="5a624-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="5a624-147">Это делается путем регистрации рабочего элемента с <xref:System.Windows.Threading.Dispatcher> из [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-148"><xref:System.Windows.Threading.Dispatcher> Класс предоставляет два метода для регистрации рабочих элементов: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> и <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="5a624-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="5a624-149">Оба метода назначают делегат для выполнения.</span><span class="sxs-lookup"><span data-stu-id="5a624-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="5a624-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>синхронный вызов — то есть, он не возвращает до [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока не закончит выполнение делегата.</span><span class="sxs-lookup"><span data-stu-id="5a624-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="5a624-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>является асинхронным и немедленно возвращается.</span><span class="sxs-lookup"><span data-stu-id="5a624-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="5a624-152"><xref:System.Windows.Threading.Dispatcher> Упорядочивает элементы в своей очереди по приоритету.</span><span class="sxs-lookup"><span data-stu-id="5a624-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="5a624-153">Существуют десять уровней, которые могут быть указаны при добавлении элемента к <xref:System.Windows.Threading.Dispatcher> очереди.</span><span class="sxs-lookup"><span data-stu-id="5a624-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="5a624-154">Эти приоритеты сохраняются в <xref:System.Windows.Threading.DispatcherPriority> перечисления.</span><span class="sxs-lookup"><span data-stu-id="5a624-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="5a624-155">Подробные сведения о <xref:System.Windows.Threading.DispatcherPriority> уровней можно найти в [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] документации.</span><span class="sxs-lookup"><span data-stu-id="5a624-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="5a624-156">Потоки в действии: примеры</span><span class="sxs-lookup"><span data-stu-id="5a624-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="5a624-157">Пример однопоточного приложения с длительным выполнением вычислений</span><span class="sxs-lookup"><span data-stu-id="5a624-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="5a624-158">Большинство [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] проводят большую часть своего времени простоя при ожидании события, создаваемые в ответ на взаимодействие с пользователем.</span><span class="sxs-lookup"><span data-stu-id="5a624-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="5a624-159">С помощью тщательного программирования это время простоя можно использовать конструктивно, не влияя на время отклика [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5a624-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="5a624-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Потоковая модель не допускает входные данные прервать операцию, которая происходит в [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-161">Это означает, что необходимо убедиться, чтобы вернуться к <xref:System.Windows.Threading.Dispatcher> периодически к процессу отложенные события ввода, прежде чем они станут устаревшими.</span><span class="sxs-lookup"><span data-stu-id="5a624-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="5a624-162">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="5a624-162">Consider the following example:</span></span>  
  
 <span data-ttu-id="5a624-163">![Снимок экрана приложения Prime numbers](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span><span class="sxs-lookup"><span data-stu-id="5a624-163">![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span></span>  
  
 <span data-ttu-id="5a624-164">Это простое приложение ищет простые числа, начиная от трех и далее.</span><span class="sxs-lookup"><span data-stu-id="5a624-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="5a624-165">Когда пользователь щелкает **запустить** кнопки, поиск начинается.</span><span class="sxs-lookup"><span data-stu-id="5a624-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="5a624-166">Когда программа находит простое число, она обновляет пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="5a624-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="5a624-167">В любой момент пользователь может остановить поиск.</span><span class="sxs-lookup"><span data-stu-id="5a624-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="5a624-168">При всей простоте операции поиск простых чисел может происходить бесконечно, что представляет некоторые трудности.</span><span class="sxs-lookup"><span data-stu-id="5a624-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="5a624-169">Если бы обработка всего поиска внутри обработчик события нажатия кнопки, никогда бы не получил [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потоков возможность для обработки других событий.</span><span class="sxs-lookup"><span data-stu-id="5a624-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="5a624-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Сможет отвечать на входные данные или обработать сообщения.</span><span class="sxs-lookup"><span data-stu-id="5a624-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="5a624-171">Он бы никогда не обновил отображение и не ответил бы на нажатие кнопки.</span><span class="sxs-lookup"><span data-stu-id="5a624-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="5a624-172">Можно провести поиск простого числа в отдельном потоке, но тогда пришлось бы иметь дело с проблемами синхронизации.</span><span class="sxs-lookup"><span data-stu-id="5a624-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="5a624-173">С помощью однопотокового подхода можно непосредственно обновить подпись, в которой перечислено наибольшее простое число.</span><span class="sxs-lookup"><span data-stu-id="5a624-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="5a624-174">Если разбить задачу вычисления на управляемые фрагменты, можно периодически возвращаться к <xref:System.Windows.Threading.Dispatcher> и обработки событий.</span><span class="sxs-lookup"><span data-stu-id="5a624-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="5a624-175">Можно дать [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] возможность обновлять и обрабатывать входные данные.</span><span class="sxs-lookup"><span data-stu-id="5a624-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="5a624-176">Лучшим способом разбиения времени обработки между вычислением и обработкой события является управление вычислением из <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5a624-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="5a624-177">С помощью <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> метод, можно запланировать проверку простого числа в той же очереди, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] , являются производными от события.</span><span class="sxs-lookup"><span data-stu-id="5a624-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="5a624-178">В приведенном примере запланирована проверка только одного простого числа в каждый момент времени.</span><span class="sxs-lookup"><span data-stu-id="5a624-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="5a624-179">После завершения проверки простого числа немедленно планируется следующая проверка.</span><span class="sxs-lookup"><span data-stu-id="5a624-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="5a624-180">Эта проверка выполняется только после ожидающих [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] обработки событий.</span><span class="sxs-lookup"><span data-stu-id="5a624-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 <span data-ttu-id="5a624-181">![Иллюстрация очереди диспетчера](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span><span class="sxs-lookup"><span data-stu-id="5a624-181">![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span></span>  
  
 <span data-ttu-id="5a624-182">С помощью этого механизма приложение [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)] выполняет проверку орфографии.</span><span class="sxs-lookup"><span data-stu-id="5a624-182">[!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)] accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="5a624-183">Проверка орфографии выполняется в фоновом режиме, используя время простоя [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-184">Давайте посмотрим на код.</span><span class="sxs-lookup"><span data-stu-id="5a624-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="5a624-185">В следующем примере показан код XAML, который создает пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="5a624-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="5a624-186">В следующем примере показан код программной части.</span><span class="sxs-lookup"><span data-stu-id="5a624-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="5a624-187">В примере показан обработчик событий для <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="5a624-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="5a624-188">Помимо обновления текста на <xref:System.Windows.Controls.Button>, этот обработчик отвечает за планирование проверки первого простого числа путем добавления делегата <xref:System.Windows.Threading.Dispatcher> очереди.</span><span class="sxs-lookup"><span data-stu-id="5a624-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="5a624-189">Иногда после завершения работы, этот обработчик событий <xref:System.Windows.Threading.Dispatcher> выберет этот делегат для выполнения.</span><span class="sxs-lookup"><span data-stu-id="5a624-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="5a624-190">Как упоминалось ранее, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> — <xref:System.Windows.Threading.Dispatcher> члена, используемые для планирования делегат для выполнения.</span><span class="sxs-lookup"><span data-stu-id="5a624-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="5a624-191">В этом случае мы выбираем <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> приоритет.</span><span class="sxs-lookup"><span data-stu-id="5a624-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="5a624-192"><xref:System.Windows.Threading.Dispatcher> Этот делегат будет выполняться, только в том случае, если нет важных событий для обработки.</span><span class="sxs-lookup"><span data-stu-id="5a624-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> <span data-ttu-id="5a624-193">Быстродействие [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] представляет большую важность, чем проверка числа.</span><span class="sxs-lookup"><span data-stu-id="5a624-193">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking.</span></span> <span data-ttu-id="5a624-194">Также передается новый делегат, представляющий подпрограмму проверки числа.</span><span class="sxs-lookup"><span data-stu-id="5a624-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="5a624-195">Этот метод проверяет, является ли следующее нечетное число простым.</span><span class="sxs-lookup"><span data-stu-id="5a624-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="5a624-196">Если оно простое, метод непосредственно обновляет `bigPrime` <xref:System.Windows.Controls.TextBlock> в соответствии с его обнаружения.</span><span class="sxs-lookup"><span data-stu-id="5a624-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="5a624-197">Мы можем сделать так потому, что вычисление происходит в том же потоке, который был использован для создания компонента.</span><span class="sxs-lookup"><span data-stu-id="5a624-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="5a624-198">Бы мы решили использовать отдельный поток для вычислений, нам пришлось бы использовать более сложный механизм синхронизации и выполнять обновления в [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-199">Эта ситуация будет продемонстрирована далее.</span><span class="sxs-lookup"><span data-stu-id="5a624-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="5a624-200">Полный исходный код для этого примера см. в разделе [однопотокового приложения с образцом длительных вычислений](http://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="5a624-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="5a624-201">Обработка блокирующей операции с фоновым потоком</span><span class="sxs-lookup"><span data-stu-id="5a624-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="5a624-202">Обработка блокировки операций в графическом приложении может оказаться трудной задачей.</span><span class="sxs-lookup"><span data-stu-id="5a624-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="5a624-203">Мы не будем вызывать методы блокировки из обработчиков событий, так как приложение будет остановлено.</span><span class="sxs-lookup"><span data-stu-id="5a624-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="5a624-204">Можно использовать отдельный поток для обработки этих операций, но Готово, нам нужно синхронизировать с [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потоков, поскольку нельзя изменить непосредственно [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] из рабочего потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="5a624-205">Мы используем <xref:System.Windows.Threading.Dispatcher.Invoke%2A> или <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> вставку делегатов в <xref:System.Windows.Threading.Dispatcher> из [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-206">Со временем эти делегаты будут выполнены с разрешением на изменение [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] элементов.</span><span class="sxs-lookup"><span data-stu-id="5a624-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="5a624-207">В этом примере мы имитируем вызов удаленной процедуры, который получает прогноз погоды.</span><span class="sxs-lookup"><span data-stu-id="5a624-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="5a624-208">Мы используем отдельный рабочий поток для выполнения этого вызова и планируем метод обновления в <xref:System.Windows.Threading.Dispatcher> из [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потоков при завершении.</span><span class="sxs-lookup"><span data-stu-id="5a624-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 <span data-ttu-id="5a624-209">![Снимок экрана пользовательского интерфейса Weather](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span><span class="sxs-lookup"><span data-stu-id="5a624-209">![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span></span>  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="5a624-210">Ниже приведены некоторые подробности, на которые следует обратить внимание.</span><span class="sxs-lookup"><span data-stu-id="5a624-210">The following are some of the details to be noted.</span></span>  
  
-   <span data-ttu-id="5a624-211">Создание обработчика кнопки</span><span class="sxs-lookup"><span data-stu-id="5a624-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="5a624-212">При нажатии кнопки мы отображаем рисунок часов и запускаем анимацию.</span><span class="sxs-lookup"><span data-stu-id="5a624-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="5a624-213">Мы отключаем кнопку.</span><span class="sxs-lookup"><span data-stu-id="5a624-213">We disable the button.</span></span> <span data-ttu-id="5a624-214">Мы вызвать `FetchWeatherFromServer` метод в новом потоке, а затем мы возвращаем, позволяя <xref:System.Windows.Threading.Dispatcher> для обработки событий во время ожидания сбора прогноза погоды.</span><span class="sxs-lookup"><span data-stu-id="5a624-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
-   <span data-ttu-id="5a624-215">Выборка погоды</span><span class="sxs-lookup"><span data-stu-id="5a624-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="5a624-216">Для простоты мы фактически не используем никакого сетевого кода в данном примере.</span><span class="sxs-lookup"><span data-stu-id="5a624-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="5a624-217">Вместо этого мы моделируем задержку доступа к сети, задав для нашего нового потока спящий режим в течение четырех секунд.</span><span class="sxs-lookup"><span data-stu-id="5a624-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="5a624-218">В настоящее время исходного [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потоков по-прежнему работает и реагирование на события.</span><span class="sxs-lookup"><span data-stu-id="5a624-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="5a624-219">Чтобы показать это, была оставлена запущенная анимация, и кнопки свертывания и развертывания также продолжают работать.</span><span class="sxs-lookup"><span data-stu-id="5a624-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="5a624-220">После завершения задержки и случайного выбора прогноза погоды, пора обращаться к [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-221">Это делается путем создания расписания вызов `UpdateUserInterface` в [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока с помощью этого потока <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5a624-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="5a624-222">В запланированный вызов этого метода передается строка, описывающая погоду.</span><span class="sxs-lookup"><span data-stu-id="5a624-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
-   <span data-ttu-id="5a624-223">Обновление[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="5a624-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="5a624-224">Когда <xref:System.Windows.Threading.Dispatcher> в [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток имеет время, он выполняет запланированный вызов метода `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="5a624-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="5a624-225">Этот метод останавливает анимацию часов и выбирает изображение для описания погоды.</span><span class="sxs-lookup"><span data-stu-id="5a624-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="5a624-226">Он отображает это изображение и восстанавливает кнопку "Получить прогноз погоды".</span><span class="sxs-lookup"><span data-stu-id="5a624-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="5a624-227">Несколько окон, несколько потоков</span><span class="sxs-lookup"><span data-stu-id="5a624-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="5a624-228">Некоторые [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложения требуют нескольких окон верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="5a624-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="5a624-229">Это полностью допустимо для одного потока и<xref:System.Windows.Threading.Dispatcher> комбинации для управления несколькими окнами, но иногда несколько потоков лучше всего выполняют.</span><span class="sxs-lookup"><span data-stu-id="5a624-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="5a624-230">Это особенно верно, когда существует возможность, что одно из окон будет монополизировать поток.</span><span class="sxs-lookup"><span data-stu-id="5a624-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 <span data-ttu-id="5a624-231">Проводник [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] работает таким образом.</span><span class="sxs-lookup"><span data-stu-id="5a624-231">[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] Explorer works in this fashion.</span></span> <span data-ttu-id="5a624-232">Каждое новое окно проводника принадлежит исходному процессу, однако оно создается под управлением независимого потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="5a624-233">С помощью [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> управления, можно отобразить веб-страниц.</span><span class="sxs-lookup"><span data-stu-id="5a624-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="5a624-234">Можно легко создать простую [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] заменить.</span><span class="sxs-lookup"><span data-stu-id="5a624-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="5a624-235">Начнем с важной функции: возможности открыть новое окно браузера.</span><span class="sxs-lookup"><span data-stu-id="5a624-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="5a624-236">Когда пользователь нажимает кнопку "Новое окно", запускается копия окна в отдельном потоке.</span><span class="sxs-lookup"><span data-stu-id="5a624-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="5a624-237">Таким образом, долго выполняющиеся или блокирующие операции в одном из окон не блокируют все остальные окна.</span><span class="sxs-lookup"><span data-stu-id="5a624-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="5a624-238">На самом деле у браузера имеется своя собственная сложная поточная модель.</span><span class="sxs-lookup"><span data-stu-id="5a624-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="5a624-239">Мы выбрали его, поскольку он знаком большинству читателей.</span><span class="sxs-lookup"><span data-stu-id="5a624-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="5a624-240">В следующем примере показан код.</span><span class="sxs-lookup"><span data-stu-id="5a624-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="5a624-241">В данном контексте наиболее интересными являются следующие сегменты потоков этого кода:</span><span class="sxs-lookup"><span data-stu-id="5a624-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="5a624-242">Этот метод вызывается при нажатии кнопки "Новое окно".</span><span class="sxs-lookup"><span data-stu-id="5a624-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="5a624-243">Она создает новый поток и запускает его в асинхронном режиме.</span><span class="sxs-lookup"><span data-stu-id="5a624-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="5a624-244">Этот метод является начальной точкой для нового потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="5a624-245">Мы создаем новое окно под элементом управления этого потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="5a624-246">автоматически создает новую <xref:System.Windows.Threading.Dispatcher> для нового потока управления.</span><span class="sxs-lookup"><span data-stu-id="5a624-246"> automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="5a624-247">Все что нужно сделать для обеспечения функциональности окна — Запуск <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="5a624-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="5a624-248">Технические подробности и важные моменты</span><span class="sxs-lookup"><span data-stu-id="5a624-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="5a624-249">Написание компонентов, использующих поток</span><span class="sxs-lookup"><span data-stu-id="5a624-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="5a624-250">[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Руководство разработчика описывает образец того, как компонент может предоставлять асинхронное поведение для своих клиентов (см. [Обзор асинхронной модели на основе событий](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="5a624-250">The [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="5a624-251">Например, предположим, что нужно упаковать `FetchWeatherFromServer` метод в неграфический компонент многократного использования.</span><span class="sxs-lookup"><span data-stu-id="5a624-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="5a624-252">Следуя стандартному [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] шаблона, это будет выглядеть примерно следующим образом.</span><span class="sxs-lookup"><span data-stu-id="5a624-252">Following the standard [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="5a624-253">`GetWeatherAsync` использовал бы один из методов, описанных выше, таких как создание фонового потока, для работы в асинхронном режиме, не блокируя вызов потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="5a624-254">Одна из наиболее важных частей этого шаблона вызывает *имя_метода* `Completed` метод в том же потоке, который вызвал *имя_метода* `Async` метода начинается с.</span><span class="sxs-lookup"><span data-stu-id="5a624-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="5a624-255">Это можно сделать с помощью [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] довольно просто, размещая <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>— но затем неграфический компонент может использоваться только в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] приложений, не в [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] или [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] программы.</span><span class="sxs-lookup"><span data-stu-id="5a624-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="5a624-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext> Класс адреса этой задачи — представляйте его упрощенную версию <xref:System.Windows.Threading.Dispatcher> , работает с другими [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] также платформ.</span><span class="sxs-lookup"><span data-stu-id="5a624-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="5a624-257">Вложенная накачка</span><span class="sxs-lookup"><span data-stu-id="5a624-257">Nested Pumping</span></span>  
 <span data-ttu-id="5a624-258">Иногда не выполнима полная блокировка [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-259">Давайте рассмотрим <xref:System.Windows.MessageBox.Show%2A> метод <xref:System.Windows.MessageBox> класса.</span><span class="sxs-lookup"><span data-stu-id="5a624-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="5a624-260"><xref:System.Windows.MessageBox.Show%2A>не возвращает, пока пользователь не щелкнет «ОК».</span><span class="sxs-lookup"><span data-stu-id="5a624-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="5a624-261">Однако он создает окно, которое должно иметь цикл обработки сообщений, чтобы быть интерактивным.</span><span class="sxs-lookup"><span data-stu-id="5a624-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="5a624-262">Ожидая, когда пользователь нажмет кнопку "ОК", исходное окно приложения не отвечает на ввод данных пользователем.</span><span class="sxs-lookup"><span data-stu-id="5a624-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="5a624-263">Тем не менее оно продолжает обрабатывать сообщения отображения.</span><span class="sxs-lookup"><span data-stu-id="5a624-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="5a624-264">Исходное окно перерисовывается при его перекрытии и выведении.</span><span class="sxs-lookup"><span data-stu-id="5a624-264">The original window redraws itself when covered and revealed.</span></span>  
  
 <span data-ttu-id="5a624-265">![MessageBox с кнопкой "ОК"](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span><span class="sxs-lookup"><span data-stu-id="5a624-265">![MessageBox with an "OK" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span></span>  
  
 <span data-ttu-id="5a624-266">Данное окно сообщения должно подчиняться какому-либо потоку.</span><span class="sxs-lookup"><span data-stu-id="5a624-266">Some thread must be in charge of the message box window.</span></span> <span data-ttu-id="5a624-267">Приложение [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] могло бы создать новый поток специально для данного окна сообщения, но этот поток не смог бы отображать отключенные элементы в исходном окне (вспомните предыдущее обсуждение взаимного исключения).</span><span class="sxs-lookup"><span data-stu-id="5a624-267">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="5a624-268">Вместо этого [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] использует систему обработки вложенных сообщений.</span><span class="sxs-lookup"><span data-stu-id="5a624-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="5a624-269"><xref:System.Windows.Threading.Dispatcher> Класс содержит специальный метод <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, который затем сохраняет текущую точку выполнения приложения начинается новый цикл обработки сообщений.</span><span class="sxs-lookup"><span data-stu-id="5a624-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="5a624-270">После завершения цикла обработки вложенных сообщений выполнение возобновляется после исходного <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> вызова.</span><span class="sxs-lookup"><span data-stu-id="5a624-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="5a624-271">В этом случае <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> поддерживает программный контекст при вызове <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, и он начинается новый цикл обработки сообщений для перерисовки фона окна и обработки входных данных для окна сообщения.</span><span class="sxs-lookup"><span data-stu-id="5a624-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="5a624-272">Когда пользователь нажимает кнопку OK и очищает всплывающее окно, вложенные циклы завершаются и управление возобновляется после вызова <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="5a624-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="5a624-273">Устаревшие перенаправленные события</span><span class="sxs-lookup"><span data-stu-id="5a624-273">Stale Routed Events</span></span>  
 <span data-ttu-id="5a624-274">Маршрутизация системы обработки событий в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] уведомляет все деревья, когда вызываются события.</span><span class="sxs-lookup"><span data-stu-id="5a624-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="5a624-275">При нажатии левой кнопки мыши над эллипсом, `handler2` выполняется.</span><span class="sxs-lookup"><span data-stu-id="5a624-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="5a624-276">После `handler2` окончания события передается вдоль <xref:System.Windows.Controls.Canvas> объекта, который использует `handler1` для его обработки.</span><span class="sxs-lookup"><span data-stu-id="5a624-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="5a624-277">Это происходит только в том случае, если `handler2` не задает явно пометить объект событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="5a624-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="5a624-278">Возможно, `handler2` займет немало времени для обработки этого события.</span><span class="sxs-lookup"><span data-stu-id="5a624-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="5a624-279">`handler2`может использовать <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> начинается цикл вложенных сообщений, который не возвращает часов.</span><span class="sxs-lookup"><span data-stu-id="5a624-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="5a624-280">Если `handler2` не помечает событие как обработанное после цикла обработки сообщений завершения, событие передается вверх по дереву, даже если оно является очень старым.</span><span class="sxs-lookup"><span data-stu-id="5a624-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="5a624-281">Повторный вход и блокировка</span><span class="sxs-lookup"><span data-stu-id="5a624-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="5a624-282">Механизм блокировки [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] не работает точно так, как это можно представить; можно предположить, что поток завершит операцию полностью, запрашивая блокировку.</span><span class="sxs-lookup"><span data-stu-id="5a624-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="5a624-283">В действительности поток продолжает получать и обрабатывать сообщения с высоким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="5a624-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="5a624-284">Это помогает избежать взаимоблокировок и максимально повышает скорость отклика интерфейсов, но может приводить к незначительным ошибкам.</span><span class="sxs-lookup"><span data-stu-id="5a624-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="5a624-285">Большая часть времени, не нужно что-либо знать об этом, но в редких случаях (как правило, включающих [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] сообщений окна или компоненты COM STA) это может быть знания.</span><span class="sxs-lookup"><span data-stu-id="5a624-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="5a624-286">Большинство интерфейсов не были собраны с учета безопасности потока, так как разработчики работают в предположении, что [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] никогда не осуществляется более чем одним потоком.</span><span class="sxs-lookup"><span data-stu-id="5a624-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="5a624-287">В этом случае что однопоточное вносимые изменения среды в непредвиденное время неблагоприятные последствия, <xref:System.Windows.Threading.DispatcherObject> предполагается механизм взаимного исключения.</span><span class="sxs-lookup"><span data-stu-id="5a624-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="5a624-288">Рассмотрим следующий псевдокод:</span><span class="sxs-lookup"><span data-stu-id="5a624-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="5a624-289">![Схема повторного входа потоков](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="5a624-289">![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="5a624-290">В большинстве случаев все работает правильно, но иногда в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] где такой непредвиденный повторный вход может действительно вызвать проблемы.</span><span class="sxs-lookup"><span data-stu-id="5a624-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="5a624-291">Да, в определенные ключевые моменты [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] вызовы <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, который меняет инструкцию блокировки для этого потока использовать [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] повторный вход освободить блокировку вместо обычного [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] блокировки.</span><span class="sxs-lookup"><span data-stu-id="5a624-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="5a624-292">Так почему было [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] команды выбрала такое поведение?</span><span class="sxs-lookup"><span data-stu-id="5a624-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="5a624-293">Это было связано с объектами COM STA и завершением потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="5a624-294">Если объект является сборщиком мусора, его `Finalize` метод не выполняется в выделенном потоке завершения, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-295">Именно здесь лежит проблема, поскольку объект COM STA, созданный на [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток может быть удален только в [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] потока.</span><span class="sxs-lookup"><span data-stu-id="5a624-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="5a624-296">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] Делает то же самое для <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (в этом случае с помощью Win32 `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="5a624-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="5a624-297">Но если [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] поток занят, поток завершения останавливается, и объект COM STA не удается завершить, что приводит к серьезной утечке памяти.</span><span class="sxs-lookup"><span data-stu-id="5a624-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="5a624-298">Поэтому [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] создала сложный вызов для создания блокировки работают надлежащим образом, они делают.</span><span class="sxs-lookup"><span data-stu-id="5a624-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="5a624-299">Задача для [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] — избежать непредвиденного повторного входа без внесения утечку памяти, поэтому мы не блокируют everywhere повторный вход.</span><span class="sxs-lookup"><span data-stu-id="5a624-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5a624-300">См. также</span><span class="sxs-lookup"><span data-stu-id="5a624-300">See Also</span></span>  
 [<span data-ttu-id="5a624-301">Пример однопоточного приложения с длительным выполнением вычислений</span><span class="sxs-lookup"><span data-stu-id="5a624-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](http://go.microsoft.com/fwlink/?LinkID=160038)
