---
title: Пользовательские свойства зависимостей
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: 00596911cf603ae9615eb64d0aedefe90c2520bc
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/03/2019
ms.locfileid: "73458987"
---
# <a name="custom-dependency-properties"></a>Пользовательские свойства зависимостей

В этом разделе описываются основания для создания настраиваемых свойств зависимостей для приложений [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], а также этапы и некоторые варианты реализации, которые могут повысить производительность, удобство использования и универсальность свойств.

<a name="prerequisites"></a>

## <a name="prerequisites"></a>Необходимые компоненты

Предполагается, что вы имеете представление о свойствах зависимостей с точки зрения потребителя существующих свойств зависимостей в классах [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] и ознакомились с разделом [Общие сведения о свойствах зависимостей](dependency-properties-overview.md). Чтобы выполнить примеры в этом разделе, следует также иметь представление о [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] и написании приложений [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a>Что такое свойство зависимостей?

Чтобы обеспечить поддержку стилей, привязки данных, наследования, анимации и значений по умолчанию, можно включить свойство среды CLR, которое в противном случае будет реализовано как свойство зависимостей. Свойства зависимостей — это свойства, регистрируемые в системе свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] путем вызова метода <xref:System.Windows.DependencyProperty.Register%2A> (или <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), которые поддерживаются полем идентификатора <xref:System.Windows.DependencyProperty>. Свойства зависимостей могут использоваться только типами <xref:System.Windows.DependencyObject>, но <xref:System.Windows.DependencyObject> довольно высоки в иерархии классов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], поэтому большинство классов, доступных в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], могут поддерживать свойства зависимостей. Дополнительные сведения о свойствах зависимостей и некоторых терминах и соглашениях, используемых для их описания в этом [!INCLUDE[TLA2#tla_sdk](../../../../includes/tla2sharptla-sdk-md.md)], см. в разделе [Общие сведения о свойствах зависимостей](dependency-properties-overview.md).

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a>Примеры свойств зависимостей

Примеры свойств зависимостей, реализованных в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] классах, включают свойство <xref:System.Windows.Controls.Control.Background%2A>, свойство <xref:System.Windows.FrameworkElement.Width%2A> и свойство <xref:System.Windows.Controls.TextBox.Text%2A>, среди многих других. Каждое свойство зависимости, предоставляемое классом, имеет соответствующее открытое статическое поле типа <xref:System.Windows.DependencyProperty> предоставленное в этом же классе. Это идентификатор для свойства зависимостей. Идентификатор именуется по следующему соглашению: имя свойства зависимостей, за которым следует строка `Property`. Например, соответствующее поле идентификатора <xref:System.Windows.DependencyProperty> для свойства <xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Control.BackgroundProperty>. Идентификатор хранит сведения о свойстве зависимостей в том виде, в котором оно было зарегистрировано, а идентификатор затем используется позже для других операций, использующих свойство зависимостей, например вызов <xref:System.Windows.DependencyObject.SetValue%2A>.

Как упоминалось в разделе [Общие сведения о свойствах зависимостей](dependency-properties-overview.md), все свойства зависимостей в [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (за исключением большинства присоединенных свойств) также являются свойствами CLR из-за реализации "оболочки". Таким образом, из кода можно получить или задать свойства зависимостей, вызвав методы доступа CLR, которые определяют оболочки так же, как и другие свойства среды CLR. Как потребитель установленных свойств зависимостей, обычно не используются методы <xref:System.Windows.DependencyObject> <xref:System.Windows.DependencyObject.GetValue%2A> и <xref:System.Windows.DependencyObject.SetValue%2A>, которые являются точкой подключения к базовой системе свойств. Вместо этого существующая реализация свойств CLR уже будет называться <xref:System.Windows.DependencyObject.GetValue%2A> и <xref:System.Windows.DependencyObject.SetValue%2A> в реализации оболочки `get` и `set` свойства, используя поле идентификатора соответствующим образом. При собственной реализации настраиваемого свойства зависимостей вы будете определять оболочку аналогичным образом.

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a>Почему требуется реализовывать свойство зависимостей?

При реализации свойства в классе, если класс является производным от <xref:System.Windows.DependencyObject>, вы можете вернуть свойство с помощью идентификатора <xref:System.Windows.DependencyProperty> и, таким образом, сделать его свойством зависимостей. Назначение свойства свойством зависимостей не всегда требуется и не всегда уместно и зависит от конкретной ситуации. В некоторых случаях достаточно просто снабдить свойство закрытым полем. Тем не менее реализовать свойство как свойство зависимостей потребуется, если свойство должно поддерживать одну или несколько из следующих возможностей [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].

- Требуется, чтобы свойство было задаваемым в стиле. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](../controls/styling-and-templating.md).

- Требуется, чтобы свойство поддерживало привязку данных. Дополнительные сведения о свойствах зависимостей привязки данных см. в разделе [Привязка свойств двух элементов управления](../data/how-to-bind-the-properties-of-two-controls.md).

- Требуется, чтобы свойство было задаваемым с помощью динамической ссылки ресурса. Дополнительные сведения см. в разделе [Ресурсы XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md).

- Требуется настроить автоматическое наследование значения свойства из родительского элемента в дереве элементов. В этом случае Зарегистрируйтесь в методе <xref:System.Windows.DependencyProperty.RegisterAttached%2A>, даже если также создается оболочка свойств для доступа к среде CLR. Дополнительные сведения см. в разделе [Наследование значения свойства](property-value-inheritance.md).

- Требуется, чтобы свойство поддерживало анимацию. Более подробную информацию см. в разделе [Общие сведения об эффектах анимации](../graphics-multimedia/animation-overview.md).

- Требуется, чтобы система свойств сообщала об изменении предыдущего значения свойства действиями, выполняемыми системой свойств, окружением или пользователем, или путем чтения и использования стилей. Используя метаданные свойства, свойство может указывать метод обратного вызова, который будет вызываться каждый раз, когда система свойств определит, что значение свойства было однозначно изменено. Связанным понятием является приведение значения свойства. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](dependency-property-callbacks-and-validation.md).

- Требуется использовать установленные соглашения о метаданных, которые также используются процессами [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], такими как передача сведений о том, нужно ли системе макета перестраивать визуальные компоненты элемента при изменении значения свойства. Или требуется возможность использовать переопределения метаданных таким образом, чтобы производные классы могли изменять основанные на метаданных характеристики, такие как значение по умолчанию.

- Необходимо, чтобы свойства пользовательского элемента управления получали поддержку конструктора WPF Visual Studio, например изменение окна **свойств** . Дополнительные сведения см. в разделе [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md).

Рекомендуется рассмотреть возможность реализации сценариев путем переопределения метаданных существующего свойства зависимостей, вместо реализации совершенно нового свойства. Практическая польза переопределения метаданных зависит от сценария и того, насколько этот сценарий схож с реализацией существующих свойств зависимостей и классов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Дополнительные сведения о переопределении метаданных для существующих свойств см. в разделе [Метаданные свойств зависимостей](dependency-property-metadata.md).

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a>Контрольный список определения свойства зависимостей

Определение свойства зависимостей состоит из четырех различных понятий. Эти понятия не обязательно являются строгими этапами процедуры, так как некоторые из них в итоге объединяются в одну строку кода в реализации.

- (Необязательно.) Создайте метаданные для свойства зависимостей.

- Зарегистрируйте имя свойства в системе свойств, указав тип владельца и тип значения свойства. Также укажите метаданные свойства, если они используются.

- Определите идентификатор <xref:System.Windows.DependencyProperty> как `public` `static` `readonly` поля в типе владельца.

- Определите свойство "оболочка" среды CLR, имя которого соответствует имени свойства зависимостей. Реализуйте `get` свойства оболочки CLR, а `set` методы доступа для соединения со свойством зависимостей, которое его создает.

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a>Регистрация свойства в системе свойств

Чтобы назначить свойство свойством зависимостей, необходимо зарегистрировать это свойство в таблице, обслуживаемой системой свойств, и предоставить ему уникальный идентификатор, используемый в качестве квалификатора для последующих операций системы свойств. Эти операции могут быть внутренними операциями или собственным кодом, вызывающим API системы свойств. Чтобы зарегистрировать свойство, вызовите метод <xref:System.Windows.DependencyProperty.Register%2A> в теле класса (внутри класса, но за пределами определений членов). Поле идентификатора также предоставляется вызовом метода <xref:System.Windows.DependencyProperty.Register%2A> в качестве возвращаемого значения. Причина, по которой вызов <xref:System.Windows.DependencyProperty.Register%2A> выполняется за пределами других определений элементов, заключается в том, что это возвращаемое значение используется для назначения и создания `public` `static` `readonly` поля типа <xref:System.Windows.DependencyProperty> как часть класса. Это поле становится идентификатором для вашего свойства зависимостей.

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a>Соглашения об именовании свойств зависимостей

Существуют установленные соглашения об именовании, касающиеся свойств зависимостей, которым необходимо следовать, если ситуация не является исключительной.

Само свойство зависимости будет иметь базовое имя «Акуариумграфик», как в этом примере, которое задается в качестве первого параметра <xref:System.Windows.DependencyProperty.Register%2A>. Это имя должно быть уникальным в пределах каждого регистрирующего типа. Считается, что свойства зависимостей, наследуемые через базовые типы, уже являются частью регистрирующего типа: имена наследуемых свойств нельзя зарегистрировать повторно. Однако существует способ добавления класса как владельца свойства зависимостей даже в том случае, если это свойство зависимостей не наследуется. Дополнительные сведения см. в разделе [Метаданные свойств зависимостей](dependency-property-metadata.md).

При создании поля идентификатора назовите это поле по зарегистрированному имени свойства, добавив суффикс `Property`. Это поле является идентификатором для свойства зависимостей, которое будет использоваться в качестве входных данных для <xref:System.Windows.DependencyObject.SetValue%2A> и <xref:System.Windows.DependencyObject.GetValue%2A> вызовов, которые будут выполняться в оболочках любым другим кодом при доступе к свойству с помощью вашего собственного кода. , благодаря любому доступному внешнему коду в системе свойств и, возможно, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] процессорах.

> [!NOTE]
> Определение свойства зависимостей в теле класса является обычной реализацией, однако его также можно определить в статическом конструкторе класса. Этот подход может оказаться целесообразным, если для инициализации свойства зависимостей требуется несколько строк кода.

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a>Реализация "оболочки"

Реализация программы-оболочки должна вызывать <xref:System.Windows.DependencyObject.GetValue%2A> в реализации `get` и <xref:System.Windows.DependencyObject.SetValue%2A> в реализации `set` (исходный вызов регистрации и поле также отображаются здесь для ясности).

Во всех, но исключительных обстоятельствах реализации оболочек должны выполнять только действия <xref:System.Windows.DependencyObject.GetValue%2A> и <xref:System.Windows.DependencyObject.SetValue%2A> соответственно. Причина этого обсуждается в разделе [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md).

Все существующие открытые свойства зависимостей, предоставляемые для классов [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], используют эту простую модель реализации оболочки. Основные сложности обработки свойств зависимостей определяются наследуемым поведением системы свойств или реализацией через другие понятия, такие как приведение или обратные вызовы изменения свойства через метаданные свойства.

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

Опять же, по соглашению имя свойства оболочки должно совпадать с именем, выбранным и заданным в качестве первого параметра вызова <xref:System.Windows.DependencyProperty.Register%2A>, который зарегистрировал свойство. Если свойство не следует соглашению, это не обязательно ведет к его неработоспособности, однако будет наблюдаться несколько серьезных проблем.

- Не будут работать определенные аспекты стилей и шаблонов.

- Большинство инструментов и конструкторов полагается на соглашения об именовании для правильной сериализации [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], а также для предоставления помощи разработчику на уровне свойств.

- Текущая реализация загрузчика [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] полностью обходит оболочки и основывается на соглашении об именовании при обработке значений атрибутов. Дополнительные сведения см. в разделе [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md).

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a>Метаданные свойства для нового свойства зависимостей

При регистрации свойства зависимостей через систему свойств создается объект метаданных, который хранит характеристики свойства. Многие из этих характеристик имеют значения по умолчанию, которые задаются, если свойство зарегистрировано с помощью простых подписей <xref:System.Windows.DependencyProperty.Register%2A>. Другие сигнатуры <xref:System.Windows.DependencyProperty.Register%2A> позволяют указать метаданные, которые будут использоваться при регистрации свойства. Как правило, метаданные, задаваемые для свойства зависимостей, предполагают предоставление значений по умолчанию, применяемых для новых экземпляров, которые используют свойство.

При создании свойства зависимостей, существующего в производном классе <xref:System.Windows.FrameworkElement>, можно использовать более специализированный класс метаданных <xref:System.Windows.FrameworkPropertyMetadata>, а не базовый класс <xref:System.Windows.PropertyMetadata>. Конструктор для класса <xref:System.Windows.FrameworkPropertyMetadata> имеет несколько сигнатур, где можно задать различные характеристики метаданных в сочетании. Если необходимо указать только значение по умолчанию, используйте сигнатуру, которая принимает один параметр типа <xref:System.Object>. Передайте этот параметр объекта в качестве значения по умолчанию для свойства (указанное значение по умолчанию должно быть типом, который вы указали в качестве параметра `propertyType` в вызове <xref:System.Windows.DependencyProperty.Register%2A>).

Для <xref:System.Windows.FrameworkPropertyMetadata>также можно указать флаги параметров метаданных для свойства. Эти флаги преобразуются в дискретные свойства в метаданных свойства после регистрации и используются для передачи определенных условных объектов в другие процессы, например в обработчик макетов.

#### <a name="setting-appropriate-metadata-flags"></a>Задание соответствующих флагов метаданных

- Если свойство (или изменение его значения) влияет на [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], а в частности влияет на то, как система макета должна масштабировать или визуализировать элемент на странице, установите один или несколько следующих флагов: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.

  - <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> указывает, что изменение этого свойства требует изменения [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] отрисовки, где содержащий объект может потребовать больше или меньше места в пределах родителя. Например, этот флаг следует задать для свойства "Ширина".

  - <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> указывает, что изменение этого свойства требует изменения [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] отрисовку, которая обычно не требует изменения в выделенном пространстве, но указывает на то, что положение в пространстве изменилось. Например, этот флаг следует задать для свойства "Выравнивание".

  - <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> указывает, что произошло другое изменение, которое не повлияет на макет и меру, но требует другого рендеринга. Примером будет свойство, изменяющее цвет существующего элемента, например "Фон".

  - Эти флаги часто используются в качестве протокола в метаданных для собственных реализаций переопределения системы свойств или обратных вызовов макета. Например, может существовать обратный вызов <xref:System.Windows.DependencyObject.OnPropertyChanged%2A>, который будет вызывать <xref:System.Windows.UIElement.InvalidateArrange%2A>, если какое-либо свойство экземпляра сообщает об изменении значения и имеет <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> как `true` в метаданных.

- Некоторые свойства могут влиять на характеристики отрисовки содержащего их родительского элемента указанными выше способами и помимо изменений в обязательном размере, упомянутых выше. Примером является свойство <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A>, используемое в модели документов нефиксированного формата, при котором изменения этого свойства могут изменить общую отрисовку документа нефиксированного формата, содержащего абзац. Используйте <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> или <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> для обнаружения похожих вариантов в собственных свойствах.

- По умолчанию свойства зависимостей поддерживают привязку данных. Вы можете специально отключить привязку данных для случаев, когда отсутствует практический смысл в привязке данных или когда быстродействие в привязке данных для больших объектов становится проблемой.

- По умолчанию <xref:System.Windows.Data.Binding.Mode%2A> привязки данных для свойств зависимостей по умолчанию имеет значение <xref:System.Windows.Data.BindingMode.OneWay>. Всегда можно изменить привязку на <xref:System.Windows.Data.BindingMode.TwoWay> для каждого экземпляра привязки; Дополнительные сведения см. [в разделе Указание направления привязки](../data/how-to-specify-the-direction-of-the-binding.md). Но в качестве автора свойства зависимости можно сделать так, чтобы свойство использовало <xref:System.Windows.Data.BindingMode.TwoWay> режим привязки по умолчанию. Примером существующего свойства зависимости является <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>. сценарий для этого свойства заключается в том, что логика настройки <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> и компоновка <xref:System.Windows.Controls.MenuItem> взаимодействуют с стилем темы по умолчанию. Логика свойств <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> использует привязку данных изначально для поддержания состояния свойства в соответствии с другими свойствами состояния и вызовами методов. Еще одним примером свойства, которое привязывает <xref:System.Windows.Data.BindingMode.TwoWay> по умолчанию, является <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.

- Можно также включить наследование свойств в пользовательском свойстве зависимости, установив флаг <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits>. Наследование свойств удобно для ситуации, когда родительские и дочерние элементы имеют общее свойство и для дочерних элементов имеет смысл задать то же значение свойства, что и в родительском элементе. Примером наследуемого свойства является <xref:System.Windows.FrameworkElement.DataContext%2A>, который используется для операций привязки, чтобы включить важный сценарий «основной/подробности» для представления данных. Сделав <xref:System.Windows.FrameworkElement.DataContext%2A> наследуемым, все дочерние элементы также наследуют этот контекст данных. Благодаря наследованию значения свойства вы можете указать контекст данных в корне приложения или страницы и вам не потребуется уточнять его для привязок во всех возможных дочерних элементах. <xref:System.Windows.FrameworkElement.DataContext%2A> также является хорошим примером того, чтобы проиллюстрировать, что наследование переопределяет значение по умолчанию, но оно всегда может быть задано локально для любого дочернего элемента. Дополнительные сведения см. [в разделе Использование шаблона "основной/подробности" с иерархическими данными](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md). Наследование значения свойства может влиять на производительность, и таким образом, его следует использовать с осторожностью. Дополнительные сведения см. в разделе [Наследование значения свойства](property-value-inheritance.md).

- Установите флаг <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal>, чтобы указать, должно ли свойство зависимостей обнаруживаться или использоваться службами ведения журнала навигации. Примером может быть свойство <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A>. любой элемент, выбранный в элементе управления Selection, должен быть сохранен при переходе к журналу ведения журнала.

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a>Свойства зависимости "только для чтения"

Можно определить свойство зависимости, которое доступно только для чтения. Однако ситуации для такого использования немного отличаются, как и процедура регистрации свойства в системе свойств и предоставление идентификатора. Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](read-only-dependency-properties.md).

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a>Свойства зависимостей типа коллекция

Свойства зависимостей типа коллекции имеют некоторые дополнительные проблемы при реализации, которые необходимо учитывать. Подробности см. в разделе [Свойства зависимостей типа коллекции](collection-type-dependency-properties.md).

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a>Замечания по безопасности свойств зависимостей

Свойства зависимостей должны объявляться как открытые свойства. Поля идентификаторов свойств зависимостей должны объявляться как открытые статические поля. Даже при попытке объявить другие уровни доступа (например, защищенные) доступ к свойству зависимостей всегда можно получить с помощью идентификатора в сочетании с API системы свойств. Даже поле защищенного идентификатора потенциально доступно из-за создания отчетов метаданных или API-интерфейсов определения значений, которые являются частью системы свойств, например <xref:System.Windows.LocalValueEnumerator>. Дополнительные сведения см. в разделе [Безопасность свойств зависимостей](dependency-property-security.md).

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a>Свойства зависимостей и конструкторы класса

Есть общий принцип в программировании управляемого кода (он часто принудительно применяется средствами анализа кода, такими как FxCop), подразумевающий, что конструкторы класса не должны вызывать виртуальные методы. Этот принцип обусловлен тем, что конструкторы могут быть вызваны в качестве базовой инициализации конструктора производного класса, а ввод виртуального метода через конструктор может произойти в состоянии неполной инициализации конструируемого экземпляра объекта. При наследовании от любого класса, который уже является производным от <xref:System.Windows.DependencyObject>, следует иметь в виду, что сама система свойств вызывает и предоставляет виртуальные методы внутренним образом. Эти виртуальные методы являются частью служб системы свойств [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Переопределение методов позволяет производным классам участвовать в определении значения. Чтобы избежать потенциальных проблем при инициализации среды выполнения, не задавайте значения свойств зависимостей в конструкторах классов (если только вы не следуете конкретному шаблону конструктора). Подробнее см. в разделе [Шаблоны безопасного конструктора для DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).

## <a name="see-also"></a>См. также

- [Общие сведения о свойствах зависимости](dependency-properties-overview.md)
- [Метаданные свойства зависимостей](dependency-property-metadata.md)
- [Общие сведения о разработке элементов управления](../controls/control-authoring-overview.md)
- [Свойства зависимостей типа коллекции](collection-type-dependency-properties.md)
- [Безопасность свойства зависимостей](dependency-property-security.md)
- [Загрузка кода XAML и свойства зависимостей](xaml-loading-and-dependency-properties.md)
- [Шаблоны безопасного конструктора для DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md)
