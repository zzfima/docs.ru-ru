---
title: Проверка и обратные вызовы свойства зависимостей
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- dependency properties [WPF], validation
- coerce value callbacks [WPF]
- callbacks [WPF], validation
- dependency properties [WPF], callbacks
- validation of dependency properties [WPF]
ms.assetid: 48db5fb2-da7f-49a6-8e81-3540e7b25825
ms.openlocfilehash: c5f7439753037aeb5c2ff558da63e063ad65a5e1
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186427"
---
# <a name="dependency-property-callbacks-and-validation"></a><span data-ttu-id="1426b-102">Проверка и обратные вызовы свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="1426b-102">Dependency Property Callbacks and Validation</span></span>
<span data-ttu-id="1426b-103">В этом разделе описывается создание свойства зависимостей с помощью альтернативных пользовательских реализаций функций, связанных со свойствами, таких как определение проверки, обратные вызовы, которые совершаются при каждом изменении эффективного значения свойства, и переопределение возможных внешних влияний на определение значения.</span><span class="sxs-lookup"><span data-stu-id="1426b-103">This topic describes how to create dependency properties using alternative custom implementations for property-related features such as validation determination, callbacks that are invoked whenever the property's effective value is changed, and overriding possible outside influences on value determination.</span></span> <span data-ttu-id="1426b-104">В этом разделе также рассматриваются сценарии, в которых подходит расширение стандартных правил для системы свойств с помощью этих методов.</span><span class="sxs-lookup"><span data-stu-id="1426b-104">This topic also discusses scenarios where expanding on the default property system behaviors by using these techniques is appropriate.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="1426b-105">Предварительные требования</span><span class="sxs-lookup"><span data-stu-id="1426b-105">Prerequisites</span></span>  
 <span data-ttu-id="1426b-106">В этом разделе предполагается, что вы понимаете основные сценарии реализации свойства зависимостей и способы применения метаданных к настраиваемому свойству зависимостей.</span><span class="sxs-lookup"><span data-stu-id="1426b-106">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="1426b-107">Дополнительные сведения см. в разделах [Пользовательские свойства зависимостей](custom-dependency-properties.md) и [Метаданные свойства зависимостей](dependency-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="1426b-107">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="Validation_Callbacks"></a>
## <a name="validation-callbacks"></a><span data-ttu-id="1426b-108">Обратные вызовы проверки</span><span class="sxs-lookup"><span data-stu-id="1426b-108">Validation Callbacks</span></span>  
 <span data-ttu-id="1426b-109">Обратные вызовы проверки можно назначить свойству зависимостей при первой регистрации.</span><span class="sxs-lookup"><span data-stu-id="1426b-109">Validation callbacks can be assigned to a dependency property when you first register it.</span></span> <span data-ttu-id="1426b-110">Обратный вызов проверки не является частью метаданных свойств; это прямой вход метода. <xref:System.Windows.DependencyProperty.Register%2A></span><span class="sxs-lookup"><span data-stu-id="1426b-110">The validation callback is not part of property metadata; it is a direct input of the <xref:System.Windows.DependencyProperty.Register%2A> method.</span></span> <span data-ttu-id="1426b-111">Поэтому после того, как будет создан обратный вызов проверки для свойства зависимостей, он уже не может быть переопределен новой реализацией.</span><span class="sxs-lookup"><span data-stu-id="1426b-111">Therefore, once a validation callback is created for a dependency property, it cannot be overridden by a new implementation.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="1426b-112">Обратные вызовы реализуются так, что они получают значение объекта.</span><span class="sxs-lookup"><span data-stu-id="1426b-112">The callbacks are implemented such that they are provided an object value.</span></span> <span data-ttu-id="1426b-113">Они возвращают `true`, если полученное значение является допустимым для свойства. В противном случае — возвращают `false`.</span><span class="sxs-lookup"><span data-stu-id="1426b-113">They return `true` if the provided value is valid for the property; otherwise, they return `false`.</span></span> <span data-ttu-id="1426b-114">Предполагается, что свойство принадлежит допустимому типу (зарегистрированному в системе свойств), поэтому проверка типов в обратных вызовах обычно не выполняется.</span><span class="sxs-lookup"><span data-stu-id="1426b-114">It is assumed that the property is of the correct type per the type registered with the property system, so checking type within the callbacks is not ordinarily done.</span></span> <span data-ttu-id="1426b-115">Обратные вызовы используются системой свойств в различных операциях.</span><span class="sxs-lookup"><span data-stu-id="1426b-115">The callbacks are used by the property system in a variety of different operations.</span></span> <span data-ttu-id="1426b-116">Это включает начальную инициализацию типа по значению по умолчанию, программное изменение путем отзыва <xref:System.Windows.DependencyObject.SetValue%2A>или попытки переопределить метаданные с новым значением по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="1426b-116">This includes the initial type initialization by default value, programmatic change by invoking <xref:System.Windows.DependencyObject.SetValue%2A>, or attempts to override metadata with new default value provided.</span></span> <span data-ttu-id="1426b-117">Если обратный вызов проверки совершается любой из этих операций и возвращает `false`, вызывается исключение.</span><span class="sxs-lookup"><span data-stu-id="1426b-117">If the validation callback is invoked by any of these operations, and returns `false`, then an exception will be raised.</span></span> <span data-ttu-id="1426b-118">Программисты должны быть готовы обрабатывать эти исключения.</span><span class="sxs-lookup"><span data-stu-id="1426b-118">Application writers must be prepared to handle these exceptions.</span></span> <span data-ttu-id="1426b-119">Обычно обратные вызовы проверки используются для проверки значений перечислений или для ограничения значений целых чисел, когда это свойство задает измерения, которые должны быть больше или равны нулю.</span><span class="sxs-lookup"><span data-stu-id="1426b-119">A common use of validation callbacks is validating enumeration values, or constraining values of integers or doubles when the property sets measurements that must be zero or greater.</span></span>  
  
 <span data-ttu-id="1426b-120">Обратные вызовы проверки специально предназначены для проверки классов, а не экземпляров классов.</span><span class="sxs-lookup"><span data-stu-id="1426b-120">Validation callbacks specifically are intended to be class validators, not instance validators.</span></span> <span data-ttu-id="1426b-121">Параметры обратного вызова не сообщают конкретные <xref:System.Windows.DependencyObject> свойства для проверки установлены.</span><span class="sxs-lookup"><span data-stu-id="1426b-121">The parameters of the callback do not communicate a specific <xref:System.Windows.DependencyObject> on which the properties to validate are set.</span></span> <span data-ttu-id="1426b-122">Поэтому обратные вызовы проверки не используются для принудительного применения возможных "зависимостей", способных повлиять на значение свойства, где значение свойства для этого экземпляра зависит от таких факторов, как значения других свойств этого экземпляра или состояния во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="1426b-122">Therefore the validation callbacks are not useful for enforcing the possible "dependencies" that might influence a property value, where the instance-specific value of a property is dependent on factors such as instance-specific values of other properties, or run-time state.</span></span>  
  
 <span data-ttu-id="1426b-123">Ниже приводится пример кода для очень простого сценария обратного вызова проверки: <xref:System.Double> проверка того, что свойство, которое набрано как первобытное, не <xref:System.Double.PositiveInfinity> является или <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="1426b-123">The following is example code for a very simple validation callback scenario: validating that a property that is typed as the <xref:System.Double> primitive is not <xref:System.Double.PositiveInfinity> or <xref:System.Double.NegativeInfinity>.</span></span>  
  
 [!code-csharp[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#validatevaluecallback)]
 [!code-vb[DPCallbackOverride#ValidateValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#validatevaluecallback)]  
  
<a name="Coerce_Value_Callbacks_and_Property_Changed_Events"></a>
## <a name="coerce-value-callbacks-and-property-changed-events"></a><span data-ttu-id="1426b-124">Обратные вызовы с привязкой к значению и события изменения свойств</span><span class="sxs-lookup"><span data-stu-id="1426b-124">Coerce Value Callbacks and Property Changed Events</span></span>  
 <span data-ttu-id="1426b-125">Обратные вызовы значений принудительного исполнения действительно проходят конкретный <xref:System.Windows.DependencyObject> экземпляр для свойств, как и <xref:System.Windows.PropertyChangedCallback> реализации, на которые ссылается система свойств всякий раз, когда значение свойства зависимости изменяется.</span><span class="sxs-lookup"><span data-stu-id="1426b-125">Coerce value callbacks do pass the specific <xref:System.Windows.DependencyObject> instance for properties, as do <xref:System.Windows.PropertyChangedCallback> implementations that are invoked by the property system whenever the value of a dependency property changes.</span></span> <span data-ttu-id="1426b-126">Используя сочетание этих обратных вызовов, можно создать ряд свойств элементов, где изменения значения одного свойства будут вызывать принудительное изменение или пересчет значения другого свойства.</span><span class="sxs-lookup"><span data-stu-id="1426b-126">Using these two callbacks in combination, you can create a series of properties on elements where changes in one property will force a coercion or reevaluation of another property.</span></span>  
  
 <span data-ttu-id="1426b-127">Вот типичный сценарий использования связки свойств зависимостей. Имеется свойство, управляемое пользовательским интерфейсом. Элемент содержит по одному свойству для минимального и максимального значений и третье свойство для фактического или текущего значения.</span><span class="sxs-lookup"><span data-stu-id="1426b-127">A typical scenario for using a linkage of dependency properties is when you have a user interface driven property where the element holds one property each for the minimum and maximum value, and a third property for the actual or current value.</span></span> <span data-ttu-id="1426b-128">Если максимальное значение будет изменено так, что текущее значение станет превышать это новое максимальное значение, следует изменить текущее значение, сделав его не более максимального. Аналогичная связь нужна и для минимального значения.</span><span class="sxs-lookup"><span data-stu-id="1426b-128">Here, if the maximum was adjusted in such a way that the current value exceeded the new maximum, you would want to coerce the current value to be no greater than the new maximum, and a similar relationship for minimum to current.</span></span>  
  
 <span data-ttu-id="1426b-129">Ниже приведен пример очень краткого кода для одного из трех свойств зависимостей, иллюстрирующий эту связь.</span><span class="sxs-lookup"><span data-stu-id="1426b-129">The following is very brief example code for just one of the three dependency properties that illustrate this relationship.</span></span> <span data-ttu-id="1426b-130">В примере показано, как регистрируется свойство `CurrentReading` для набора связанных свойств (максимальное, минимальное, текущее) объекта \*Reading.</span><span class="sxs-lookup"><span data-stu-id="1426b-130">The example shows how the `CurrentReading` property of a Min/Max/Current set of related \*Reading properties is registered.</span></span> <span data-ttu-id="1426b-131">Он использует проверку, как это показано в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="1426b-131">It uses the validation as shown in the previous section.</span></span>  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 <span data-ttu-id="1426b-132">Обратный вызов при изменении свойства текущего объекта используется для пересылки изменений в другие зависимые свойства путем явного выполнения обратных вызовов с привязкой к значению, зарегистрированных для этих свойств.</span><span class="sxs-lookup"><span data-stu-id="1426b-132">The property changed callback for Current is used to forward the change to other dependent properties, by explicitly invoking the coerce value callbacks that are registered for those other properties:</span></span>  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 <span data-ttu-id="1426b-133">При выполнении обратных вызовов с привязкой к значению проверяются значения свойств, от которых потенциально зависит текущее свойство, и принудительно изменяется его значение при необходимости.</span><span class="sxs-lookup"><span data-stu-id="1426b-133">The coerce value callback checks the values of properties that the current property is potentially dependent upon, and coerces the current value if necessary:</span></span>  
  
 [!code-csharp[DPCallbackOverride#CoerceCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#coercecurrent)]
 [!code-vb[DPCallbackOverride#CoerceCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#coercecurrent)]  
  
> [!NOTE]
> <span data-ttu-id="1426b-134">Значения свойств по умолчанию не изменяются.</span><span class="sxs-lookup"><span data-stu-id="1426b-134">Default values of properties are not coerced.</span></span> <span data-ttu-id="1426b-135">Значение свойства, равное значению по умолчанию, может произойти, если значение <xref:System.Windows.DependencyObject.ClearValue%2A>свойства все еще имеет свой первоначальный дефолт или через очистку других значений с помощью.</span><span class="sxs-lookup"><span data-stu-id="1426b-135">A property value equal to the default value might occur if a property value still has its initial default, or through clearing other values with <xref:System.Windows.DependencyObject.ClearValue%2A>.</span></span>  
  
 <span data-ttu-id="1426b-136">Обратные вызовы с привязкой к значению и обратные вызовы при изменении свойств являются частью метаданных свойства.</span><span class="sxs-lookup"><span data-stu-id="1426b-136">The coerce value and property changed callbacks are part of property metadata.</span></span> <span data-ttu-id="1426b-137">Вы можете изменить обратные вызовы для конкретного свойства зависимостей, так как оно задается типом, производным от типа, которому принадлежит свойство зависимостей, путем переопределения метаданных для этого свойства в типе.</span><span class="sxs-lookup"><span data-stu-id="1426b-137">Therefore, you can change the callbacks for a particular dependency property as it exists on a type that you derive from the type that owns the dependency property, by overriding the metadata for that property on your type.</span></span>  
  
<a name="Advanced"></a>
## <a name="advanced-coercion-and-callback-scenarios"></a><span data-ttu-id="1426b-138">Сценарии расширенного приведения и обратного вызова</span><span class="sxs-lookup"><span data-stu-id="1426b-138">Advanced Coercion and Callback Scenarios</span></span>  
  
### <a name="constraints-and-desired-values"></a><span data-ttu-id="1426b-139">Ограничения и требуемые значения</span><span class="sxs-lookup"><span data-stu-id="1426b-139">Constraints and Desired Values</span></span>  
 <span data-ttu-id="1426b-140">Обратные <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> вызовы будут использоваться системой свойств для принуждения к значению в соответствии с логикой, которую вы декларируете, но принудительное значение локально установленного свойства будет по-прежнему сохранять "желаемое значение" внутри.</span><span class="sxs-lookup"><span data-stu-id="1426b-140">The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> callbacks will be used by the property system to coerce a value in accordance to the logic you declare, but a coerced value of a locally set property will still retain a "desired value" internally.</span></span> <span data-ttu-id="1426b-141">Если ограничения зависят от других значений свойств, которые могут изменяться динамически во время работы приложения, приведенные ограничения будут также изменяться динамически, а ограниченное свойство может изменить свое значение, чтобы максимально приблизиться к требуемому значению с учетом новых ограничений.</span><span class="sxs-lookup"><span data-stu-id="1426b-141">If the constraints are based on other property values that may change dynamically during the application lifetime, the coercion constraints are changed dynamically also, and the constrained property can change its value to get as close to the desired value as possible given the new constraints.</span></span> <span data-ttu-id="1426b-142">Значение станет равно требуемому значению, если все ограничения будут сняты.</span><span class="sxs-lookup"><span data-stu-id="1426b-142">The value will become the desired value if all constraints are lifted.</span></span> <span data-ttu-id="1426b-143">При необходимости можно создать достаточно сложные сценарии зависимостей, если имеется, например, несколько свойств, которые циклически зависят друг от друга.</span><span class="sxs-lookup"><span data-stu-id="1426b-143">You can potentially introduce some fairly complicated dependency scenarios if you have multiple properties that are dependent on one another in a circular manner.</span></span> <span data-ttu-id="1426b-144">В сценарии, где имеется минимальное, максимальное и текущее значения, можно, например, сделать минимальное и максимальное значения определяемыми пользователем.</span><span class="sxs-lookup"><span data-stu-id="1426b-144">For instance, in the Min/Max/Current scenario, you could choose to have Minimum and Maximum be user settable.</span></span> <span data-ttu-id="1426b-145">В этом случае может потребоваться правило приведения, определяющее, что максимальное значение должно быть всегда больше минимального или наоборот.</span><span class="sxs-lookup"><span data-stu-id="1426b-145">If so, you might need to coerce that Maximum is always greater than Minimum and vice versa.</span></span> <span data-ttu-id="1426b-146">Но если приведение включено и максимальное значение приводится к минимальному, текущее значение остается в неопределенном состоянии, так как оно зависит от них обоих и ограничено диапазоном между ними, который равен нулю.</span><span class="sxs-lookup"><span data-stu-id="1426b-146">But if that coercion is active, and Maximum coerces to Minimum, it leaves Current in an unsettable state, because it is dependent on both and is constrained to the range between the values, which is zero.</span></span> <span data-ttu-id="1426b-147">С другой стороны, если максимальное или минимальное значение настраивается, текущее значение будет стремиться "отслеживать" одно из них. Это происходит из-за того, что для текущего значения сохраняется его требуемая величина и оно пытается достичь этой величины при ослаблении ограничений.</span><span class="sxs-lookup"><span data-stu-id="1426b-147">Then, if Maximum or Minimum are adjusted, Current will seem to "follow" one of the values, because the desired value of Current is still stored and is attempting to reach the desired value as the constraints are loosened.</span></span>  
  
 <span data-ttu-id="1426b-148">С технической реализацией сложных зависимостей нет проблем, но они могут ухудшить производительность, если для их осуществления потребуется выполнять большой объем вычислений. Кроме того, они могут вызвать недоумение у пользователей, если будут непосредственно влиять на пользовательский интерфейс.</span><span class="sxs-lookup"><span data-stu-id="1426b-148">There is nothing technically wrong with complex dependencies, but they can be a slight performance detriment if they require large numbers of reevaluations, and can also be confusing to users if they affect the UI directly.</span></span> <span data-ttu-id="1426b-149">Будьте внимательны при использовании обратных вызовов с привязкой к значению и обратных вызовов при изменении свойств и следите за тем, чтобы попытки приведения могли выполняться максимально однозначно, не вызывая "сверхограничений".</span><span class="sxs-lookup"><span data-stu-id="1426b-149">Be careful with property changed and coerce value callbacks and make sure that the coercion being attempted can be treated as unambiguously as possible, and does not "overconstrain".</span></span>  
  
### <a name="using-coercevalue-to-cancel-value-changes"></a><span data-ttu-id="1426b-150">Использование CoerceValue для отмены изменений значения</span><span class="sxs-lookup"><span data-stu-id="1426b-150">Using CoerceValue to Cancel Value Changes</span></span>  
 <span data-ttu-id="1426b-151">Система собственности будет <xref:System.Windows.CoerceValueCallback> рассматривать любой, который возвращает значение <xref:System.Windows.DependencyProperty.UnsetValue> как особый случай.</span><span class="sxs-lookup"><span data-stu-id="1426b-151">The property system will treat any <xref:System.Windows.CoerceValueCallback> that returns the value <xref:System.Windows.DependencyProperty.UnsetValue> as a special case.</span></span> <span data-ttu-id="1426b-152">Этот особый случай означает, что изменение <xref:System.Windows.CoerceValueCallback> свойства, которое привело к вызову, должно быть отклонено системой свойств, и что система свойств должна вместо этого сообщать о любой предыдущей стоимости свойства.</span><span class="sxs-lookup"><span data-stu-id="1426b-152">This special case means that the property change that resulted in the <xref:System.Windows.CoerceValueCallback> being called should be rejected by the property system, and that the property system should instead report whatever previous value the property had.</span></span> <span data-ttu-id="1426b-153">Этот механизм можно использовать для того, чтобы убедиться, что изменения свойства, инициированные асинхронно, все еще действительны для текущего состояния объекта, и, если это не так, запретить эти изменения.</span><span class="sxs-lookup"><span data-stu-id="1426b-153">This mechanism can be useful to check that changes to a property that were initiated asynchronously are still valid for the current object state, and suppress the changes if not.</span></span> <span data-ttu-id="1426b-154">Другой возможный сценарий. Вы можете выборочно запретить значения в зависимости от того, какой компонент определения значения свойства отвечает за переданное значение.</span><span class="sxs-lookup"><span data-stu-id="1426b-154">Another possible scenario is that you can selectively suppress a value depending on which component of property value determination is responsible for the value being reported.</span></span> <span data-ttu-id="1426b-155">Для этого можно использовать <xref:System.Windows.DependencyProperty> пройденное в обратном вызове и <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>идентификатор <xref:System.Windows.ValueSource>свойства в качестве ввода для, а затем обработать.</span><span class="sxs-lookup"><span data-stu-id="1426b-155">To do this, you can use the <xref:System.Windows.DependencyProperty> passed in the callback and the property identifier as input for <xref:System.Windows.DependencyPropertyHelper.GetValueSource%2A>, and then process the <xref:System.Windows.ValueSource>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1426b-156">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="1426b-156">See also</span></span>

- [<span data-ttu-id="1426b-157">Общие сведения о свойствах зависимости</span><span class="sxs-lookup"><span data-stu-id="1426b-157">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="1426b-158">Метаданные свойства зависимости</span><span class="sxs-lookup"><span data-stu-id="1426b-158">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="1426b-159">Пользовательские свойства зависимостей</span><span class="sxs-lookup"><span data-stu-id="1426b-159">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
