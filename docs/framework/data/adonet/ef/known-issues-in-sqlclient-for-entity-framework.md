---
title: Известные проблемы SqlClient для Entity Framework
ms.date: 03/30/2017
ms.assetid: 48fe4912-4d0f-46b6-be96-3a42c54780f6
ms.openlocfilehash: 32a1dd22111498ab5b3b75940f5485b2957367e8
ms.sourcegitcommit: 700ea803fb06c5ce98de017c7f76463ba33ff4a9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/19/2020
ms.locfileid: "77452504"
---
# <a name="known-issues-in-sqlclient-for-entity-framework"></a>Известные проблемы SqlClient для Entity Framework
В данном разделе описаны известные проблемы, связанные с поставщиком данных .NET Framework для SQL Server (SqlClient).  
  
## <a name="trailing-spaces-in-string-functions"></a>Конечные пробелы в строковых функциях  
 SQL Server игнорирует конечные пробелы в строковых значениях. Таким образом, передача конечных пробелов в строку может привести к непредсказуемым результатам и даже сбоям.  
  
 Если в строке должны находиться конечные пробелы, следует рассмотреть возможность добавления символа пробела в конец, чтобы SQL Server не обрезать строку. Если конечные пробелы не требуются, их следует усекать до их последующей передачи по конвейеру запросов.  
  
## <a name="right-function"></a>Функция RIGHT  
 Если в `null`, 0`RIGHT(nvarchar(max)` или `)`, 0`RIGHT(varchar(max)` в качестве первого аргумента передается значение, отличное от `)`, а в качестве второго аргумента передается значение, равное 0, то вместо строки `NULL` будет возвращено значение типа `empty`.  
  
## <a name="cross-and-outer-apply-operators"></a>Операторы CROSS APPLY и OUTER APPLY  
 Операторы пересечения и НАРУЖного применения появились в SQL Server 2005. В некоторых случаях конвейер запросов может сформировать инструкцию Transact-SQL, содержащую операторы CROSS APPLY и OUTER APPLY. Поскольку некоторые серверные поставщики, включая версии SQL Server более ранние, чем SQL Server 2005, не поддерживают эти операторы, такие запросы не могут выполняться на этих внутренних поставщиках.  
  
 Далее показаны некоторые стандартные сценарии, которые могут привести к появлению операторов CROSS APPLY и OUTER APPLY в выходном запросе.  
  
- Связанный вложенный запрос с разбиением на страницы.  
  
- `AnyElement` над коррелированным вложенным запросом или коллекцией, сформированной навигацией.  
  
- LINQ-запросы, использующие методы группирования, принимающие элемент selector.  
  
- Запрос, в котором явно указан оператор CROSS APPLY или OUTER APPLY.  
  
- Запрос, имеющий конструкцию DEREF над конструкцией REF.  
  
## <a name="skip-operator"></a>Оператор SKIP  
 Если используется SQL Server 2000, использование инструкции SKIP с предложением ORDER BY в неключевых столбцах может привести к возврату неверных результатов. Если неключевой столбец содержит повторяющиеся данные, то может быть пропущено больше указанного числа строк. Это происходит из-за преобразования SKIP для SQL Server 2000. Например, в следующем запросе более пяти строк может быть пропущено, если `E.NonKeyColumn` содержит дублирующиеся значения:  
  
```sql  
SELECT [E] FROM Container.EntitySet AS [E] ORDER BY [E].[NonKeyColumn] DESC SKIP 5L  
```  
  
## <a name="targeting-the-correct-sql-server-version"></a>Нацеливание на правильную версию SQL Server  
 Entity Framework предназначен для запроса Transact-SQL на основе версии SQL Server, указанной в атрибуте `ProviderManifestToken` элемента Schema в файле модели хранения (. SSDL). Данная версия может отличаться от фактической версии SQL Server, с которой в данный момент осуществлено соединение. Например, если используется SQL Server 2005, но атрибут `ProviderManifestToken` имеет значение 2008, то созданный запрос Transact-SQL может не выполняться на сервере. Например, запрос, который использует новые типы даты и времени, представленные в SQL Server 2008, не будет выполняться в предыдущих версиях SQL Server. Если используется SQL Server 2005, но для атрибута `ProviderManifestToken` задано значение 2000, то созданный запрос Transact-SQL может быть менее оптимизирован или может возникнуть исключение, сообщающее, что запрос не поддерживается. Дополнительные сведения см. в разделе «Операторы CROSS и OUTER APPLY», приведенном выше в данной теме.  
  
 Некоторые варианты поведения базы данных зависят от уровня совместимости, установленного на базе данных. Если для атрибута `ProviderManifestToken` задано значение 2005 и версия SQL Server 2005, но для уровня совместимости базы данных задано значение "80" (SQL Server 2000), созданный Transact-SQL будет нацеливанием на SQL Server 2005, но может не выполняться должным образом из-за настройки уровня совместимости. Например, если имя столбца в списке ORDER BY совпадает с именем столбца в селекторе, то можно потерять данные об упорядочивании.  
  
## <a name="nested-queries-in-projection"></a>Вложенные запросы в проекции  
 Вложенные запросы в предложении проекции могут быть переведены в запросы декартовых произведений на сервере. На некоторых внутренних серверах, в том числе SQL Server, это может привести к тому, что таблица TempDB будет иметь довольно большой размер. Это может снизить производительность сервера.  
  
 Далее приведен пример вложенного запроса в предложении проекции:  
  
```sql  
SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2 FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1 FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
```  
  
## <a name="server-generated-guid-identity-values"></a>Формируемые сервером значения идентификаторов GUID  
 Entity Framework поддерживает генерируемые сервером значения идентификаторов типа GUID, но поставщик должен поддерживать возврат сформированного сервером значения идентификатора после вставки строки. Начиная с SQL Server 2005, можно вернуть созданный сервером тип GUID в базе данных SQL Server с помощью [предложения OUTPUT](/sql/t-sql/queries/output-clause-transact-sql).
  
## <a name="see-also"></a>См. также раздел

- [SqlClient для Entity Framework](sqlclient-for-the-entity-framework.md)
- [Рекомендации и известные проблемы в LINQ to Entities](./language-reference/known-issues-and-considerations-in-linq-to-entities.md)
