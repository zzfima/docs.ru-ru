---
title: Создание кода SQL из деревьев команд. Рекомендации
ms.date: 03/30/2017
ms.assetid: 71ef6a24-4c4f-4254-af3a-ffc0d855b0a8
ms.openlocfilehash: 869722b91550855a184a74e706271c3e2d417b84
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73040002"
---
# <a name="generating-sql-from-command-trees---best-practices"></a>Создание кода SQL из деревьев команд. Рекомендации

Деревья команд выходного запроса по своей структуре близки к моделям запросов, выражаемым на языке SQL. Однако модули записи поставщика при создании кода SQL на основе дерева команд выходного запроса сталкиваются с некоторыми распространенными проблемами. Они обсуждаются в данном разделе. В следующем разделе приводится образец поставщика, показывающий решение этих проблем.

## <a name="group-dbexpression-nodes-in-a-sql-select-statement"></a>Группирование узлов DbExpression в инструкции SELECT языка SQL

Типичная инструкция SQL имеет вложенную структуру следующего вида:

```sql
SELECT …
FROM …
WHERE …
GROUP BY …
ORDER BY …
```

Одно или несколько предложений могут быть пустыми.  Вложенная инструкция SELECT может находиться в любой строке.

Результат преобразования дерева команд запроса в инструкцию SELECT языка SQL будет содержать по одному подзапросу на каждый реляционный оператор. Однако это приведет к возникновению излишних вложенных запросов, и в результате инструкцию будет трудно читать.  В некоторых хранилищах данных производительность такого запроса будет низкой.

В качестве примера рассмотрим следующее дерево команд запроса:

```csharp
Project (
a.x,
   a = Filter(
      b.y = 5,
      b = Scan("TableA")
   )
)
```

Неэффективное преобразование даст нам:

```sql
SELECT a.x
FROM (   SELECT *
         FROM TableA as b
         WHERE b.y = 5) as a
```

Заметьте, что каждый узел реляционного выражения превращается в отдельную инструкцию SELECT языка SQL.

Следовательно, важно агрегировать как можно больше узлов выражений в одну инструкцию SELECT языка SQL, не нарушая правильности инструкции.

Результат такого агрегирования для приведенного выше примера будет иметь следующий вид:

```sql
SELECT b.x
FROM TableA as b
WHERE b.y = 5
```

## <a name="flatten-joins-in-a-sql-select-statement"></a>Уплощение соединений в инструкции SELECT языка SQL

Частным случаем агрегирования нескольких узлов в одну инструкцию SELECT языка SQL является агрегирование нескольких выражений соединения. Класс DbJoinExpression представляет одно соединение между двумя исходными таблицами. Но в одной инструкции SELECT языка SQL можно задать несколько соединений. В этом случае соединения выполняются в порядке, в котором они указаны.

Левосторонние соединения (которые выглядят как левые дочерние другого соединения) проще сделать плоскими и превратить в одну инструкцию SELECT языка SQL. В качестве примера рассмотрим следующее дерево команд запроса:

```csharp
InnerJoin(
   a = LeftOuterJoin(
   b = Extent("TableA")
   c = Extent("TableB")
   ON b.y = c.x ),
   d = Extent("TableC")
   ON a.b.y = d.z
)
```

Оно верно переводится в следующую инструкцию:

```sql
SELECT *
FROM TableA as b
LEFT OUTER JOIN TableB as c ON b.y = c.x
INNER JOIN TableC as d ON b.y = d.z
```

Однако соединения, не являющиеся левосторонними соединениями, невозможно легко превратить в плоскую структуру, и не следует пытаться это сделать. В качестве примера рассмотрим соединения в следующем дереве команд запроса:

```csharp
InnerJoin(
   a = Extent("TableA")
   b = LeftOuterJoin(
   c = Extent("TableB")
   d = Extent("TableC")
   ON c.y = d.x),
   ON a.z = b.c.y
)
```

Это дерево будет преобразовано в инструкцию SELECT языка SQL с подзапросом.

```sql
SELECT *
FROM TableA as a
INNER JOIN (SELECT *
   FROM TableB as c
   LEFT OUTER JOIN TableC as d
   ON c.y = d.x) as b
ON b.y = d.z
```

## <a name="input-alias-redirecting"></a>Перенаправление входных псевдонимов

Чтобы понять, что представляет собой перенаправление входных псевдонимов, рассмотрим структуру реляционных выражений, таких как DbFilterExpression, DbProjectExpression, DbCrossJoinExpression, DbJoinExpression, DbSortExpression, DbGroupByExpression, DbApplyExpression и DbSkipExpression.

Каждый из этих типов имеет одно или несколько свойств Input, описывающих входную коллекцию; для представления каждого элемента этого входа во время обхода коллекции используется переменная привязки, соответствующая данному элементу. Переменная привязки используется для ссылки на входной элемент, например в свойстве Predicate выражения DbFilterExpression или свойстве Projection выражения DbProjectExpression.

При агрегировании большего числа узлов реляционных выражений в одну инструкцию SELECT языка SQL и вычислении выражения, являющегося частью реляционного выражения (например, свойства Projection выражения DbProjectExpression), используемая переменная привязки может не совпадать с псевдонимом входного значения, так как несколько привязок выражений будут перенаправлены в один и тот же экстент.  Эта проблема называется переименованием псевдонимов.

Рассмотрим первый пример данного раздела. При примитивном преобразовании Projection a.x (DbPropertyExpression(a, x)) правильно будет преобразовать в `a.x`, поскольку мы создали псевдоним входного значения «a» для соответствия переменной привязки.  Однако при агрегировании обоих узлов в единую инструкцию SELECT языка SQL то же выражение DbPropertyExpression следует преобразовать в `b.x`, так как для входного значения был задан псевдоним «b».

## <a name="join-alias-flattening"></a>Преобразование псевдонимов соединений в плоские

В отличие от любых других реляционных выражений в дереве выходных команд, результирующим типом для выражения DbJoinExpression является строка, состоящая из двух столбцов, каждый из которых соответствует одному из входов. При построении Дбпропертекспрессион для доступа к скалярному свойству, полученному из объединения, оно находится над другим Дбпропертекспрессион.

Например, можно указать «a.b.y» в примере 2 и «b.c.y» в примере 3. Однако в соответствующих инструкциях SQL они именуются «b.y». Такое присвоение новых псевдонимов называется уплощением псевдонимов соединений.

## <a name="column-name-and-extent-alias-renaming"></a>Переименование столбцов и псевдонимов экстентов

Если запрос SELECT языка SQL, содержащий соединение, должен быть выполнен в проекции, то при перечислении всех участвующих в запросе столбцов из входных таблиц может произойти коллизия имен, так как имена столбцов во входных таблицах могут совпадать. Чтобы избежать коллизии, следует использовать для столбца другое имя.

Кроме того, при уплощении соединений участвующие в запросе таблицы (или вложенные запросы) могут содержать конфликтующие псевдонимы. В таком случае эти псевдонимы следует переименовать.

## <a name="avoid-select-"></a>Предотвращение применения инструкции SELECT *

Не следует использовать оператор `SELECT *` для выборки из базовых таблиц. Модель хранения в Entity Framework приложении может включать только подмножество столбцов, которые находятся в таблице базы данных. В этом случае оператор `SELECT *` может выдать неверный результат. Вместо этого следует указать все столбцы, участвующие в запросе, по именам столбцов из результирующего типа выражений, участвующих в запросе.

## <a name="reuse-of-expressions"></a>Повторное использование выражений

Выражения можно повторно использовать в дереве команд запроса, переданном Entity Framework. Не следует предполагать, что каждое выражение появляется в дереве команд запроса только один раз.

## <a name="mapping-primitive-types"></a>Сопоставление примитивных типов

При сопоставлении концептуальных типов (типов модели EDM) с типами поставщика следует проводить сопоставление с самым большим типом (Int32), чтобы поместились все возможные значения. Кроме того, Избегайте сопоставления с типами, которые не могут использоваться для многих операций, таких как типы больших двоичных объектов (например, `ntext` в SQL Server).

## <a name="see-also"></a>См. также

- [Создание SQL](sql-generation.md)
