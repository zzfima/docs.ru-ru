---
title: Сведения о производительности (Entity Framework)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 2b116a22c0f422377246d8cc0b2d647fd78a289b
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2019
ms.locfileid: "73039858"
---
# <a name="performance-considerations-entity-framework"></a>Сведения о производительности (Entity Framework)
В этом подразделе описаны характеристики производительности платформы ADO.NET Entity Framework, а также приведены соображения по повышению производительности приложений платформы Entity Framework.  
  
## <a name="stages-of-query-execution"></a>Этапы выполнения запросов  
 Чтобы лучше понять специфику производительности запросов платформы Entity Framework, необходимо разобраться с операциями, которые совершаются при выполнении запроса к концептуальной модели и при возврате данных в виде объектов. В следующей таблице описан этот ряд операций.  
  
|Операция|Относительные затраты|Частота|Комментарии|  
|---------------|-------------------|---------------|--------------|  
|Загрузка метаданных|Средняя|По одному разу в каждом домене приложения.|Метаданные модели и сопоставления, используемые платформой Entity Framework, загружаются в <xref:System.Data.Metadata.Edm.MetadataWorkspace>. Эти метаданные собираются глобально и доступны другим экземплярам <xref:System.Data.Objects.ObjectContext> в том же домене приложения.|  
|Открытие подключения базы данных|Умеренный<sup>1</sup>|При необходимости.|Поскольку открытое подключение к базе данных потребляет ценный ресурс, Entity Framework открывается и закрывает подключение к базе данных по мере необходимости. Кроме того, соединение можно открыть явно. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).|  
|Создание представлений...|High|По одному разу в каждом домене приложения. (могут создаваться предварительно.)|Прежде чем платформа Entity Framework сможет выполнять запросы к концептуальной модели или сохранять изменения в источнике данных, ей необходимо создать набор локальных представлений запросов для доступа к базе данных. В связи с высокими затратами на создание этих представлений их можно создать заранее и добавить в проект во время разработки. Дополнительные сведения см. в разделе [как предварительно создавать представления для повышения производительности запросов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).|  
|Подготовка запроса|Умеренное<sup>2</sup>|Один раз для каждого уникального запроса.|Включает затраты на создание команды запроса, создание дерева команд на базе метаданных модели и сопоставления, а также определение вида возвращаемых данных. Теперь как команды запросов Entity SQL, так и запросы LINQ кэшируются, поэтому при последующем выполнении один и тот же запрос занимает еще меньше времени. Можно по-прежнему использовать скомпилированные запросы LINQ для снижения затрат при последующем выполнении, и скомпилированные запросы могут быть более эффективными, чем запросы LINQ, которые автоматически сохраняются в кэше. Дополнительные сведения см. в разделе [скомпилированные запросы (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md). Общие сведения о выполнении запросов LINQ см. в разделе [LINQ to Entities](./language-reference/linq-to-entities.md). **Примечание.**  Запросы LINQ to Entities, которые применяют оператор `Enumerable.Contains` к коллекциям в памяти, не кэшируются автоматически. Также в скомпилированных запросах LINQ не допускаются коллекции в памяти с параметрами.|  
|Выполнение запроса|Низкое<sup>2</sup>|Один раз для каждого запроса.|Затраты на выполнение команды к источнику данных с помощью поставщика данных ADO.NET. Поскольку большинство источников данных кэширует планы запросов, при последующем выполнении один и тот же запрос может занимать меньше времени.|  
|Загрузка и проверка типов|Низкое<sup>3</sup>|Один раз для каждого элемента <xref:System.Data.Objects.ObjectContext>.|Типы загружаются и проверяются относительно типов, определенных в концептуальной модели.|  
|Отслеживание|Низкое<sup>3</sup>|Один раз для каждого объекта, возвращаемого запросом. <sup>4</sup>|Если запрос использует параметр слияния <xref:System.Data.Objects.MergeOption.NoTracking>, то этот шаг не влияет на производительность.<br /><br /> Если запрос использует параметры слияния <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges> или <xref:System.Data.Objects.MergeOption.OverwriteChanges>, то результаты запроса отслеживаются в <xref:System.Data.Objects.ObjectStateManager>. Для каждого отслеживаемого объекта, возвращаемого запросом, создается ключ <xref:System.Data.EntityKey>, который используется для создания <xref:System.Data.Objects.ObjectStateEntry> в <xref:System.Data.Objects.ObjectStateManager>. Если для <xref:System.Data.Objects.ObjectStateEntry> можно найти существующий объект <xref:System.Data.EntityKey>, то возвращается существующий объект. Если используется параметр <xref:System.Data.Objects.MergeOption.PreserveChanges> или <xref:System.Data.Objects.MergeOption.OverwriteChanges>, то объект обновляется до возвращения.<br /><br /> Дополнительные сведения см. в разделе [разрешение удостоверений, управление состоянием и отслеживание изменений](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).|  
|Материализация объектов|Умеренное<sup>3</sup>|Один раз для каждого объекта, возвращаемого запросом. <sup>4</sup>|Процесс считывания возвращенного объекта <xref:System.Data.Common.DbDataReader>, создания объектов и установки значений свойств, основанных на значениях в каждом экземпляре класса <xref:System.Data.Common.DbDataRecord>. Если объект уже существует в классе <xref:System.Data.Objects.ObjectContext> и в запросе используются параметры слияния <xref:System.Data.Objects.MergeOption.AppendOnly> или <xref:System.Data.Objects.MergeOption.PreserveChanges>, то этот шаг не влияет на производительность. Дополнительные сведения см. в разделе [разрешение удостоверений, управление состоянием и отслеживание изменений](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).|  
  
 <sup>1</sup> если поставщик источника данных реализует пулы соединений, стоимость открытия соединения распределяется по пулу. Поставщик .NET для SQL Server поддерживает организацию пулов соединений.  
  
 <sup>2</sup> увеличение стоимости с повышением сложности запросов.  
  
 <sup>3</sup> Общая стоимость увеличивается пропорционально количеству объектов, возвращаемых запросом.  
  
 <sup>4</sup> эти затраты не требуются для запросов EntityClient, так как запросы EntityClient возвращают <xref:System.Data.EntityClient.EntityDataReader> вместо объектов. Дополнительные сведения см. [в разделе Поставщик EntityClient для Entity Framework](entityclient-provider-for-the-entity-framework.md).  
  
## <a name="additional-considerations"></a>Дополнительные сведения  
 Ниже приведены дополнительные соображения по факторам, способным влиять на производительность приложений Entity Framework.  
  
### <a name="query-execution"></a>Выполнение запроса  
 Поскольку запросы могут быть ресурсоемкими, учитывайте, в каком участке кода и на каком компьютере выполняется запрос.  
  
#### <a name="deferred-versus-immediate-execution"></a>Отложенное или немедленное выполнение  
 При создании запроса <xref:System.Data.Objects.ObjectQuery%601> или LINQ запрос может выполняться не сразу. Выполнение запроса откладывается до тех пор, пока не понадобятся его результаты, например результаты перечисления `foreach` (C#) или `For Each` (Visual Basic), либо если запрос должен заполнить коллекцию <xref:System.Collections.Generic.List%601>. Выполнение запроса начинается немедленно при вызове метода <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> в <xref:System.Data.Objects.ObjectQuery%601> либо при вызове метода LINQ, возвращающего одноэлементный запрос, например <xref:System.Linq.Enumerable.First%2A> или <xref:System.Linq.Enumerable.Any%2A>. Дополнительные сведения см. в разделе [запросы объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) и [выполнение запросов (LINQ to Entities)](./language-reference/query-execution.md).  
  
#### <a name="client-side-execution-of-linq-queries"></a>Выполнение запросов LINQ на стороне клиента  
 Хотя запрос LINQ выполняется на том компьютере, где размещен источник данных, некоторые части запроса LINQ могут обрабатываться на клиентском компьютере. Дополнительные сведения см. в разделе Выполнение [запроса хранилища (LINQ to Entities)](./language-reference/query-execution.md).  
  
### <a name="query-and-mapping-complexity"></a>Сложность запросов и сопоставления  
 Сложность отдельных запросов и сопоставления в модели сущности значительно влияет на производительность запросов.  
  
#### <a name="mapping-complexity"></a>Сложность сопоставления  
 Модели, более сложные, чем простое однозначное сопоставление между сущностями в концептуальной модели и таблицах в режиме хранилища, приводят к созданию более сложных команд, чем модели с однозначным сопоставлением.  
  
#### <a name="query-complexity"></a>Сложность запросов  
 Запросы, требующие большого числа соединений в командах, выполняемых с источником данных или возвращающих большой объем данных, могут влиять на производительность следующим образом:  
  
- Запросы к концептуальной модели, которые кажутся простыми, могут приводить к выполнению более сложных запросов к источнику данных. Это может происходить как следствие преобразования платформой Entity Framework запроса к концептуальной модели в эквивалентный запрос к источнику данных. Если один набор сущностей, заданный в концептуальной модели, сопоставляется с несколькими таблицами источника данных либо если связь между сущностями сопоставлена с соединяемой таблицей, то команда запроса к источнику данных может потребовать одного или нескольких соединений.  
  
    > [!NOTE]
    > Чтобы просмотреть команды, выполняемые по источнику данных для данного запроса, воспользуйтесь методом <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> классов <xref:System.Data.Objects.ObjectQuery%601> или <xref:System.Data.EntityClient.EntityCommand>. Дополнительные сведения см. в разделе [практические руководства. Просмотр команд Store](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).  
  
- Вложенные запросы Entity SQL могут создавать соединения на сервере, а также возвращать большое количество строк.  
  
     Далее приведен пример вложенного запроса в предложении проекции:  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2   
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1   
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     Кроме того, подобные запросы заставляют конвейер запросов создавать одиночный запрос с дублированием объектов во вложенных запросах. В результате одиночный столбец может дублироваться несколько раз. В некоторых базах данных, в том числе SQL Server, это может приводить к чрезмерному значительному разрастанию таблицы TempDB, что снижает производительность сервера. Вложенные запросы следует выполнять с осторожностью.  
  
- Любые запросы, возвращающие большие объемы данных, могут снижать производительность, если клиент выполняет операции, использующие ресурсы пропорционально объему результирующего набора. В таких случаях, возможно, стоит ограничить объем данных, возвращаемых запросом. Дополнительные сведения см. [в разделе инструкции. Просмотр результатов запроса](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).  
  
 Любые команды, автоматически созданные платформой Entity Framework, могут оказываться сложнее аналогичных команд, написанных вручную разработчиком базы данных. Если требуется явный контроль над командами, выполняемыми с источником данных, подумайте об определении сопоставления с возвращающей табличное значение функцией или хранимой процедурой.  
  
#### <a name="relationships"></a>Отношения  
 Для оптимальной производительности запросов необходимо определить связи между сущностями как в виде ассоциаций в модели сущности, так и в виде логических связей в источнике данных.  
  
### <a name="query-paths"></a>Пути запроса  
 По умолчанию при выполнении запроса <xref:System.Data.Objects.ObjectQuery%601> связанные объекты не возвращаются (хотя возвращаются объекты, представляющие сами связи). Связанные объекты можно загрузить одним из трех способов.  
  
1. Задайте путь запроса до выполнения <xref:System.Data.Objects.ObjectQuery%601>.  
  
2. Вызовите метод `Load` для свойства навигации, доступного для объекта.  
  
3. Установите параметр <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> объекта <xref:System.Data.Objects.ObjectContext> в значение `true`. Обратите внимание, что это происходит автоматически при создании кода уровня объекта с помощью [конструктора EDM](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)). Дополнительные сведения см. в разделе [Обзор сформированного кода](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).  
  
 При выборе параметра помните, что придется соблюдать баланс между числом запросов к базе данных и объемом данных, возвращаемых в одном запросе. Дополнительные сведения см. в разделе [Загрузка связанных объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).  
  
#### <a name="using-query-paths"></a>Использование путей запроса  
 Пути запроса определяют граф объектов, возвращаемых запросом. При указании пути запроса для возврата всех определенных в нем объектов требуется только один запрос к базе данных. Использование путей запроса может привести к тому, что над источником данных будут выполняться сложные команды из, на первый взгляд, простых запросов к объектам. Происходит это потому, что для возвращения связанных объектов в рамках одного запроса требуется одно или несколько соединений. Сложность будет выше в запросах к сложным моделям сущностей, таким как, например, сущность с наследованием или путь, содержащий связи «многие ко многим».  
  
> [!NOTE]
> Используйте метод <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A>, чтобы увидеть команду, которая будет сформирована методом <xref:System.Data.Objects.ObjectQuery%601>. Дополнительные сведения см. в разделе [практические руководства. Просмотр команд Store](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).  
  
 Когда путь запроса содержит слишком много связанных объектов или эти объекты содержат слишком много строковых данных, источник данных может оказаться не в состоянии выполнить запрос. Это происходит, если запросу требуется промежуточное временное хранилище, которое превышает возможности источника данных. В этом случае можно снизить сложность запроса к источнику данных путем явной загрузки связанных объектов.  
  
#### <a name="explicitly-loading-related-objects"></a>Явная загрузка связанных объектов  
 Явно загрузить связанные объекты можно, вызвав метод `Load` для свойства навигации, возвращающего <xref:System.Data.Objects.DataClasses.EntityCollection%601> или <xref:System.Data.Objects.DataClasses.EntityReference%601>. При явной загрузке объектов требуется выполнять цикл обмена данными с базой данных при каждом вызове метода `Load`.  
  
> [!NOTE]
> Если при циклической обработке коллекции возвращенных объектов, например при использовании инструкции `Load` (`foreach` в Visual Basic), вызывается метод `For Each`, поставщик для каждого конкретного источника данных должен поддерживать несколько активных результирующих наборов на одном соединении. Для базы данных SQL Server в строке подключения поставщика необходимо указать значение `MultipleActiveResultSets = true`.  
  
 Можно также использовать метод <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, если сущности не имеют свойств <xref:System.Data.Objects.DataClasses.EntityCollection%601> и <xref:System.Data.Objects.DataClasses.EntityReference%601>. Это может оказаться полезным в том случае, если используются сущности POCO.  
  
 Хотя явная загрузка связанных объектов сократит число соединений и объем избыточных данных, метод `Load` потребует повторного соединения к базе данных, что может привести к повышении накладных расходов при загрузке большого числа объектов.  
  
### <a name="saving-changes"></a>Сохранение изменений  
 При вызове метода <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> для <xref:System.Data.Objects.ObjectContext> для каждого добавленного, обновленного или удаленного объекта в контексте создается отдельная команда создания, обновления или удаления. Эти команды выполняются для источника данных в единой транзакции. Как и в случае с запросами, производительность операций создания, обновления и удаления зависит от сложности сопоставления в концептуальной модели.  
  
### <a name="distributed-transactions"></a>Распределенные транзакции  
 Операции в явной транзакции, требующие ресурсов, управляемых координатором распределенных транзакций (DTC), будут гораздо затратнее, чем схожая операция, не требующая его использования. Повышение уровня явных транзакций до DTC будет происходить в следующих случаях.  
  
- Явная транзакция с операцией для базы данных SQL Server 2000 или другого источника данных, который всегда повышает уровень явных транзакций до DTC.  
  
- Явная транзакция с операцией с SQL Server 2005, если соединение управляется Entity Framework. Это происходит потому, что SQL Server 2005 повышает уровень DTC при каждом закрытии и повторном открытии соединения в рамках одной транзакции, что является поведением по умолчанию для Entity Framework. Такое повышение уровня до DTC не происходит при использовании SQL Server 2008. Чтобы избежать такого повышения уровня при работе с SQL Server 2005, необходимо явно открывать и закрывать соединение в пределах одной транзакции. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).  
  
 Явная транзакция используется, если в пределах транзакции <xref:System.Transactions> выполняется одна или несколько операций. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).  
  
## <a name="strategies-for-improving-performance"></a>Стратегии повышения производительности  
 Ниже перечислены методики, позволяющие повысить общую производительность запросов платформы Entity Framework.  
  
#### <a name="pre-generate-views"></a>Предварительное создание представлений  
 Создание представлений на базе модели сущностей - это значительная статья расходов при первом выполнении запроса приложением. С помощью программы EdmGen.exe можно заранее создавать представления в виде файлов с кодом Visual Basic или C#, которые будут добавляться в проект во время проектирования. Можно также использовать средства преобразования текстовых шаблонов для создания представлений до компиляции. Предварительно созданные представления во время выполнения будут проверяться на согласованность с текущей версией указанной модели сущностей. Дополнительные сведения см. в разделе [как предварительно создавать представления для повышения производительности запросов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).
  
 При работе с очень большими моделями нужно принимать во внимание следующие соображения.  
  
 Формат метаданных .NET ограничивает число символов пользовательской строки в заданном двоичном блоке до 16 777 215 (0xFFFFFF). Если вы создаете представления для очень большой модели, а файл представления достигает этого предельного размера, вы получаете "нет логического пространства для создания дополнительных пользовательских строк". Ошибка компиляции. Это ограничение имеет силу для всех управляемых библиотек. Дополнительные сведения см. в [блоге](https://go.microsoft.com/fwlink/?LinkId=201476) , в котором показано, как избежать ошибки при работе с большими и сложными моделями.  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a>Рассмотрите возможность использования параметра слияния NoTracking для запросов  
 Для отслеживания возвращаемых объектов в контексте объекта требуются определенные затраты. Для распознавания изменений в объектах и гарантии того, что несколько запросов к одной логической сущности возвратят один экземпляр объекта, требуется, чтобы объекты были присоединены к экземпляру <xref:System.Data.Objects.ObjectContext>. Если вы не планируете выполнять обновления или удаления объектов и не требуется управление удостоверениями, рассмотрите возможность использования параметров слияния <xref:System.Data.Objects.MergeOption.NoTracking> при выполнении запросов.  
  
#### <a name="return-the-correct-amount-of-data"></a>Возвращение правильного объема данных  
 В некоторых случаях указание пути запроса с помощью метода <xref:System.Data.Objects.ObjectQuery%601.Include%2A> выполняется гораздо быстрее, поскольку требуется меньше циклов обмена данными с базой данных. Однако в других сценариях дополнительные циклы обмена данными с базой данных при загрузке связанных объектов могут выполняться быстрее, поскольку более простые запросы с меньшим количеством соединений ведут к меньшей избыточности данных. В связи с этим рекомендуется проверять производительность разных способов получения связанных объектов. Дополнительные сведения см. в разделе [Загрузка связанных объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).  
  
 Чтобы избежать возвращения слишком большого объема данных в одном запросе, можно прибегнуть к подкачке страниц результатов запроса, что даст более простые в управлении группы. Дополнительные сведения см. [в разделе инструкции. Просмотр результатов запроса](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a>Ограничение области объекта ObjectContext  
 В большинстве случаев следует создавать экземпляр <xref:System.Data.Objects.ObjectContext> внутри инструкции `using` (`Using…End Using` в Visual Basic). Это может повысить производительность, поскольку гарантирует автоматическое удаление ресурсов, связанных с контекстом объекта, при выходе из блока инструкции в коде. Однако, если элементы управления привязаны к объектам, управляемым контекстом объекта, экземпляр <xref:System.Data.Objects.ObjectContext> следует сохранять до тех пор, пока требуется привязка, а удалять его - вручную. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).  
  
#### <a name="consider-opening-the-database-connection-manually"></a>Рассмотрите возможность подключения базы данных вручную  
 Когда приложение выполняет ряд запросов объектов или часто вызывает <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> для сохранения операций создания, обновления и удаления в источнике данных, Entity Framework должны постоянно открываться и закрывать соединение с источником данных. В таких случаях следует попробовать вручную открывать соединение в начале этих операций и либо закрывать, либо удалять соединение по их завершении. Дополнительные сведения см. в разделе [Управление соединениями и транзакциями](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).  
  
## <a name="performance-data"></a>Данные производительности  
 Некоторые данные о производительности для Entity Framework публикуются в следующих сообщениях в [блоге группы разработчиков ADO.NET](https://go.microsoft.com/fwlink/?LinkId=91905):  
  
- [Изучение производительности ADO.NET Entity Framework. часть 1](https://go.microsoft.com/fwlink/?LinkId=123907)  
  
- [Изучение производительности ADO.NET Entity Framework – часть 2](https://go.microsoft.com/fwlink/?LinkId=123909)  
  
- [Сравнение производительности ADO.NET Entity Framework](https://go.microsoft.com/fwlink/?LinkID=123913)  
  
## <a name="see-also"></a>См. также

- [Вопросы разработки и развертывания](development-and-deployment-considerations.md)
