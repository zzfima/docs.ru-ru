---
title: Вопросы безопасности (Entity Framework)
ms.date: 03/30/2017
ms.assetid: 84758642-9b72-4447-86f9-f831fef46962
ms.openlocfilehash: e2e1fc75049d41b50aa59092fe1aa21e8cdab659
ms.sourcegitcommit: 700ea803fb06c5ce98de017c7f76463ba33ff4a9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/19/2020
ms.locfileid: "77452491"
---
# <a name="security-considerations-entity-framework"></a>Вопросы безопасности (Entity Framework)
В этом разделе описываются вопросы безопасности, связанные с разработкой, развертыванием и запуском приложений Entity Framework. Также следует следовать рекомендациям по созданию безопасных приложений .NET Framework. Дополнительные сведения см. в [обзоре безопасности](../security-overview.md).  
  
## <a name="general-security-considerations"></a>Общие соображения безопасности  
 Следующие вопросы безопасности относятся ко всем приложениям, использующим Entity Framework.  
  
#### <a name="use-only-trusted-data-source-providers"></a>Использование только доверенных поставщиков источников данных.  
 Для обеспечения связи с источником данных поставщик должен выполнить следующие действия:  
  
- Получение строки подключения из Entity Framework.  
  
- перевести дерево команд на собственный язык запросов источника данных;  
  
- собрать и возвратить результирующие наборы.  
  
 Во время операции входа в систему сведения, полученные с помощью пароля пользователя, передаются на сервер через сетевые библиотеки базового источника данных. Злонамеренный поставщик может похитить учетные данные пользователя, сформировать вредоносные запросы или внести несанкционированные изменения в результирующий набор.  
  
#### <a name="encrypt-your-connection-to-protect-sensitive-data"></a>Шифрование соединения для защиты конфиденциальных данных  
 Entity Framework не обрабатывает шифрование данных напрямую. Если пользователи получают доступ к данным через открытую сеть, то в приложении для повышения безопасности необходимо устанавливать зашифрованное соединение с источником данных. Дополнительные сведения см. в документации источника данных, связанной с безопасностью. Сведения об источнике данных SQL Server см. [в разделе Шифрование соединений для SQL Server](https://docs.microsoft.com/previous-versions/sql/sql-server-2008-r2/ms189067(v=sql.105)).  
  
#### <a name="secure-the-connection-string"></a>Защита строки соединения  
 Защита доступа к источникам данным - одна из важнейших целей защиты приложения. Строка соединения потенциально уязвима, если не защищена или не сформирована должным образом. Хранение сведений о соединении в виде простого текста или хранение их в памяти представляет угрозу безопасности для всей системы. Ниже представлены рекомендуемые методы защиты строки соединения.  
  
- При соединении с источником данных SQL Server используйте проверку подлинности Windows.  
  
     При использовании проверки подлинности Windows для соединения с источником данных SQL Server строка соединения не содержит сведений об имени входа и пароле.  
  
- Шифрование разделов файла конфигурации с использованием защищенной конфигурации.  
  
     В ASP.NET 2.0 предоставляется возможность, известная как защищенная конфигурация, которая позволяет шифровать конфиденциальные сведения в файле конфигурации. Безусловно, защищенная конфигурация разрабатывалась в первую очередь для ASP.NET, но ее можно также использовать для шифрования разделов файлов конфигурации в приложениях Windows. Подробное описание новых возможностей защищенной конфигурации см. в разделе [Шифрование сведений о конфигурации с помощью защищенной конфигурации](https://docs.microsoft.com/previous-versions/aspnet/53tyfkaw(v=vs.100)).  
  
- Хранение строк соединения в защищенных файлах конфигурации.  
  
     Строку соединения ни в коем случае нельзя внедрять в исходный код. Строки соединения можно хранить в файлах конфигурации, что исключает необходимость внедрять их в код приложения. По умолчанию мастер моделей EDM хранит строки соединения в файле конфигурации приложения. Этот файл необходимо защитить от несанкционированного доступа.  
  
- Использование построителей строки соединения при динамическом создании соединений.  
  
     Если строки соединения необходимо конструировать во время выполнения, используется класс <xref:System.Data.EntityClient.EntityConnectionStringBuilder>. Этот класс построителя строк соединения помогает предотвратить атаки внедрения кода путем проверки входных данных и экранирования недопустимых данных. Дополнительные сведения см. [в разделе инструкции. Создание строки подключения EntityConnection](how-to-build-an-entityconnection-connection-string.md). Кроме того, используйте соответствующий класс построителя строк для создания строки подключения к источнику данных, которая является частью строки подключения Entity Framework. Дополнительные сведения о построителях строк подключения для поставщиков ADO.NET см. в разделе [построители строк подключения](../connection-string-builders.md).  
  
 Дополнительные сведения см. в разделе [Защита сведений о подключении](../protecting-connection-information.md).  
  
#### <a name="do-not-expose-an-entityconnection-to-untrusted-users"></a>Не следует предоставлять доступ к объекту EntityConnection пользователям, не заслуживающим доверия  
 Объект <xref:System.Data.EntityClient.EntityConnection> отображает строку соединения базового соединения. Пользователь, получивший доступ к объекту <xref:System.Data.EntityClient.EntityConnection>, может также изменить <xref:System.Data.ConnectionState> базового соединения. Класс <xref:System.Data.EntityClient.EntityConnection> не является потокобезопасным.  
  
#### <a name="do-not-pass-connections-outside-the-security-context"></a>Не следует передавать соединения за пределы контекста безопасности  
 После установки соединения его нельзя передавать за пределы контекста безопасности. Например, один поток с разрешением открыть соединение не должен хранить это соединение в глобальном местоположении. Если соединение доступно в глобальном местонахождении, то другой вредоносный поток может использовать открытое соединение, не имея на это явно предоставленного разрешения.  
  
#### <a name="be-aware-that-logon-information-and-passwords-may-be-visible-in-a-memory-dump"></a>Следует учитывать, что сведения о входе в систему и пароли могут быть обнаружены в дампе памяти  
 Если данные о входе в систему и пароль передаются в строке соединения, эти сведения хранятся в памяти до тех пор, пока операция сборки мусора не освободит ресурсы. В результате этого становится невозможным определение того, с какого момента строка пароля перестает находиться в памяти. После сбоя приложения файл дампа памяти может содержать конфиденциальные данные, а возможность просматривать этот файл дампа памяти способен получить пользователь, эксплуатирующий это приложение, а также любой другой пользователь с административным доступом к компьютеру. Для соединения с Microsoft SQL Server используйте проверку подлинности Windows.  
  
#### <a name="grant-users-only-the-necessary-permissions-in-the-data-source"></a>Предоставление пользователям только необходимых разрешений на доступ к источнику данных  
 Администратор источника данных должен предоставлять пользователям только необходимые разрешения. Язык [!INCLUDE[esql](../../../../../includes/esql-md.md)] не поддерживает такие инструкции DML изменяющие данные, как INSERT, UPDATE или DELETE; тем не менее пользователи могут получить доступ к соединению с источником данных. Злонамеренный пользователь может с помощью этого соединения выполнять инструкции DML на собственном языке источника данных.  
  
#### <a name="run-applications-with-the-minimum-permissions"></a>Запуск приложения с минимально возможными разрешениями  
 Если управляемое приложение разрешается запускать с разрешением полного доверия, .NET Framework не ограничивает доступ приложения к компьютеру. Это может стать предпосылкой появления в приложении потенциально уязвимого места, что представляет угрозу для всей системы. Чтобы использовать систему управления доступом для кода и другие механизмы безопасности в .NET Framework, следует запускать приложения с разрешениями частичного доверия и минимальным набором разрешений, необходимых для обеспечения работы приложения. Следующие разрешения на доступ к коду являются минимальными разрешениями, которые требуются для приложения Entity Framework.  
  
- <xref:System.Security.Permissions.FileIOPermission>. Разрешение <xref:System.Security.Permissions.FileIOPermissionAccess.Write> на открытие заданных файлов метаданных или разрешение <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> на поиск в каталоге файлов метаданных.  
  
- <xref:System.Security.Permissions.ReflectionPermission>. Разрешение <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess> на поддержку запросов LINQ to Entities.  
  
- <xref:System.Transactions.DistributedTransactionPermission>. Разрешение <xref:System.Security.Permissions.PermissionState.Unrestricted> на участие в транзакции <xref:System.Transactions><xref:System.Transactions.Transaction>.  
  
- <xref:System.Security.Permissions.SecurityPermission>. Разрешение <xref:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter> на сериализацию исключений с помощью интерфейса <xref:System.Runtime.Serialization.ISerializable>.  
  
- Разрешение на открытие подключения к базе данных и выполнение команд в базе данных, например <xref:System.Data.SqlClient.SqlClientPermission> для базы данных SQL Server.  
  
 Для получения дополнительной информации см. [Code Access Security and ADO.NET](../code-access-security.md).  
  
#### <a name="do-not-install-untrusted-applications"></a>Не устанавливайте приложения, не заслуживающие доверия  
 Entity Framework не применяет никаких разрешений безопасности и вызовет любой предоставленный пользователем код объекта данных в процессе независимо от того, является ли он доверенным или нет. Убедитесь, что проверка подлинности и авторизация клиента выполняются хранилищем данных и приложением.  
  
#### <a name="restrict-access-to-all-configuration-files"></a>Ограничьте доступ ко всем файлам конфигурации  
 Администратор должен ограничить доступ на запись ко всем файлам, которые задают конфигурацию приложения, включая ентерприсесек. config, Security. config, Machine. conf, и файл конфигурации приложения \<*приложение*>. exe. config.  
  
 Неизменяемое имя поставщика можно изменить в файле app.config. Клиентское приложение должно обеспечивать доступ к базовому поставщику через фабричную модель стандартного поставщика с использованием строгого имени.  
  
#### <a name="restrict-permissions-to-the-model-and-mapping-files"></a>Ограничьте разрешения на файлы модели и сопоставления.  
 Администратор должен предоставлять доступ для записи к файлам модели и сопоставления (EDMX-файлы, CSDL-файлы, SSDL-файлы и MSL-файлы) только тем пользователям, которые изменяют модель или сопоставления. Entity Framework требуется только доступ для чтения к этим файлам во время выполнения. Администратор также должен ограничить доступ к слоям объектов и предварительно скомпилированным файлам исходного кода представления, созданным инструментами EDM.  
  
## <a name="security-considerations-for-queries"></a>Вопросы безопасности применительно к запросам  
 При запросах к концептуальной модели применимы следующие рекомендации по безопасности. Эти рекомендации по безопасности применимы к запросам [!INCLUDE[esql](../../../../../includes/esql-md.md)], использующим EntityClient, и к объектным запросам, использующим LINQ, [!INCLUDE[esql](../../../../../includes/esql-md.md)] и методы построителя запросов.  
  
#### <a name="prevent-sql-injection-attacks"></a>Предотвращение атак путем внедрения кода SQL  
 Приложения часто получают внешние входные данные (от пользователя или другого внешнего агента) и выполняют действия над этими входными данными. Любые входные данные, прямо или косвенно полученные от пользователя или внешнего агента, могут иметь содержимое, в котором используется синтаксис целевого языка для выполнения несанкционированных действий. Если целевым языком является язык SQL (SQL), например Transact-SQL, такая манипуляция называется атакой путем внедрения кода SQL. Злонамеренный пользователь может внедрить данные непосредственно в запрос и удалить таблицу базы данных, вызвать отказ в обслуживании или другим образом изменить характер выполняемой операции.  
  
- Атаки путем внедрения кода [!INCLUDE[esql](../../../../../includes/esql-md.md)]:  
  
     Атаки путем внедрения кода SQL осуществляются на языке [!INCLUDE[esql](../../../../../includes/esql-md.md)] путем предоставления вредоносных входных значений в составе предикатов запросов и имен параметров. Для предотвращения атак путем внедрения кода SQL ни в коем случае нельзя объединять входные данные пользователя с текстом команд [!INCLUDE[esql](../../../../../includes/esql-md.md)].  
  
     Запросы [!INCLUDE[esql](../../../../../includes/esql-md.md)] принимают параметры во всех случаях, где допускаются литералы. Необходимо использовать параметризованные запросы, а не внедрять литералы, полученные от внешних агентов, непосредственно в запрос. Также следует использовать [методы построителя запросов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896238(v=vs.100)) для безопасного создания Entity SQL.  
  
- Атаки путем внедрения LINQ to Entities:  
  
     Хотя построение запросов возможно в LINQ to Entities, оно выполняется с помощью API объектной модели. В отличие от запросов [!INCLUDE[esql](../../../../../includes/esql-md.md)], LINQ to Entities запросы не формируются с помощью манипуляций со строками или объединения, и они не являются уязвимыми к традиционным атакам путем внедрения кода SQL.  
  
#### <a name="prevent-very-large-result-sets"></a>Предотвращение создания очень больших результирующих наборов  
 Слишком большой результирующий набор может вызвать завершение работы клиентской системы, если клиент выполняет операции, для которых потребность в ресурсах пропорциональна размеру результирующего набора. Непредвиденное появление больших результирующих наборов может происходить при следующих условиях:  
  
- в запросах к большим базам данных, не включающих соответствующих условий фильтрации;  
  
- в запросах, создающих декартовы соединения на сервере;  
  
- во вложенных запросах [!INCLUDE[esql](../../../../../includes/esql-md.md)].  
  
 Принимая ввод от пользователя, необходимо убедиться в том, что входные данные не могут привести к созданию слишком больших результирующих наборов, которые не сможет обработать система. Можно также использовать метод <xref:System.Linq.Queryable.Take%2A> в LINQ to Entities или оператор [Limit](./language-reference/limit-entity-sql.md) в [!INCLUDE[esql](../../../../../includes/esql-md.md)], чтобы ограничить размер результирующего набора.  
  
#### <a name="avoid-returning-iqueryable-results-when-exposing-methods-to-potentially-untrusted-callers"></a>Старайтесь не возвращать результаты IQueryable, если методы доступны потенциально ненадежным вызывающим объектам.  
 Старайтесь не возвращать типы <xref:System.Linq.IQueryable%601> из методов, которые доступны потенциально ненадежным вызывающим объектам, по следующим причинам.  
  
- Объект-получатель запроса, обеспечивающего доступ к типу <xref:System.Linq.IQueryable%601>, может вызвать метод, предоставляющий доступ к защищенным данным или увеличивающий размер результирующего набора. Например, рассмотрим следующую сигнатуру метода.  

    ```csharp
    public IQueryable<Customer> GetCustomer(int customerId)
    ```

    Объект-получатель этого запроса может вызвать метод `.Include("Orders")`, возвращающий `IQueryable<Customer>`, по которому можно извлечь данные, доступ к которым через этот запрос не планировался. Этого можно избежать, если изменить тип возвращаемого значения метода на <xref:System.Collections.Generic.IEnumerable%601> и вызвать метод (например, `.ToList()`) для материализации результатов.  
  
- Поскольку запросы <xref:System.Linq.IQueryable%601> выполняются при переборе результатов, объект-получатель запроса, обеспечивающего доступ к типу <xref:System.Linq.IQueryable%601>, может обработать возникшие исключения. Исключения могут содержать информацию, не предназначенную объекту-получателю.  
  
## <a name="security-considerations-for-entities"></a>Вопросы безопасности применительно к сущностям  
 Следующие рекомендации по безопасности применимы при формировании типов сущностей и работе с ними.  
  
#### <a name="do-not-share-an-objectcontext-across-application-domains"></a>Не следует совместно использовать контекст ObjectContext во всех доменах приложений  
 Совместное использование <xref:System.Data.Objects.ObjectContext> в нескольких доменах приложений может создать предпосылки получения доступа к данным в строке соединения. Вместо этого следует передать сериализованные объекты или графы объектов в домен другого приложения, а затем присоединить эти объекты к <xref:System.Data.Objects.ObjectContext> в этом домене приложения. Дополнительные сведения см. в разделе [сериализация объектов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738446(v=vs.100)).  
  
#### <a name="prevent-type-safety-violations"></a>Предотвращение нарушений безопасности типов  
 Если нарушается безопасность типа, Entity Framework не может гарантировать целостность данных в объектах. Нарушения безопасности типов могут происходить, если разрешается эксплуатация ненадежных приложений с полным уровнем доверия для управления доступом для кода.  
  
#### <a name="handle-exceptions"></a>Выполните обработку исключений.  
 Доступ к методам и свойствам <xref:System.Data.Objects.ObjectContext> в блоке try-catch. Обработка исключений предотвращает их попадание в пользовательское приложение, и поэтому пользователи приложения не смогут получить доступ к записям в <xref:System.Data.Objects.ObjectStateManager> или к данным модели (например, именам таблиц).  
  
## <a name="security-considerations-for-aspnet-applications"></a>Вопросы безопасности применительно к приложениям ASP.NET  

При работе с путями в приложениях ASP.NET следует учитывать следующее.  
  
#### <a name="verify-whether-your-host-performs-path-checks"></a>Убедиться в том, что узел выполняет проверку путей  
 При использовании строки подстановки `|DataDirectory|` (заключенной в символы вертикальной черты) ADO.NET проверяет, поддерживается ли разрешенный путь. Например, недопустима подстрока ".." после `DataDirectory`. Такая же проверка разрешения оператора root веб-приложения (`~`) выполняется процессом размещения ASP.NET. Эту проверку выполняют службы IIS, однако узлы, отличные от IIS, могут не проверять, поддерживается ли преобразованный путь. Вам следует ознакомиться с поведением узла, на котором развертывается приложение Entity Framework.  
  
#### <a name="do-not-make-assumptions-about-resolved-path-names"></a>Не следует делать предположений в отношении преобразованных имен путей  
 Хотя значения, в которые оператор root (`~`) и строка подстановки `DataDirectory` разрешаются, должны оставаться постоянными во время выполнения приложения, Entity Framework не ограничивает изменение этих значений узлом.  
  
#### <a name="verify-the-path-length-before-deployment"></a>Проверить длину пути перед развертыванием.  
 Перед развертыванием Entity Frameworkного приложения следует убедиться, что значения корневого оператора (~) и строки подстановки `DataDirectory` не превышают ограничения длины пути в операционной системе. Поставщики данных ADO.NET не гарантируют, что длина пути находится в пределах допустимых ограничений.  
  
## <a name="security-considerations-for-adonet-metadata"></a>Вопросы безопасности применительно к метаданным ADO.NET  
 При формировании и работе с файлами модели и сопоставления применимы следующие рекомендации по безопасности.  
  
#### <a name="do-not-expose-sensitive-information-through-logging"></a>Не следует представлять доступ к конфиденциальным сведениям с помощью средств ведения журнала  
Компоненты службы метаданных ADO.NET не заносить в журнал никаких частных данных. Если имеются результаты, которые не удается возвратить из-за ограничений доступа, то системы управления базами данных и файловые системы должны возвращать нулевой результат, а не активизировать исключение, которое может содержать конфиденциальные данные.  
  
#### <a name="do-not-accept-metadataworkspace-objects-from-untrusted-sources"></a>Не следует принимать объекты MetadataWorkspace из ненадежных источников  
 Приложения не должны принимать экземпляры объектов класса <xref:System.Data.Metadata.Edm.MetadataWorkspace> из ненадежных источников. Вместо этого необходимо явно создать и заполнить рабочую область из такого источника.  
  
## <a name="see-also"></a>См. также раздел

- [Защита приложений ADO.NET](../securing-ado-net-applications.md)
- [Требования к развертыванию](deployment-considerations.md)
- [Вопросы миграции](migration-considerations.md)
