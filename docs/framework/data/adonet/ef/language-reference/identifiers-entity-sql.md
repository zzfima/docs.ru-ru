---
title: Идентификаторы (Entity SQL)
ms.date: 03/30/2017
ms.assetid: d58a5edd-7b5c-48e1-b5d7-a326ff426aa4
ms.openlocfilehash: 4a8f98a9ea9601e1bf5f178e404f99e4a9160078
ms.sourcegitcommit: 4e2d355baba82814fa53efd6b8bbb45bfe054d11
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/04/2019
ms.locfileid: "70250721"
---
# <a name="identifiers-entity-sql"></a>Идентификаторы (Entity SQL)
В языке [!INCLUDE[esql](../../../../../../includes/esql-md.md)] идентификаторы используются для представления псевдонимов выражений запросов, ссылок на переменные, свойств объектов, функций и т. д. [!INCLUDE[esql](../../../../../../includes/esql-md.md)]предоставляет два вида идентификаторов: Простые идентификаторы и заключенные в кавычки идентификаторы.  
  
## <a name="simple-identifiers"></a>Простые идентификаторы  
 Простой идентификатор в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] представляет собой последовательность буквенно-цифровых символов и знаков подчеркивания. Первым символом в идентификаторе должен быть алфавитный символ (a-z или A-Z).  
  
## <a name="quoted-identifiers"></a>Заключенные в кавычки идентификаторы  
 Заключенный в кавычки идентификатор - это любая последовательность символов, заключенная в квадратные скобки ([]). Заключенные в кавычки идентификаторы позволяют задавать идентификаторы с символами, которые нельзя использовать в простых идентификаторах. Все символы между квадратными скобками становятся частью идентификатора, включая все пробелы.  
  
 Заключенный в кавычки идентификатор не может содержать следующие символы.  
  
- Перевод строки.  
  
- Возврат каретки.  
  
- Табуляция.  
  
- Возврат на одну позицию назад.  
  
- Дополнительные квадратные скобки (то есть квадратные скобки внутри квадратных скобок, выделяющих идентификатор).  
  
 Заключенный в кавычки идентификатор может содержать символы Юникода.  
  
 Как показано в следующем примере, заключенные в кавычки идентификаторы позволяют создавать символы для имен свойств, которые нельзя использовать в простых идентификаторах:  
  
 `SELECT c.ContactName AS [Contact Name] FROM customers AS c`  
  
 Заключенные в кавычки идентификаторы можно также использовать, чтобы задавать идентификаторы, которые являются зарезервированными ключевыми словами [!INCLUDE[esql](../../../../../../includes/esql-md.md)]. Например, если у типа `Email` есть свойство «From», то при помощи квадратных скобок его можно отличить от зарезервированного ключевого слова FROM следующим образом:  
  
 `SELECT e.[From] FROM emails AS e`  
  
 Заключенный в кавычки идентификатор можно использовать в правой части оператора «точка» (.).  
  
 `SELECT t FROM ts as t WHERE t.[property] == 2`  
  
 Чтобы использовать в идентификаторе квадратную скобку, добавьте дополнительную квадратную скобку. В следующем примере «`abc]`» является идентификатором.  
  
 `SELECT t from ts as t WHERE t.[abc]]] == 2`  
  
 Сведения о семантике сравнения идентификаторов в кавычках см. в разделе [input character set](input-character-set-entity-sql.md).  
  
## <a name="aliasing-rules"></a>Правила присвоения псевдонимов  
 При необходимости в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] запросах рекомендуется указывать псевдонимы, включая следующие [!INCLUDE[esql](../../../../../../includes/esql-md.md)] конструкции:  
  
- Поля конструктора строк.  
  
- Элементы в предложении FROM выражения запроса.  
  
- Элементы в предложении SELECT выражения запроса.  
  
- Элементы в предложении GROUP BY выражения запроса.  
  
### <a name="valid-aliases"></a>Допустимые псевдонимы  
 Допустимые псевдонимы в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] — это любой простой идентификатор или заключенный в кавычки идентификатор.  
  
### <a name="alias-generation"></a>Создание псевдонима  
 Если в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] выражении запроса не указан псевдоним, [!INCLUDE[esql](../../../../../../includes/esql-md.md)] пытается создать псевдоним на основе следующих простых правил:  
  
- Если выражение запроса (в котором не задан псевдоним) является простым или заключенным в кавычки идентификатором, то он используется в качестве псевдонима. Например, запись `ROW(a, [b])` преобразуется в `ROW(a AS a, [b] AS [b])`.  
  
- Если выражение запроса более сложное, но последним его компонентом является простой идентификатор, тогда в качестве псевдонима используется этот идентификатор. Например, запись `ROW(a.a1, b.[b1])` преобразуется в `ROW(a.a1 AS a1, b.[b1] AS [b1])`.  
  
 Если в будущем планируется использование псевдонима, не рекомендуется прибегать к неявному присвоению псевдонимов. Результатом любого конфликта псевдонимов (неявных или явных) или их повторения в одной области будет ошибка компиляции. Неявный псевдоним пройдет компиляцию при наличии явного или неявного псевдонима с таким же именем.  
  
 Неявные псевдонимы формируются автоматически на основе ввода пользователя. Например, следующая строка кода сформирует для обоих столбцов псевдоним NAME, что приведет к конфликту.  
  
```  
SELECT product.NAME, person.NAME  
```  
  
 Следующая строка кода, в которой использованы явные псевдонимы, также завершится неудачно. Однако, прочитав код, можно яснее увидеть ошибку.  
  
```  
SELECT 1 AS X, 2 AS X …  
```  
  
## <a name="scoping-rules"></a>Правила области видимости  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)]определяет правила области, определяющие, когда определенные переменные видимы на языке запросов. Некоторые выражения или инструкции вводят новые имена. Правила области определяют, где можно использовать эти имена, а также когда и где новая декларация с таким же именем, как у другой, может скрывать предшествующую ей декларацию.  
  
 Если в [!INCLUDE[esql](../../../../../../includes/esql-md.md)] запросе определены имена, они говорят, что они определены в области. Область охватывает весь регион запроса. Все выражения или ссылки на имена в конкретной области могут видеть имена, определенные в этой области. На имена, определенные в данной области, нельзя ссылаться до начала области и после ее конца.  
  
 Области могут быть вложенными. Части представляют новые области, охватывающие все регионы, и эти регионы могут содержать другие [!INCLUDE[esql](../../../../../../includes/esql-md.md)] выражения, в которых также вводятся области. [!INCLUDE[esql](../../../../../../includes/esql-md.md)] Когда есть вложенные области, можно ссылаться на имена, определенные в самой глубоко вложенной области, которая содержит ссылку. Также можно создавать ссылки на любые имена, определенные в любых внешних областях. Любые две области, находящиеся внутри одной области, считаются областями одного уровня. Нельзя создавать ссылки на имена, определенные в разных областях одного уровня.  
  
 Если имя, объявленное во внутренней области, совпадает с именем, объявленным во внешней области, ссылки внутри этой внутренней области или внутри областей, объявленных внутри этой области, указывают только на вновь объявленное имя. Имя во внешней области скрыто.  
  
 Нельзя создавать ссылки на имена до их объявления, даже внутри одной области.  
  
 Глобальные имена могут существовать как часть среды выполнения. Это могут быть имена постоянных коллекций или переменных среды. Чтобы имя стало глобальным, его необходимо объявить в наиболее внешней области.  
  
 Параметры не входят в области. Поскольку ссылки на параметры содержат специальный синтаксис, имена параметров никогда не конфликтуют с другими именами в запросе.  
  
### <a name="query-expressions"></a>Выражения запросов  
 Выражение [!INCLUDE[esql](../../../../../../includes/esql-md.md)] запроса вводит новую область. Имена, определенные в предложении FROM, вводятся в область from в порядке появления, слева направо. В списке соединений выражения могут ссылаться на имена, которые определены в списке ранее. Открытые свойства (поля и так далее) элементов, идентифицированных в предложении FROM, в область from не добавляются. В ссылке на них следует всегда использовать имя псевдонима. Обычно считается, что все части выражения SELECT находятся в области from.  
  
 Предложение GROUP BY также вводит новую область одного уровня. Каждая группа может иметь имя группы, которое ссылается на коллекцию элементов в группе. Каждое выражение группирования также вводит новое имя в область группы. Кроме того, в эту область также добавляется статистическое выражение вложения (или группа с именем). Сами выражения группирования находятся в области from. Однако при использовании предложения GROUP BY считается, что список выбора (проекция), предложение HAVING и предложение ORDER BY находятся в области группы, а не в области from. Статистические выражения обрабатываются особым образом, как описано в следующем маркированном списке.  
  
 Далее приведены дополнительные замечания об областях.  
  
- Список выбора может вводить в область новые имена по порядку. Расположенные справа выражения проекций могут ссылаться на имена в проекциях слева.  
  
- Предложение ORDER BY может ссылаться на имена (псевдонимы), указанные в списке выбора.  
  
- Порядок оценки предложений внутри выражения SELECT определяет порядок, в котором имена вводятся в область. Первым оценивается предложение FROM, затем предложения WHERE, GROUP BY, HAVING, SELECT и, наконец, предложение ORDER BY.  
  
### <a name="aggregate-handling"></a>Обработка статистических выражений  
 [!INCLUDE[esql](../../../../../../includes/esql-md.md)]поддерживает две формы статистических выражений: агрегаты на основе коллекций и статистические выражения на основе групп. В [!INCLUDE[esql](../../../../../../includes/esql-md.md)] статистические выражения на базе коллекции являются предпочтительными конструкциями, а статистические выражения на базе группы поддерживаются для совместимости с SQL.  
  
 При разрешении статистического [!INCLUDE[esql](../../../../../../includes/esql-md.md)] выражения сначала пытается обработать его как статистическую функцию на основе коллекции. Если это не удается [!INCLUDE[esql](../../../../../../includes/esql-md.md)] , преобразует входные данные статистической функции в ссылку на статистическую функцию вложения и пытается разрешить это новое выражение, как показано в следующем примере.  
  
 `AVG(t.c) becomes AVG(group..(t.c))`  
  
## <a name="see-also"></a>См. также

- [Справочник по Entity SQL](entity-sql-reference.md)
- [Общие сведения об Entity SQL](entity-sql-overview.md)
- [Набор символов ввода](input-character-set-entity-sql.md)
