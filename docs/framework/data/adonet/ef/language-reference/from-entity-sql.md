---
title: FROM (Entity SQL)
ms.date: 03/30/2017
ms.assetid: ff3e3048-0d5d-4502-ae5c-9187fcbd0514
ms.openlocfilehash: 2334a30009d6bef9544d2ca1e0ab923a7441d6f2
ms.sourcegitcommit: 8a0fe8a2227af612f8b8941bdb8b19d6268748e7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/03/2019
ms.locfileid: "71833817"
---
# <a name="from-entity-sql"></a>FROM (Entity SQL)
Указывает коллекцию, используемую в инструкциях [SELECT](select-entity-sql.md) .

## <a name="syntax"></a>Синтаксис

```sql
FROM expression [ ,...n ] AS C
```

## <a name="arguments"></a>Аргументы

`expression` \
Любое допустимое выражение запроса, возвращающее коллекцию, которая используется как источник в инструкции `SELECT`.

## <a name="remarks"></a>Примечания

Предложение `FROM` - это список с разделителями-запятыми из одного или нескольких элементов предложения `FROM`. Предложение `FROM` может быть использовано, чтобы указать один или несколько источников для инструкции `SELECT`. Самая простая форма предложения `FROM` - единственное выражение запроса, которое определяет коллекцию и псевдоним, использованные как источники в инструкции `SELECT`, как показано в следующем примере.

`FROM C as c`

## <a name="from-clause-items"></a>Элементы предложения FROM

Каждый элемент предложения `FROM` ссылается на исходную коллекцию в запросе [!INCLUDE[esql](../../../../../../includes/esql-md.md)]. Язык [!INCLUDE[esql](../../../../../../includes/esql-md.md)] поддерживает следующие классы элементов предложения `FROM`: простые элементы предложения `FROM`, элементы предложения `JOIN FROM` и элементы предложения `APPLY FROM`. Каждый из этих элементов предложения `FROM` более подробно описан в следующих разделах.

### <a name="simple-from-clause-item"></a>Простой элемент предложения FROM

Самый простой элемент предложения `FROM` - единственное выражение, которое определяет коллекцию и псевдоним. Выражение может быть просто набором сущностей, вложенным запросом или другим выражением, которое относится к типу коллекции. Ниже представлен пример такого кода.

```sql
LOB.Customers as c
```

Спецификация псевдонима является необязательным элементом. Альтернативная спецификация приведенного выше элемента предложения from может быть следующей:

```sql
LOB.Customers
```

Если псевдоним не задан, то [!INCLUDE[esql](../../../../../../includes/esql-md.md)] попытается сформировать псевдоним на основе выражения коллекции.

### <a name="join-from-clause-item"></a>Элемент предложения JOIN FROM

Элемент предложения `JOIN FROM` представляет соединение между двумя элементами предложения `FROM`. Язык [!INCLUDE[esql](../../../../../../includes/esql-md.md)] поддерживает перекрестные соединения, внутренние соединения, левые и правые внешние соединения и полные внешние соединения. Все эти объединения поддерживаются аналогично тому, как они поддерживаются в Transact-SQL. Как и в языке Transact-SQL, два элемента предложения `FROM`, участвующие в `JOIN`, должны быть независимыми. (т. е. они не могут быть коррелированными). В этих случаях можно использовать операторы `CROSS APPLY` или `OUTER APPLY`.

#### <a name="cross-joins"></a>Перекрестные соединения

Выражение запроса `CROSS JOIN` формируют декартово произведение двух коллекций, как показано в следующем примере:

`FROM C AS c CROSS JOIN D as d`

#### <a name="inner-joins"></a>Внутренние соединения

Оператор `INNER JOIN` формирует ограниченное декартово произведение двух коллекций, как показано в следующем примере:

`FROM C AS c [INNER] JOIN D AS d ON e`

Предшествующее выражение запроса обрабатывает сочетание каждого элемента коллекции слева, сопоставленного каждому элементу коллекции справа, где условие `ON` имеет значение TRUE. Если не указано условие `ON`, соединение `INNER JOIN` вырождается в `CROSS JOIN`.

#### <a name="left-outer-joins-and-right-outer-joins"></a>Левые и правые внешние соединения

Выражение запроса `OUTER JOIN` формирует ограниченное декартово произведение двух коллекций, как показано в следующем примере:

`FROM C AS c LEFT OUTER JOIN D AS d ON e`

Предшествующее выражение запроса обрабатывает сочетание каждого элемента коллекции слева, сопоставленного каждому элементу коллекции справа, где условие `ON` имеет значение TRUE. Если условие `ON` не выполняется, выражение все же обрабатывает единственный экземпляр элемента слева, поставленный в соответствие элементу справа, со значением NULL.

Оператор `RIGHT OUTER JOIN` можно выразить аналогичным способом.

#### <a name="full-outer-joins"></a>Полные внешние соединения

Явное соединение `FULL OUTER JOIN` формирует ограниченное декартово произведение двух коллекций, как показано в следующем примере:

`FROM C AS c FULL OUTER JOIN D AS d ON e`

Предшествующее выражение запроса обрабатывает сочетание каждого элемента коллекции слева, сопоставленного каждому элементу коллекции справа, где условие `ON` имеет значение TRUE. Если условие `ON` не выполняется, выражение все же обрабатывает один экземпляр элемента слева, поставленный в соответствие элементу справа, со значением NULL. Выражение также обрабатывает один экземпляр элемента справа, сопоставленный с элементом слева, со значением NULL.

> [!NOTE]
> Чтобы сохранить совместимость с SQL-92, в Transact-SQL ВНЕШНее ключевое слово является необязательным. Поэтому `LEFT JOIN`, `RIGHT JOIN` и `FULL JOIN` являются синонимами для `LEFT OUTER JOIN`, `RIGHT OUTER JOIN` и `FULL OUTER JOIN`.

### <a name="apply-clause-item"></a>Элемент предложения APPLY

Язык [!INCLUDE[esql](../../../../../../includes/esql-md.md)] поддерживает два вида операторов`APPLY`: `CROSS APPLY` и `OUTER APPLY`.

`CROSS APPLY` формирует уникальную пару каждого элемента коллекции слева с элементом коллекции, полученным путем вычисления выражения справа. При использовании оператора `CROSS APPLY`, выражение справа функционально зависимо от элемента слева, как показано в следующем примере связанной коллекции:

`SELECT c, f FROM C AS c CROSS APPLY c.Assoc AS f`

Поведение `CROSS APPLY` аналогично поведению списка соединения. Если выражение справа принимает значение пустой коллекции, оператор `CROSS APPLY` не формирует пар для этого экземпляра элемента слева.

Оператор `OUTER APPLY` похож на `CROSS APPLY`, но пары формируются, даже если выражение справа принимает значение пустой коллекции. Ниже приведен пример оператора `OUTER APPLY`:

`SELECT c, f FROM C AS c OUTER APPLY c.Assoc AS f`

> [!NOTE]
> В отличие от языка Transact-SQL нет необходимости в явном развложении Step в [!INCLUDE[esql](../../../../../../includes/esql-md.md)].

> [!NOTE]
> операторы `CROSS` и `OUTER APPLY` были введены в SQL Server 2005. В некоторых случаях конвейер запросов может сформировать код Transact-SQL, который содержит операторы `CROSS APPLY` и `OUTER APPLY`. Поскольку некоторые серверные поставщики, включая версии SQL Server более ранние, чем SQL Server 2005, не поддерживают эти операторы, такие запросы не могут выполняться на этих внутренних поставщиках.
>
> Некоторыми типичными сценариями, которые бы могли привести к появлению операторов `CROSS APPLY` и (или) `OUTER APPLY` в выходном запросе, являются: связанный вложенный запрос с подкачкой страниц; AnyElement со связанным вложенным запросом или с коллекцией, полученной путем навигации; запросы LINQ, в которых используются методы группирования, принимающие селектор элементов; запрос, в котором явно указан оператор `CROSS APPLY` или `OUTER APPLY`; запрос с конструкцией `DEREF` для конструкции `REF`.

## <a name="multiple-collections-in-the-from-clause"></a>Несколько коллекций в предложении FROM

Предложение `FROM` может содержать одну и более коллекций, разделенных запятыми. В таких случаях коллекции считаются объединенными. Такую структуру можно считать n-сторонним соединением CROSS JOIN.

В следующем примере `C` и `D` являются независимыми коллекциями, но `c.Names` зависит от `C`.

```sql
FROM C AS c, D AS d, c.Names AS e
```

Предыдущий пример логически эквивалентен следующему примеру:

`FROM (C AS c JOIN D AS d) CROSS APPLY c.Names AS e`

## <a name="left-correlation"></a>Левая корреляция
 Элементы в предложении `FROM` могут ссылаться на элементы, указанные в более ранних предложениях. В следующем примере `C` и `D` являются независимыми коллекциями, но `c.Names` зависит от `C`:

```sql
from C as c, D as d, c.Names as e
```

Это логически равносильно:

```sql
from (C as c join D as d) cross apply c.Names as e
```

## <a name="semantics"></a>Семантика

Логически предполагается, что коллекции в предложении `FROM` - часть `n`-стороннего перекрестного соединения (за исключением случая 1-стороннего перекрестного соединения). Псевдонимы в предложении `FROM` обрабатываются слева направо и добавляются в текущую область для последующего применения. Предполагается, что предложение `FROM` формирует мультинабор строк. В предложении `FROM` будет одно поле для каждого элемента, которое представляет единственный элемент из этого элемента сбора.

Предложение `FROM` логически формирует мультинабор строк типа Row(c, d, e); при этом предполагается, что поля c, d и e являются элементами типа `C`, `D` и `c.Names`.

В языке [!INCLUDE[esql](../../../../../../includes/esql-md.md)] появился псевдоним для каждого простого элемента предложения `FROM` в области. Например, в следующем фрагменте предложения FROM в область введены имена c, d и e.

```sql
from (C as c join D as d) cross apply c.Names as e
```

В [!INCLUDE[esql](../../../../../../includes/esql-md.md)] (в отличие от Transact-SQL) предложение `FROM` вводит только псевдонимы в область. Любые обращения к столбцам (свойствам) этих коллекций нужно уточнить с помощью псевдонима.

## <a name="pulling-up-keys-from-nested-queries"></a>Извлечение ключей из вложенных запросов

Определенные типы запросов, для которых требуется извлечь ключи из вложенного запроса, не поддерживаются. Например, допустим следующий запрос:

```sql
select c.Orders from Customers as c
```

Однако следующий запрос является недопустимым, так как вложенный запрос не содержит ключей:

```sql
select {1} from {2, 3}
```

## <a name="see-also"></a>См. также

- [Справочник по Entity SQL](entity-sql-reference.md)
- [Выражения запросов](query-expressions-entity-sql.md)
- [Допускающие значения NULL структурированные типы](nullable-structured-types-entity-sql.md)
