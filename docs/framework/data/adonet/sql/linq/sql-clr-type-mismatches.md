---
title: Несоответствия типов SQL-CLR
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 0a90c33f-7ed7-4501-ad5f-6224c5da8e9b
ms.openlocfilehash: 13d8d68140b68652b5e059ae9fb106f32142f698
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61876867"
---
# <a name="sql-clr-type-mismatches"></a>Несоответствия типов SQL-CLR

[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] автоматизирует большую часть преобразований между объектной моделью и SQL Server. Однако существуют ситуации, препятствующие точному преобразованию. Эти основные несоответствия между типами среды CLR и типами баз данных SQL Server перечислены в следующих разделах. Дополнительные сведения о сопоставлении конкретных типов и о преобразовании функций [сопоставления типов SQL-CLR](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-type-mapping.md) и [типы данных и функции](../../../../../../docs/framework/data/adonet/sql/linq/data-types-and-functions.md).

## <a name="data-types"></a>Типы данных

Преобразование между CLR и SQL Server происходит в тот момент, когда запрос направляется в базу данных, а также когда результаты отправляются обратно в модель объектов. Например, в следующем запросе Transact-SQL необходимы два преобразования значений:

```sql
Select DateOfBirth From Customer Where CustomerId = @id
```

Перед тем как запрос можно будет выполнить в SQL Server, должно быть указано значение параметра Transact-SQL. В этом примере значение параметра `id` должно быть сначала преобразовано из типа CLR <xref:System.Int32?displayProperty=nameWithType> в тип SQL Server `INT`, чтобы база данных могла понять, каково это значение. Затем, чтобы получить результат, столбец SQL Server `DateOfBirth` должен быть преобразован из типа SQL Server `DATETIME` в тип CLR <xref:System.DateTime?displayProperty=nameWithType>, чтобы его можно было использовать в модели объектов. В этом примере типы модели объектов CLR естественным образом сопоставляются с типами базы данных SQL Server. Но так происходит не всегда.

### <a name="missing-counterparts"></a>Отсутствие аналогов

Следующие типы не имеют соответствующих аналогов.

- Несоответствия в пространстве имен CLR <xref:System>.

  - **Целые числа без знака**. Эти типы обычно сопоставляются со своими более крупными аналогами со знаками, чтобы избежать переполнения. На основе значения литералы могут быть преобразованы в числа со знаками такого же или меньшего размера.

  - **Логическое**. Эти типы могут быть сопоставлены битам, большим числам или строкам. Литерал может быть сопоставлен выражению, имеющему такое же значение (например, `1=1` в SQL для `True` в CLS).

  - **TimeSpan**. Этот тип представляет различие между двумя значениями `DateTime` и не соответствует типу `timestamp` SQL Server. В некоторых случаях тип CLR <xref:System.TimeSpan?displayProperty=nameWithType> может также сопоставляться с типом `TIME` SQL Server. Назначение типа SQL Server `TIME` состоит только в том, чтобы представлять положительные значения менее суток. Диапазон типа CLR <xref:System.TimeSpan> значительно шире.

  > [!NOTE]
  > Связанные с SQL Server [!INCLUDE[dnprdnshort](../../../../../../includes/dnprdnshort-md.md)] типы в <xref:System.Data.SqlTypes> не включаются в это сравнение.

- Несоответствия в SQL Server.

  - **Символьные типы фиксированной длины**. Transact-SQL различаются категории Юникода и не в Юникоде и существует три типа в каждой категории: фиксированной длины `nchar` / `char`, переменной длины `nvarchar` / `varchar`, и большего размера `ntext` / `text`. Символьные типы фиксированной длины могут быть сопоставлены с типом CLR <xref:System.Char?displayProperty=nameWithType> для получения символов, однако они не совсем соответствуют такому же типу в преобразованиях и поведении.

  - **Бит**. Хотя домен `bit` имеет то же число значений, что и `Nullable<Boolean>`, это два различных типа. `Bit` принимает значения `1` и `0` вместо `true` / `false`и не может использоваться в качестве эквивалента логических выражений.

  - **Метка времени**. В отличие от типа CLR <xref:System.TimeSpan?displayProperty=nameWithType> тип SQL Server `TIMESTAMP` представляет созданное базой данных 8-разрядное число, уникальное для каждого обновления и не основанное на различии между значениями <xref:System.DateTime>.

  - **Money** и **SmallMoney**. Эти типы могут быть сопоставлены типу <xref:System.Decimal>, однако являются, по существу, разными типами и рассматриваются как таковые серверными функциями и преобразованиями.

### <a name="multiple-mappings"></a>Множественные сопоставления

Существует множество типов данных SQL Server, которые могут быть сопоставлены одному или нескольким типам данных CLR. С другой стороны, имеется множество типов CLR, которые могут быть сопоставлены с одним или несколькими типами SQL Server. Хотя сопоставление может быть поддержано средствами LINQ to SQL, это не значит, что два сопоставляемых типа, относящихся к CLR и SQL Server, полностью соответствуют друг другу по точности, диапазону и семантике. Некоторые сопоставления могут включать различия по любому из упомянутых измерений или по всем измерениям. Вы найдете сведения об этих потенциальных различиях для различных вариантов сопоставлений [сопоставление типов SQL-CLR](../../../../../../docs/framework/data/adonet/sql/linq/sql-clr-type-mapping.md).

### <a name="user-defined-types"></a>Определяемые пользователем типы

Определяемые пользователем типы CLR разработаны, чтобы помочь устранить разрыв в системе типов. Однако с их помощью выявляются интересные моменты, касающиеся управления версиями типа. Изменение версии в клиенте может не иметь соответствующего изменения типа, хранящегося на сервере базы данных. Любое такое изменение приводит к несоответствию другого типа, при котором может отсутствовать соответствие семантик типа и может стать очевидным пропуск версии. Дальнейшие сложности возникают при оптимизации иерархий наследования в последующих версиях.

## <a name="expression-semantics"></a>Семантики выражений

Кроме парного несоответствия между типами CLR и базы данных, несоответствие осложняется и выражениями. Необходимо учесть несоответствия в семантиках операторов, функций, в неявных преобразованиях типов, а также правила приоритета.

В следующих подразделах показано несоответствие между внешне схожими выражениями. Можно создать выражения SQL, которые семантически эквивалентны заданному выражению CLR. Однако не совсем ясно, являются ли семантические различия между внешне схожими выражениями очевидными для пользователя CLR и нужны ли изменения, необходимые для семантической равнозначности. Это является особенно важным вопросом при вычислении выражения для набора значений. Видимость различий может зависеть от данных и может быть труднораспознаваемой при кодировании и отладке.

### <a name="null-semantics"></a>Семантика NULL

Выражения SQL предоставляют логику с тремя значениями для логических выражений. Возможен следующий результат: true, false или NULL. С другой стороны, CLR указывает логический результат с двумя значениями для сравнений, использующих значения NULL. Рассмотрим следующий код.

[!code-csharp[DLinqMismatch#2](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqMismatch/cs/Program.cs#2)]
[!code-vb[DLinqMismatch#2](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqMismatch/vb/Module1.vb#2)]

```sql
-- Assume col1 and col2 are integer columns with null values.
-- Assume that ANSI null behavior has not been explicitly
--  turned off.
Select …
From …
Where col1 = col2
-- Evaluates to null, not true and the corresponding row is not
--   selected.
-- To obtain matching behavior (i -> col1, j -> col2) change
--   the query to the following:
Select …
From …
Where
    col1 = col2
or (col1 is null and col2 is null)
-- (Visual Basic 'Nothing'.)
```

Схожая проблема возникает, исходя из предположения результатов с двумя значениями.

[!code-csharp[DLinqMismatch#3](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqMismatch/cs/Program.cs#3)]
[!code-vb[DLinqMismatch#3](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqMismatch/vb/Module1.vb#3)]

```sql
-- Assume col1 and col2 are nullable columns.
-- Assume that ANSI null behavior has not been explicitly
--   turned off.
Select …
From …
Where
    col1 = col2
or col1 != col2
-- Visual Basic: col1 <> col2.

-- Excludes the case where the boolean expression evaluates
--   to null. Therefore the where clause does not always
--   evaluate to true.
```

В предыдущем случае можно получить эквивалентное поведение при создании SQL, однако преобразование может неточно отразить ваше намерение.

[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] не накладывает C# `null` или Visual Basic `nothing` семантику сравнения на SQL Server. Операторы сравнения синтаксически преобразуются в эквивалентные команды SQL. Семантики отражают семантики SQL в соответствии с параметрами сервера или подключения. В заданных по умолчанию параметрах SQL два значения NULL считаются неравными (хотя, чтобы изменить семантики, можно изменить эти параметры). [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] не учитывает параметры сервера в преобразовании запроса.

Сравнение с литералом `null` (`nothing`) преобразуется в соответствующую версию SQL (`is null` или `is not null`).

Значение `null` (`nothing`) в сортировке определено SQL Server; [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] не изменяет сортировку.

### <a name="type-conversion-and-promotion"></a>Преобразование и повышение типов

SQL поддерживает широкий набор неявных преобразований в выражениях. Для схожих выражений в C# потребуется явное приведение Пример:

- Типы `Nvarchar` и `DateTime` можно сравнить в SQL без явных приведений; C# требует явного преобразования.

- `Decimal` неявно преобразуется в `DateTime` в SQL. Язык C# не допускает неявных преобразований.

Аналогично: приоритеты типов в Transact-SQL отличаются от приоритетов типов C# из-за отличий в базовом наборе типов. В действительности же явная связь поднабора/расширенного набора между списками приоритетов отсутствует. Так, при сравнении типов `nvarchar` с `varchar` выполняется неявное преобразование выражения типа `varchar` в `nvarchar`. Среда CLR не предоставляет эквивалентного повышения.

В простых случаях различия приводят к выражениям CLR с приведениями, которые избыточны для соответствующего выражения SQL. Более важно то, что промежуточные результаты выражения SQL могут быть неявно повышены до типа, не имеющего точного аналога в языке C#, и наоборот. В целом тестирование, отладка и проверка таких выражений является дополнительной значительной нагрузкой для пользователя.

### <a name="collation"></a>Параметры сортировки

Transact-SQL поддерживает явные параметры сортировки в качестве заметок к типам символьных строк. Эти параметры сортировки определяют допустимость определенных сравнений. Например, сравнение двух столбцов с различными явными параметры сортировки недопустимо. Использование более простого строкового типа CTS не вызывает подобных ошибок. Рассмотрим следующий пример.

```sql
create table T2 (
    Col1 nvarchar(10),
    Col2      nvarchar(10) collate Latin_general_ci_as
)
```

[!code-csharp[DLinqMismatch#4](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqMismatch/cs/Program.cs#4)]
[!code-vb[DLinqMismatch#4](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqMismatch/vb/Module1.vb#4)]

```sql
Select …
From …
Where Col1 = Col2
-- Error, collation conflict.
```

По сути, вложенное предложение сортировки создает *ограниченный тип* , не в качестве замены.

Аналогично, в системах типов могут применяться самые разные порядки сортировки. Это различие влияет на сортировку результатов. Идентификатор <xref:System.Guid> сортируется во всех 16 байтах в лексикографическом порядке (`IComparable()`), тогда как T-SQL сравнивает идентификаторы GUID в следующем порядке: node(10-15), clock-seq(8-9), time-high(6-7), time-mid(4-5), time-low(0-3). Это упорядочивание выполнялось в SQL 7.0, где идентификаторы GUID, созданные NT-системой, имели именно такой октетный порядок. Данный способ обеспечивал, что GUID, созданные на одном кластере узла, последовательно объединялись в соответствии с меткой времени. Он также использовался для создания индексов (вставки становились добавлениями вместо случайных операций ввода-вывода). Позднее в Windows порядок был зашифрован в связи с вопросами обеспечения конфиденциальности, однако SQL должен поддерживать совместимость. Решение — использовать <xref:System.Data.SqlTypes.SqlGuid> вместо <xref:System.Guid>.

### <a name="operator-and-function-differences"></a>Отличия функции и оператора

Операторы и функции, являющиеся по существу сравнимыми, имеют незначительно отличающиеся семантики. Пример:

- C# задает сокращенные семантики на основе лексического порядка операндов для логических операторов `&&` и `||`. С другой стороны, SQL предназначен для запросов на основе наборов и поэтому предоставляет оптимизатору больше возможностей при выборе порядка выполнения. Ниже приведены некоторые выводы.

  - Семантически эквивалентного преобразования потребует "`CASE` ... `WHEN` … `THEN`«конструкцию в SQL, во избежание изменения порядка выполнения операнда.

  - Свободное преобразование в `AND` / `OR` операторов может привести к непредвиденным ошибкам, если C# выражение зависит от второго операнда, основанного на результат вычисления первого операнда.

- Функция `Round()` имеет разные семантики в среде [!INCLUDE[dnprdnshort](../../../../../../includes/dnprdnshort-md.md)] и в T-SQL.

- Начальный индекс для строк в CLR равен нулю, а в SQL - 1. Поэтому для каждой функции с индексом необходимо преобразование индекса.

- В отличие от SQL, среда CLR поддерживает оператор остатка от деления (%) для чисел с плавающей запятой.

- Оператор `Like` эффективно использует автоматические перегрузки на основе неявных преобразований. Несмотря на то, что оператор `Like` определен для действия в типах символьных строк, неявное преобразование из числовых типов или типов `DateTime` допускает использование нестроковых типов с `Like`. В CTS сравнимые неявные преобразования не существуют. Поэтому необходимы дополнительные перегрузки.

    > [!NOTE]
    > Это поведение оператора `Like` характерно только для языка C#; ключевое слово `Like` Visual Basic остается неизменным.

- Переполнение всегда проверяется в SQL, но он должен быть явно указан в C# (не в Visual Basic) во избежание циклического возврата. Даны столбцы целых чисел C1, C2 и C3, если C1+C2 хранится в C3 (Обновление T Set C3 = C1 + C2).

    ```sql
    create table T3 (
        Col1      integer,
        Col2      integer
    )
    insert into T3 (col1, col2) values (2147483647, 5)
    -- Valid values: max integer value and 5.
    select * from T3 where col1 + col2 < 0
    -- Produces arithmetic overflow error.
    ```

[!code-csharp[DLinqMismatch#5](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqMismatch/cs/Program.cs#5)]
[!code-vb[DLinqMismatch#5](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqMismatch/vb/Module1.vb#5)]

- SQL выполняет симметричное арифметическое округление, тогда как [!INCLUDE[dnprdnshort](../../../../../../includes/dnprdnshort-md.md)] использует банковское округление. Дополнительные сведения см. в статье 196652 базы знаний.

- По умолчанию для распространенных языков символьно-строковые сравнения в SQL не зависят от регистра. В Visual Basic и C# сравнения выполняются с учетом регистра. Например `s == "Food"` (`s = "Food"` в Visual Basic) и `s == "Food"` могут выдавать различные результаты, если `s` является `food`.

    ```sql
    -- Assume default US-English locale (case insensitive).
    create table T4 (
        Col1      nvarchar (256)
    )
    insert into T4 values (‘Food’)
    insert into T4 values (‘FOOD’)
    select * from T4 where Col1 = ‘food’
    -- Both the rows are returned because of case-insensitive matching.
    ```

[!code-csharp[DLinqMismatch#6](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqMismatch/cs/Program.cs#6)]
[!code-vb[DLinqMismatch#6](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqMismatch/vb/Module1.vb#6)]

- Семантики операторов или функций, примененных к аргументам символьных типов фиксированной длины в SQL, значительно отличаются от семантик таких же операторов/функций, примененных к строке <xref:System.String?displayProperty=nameWithType> CLR. Этот вопрос также можно рассмотреть как распространение проблемы отсутствующего аналога, которая обсуждается в разделе о типах.

    ```sql
    create table T4 (
        Col1      nchar(4)
    )
    Insert into T5(Col1) values ('21');
    Insert into T5(Col1) values ('1021');
    Select * from T5 where Col1 like '%1'
    -- Only the second row with Col1 = '1021' is returned.
    -- Not the first row!
    ```

     [!code-csharp[DLinqMismatch#7](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqMismatch/cs/Program.cs#7)]
     [!code-vb[DLinqMismatch#7](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqMismatch/vb/Module1.vb#7)]

     Похожая проблема возникает при объединении строк.

    ```sql
    create table T6 (
        Col1      nchar(4)
        Col2       nchar(4)
    )
    Insert into T6 values ('a', 'b');
    Select Col1+Col2 from T6
    -- Returns concatenation of padded strings "a   b   " and not "ab".
    ```

В результате для выражений CLR могут потребоваться сложные преобразования, а для доступа к возможностям SQL могут быть необходимы дополнительные операторы и функции.

### <a name="type-casting"></a>Приведение типа

В C# и SQL пользователи могут переопределить заданные по умолчанию семантики выражений за счет использования явных приведений типов (`Cast` и `Convert`). Однако предоставление этой возможности в рамках системы типа создает трудности. Приведение SQL, предоставляющее необходимые семантики, не может быть просто преобразовано в соответствующее приведение C#. С другой стороны, приведение C# нельзя напрямую преобразовать в эквивалентное приведение SQL в связи с несоответствием типов, отсутствием аналогов и наличием иерархий приоритетов различных типов. Приходится идти на компромисс между несовпадением системы типа и потерей эффективности выражения.

В других случаях приведение типа может и не потребоваться в домене для проверки выражения, однако оно может быть необходимо для гарантии правильного применения к выражению нестандартного сопоставления.

```sql
-- Example from "Non-default Mapping" section extended
create table T5 (
    Col1      nvarchar(10),
    Col2      nvarchar(10)
)
Insert into T5(col1, col2) values (‘3’, ‘2’);
```

[!code-csharp[DLinqMismatch#8](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqMismatch/cs/Program.cs#8)]
[!code-vb[DLinqMismatch#8](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqMismatch/vb/Module1.vb#8)]

```sql
Select *
From T5
Where Col1 + Col2 > 4
-- "Col1 + Col2" expr evaluates to '32'
```

## <a name="performance-issues"></a>Проблемы производительности

Учета для некоторых SQL Server и CLR различия типов может привести к снижению производительности при переходах между CLR и SQL Server системы типов. Помимо этого, возможны следующие сценарии, приводящие к снижению производительности.

- Принудительный порядок оценки логических операторов and и or.

- Создание SQL-запроса для принудительного порядка оценки предикатов ограничивает возможности оптимизатора SQL.

- Преобразования типов, представленные компилятором CLR или реализацией объектно-реляционного запроса, могут ограничить использование индекса.

     Например, примененная к объекту директива

    ```sql
    -- Table DDL
    create table T5 (
        Col1      varchar(100)
    )
    ```

     [!code-csharp[DLinqMismatch#9](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqMismatch/cs/Program.cs#9)]
     [!code-vb[DLinqMismatch#9](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqMismatch/vb/Module1.vb#9)]

     Рассмотрим преобразование выражения `(s = SOME_STRING_CONSTANT)`.

    ```sql
    -- Corresponding part of SQL where clause
    Where …
    Col1 = SOME_STRING_CONSTANT
    -- This expression is of the form <varchar> = <nvarchar>.
    -- Hence SQL introduces a conversion from varchar to nvarchar,
    --   resulting in
    Where …
    Convert(nvarchar(100), Col1) = SOME_STRING_CONSTANT
    -- Cannot use the index for column Col1 for some implementations.
    ```

Наряду с семантическими различиями при переходах между системами типов SQL Server и CLR важно учитывать изменение производительности. Для больших наборов данных подобные проблемы производительности могут определить, является ли приложение развертываемым.

## <a name="see-also"></a>См. также

- [Основные сведения](../../../../../../docs/framework/data/adonet/sql/linq/background-information.md)
