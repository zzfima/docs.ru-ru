---
title: Оптимистическая блокировка. Обзор
ms.date: 03/30/2017
ms.assetid: c2e38512-d0c8-4807-b30a-cb7e30338694
ms.openlocfilehash: a61d4c5b35f3797539fe845045b8a959b0351350
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2019
ms.locfileid: "69938630"
---
# <a name="optimistic-concurrency-overview"></a>Оптимистическая блокировка. Обзор
Технология [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] поддерживает средства управления оптимистическим параллелизмом. В следующей таблице описаны термины, применяемые к оптимистичному параллелизму [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] в документации.  
  
|Термины|Описание|  
|-----------|-----------------|  
|параллелизм|Ситуация, при которой несколько пользователей одновременно пытаются обновить одну строку базы данных.|  
|конфликт параллелизма|Ситуация, при которой несколько пользователей одновременно пытаются отправить конфликтующие значения в один или несколько столбцов строки.|  
|управление параллелизмом|Метод, используемый для разрешения конфликтов параллелизма.|  
|оптимистический контроль параллелизма|Метод, при котором, прежде чем разрешить отправку изменений, определяется, не были ли изменены значения в строке другими транзакциями.<br /><br /> Отличие от *пессимистического управления параллелизмом*, который блокирует запись, чтобы избежать конфликтов параллелизма.<br /><br /> *Оптимистическая блокировка* , так как считает вероятность того, что одна транзакция мешает другой, маловероятно.|  
|разрешение конфликтов|Процесс обновления конфликтующего элемента путем повторного запроса к базе данных и последующего согласования различий.<br /><br /> При обновлении объекта средство отслеживания изменений [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] содержит следующие данные:<br /><br /> — Значения, изначально взятые из базы данных и используемые для проверки обновлений.<br />— Новые значения базы данных из последующего запроса.<br /><br /> После этого [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] определяет, является ли объект конфликтующим (то есть изменилось ли одно или несколько значений его членов). Если объект конфликтует, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] далее определяется, какие из его членов конфликтуют.<br /><br /> Каждый конфликт члена, обнаруженный [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], добавляется в список конфликтов.|  
  
 В объектной модели *конфликт оптимистичного параллелизма* возникает, если выполняются оба следующих условия. [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]  
  
- Клиент пытается отправить изменения в базу данных.  
  
- Одно или несколько значений проверки обновлений было обновлено в базе данных с момента последнего чтения этих значений клиентом.  
  
 Процесс разрешения этого конфликта включает обнаружение конфликтующих членов и принятие решения о том, какие действия следует к ним применить.  
  
> [!NOTE]
> В проверках оптимистического параллелизма участвуют только те члены, которые сопоставлены свойству <xref:System.Data.Linq.Mapping.UpdateCheck.Always> или <xref:System.Data.Linq.Mapping.UpdateCheck.WhenChanged>. Для членов, сопоставленных свойству <xref:System.Data.Linq.Mapping.UpdateCheck.Never>, никаких проверок не производится. Дополнительные сведения см. в разделе <xref:System.Data.Linq.Mapping.UpdateCheck>.  
  
## <a name="example"></a>Пример  
 Рассмотрим в качестве примера следующий сценарий, в котором Пользователь1 начинает подготовку к обновлению, запрашивая строку в базе данных. Пользователь1 получает строку со значениями "Алексеи", "Мария" и "Продажи".  
  
 Пользователь1 хочет изменить значение в столбце "Менеджер" на "Алексей", а значение в столбце "Отдел" на "Маркетинг". Прежде чем Пользователь1 смог отправить эти изменения, Пользователь2 отправил изменения в эту базу данных. Поэтому теперь значение в столбце "Помощник" изменилось на "Инна", а значение в столбце "Отдел" изменилось на "Обслуживание".  
  
 Когда пользователь Пользователь1 пытается отправить изменения, происходит сбой при отправке и возникает исключение <xref:System.Data.Linq.ChangeConflictException>. Этот результат происходит по той причине, что значения базы данных для столбцов "Помощник" и "Отдел" не совпадают с ожидаемыми значениями. Члены, представляющие столбцы "Помощник" и "Отдел", являются конфликтующими. Эта ситуация обобщается в следующей таблице.  
  
||Руководитель|Помощник|Отдел|  
|------|-------------|---------------|----------------|  
|Исходное состояние|Алексеи|Мария|Продажи|  
|Пользователь1|Алексей||Маркетинговый отдел|  
|Пользователь2||Инна|Служба|  
  
 Подобные конфликты можно разрешать различными способами. Дополнительные сведения см. в разделе [Практическое руководство. Управление конфликтами](../../../../../../docs/framework/data/adonet/sql/linq/how-to-manage-change-conflicts.md)изменений.  
  
## <a name="conflict-detection-and-resolution-checklist"></a>Контрольный список обнаружения и разрешения конфликтов  
 Конфликты можно обнаруживать и разрешать на любом уровне детализации. С одной стороны, можно разрешить все конфликты одним из трех способов (см. <xref:System.Data.Linq.RefreshMode>) без каких-либо дополнительных действий. С другой стороны, можно указать конкретное действие для каждого типа конфликта и для каждого конфликтующего члена.  
  
- Укажите или проверьте параметры <xref:System.Data.Linq.Mapping.UpdateCheck> в объектной модели.  
  
     Дополнительные сведения см. в разделе [Практическое руководство. Укажите, какие элементы проверяются на конфликты](../../../../../../docs/framework/data/adonet/sql/linq/how-to-specify-which-members-are-tested-for-concurrency-conflicts.md)параллелизма.  
  
- В блоке "try/catch" вызова метода <xref:System.Data.Linq.DataContext.SubmitChanges%2A> укажите, в какой точке должны вызываться исключения.  
  
     Дополнительные сведения см. в разделе [Практическое руководство. Укажите, когда вызываются](../../../../../../docs/framework/data/adonet/sql/linq/how-to-specify-when-concurrency-exceptions-are-thrown.md)исключения параллелизма.  
  
- Определите уровень детализации извлекаемых сведений о конфликте и вставьте соответствующий код в блок "try/catch".  
  
     Дополнительные сведения см. в разделе [Практическое руководство. Получение сведений о](../../../../../../docs/framework/data/adonet/sql/linq/how-to-retrieve-entity-conflict-information.md) конфликтах [сущностей и инструкции: Получение сведений о](../../../../../../docs/framework/data/adonet/sql/linq/how-to-retrieve-member-conflict-information.md)конфликтах элементов.  
  
- Включите в `try` / код способразрешенияразличныхобнаруженныхконфликтов.`catch`  
  
     Дополнительные сведения см. в разделе [Практическое руководство. Разрешите конфликты, сооставляя](../../../../../../docs/framework/data/adonet/sql/linq/how-to-resolve-conflicts-by-retaining-database-values.md)значения [базы данных, как: Разрешите конфликты, перезаписав](../../../../../../docs/framework/data/adonet/sql/linq/how-to-resolve-conflicts-by-overwriting-database-values.md)значения базы [данных, и выполните следующие действия. Разрешите конфликты путем слияния со](../../../../../../docs/framework/data/adonet/sql/linq/how-to-resolve-conflicts-by-merging-with-database-values.md)значениями базы данных.  
  
## <a name="linq-to-sql-types-that-support-conflict-discovery-and-resolution"></a>Типы LINQ to SQL, поддерживающие обнаружение и разрешение конфликтов  
 Ниже перечислены классы и возможности, поддерживающие разрешение конфликтов при оптимистическом параллелизме в [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].  
  
- <xref:System.Data.Linq.ObjectChangeConflict?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.MemberChangeConflict?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.ChangeConflictCollection?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.ChangeConflictException?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.DataContext.ChangeConflicts%2A?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.DataContext.SubmitChanges%2A?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.DataContext.Refresh%2A?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.Mapping.ColumnAttribute.UpdateCheck%2A?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.Mapping.UpdateCheck?displayProperty=nameWithType>  
  
- <xref:System.Data.Linq.RefreshMode?displayProperty=nameWithType>  
  
## <a name="see-also"></a>См. также

- [Практическое руководство. Управление конфликтами изменений](../../../../../../docs/framework/data/adonet/sql/linq/how-to-manage-change-conflicts.md)
