---
title: Отложенная и немедленная загрузка
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d7247f-a3b7-460b-b342-5c1a2365aa1a
ms.openlocfilehash: 2045cab19e7400f94888297571a172de1578094d
ms.sourcegitcommit: d2e1dfa7ef2d4e9ffae3d431cf6a4ffd9c8d378f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/07/2019
ms.locfileid: "70794141"
---
# <a name="deferred-versus-immediate-loading"></a>Отложенная и немедленная загрузка
При запросе объекта фактически извлекается только запрошенный объект. *Связанные* объекты не извлекаться автоматически одновременно. (Дополнительные сведения см. в разделе [запросы по связям](querying-across-relationships.md).) Пользователь не может определить, что связанные объекты еще не загружены, поскольку попытка получить к ним доступ приводит к выполнению запроса, который их извлекает.  
  
 Например, может потребоваться запросить определенный набор заказов, а затем отправить уведомление по электронной почте определенным клиентам. В этом случае не требуется сразу извлекать все данные о клиентах вместе с каждым заказом. Можно использовать отложенную загрузку для получения дополнительной информации только тогда, когда она действительно необходима. Рассмотрим следующий пример.  
  
 [!code-csharp[DLinqQueryConcepts#1](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#1)]
 [!code-vb[DLinqQueryConcepts#1](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#1)]  
  
 Иногда бывает полезным реализовать и противоположный подход. Предположим, имеется приложение, которому требуется одновременно просматривать данные о клиентах и заказах. В этом случае необходимы оба набора данных. Поскольку приложению требуются сведения о заказах для каждого клиента в момент получения результатов, нецелесообразно отправлять отдельные запросы на получение заказов для каждого клиента. Более эффективно извлекать данные о заказах одновременно с данными о клиентах.  
  
 [!code-csharp[DLinqQueryConcepts#2](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#2)]
 [!code-vb[DLinqQueryConcepts#2](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#2)]  
  
 Можно также объединить клиентов и заказы в одном запросе путем создания перекрестного произведения и извлечения всех связанных битов данных в виде одной большой проекции. Однако эти результаты не являются сущностями (Дополнительные сведения см. [в разделе Объектная модель LINQ to SQL](the-linq-to-sql-object-model.md)). Сущности представляют собой объекты, которые обладают идентификациями и которые можно изменить. Результаты, напротив, являются проекциями, и их нельзя ни изменить, ни сохранить. Более того, при таком подходе извлекается большое количество избыточных данных, поскольку в плоских выходных данных, полученных в результате объединения, каждый клиент повторяется в каждом заказе.  
  
 Действительно эффективным стал бы способ параллельного извлечения набора связанных объектов. Этот набор является отделенным разделом графа, поэтому пользователь извлекает ровно тот объем данных, который ему необходим. Для этой цели [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] предоставляет <xref:System.Data.Linq.DataLoadOptions> немедленную загрузку региона объектной модели. Ниже перечислены используемые методы.  
  
- Метод <xref:System.Data.Linq.DataLoadOptions.LoadWith%2A> для немедленной загрузки данные, связанных с основными целевыми объектами.  
  
- Метод <xref:System.Data.Linq.DataLoadOptions.AssociateWith%2A> для фильтрации объектов, извлеченных для определенной связи.  
  
## <a name="see-also"></a>См. также

- [Основные принципы запросов](query-concepts.md)
