---
title: N-уровневое использование LINQ to SQL с веб-службами
ms.date: 03/30/2017
ms.assetid: 9cb10eb8-957f-4beb-a271-5f682016fed2
ms.openlocfilehash: 7a52c17c58df24235a5691c84df159dbea3a8d25
ms.sourcegitcommit: 7bc6887ab658550baa78f1520ea735838249345e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/03/2020
ms.locfileid: "75634590"
---
# <a name="linq-to-sql-n-tier-with-web-services"></a>N-уровневое использование LINQ to SQL с веб-службами
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] разработан специально для использования на среднем уровне в слабо связанном слое доступа к данным (DAL), таком как веб-служба. Если уровнем представления данных является веб-страница ASP.NET, то для управления передачей данных между пользовательским интерфейсом и <xref:System.Web.UI.WebControls.LinqDataSource> на среднем уровне используется серверный веб-элемент управления [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]. Если уровень представления данных не является страницей ASP.NET, то и на среднем уровне, и на уровне представления данных необходимо выполнить дополнительные действия по управлению сериализацией и десериализацией данных.  
  
## <a name="setting-up-linq-to-sql-on-the-middle-tier"></a>Настройка технологии LINQ to SQL на среднем уровне  
 Средний уровень веб-службы или многоуровневого приложения содержит контекст данных и классы сущностей. Эти классы можно создать вручную либо с помощью SQLMetal. exe или реляционный конструктор объектов, как описано в других разделах документации. Во время разработки можно сделать класс сущностей сериализуемым. Дополнительные сведения см. [в разделе инструкции. обеспечение сериализации сущностей](how-to-make-entities-serializable.md). Другой вариант — создать отдельный набор классов, инкапсулирующих данные для сериализации, а затем выполнить проецирование этих сериализуемых типов при возврате данных в запросах LINQ.  
  
 Затем следует определить интерфейс с методами, которые клиенты будут вызывать для извлечения, вставки и обновления данных. Методы интерфейса заключают запросы LINQ. Для обработки удаленных вызовов методов и сериализации данных можно использовать любой вид механизма сериализации. Единственное требование заключается в том, что если в объектной модели существуют циклические или двунаправленные отношения, например между классами "Customers" и "Orders" в стандартной объектной модели "Northwind", то необходимо использовать сериализатор, который поддерживает такие отношения. Сериализатор Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> поддерживает двунаправленные отношения, а сериализатор XmlSerializer, который используется для веб-служб, не совместимых с WCF, не поддерживает. Если используется сериализатор XmlSerializer, то необходимо убедиться, что в объектной модели отсутствуют циклические связи.  
  
 Дополнительные сведения о Windows Communication Foundation см. [в разделе Windows Communication Foundation Services and WCF Data Services в Visual Studio](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio).  
  
 Реализуйте бизнес-правила и другую логику, относящуюся к домену, используя разделяемые классы и методы в классе <xref:System.Data.Linq.DataContext> и классах сущностей для обработки событий [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] времени выполнения. Дополнительные сведения см. в разделе [Реализация N-уровневой бизнес-логики](implementing-business-logic-linq-to-sql.md).  
  
## <a name="defining-the-serializable-types"></a>Определение сериализуемых типов  
 Клиент или уровень представления данных должен иметь определения типов для классов, которые он будет получать от среднего уровня. Данные типы могут сами быть классами сущностей или представлять собой особые классы, которые включают только определенные поля из классов сущностей для удаленного взаимодействия. В любом случае [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] полностью беспроблемен о том, как уровень представления данных получает определения типов. Например, уровень представления данных может использовать технологию WCF для автоматического создания типов, содержать копию библиотеки DLL, в которой определены эти типы или определить собственные версии типов.  
  
## <a name="retrieving-and-inserting-data"></a>Извлечение и вставка данных  
 Средний уровень определяет интерфейс, указывающий, как уровень представления данных получает доступ к данным. Например, `GetProductByID(int productID)` или `GetCustomers()`. На среднем уровне тело метода обычно создает новый экземпляр класса <xref:System.Data.Linq.DataContext> и выполняет запрос к одной или нескольким своим таблицам. Затем средний уровень возвращает результат в виде интерфейса <xref:System.Collections.Generic.IEnumerable%601>, где `T` является классом сущностей или другим типом, используемым для сериализации. Уровень представления данных никогда не отправляет переменные запроса непосредственно на средний уровень и не получает этих переменных из среднего уровня. Оба уровня обмениваются значениями, объектами и коллекциями конкретных данных. После получения коллекции уровень представления может использовать LINQ to Objects, чтобы при необходимости запросить его.  
  
 При вставке данных уровень представления может создать новый объект и отправить его на средний уровень или указать среднему уровню создать объект на основе предоставленных им значений. В общем случае извлечение и вставка данных в многоуровневых приложениях не сильно отличается от аналогичного процесса в двухуровневых приложениях. Дополнительные сведения см. в статьях [запросы к базе данных](querying-the-database.md) и [внесение и отправка изменений данных](making-and-submitting-data-changes.md).  
  
## <a name="tracking-changes-for-updates-and-deletes"></a>Отслеживание изменений для обновления и удаления  
 Технология [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] поддерживает оптимистический параллелизм, основанный на отметках времени (также называемых RowVersions) или на исходных значениях. Если таблицам базы данных присвоены метки времени, то для операций обновления и удаления требуются некоторые дополнительные действия либо на среднем уровне, либо на уровне представления данных. Однако если для проверок на оптимистический параллелизм необходимо использовать исходные значения, то ответственность за отслеживание этих значений и отправку их обратно при выполнении обновлений лежит на уровне представления данных. Причиной этого является тот факт, что изменения сущностей, выполненные на уровне представления данных, не отслеживаются на среднем уровне. В действительности, исходное извлечение сущности и окончательное его обновление обычно выполняется двумя совершенно различными экземплярами класса <xref:System.Data.Linq.DataContext>.  
  
 Чем больше количество изменений, выполненных на уровне представления данных, тем сложнее становится отслеживать эти изменения и отправлять их в пакетах обратно на средний уровень. Реализация механизма передачи изменений полностью зависит от приложения. Единственное требование заключается в том, что технологии [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] должны быть предоставлены исходные значений, которые необходимы для выполнения проверок на оптимистический параллелизм.  
  
 Дополнительные сведения см. в статьях [Получение данных и операции CUD в N-уровневых приложениях (LINQ to SQL)](data-retrieval-and-cud-operations-in-n-tier-applications.md).  
  
## <a name="see-also"></a>См. также:

- [N-уровневые и удаленные приложения и LINQ to SQL](n-tier-and-remote-applications-with-linq-to-sql.md)
- [Обзор серверного веб-элемента управления LinqDataSource](https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100))
