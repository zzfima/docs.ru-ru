---
title: Профилировщики CLR и приложений Windows Store
ms.date: 03/30/2017
dev_langs:
- csharp
applies_to:
- Windows 10
- Windows 8
helpviewer_keywords:
- profiling API
- profiling API [.NET Framework]
- profiling managed code
- profiling managed code [Windows Store Apps]
ms.assetid: 1c8eb2e7-f20a-42f9-a795-71503486a0f5
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 27e1433415bdc6303555ab9ae04a20e097248535
ms.sourcegitcommit: ad99773e5e45068ce03b99518008397e1299e0d1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2018
ms.locfileid: "46937622"
---
# <a name="clr-profilers-and-windows-store-apps"></a>Профилировщики CLR и приложений Windows Store

Здесь описывается, что нужно подумать о при написание средств диагностики анализа управляемого кода, выполняемого в приложении Windows Store. Он также предоставляет инструкции для изменения существующих средств разработки, чтобы они продолжали работать, если выполнить их в приложениях Windows Store. Чтобы понять эту информацию, проще всего, если вы знакомы с Common языковой среды выполнения API профилирования, вы уже использовали этот API в это средство диагностики, что будет работать правильно с настольных приложений Windows и теперь интересны изменение средство для правильной работы для приложений Windows Store.

## <a name="introduction"></a>Вступление

Если вы внесли за вводный абзац, затем вы знакомы с API профилирования CLR. Вы уже написали средство диагностики, которое работает хорошо против управляемых настольных приложений. Теперь можно узнать, что делать, что ваше средство управляемого приложения Windows Store. Возможно вы уже пытались пройти это работало и обнаружили, что это не простой задачей. Действительно существует ряд аспектов, которые могут быть не очевидным для всех разработчиков средств. Пример:

- Приложения Windows Store выполняются в контексте с сильно ограниченными разрешениями.

- Файлы метаданных Windows имеют уникальные характеристики по сравнению с традиционной управляемые модули.

- Приложения Windows Store имеют привычку Приостановка сами при интерактивность выходит из строя.

- Ваш механизмы межпроцессного взаимодействия может перестать работать по различным причинам.

В этом разделе перечислены задачи, которые необходимо учитывать и как работать с ними должным образом.

Если вы не знакомы с API профилирования CLR, перейдите вниз, чтобы ресурсы в конце этого раздела для лучшего вводные сведения.

Предоставляет подробные сведения о API-интерфейсы Windows и как они должны использоваться тоже выходит за рамки этой статьи. Рассмотрим в этом разделе отправной точки и ссылаться на MSDN, чтобы узнать больше о любые интерфейсы API Windows, указанный здесь.

## <a name="architecture-and-terminology"></a>Архитектура и терминология

Как правило это средство диагностики имеет архитектурой, как показано на следующем рисунке. Он используется термин «профилировщик», но многие средства на далеко за пределы обычной производительностью или профилирование памяти в областях, таких как объем протестированного кода, макетирование объектов платформы, отладка, приложение мониторинга и т. д. Переход во времени. Для простоты в этом разделе будет ссылаться на все эти средства, как средства профилирования.

В этом разделе используется следующая терминология:

**Приложение**

Это приложение, которое анализирует профилировщика. Как правило разработчик приложения использует профилировщика для диагностики проблем с приложением. В большинстве случаев это приложение было бы классического приложения Windows, но в этом разделе, у нас есть приложения Windows Store.

**Profiler DLL**

Это компонент, который загружает в пространство процесса приложения выполняется анализ. Этот компонент также называется «агент», профилировщика реализует [ICorProfilerCallback](icorprofilercallback-interface.md)[интерфейс ICorProfilerCallback](icorprofilercallback-interface.md)(2,3, и т.д.) интерфейсов и использует [ ICorProfilerInfo](icorprofilerinfo-interface.md)(2,3, и т.д.) интерфейсы для сбора данных о проанализированных приложения и потенциально изменять аспекты поведения приложения.

**Profiler пользовательского интерфейса**

Это настольным приложением, которое пользователь профилировщика взаимодействует с. Он отвечает за отображение состояния приложения для пользователя и предоставления пользователю возможность управлять поведением проанализированного приложения. Этот компонент всегда выполняется в свое собственное пространство процесса, отдельно от пространство процесса профилируемого приложения. Пользовательский Интерфейс Profiler также может служить «присоединение триггера» которых — это процесс, который вызывает [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md) метод, чтобы приложение проанализированного загрузить библиотеку DLL Profiler в тех случаях, когда библиотека DLL профилировщика не загрузить при запуске.

> [!IMPORTANT]
> Пользовательский Интерфейс Profiler должны оставаться классического приложения Windows, даже в том случае, если он используется для управления и создания отчетов в приложение Windows Store. Вряд ли будет иметь возможность упаковки и доставки вашей средства диагностики в Windows Store. Ваше средство необходимо выполнить действия, которые не приложения Windows Store, и многие из этих возможностей находятся внутри пользовательского интерфейса Profiler.

В этом документе в примере кода предполагается, что:

- Библиотека DLL Profiler создается на языке C++, так как он должен быть собственная библиотека DLL, в соответствии с требованиями API профилирования CLR.

- Пользовательский Интерфейс Profiler создается на языке C#. Это не является обязательным, но поскольку нет никаких ограничений на язык для пользовательского интерфейса Profiler процесса, почему бы не выбрать язык, оптимизируют и упрощают?

### <a name="windows-rt-devices"></a>Устройства Windows RT

Устройства Windows RT довольно заблокированы. Сторонние средства профилирования просто не может быть загружена с таких устройств. В этом документе рассматриваются на ПК Windows 8.

## <a name="consuming-windows-runtime-apis"></a>Использование API среды выполнения Windows

В ряде сценариев, описанных в следующих разделах своего настольного приложения в пользовательском Интерфейсе Profiler необходимо использовать некоторые новые интерфейсы API среды выполнения Windows. Вы захотите см. в документации, чтобы понять, какие интерфейсы API среды выполнения Windows можно использовать из классических приложений и их поведение отличается ли когда вызывается из настольных приложений и Windows Store apps.

Если пользовательский Интерфейс Profiler записывается в управляемом коде, будет существовать несколько действий, которые необходимо предпринять, чтобы обеспечить использование этих API среды выполнения Windows легко. См. в разделе [управляемые Классические приложения и среды выполнения Windows](https://go.microsoft.com/fwlink/?LinkID=271858) для получения дополнительной информации.

## <a name="loading-the-profiler-dll"></a>Загрузка Profiler DLL

В этом разделе описывается, как Profiler пользовательский Интерфейс вызывает приложения Windows Store для загрузки библиотеки DLL Profiler. Код, описанный в этом разделе принадлежит в приложении Profiler пользовательского интерфейса рабочего стола и поэтому предполагает использование Windows API, которые являются безопасна для классических приложений, но не обязательно безопасные, для приложений Windows Store.

Пользовательский Интерфейс Profiler может привести к Profiler DLL будет загружаться в пространство процесса приложения двумя способами:

- При запуске приложения, управляет переменными среды.

- Путем присоединения к приложению после завершения запуска путем вызова [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md) метод.

Один из вашей первой препятствий будут поступать с загрузкой при запуске и загрузкой путем присоединения Profiler библиотеки DLL для правильной работы с приложениями Windows Store. Обе формы загрузки общими некоторые особенности, поэтому начнем с ними.

### <a name="common-considerations-for-startup-and-attach-loads"></a>Общие соображения для запуска и присоединения загрузок

**Подписи к Profiler DLL**

Когда Windows пытается загрузить Profiler DLL, он проверяет, что библиотека DLL Profiler подписан должным образом. В противном случае происходит сбой загрузки по умолчанию. Это можно сделать двумя способами.

- Убедитесь, что библиотека DLL Profiler подписан.

- Сообщите пользователю, что им требуется установить лицензию разработчика на их компьютере под управлением Windows 8 перед использованием средства. Это можно сделать автоматически из Visual Studio, или вручную из командной строки. Дополнительные сведения см. в разделе [получение лицензии разработчика](https://msdn.microsoft.com/library/windows/apps/Hh974578.aspx).

**Разрешения файловой системы**

Приложения Windows Store должен иметь разрешение для загрузки и выполнения Profiler DLL из расположения в файловой системе, в котором она residesBy по умолчанию, приложение Windows Store не имеет такое разрешение на большинству каталогов, а Неудачная попытка загрузить библиотеку DLL Profiler будет создавать запись в журнале событий приложений Windows, который выглядит примерно следующим образом:

```Output
NET Runtime version 4.0.30319.17929 - Loading profiler failed during CoCreateInstance.  Profiler CLSID: '{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}'.  HRESULT: 0x80070005.  Process ID (decimal): 4688.  Message ID: [0x2504].
```

Как правило приложения Windows Store разрешены только для доступа к ограниченным набором расположения на диске. Каждое приложение Windows Store может получить доступ свои собственные папки данных приложения, а также несколько других областей в файловой системе, для которого все приложения Windows Store предоставляется доступ. Лучше всего установить библиотеки DLL Profiler и его зависимостей, где-нибудь в Program Files или Program Files (x86), так как все приложения Windows Store разрешения read и execute существует по умолчанию.

### <a name="startup-load"></a>Нагрузки запуска

Как правило, в настольном приложении вашей Profiler запросов в пользовательском Интерфейсе нагрузки запуска библиотеки DLL Profiler путем инициализации блок среды, содержащую необходимые переменные среды, API профилирования CLR (т. е. `COR_PROFILER`, `COR_ENABLE_PROFILING`, и `COR_PROFILER_PATH`), и затем создающая новый процесс с этот блок среды. То же верно для приложений Windows Store, но механизмы отличаются.

**Не запускать с повышенными правами**

Если процесс пытается запустить приложение Windows Store процесс B, процесс A должны выполняться в среднюю целостность уровня, не на уровне высоким уровнем целостности (что не с повышенными правами). Это означает, что либо Profiler пользовательского интерфейса должна быть запущена на среднем уровне целостности, либо он должен породить другого процесса рабочего стола на среднем уровне целостности позаботиться о запуске приложения Windows Store.

**Выбор на приложение Windows Store, для профиля**

Во-первых стоит спросить пользователя вашего профилировщика, какие приложения Windows Store, чтобы запустить. Для классических приложений возможно отобразит диалоговое окно обзора, и пользователь может найти и выбрать файл .exe. Но Windows Store apps отличаются, и с помощью диалогового окна обзора не имеет смысла. Вместо этого лучше для представления пользователю приложения Windows Store, установленные для этого пользователя выбрать из списка.

Можно использовать [PackageManager класс](https://msdn.microsoft.com/library/windows/apps/windows.management.deployment.packagemanager.aspx) для создания этого списка. `PackageManager` — Это класс среды выполнения Windows, которая доступна для классических приложений, и на самом деле это *только* для классических приложений.

В следующем примере кода из гипотетической пользовательского интерфейса Profiler, записывается в виде классического приложения в C# yses `PackageManager` для создания списка приложений Windows:

```csharp
string currentUserSID = WindowsIdentity.GetCurrent().User.ToString();
IAppxFactory appxFactory = (IAppxFactory) new AppxFactory();
PackageManager packageManager = new PackageManager();
IEnumerable<Package> packages = packageManager.FindPackagesForUser(currentUserSID);
```

**Указание блока настраиваемой среды**

Новый интерфейс COM, [IPackageDebugSettings](https://msdn.microsoft.com/library/hh438393\(v=vs.85\).aspx), позволяет настроить поведение выполнения в приложение Windows Store, чтобы упростить некоторые виды диагностики. Один из его методов [EnableDebugging](https://msdn.microsoft.com/library/hh438395\(v=vs.85\).aspx), позволяет передавать блок среды в приложение Windows Store, при запуске приложения, а также другие полезные эффекты, например, отключение автоматического процесса приостановки. Блок среды важно, потому что это, где необходимо указать переменные среды (`COR_PROFILER`, `COR_ENABLE_PROFILING`, и `COR_PROFILER_PATH)`) используется в среде CLR для загрузки библиотеки DLL Profiler.

Рассмотрим следующий фрагмент кода:

```csharp
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();
pkgDebugSettings.EnableDebugging(packgeFullName, debuggerCommandLine, 
                                                                 (IntPtr)fixedEnvironmentPzz);
```

Существует несколько элементов, которые необходимо получить справа:

- `packageFullName` можно определить во время прохода пакетов и получения `package.Id.FullName`.

- `debuggerCommandLine` — немного интереснее. Чтобы передать блок пользовательские среды приложений Windows Store, необходимо написать собственный, упрощенный отладчик фиктивный. Windows включает в себя приложения Windows Store приостановлена, а затем присоединяется отладчик, запустив отладчик с помощью командной строки, как в этом примере:

    ```Output
    MyDummyDebugger.exe -p 1336 -tid 1424
    ```

     где `-p 1336` означает, что приложение Windows Store имеет 1336 идентификатор процесса, и `-tid 1424` означает 1424 идентификатор потока, которое приостанавливается поток. Фиктивный отладчик будет проанализировать ThreadID из командной строки, возобновить этот поток и завершает работу.

     Вот некоторые примеры кода C++ для этого (не забудьте добавить проверку ошибок!):

    ```cpp
    int wmain(int argc, wchar_t* argv[])
    {
        // …
        // Parse command line here
        // …

        HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, 
                                                                  FALSE /* bInheritHandle */, nThreadID);
        ResumeThread(hThread);
        CloseHandle(hThread);
        return 0;
    }
    ```

     Вам потребуется развернуть этот фиктивный отладчик как часть установки средство диагностики, а затем укажите путь к этот отладчик в `debuggerCommandLine` параметра.

**Запуск приложения Windows Store**

Некоторое время, чтобы запустить приложение Windows Store наконец-то наступило. Если вы уже уже попробовал сделать это самостоятельно, вы могли заметить, [CreateProcess](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) не показано, как создать процесс приложения Windows Store. Вместо этого необходимо использовать [IApplicationActivationManager::ActivateApplication](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iapplicationactivationmanager-activateapplication) метод. Чтобы сделать это, необходимо получить идентификатор модели пользователя приложения, приложения Windows Store, которое вы начинаете. И это означает, что необходимо сделать немного углубиться помощью манифеста.

Во время прохода пакеты (см. в разделе «Выбор Windows Store для профиля приложения» в [нагрузки запуска](#startup-load) разделе ранее), вам понадобится набор приложений, которые содержатся в манифесте текущего пакета:

```csharp
string manifestPath = package.InstalledLocation.Path + "\\AppxManifest.xml";

AppxPackaging.IStream manifestStream;
SHCreateStreamOnFileEx(
                    manifestPath,
                    0x00000040,     // STGM_READ | STGM_SHARE_DENY_NONE
                    0,              // file creation attributes
                    false,          // fCreate
                    null,           // reserved
                    out manifestStream);

IAppxManifestReader manifestReader = appxFactory.CreateManifestReader(manifestStream);

IAppxManifestApplicationsEnumerator appsEnum = manifestReader.GetApplications();
```

Да, один пакет может иметь несколько приложений, и каждое приложение имеет собственный идентификатор модели пользователя приложения. Поэтому вам понадобится задавайте какое приложение в профиль пользователя, и взять идентификатор модели пользователя приложения из данного конкретного приложения.

```csharp
while (appsEnum.GetHasCurrent() != 0)
{
    IAppxManifestApplication app = appsEnum.GetCurrent();
    string appUserModelId = app.GetAppUserModelId();
    //...
}
```

Наконец теперь у вас есть необходимые для запуска приложения Windows Store:

```csharp
IApplicationActivationManager appActivationMgr = new ApplicationActivationManager();
appActivationMgr.ActivateApplication(appUserModelId, appArgs, ACTIVATEOPTIONS.AO_NONE, out pid);
```

**Не забудьте вызвать DisableDebugging**

При вызове [IPackageDebugSettings::EnableDebugging](https://msdn.microsoft.com/library/hh438395\(v=VS.85\).aspx), внесенные обещание, которое вы бы очистку после путем вызова [IPackageDebugSettings::DisableDebugging](https://msdn.microsoft.com/library/hh438394\(v=vs.85\).aspx) метод, поэтому не забудьте сделать Когда превышает сеанса профилирования.

### <a name="attach-load"></a>Присоединение нагрузки

Когда пользовательский Интерфейс Profiler потребуется возможность прикрепления Profiler DLL для приложений, уже был запущен, он использует [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md). То же самое относится с приложениями Windows Store. Но помимо Общие рекомендации, приведенные выше, убедитесь, что основное приложение Windows Store не был приостановлен.

**EnableDebugging**

Как и для запуска загрузки, вызовите [IPackageDebugSettings::EnableDebugging](https://msdn.microsoft.com/library/hh438395\(v=VS.85\).aspx) метод. Это не требуется для передачи блок среды, но требуется один из его других функций: отключение автоматического процесса приостановки. В противном случае, когда пользовательский Интерфейс Profiler вызывает [AttachProfiler](iclrprofiling-attachprofiler-method.md), основное приложение Windows Store может быть приостановлен. На самом деле это скорее всего, если пользователь теперь взаимодействует с помощью пользовательского интерфейса Profiler, и приложение Windows Store не активна на ни на одном экране пользователя. И если Windows Store, приложение приостановлено, он не будет отвечать на любые сигнал, что среда CLR отправляет к нему присоединение Profiler библиотеки DLL.

Поэтому нужно будет сделать нечто подобное:

```csharp
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();
pkgDebugSettings.EnableDebugging(packgeFullName, null /* debuggerCommandLine */, 
                                                                 IntPtr.Zero /* environment */);
```

Это тот же вызов, которые можно производить в случае запуска нагрузки, за исключением того, вы не были указаны в командной строке отладчика и блок среды.

**DisableDebugging**

Как всегда, не забудьте вызвать [IPackageDebugSettings::DisableDebugging](https://msdn.microsoft.com/library/hh438394\(v=vs.85\).aspx) после завершения сеанса профилирования.

## <a name="running-inside-the-windows-store-app"></a>Работает ли он в приложения Windows Store

Поэтому приложения Windows Store наконец загрузки библиотеки DLL Profiler. Теперь библиотека DLL Profiler необходимо вести как воспроизвести, различные правила, необходимые приложениям Windows Store, включая какие допустимый API и как выполнять с помощью ограниченной разрешения.

### <a name="stick-to-the-windows-store-app-apis"></a>Придерживайтесь интерфейсов API для приложений Windows Store

При просмотре в Windows API, вы заметите, что каждый API описан как применимо для классических приложений и приложений Windows Store. Например **требования** раздел документации для [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) функции указывает, что функция применяется только для настольных приложений. Напротив [InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex) функция доступна для настольных приложений и приложений Windows Store.

При разработке библиотеки DLL Profiler, обрабатывать его так, будто это приложение Windows Store и использовать только интерфейсы API, которые описаны как доступные для приложения Windows Store. Анализ зависимостей (например, можно запустить `link /dump /imports` от библиотеки DLL Profiler для аудита) и затем найти документы или для просмотра зависимостей, являющихся ОК и который не. В большинстве случаев ваши нарушений можно исправить, просто заменив их новой формы из API, который описан как ориентированные (например, заменив [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) с [ InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex)).

Можно заметить, что библиотека DLL Profiler вызывает некоторые API, которые применяются к только Классические приложения и еще кажется, что для работы даже при загрузке библиотеки DLL Profiler в приложении Windows Store. Следует учитывать, что это рискованно начинать использовать любой API, которые не описаны для использования с приложениями Windows Store в вашей библиотеке DLL Profiler при загрузке в процесс приложения Windows Store.

- Такие интерфейсы API для работы при вызове в уникальный контекст, приложения Windows Store работать в не гарантируется.

- Такие интерфейсы API могут не работать согласованно, при вызове из в рамках разных процессов приложения Windows Store.

- Такие интерфейсы API может показаться нормально работать в приложениях Windows Store в текущей версии Windows, но может нарушить работу или отключены в будущих версиях Windows.

Наилучшие рекомендации — исправление всех нарушений и избежать риска.

Может оказаться абсолютно невозможно делать без конкретный API и не может найти замену подходит для приложений Windows Store. В этом случае необходимо как минимум:

- Тестирование, тестирование и тестирование daylights жизни за пределы использования этого API.

- Понять, что API может внезапно прервать или исчезнуть, если вызывается из внутри Windows Store apps в будущих версиях Windows. Это не будет считаться проблема совместимости корпорацией Майкрософт и поддержка использования он будет приоритет.

### <a name="reduced-permissions"></a>Ограниченными разрешениями

Он выходит за рамки этого раздела, чтобы получить список всех способов, которые разрешений для приложения Windows Store отличаются от настольных приложений. Но определенно поведение будет отличаться при каждом DLL Profiler (при загрузке в приложение по сравнению с классического приложения Windows Store) пытается получить доступ к любым ресурсам. В файловой системе — это наиболее распространенный пример. Существуют, но некоторые размещает на диске, который может получить доступ, приложения Windows Store (см. в разделе [доступ и разрешения файлов (приложения для среды выполнения Windows](https://msdn.microsoft.com/library/windows/apps/hh967755.aspx)), и библиотеки DLL Profiler будет ограничениями. Тщательно протестируйте код.

### <a name="inter-process-communication"></a>Межпроцессное взаимодействие

Как показано на схеме в начале этой статьи, библиотеки DLL Profiler (загрузить в пространство процесса приложения Windows Store) скорее всего, понадобится взаимодействовать с Profiler пользовательского интерфейса (под управлением в пространстве процесса отдельные приложения на рабочем столе) через свой собственный пользовательский процесс между канал взаимодействия (IPC). Пользовательский Интерфейс Profiler отправляет сигналы на библиотеку DLL Profiler, чтобы изменить его поведение и библиотеки DLL Profiler отправляет данные из проанализированного приложения Windows Store обратно к пользовательскому Интерфейсу Profiler для последующей обработки и отображения пользователю профилировщика.

Большинство Профилировщики должны работать таким образом, но параметры, выбранные для механизма межпроцессного Взаимодействия более ограничены, при загрузке библиотеки DLL Profiler в приложения Windows Store. Например именованные каналы не являются частью Windows Store app SDK, поэтому их нельзя использовать.

Но, разумеется, файлы, по-прежнему in, хотя и за меньшее время. Также доступны события.

**Взаимодействие через файлы**

Большая часть ваших данных скорее всего будет передавать между Profiler библиотеки DLL и Profiler пользовательского интерфейса с помощью файлов. Главное – выбрать расположение файла, как DLL Profiler (в контексте приложения Windows Store), так и пользовательского интерфейса Profiler прочитаны и доступ на запись к. Например путь к временной папке Profiler DLL и Profiler пользовательского интерфейса можно получить доступ к которому, но не пакет приложения Windows Store можно получить доступ (выполняя все сведения при входе из других пакетов приложений Windows Store).

Profiler пользовательского интерфейса и Profiler DLL можно было определить этот путь независимо друг от друга. Пользовательский Интерфейс Profiler, когда он выполняет итерацию всех пакетов, установленных для текущего пользователя (см. выше в примере кода), получает доступ к `PackageId` класс, из которого можно получить путь к временной папке с кодом, аналогичную этот фрагмент кода. (Как всегда, проверка ошибок опущена для краткости.)

```csharp
// C# code for the Profiler UI.
ApplicationData appData =
    ApplicationDataManager.CreateForPackageFamily(
        packageId.FamilyName);

tempDir = appData.TemporaryFolder.Path;
```

В то же время библиотека DLL Profiler можно сделать по сути то же самое, хотя его можно более легко получить к [ApplicationData](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx) , используя [ApplicationData.Current](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.current.aspx) свойство.

**Посредством событий**

Если требуется простой передачи сигналов семантику между Profiler пользовательского интерфейса и Profiler DLL, события внутри приложения Windows Store, а также классических приложений можно использовать.

Из библиотеки DLL Profiler, можно просто вызвать [CreateEventEx](/windows/desktop/api/synchapi/nf-synchapi-createeventexa) функцию для создания именованного события с любое имя. Пример:

```cpp
// Profiler DLL in Windows Store app (C++).
CreateEventEx(
    NULL,  // Not inherited
    "MyNamedEvent"
    CREATE_EVENT_MANUAL_RESET, /* explicit ResetEvent() required; leave initial state unsignaled */
    EVENT_ALL_ACCESS);
```

Пользовательский Интерфейс Profiler необходимо найти этого именованного события в пространстве имен приложения Windows Store. Например, вызвать пользовательский Интерфейс Profiler [CreateEventEx](/windows/desktop/api/synchapi/nf-synchapi-createeventexa), указав имя, события

`AppContainerNamedObjects\<acSid>\MyNamedEvent`

`<acSid>` является идентификатор безопасности приложения Windows Store AppContainer. Раздела выше в этом разделе показано, как для выполнения итерации по пакеты, установленные для текущего пользователя. В этот пример кода вы можете получить идентификатор пакета. И в идентификатор пакета, вы можете получить `<acSid>` с кодом, аналогичную следующей:

```csharp
IntPtr acPSID;
DeriveAppContainerSidFromAppContainerName(packageId.FamilyName, out acPSID);

string acSid;
ConvertSidToStringSid(acPSID, out acSid);

string acDir;
GetAppContainerFolderPath(acSid, out acDir);
```

### <a name="no-shutdown-notifications"></a>Без уведомления о завершении работы

При его выполнении в приложения Windows Store, библиотеки DLL Profiler не следует полагаться на либо [ICorProfilerCallback::Shutdown](icorprofilercallback-shutdown-method.md) или даже [DllMain](/windows/desktop/Dlls/dllmain) (с `DLL_PROCESS_DETACH`) вызывается для оповещения библиотеки DLL Profiler что выполняется выход из приложения Windows Store. На самом деле следует ожидать, что они никогда не будет вызываться. Исторически сложилось так, что многие библиотеки DLL Profiler использовали эти уведомления как удобный окружение для очистки кэша на диск, закрытие файлов, отправки уведомлений Profiler пользовательского интерфейса и т. д. Но теперь библиотека DLL Profiler необходимо организовать немного по-разному.

Библиотека DLL Profiler должно быть сведения о ведении журнала, он. Из соображений производительности может потребоваться пакетной информацию в памяти и очистить его на диск пакета при увеличении размера за определенным пороговым значением. Но предположим, что все сведения, еще не записаны на диск может быть потеряны. Это означает, что вы захотите выбрать порогового осмотрительно, и что Profiler пользовательского интерфейса должна быть усиленной защитой, для работы с неполной информацией, написанной библиотеки DLL Profiler.

## <a name="windows-runtime-metadata-files"></a>Файлы метаданных среды выполнения Windows

Это выходит за рамки этого документа, чтобы подробно на метаданные среды выполнения Windows (WinMD), файлы. В этом разделе ограничено реакцией API профилирования CLR, при загрузке файлов WinMD приложением Windows Store, которое анализирует Profiler библиотеки DLL.

### <a name="managed-and-non-managed-winmds"></a>Управляемые и неуправляемые файлы Winmd

Если разработчик использует Visual Studio для создания нового проекта компонента среды выполнения Windows, построение этого проекта создается файл WinMD, описывающий метаданные (описания типов классов, интерфейсов, т. д.), созданные разработчиком. Если этот проект является проектом управляемый язык, на языке C# или VB, этот же WinMD-файл также содержит реализацию этих типов (это значит, что он содержит все IL, скомпилированной на основе исходного кода для разработчиков). Такие файлы называются управляемыми файлами WinMD. Они интересным, в том, что они содержат метаданные среды выполнения Windows и базовой реализации.

Напротив Если разработчик создает проект компонента среды выполнения Windows для C++, построение этого проекта создает файл WinMD, который содержит только метаданные и реализация компилируется в отдельной собственной DLL. Аналогичным образом файлы WinMD, которые поставляются в пакете SDK для Windows содержат только метаданные, с реализацией, компилируются в отдельные собственные библиотеки DLL, которые входят в состав Windows.

Приведенные ниже сведения относятся оба управляемых файлы Winmd, которые содержат метаданные и реализацию, и неуправляемые файлы Winmd, в которой содержат только метаданные.

### <a name="winmd-files-look-like-clr-modules"></a>Файлы WinMD выглядеть модулей среды CLR

Как из библиотеки CLR, все файлы WinMD, модули. Таким образом, API профилирования CLR сообщает Profiler библиотеки DLL при загрузке WinMD-файлов и их идентификаторы ModuleID Каковы, так же как и для других управляемых модулей.

Библиотека DLL Profiler различает WinMD-файлов из других модулей, вызвав [ICorProfilerInfo3::GetModuleInfo2](icorprofilerinfo3-getmoduleinfo2-method.md) метода, а также проверять `pdwModuleFlags` выходной параметр для [COR_PRF_MODULE_WINDOWS_ Среда ВЫПОЛНЕНИЯ](cor-prf-module-flags-enumeration.md) флаг. (Он имеет значение только в том случае, если ModuleID представляет winmd-файлом.)

### <a name="reading-metadata-from-winmds"></a>Чтение метаданных из файлы Winmd

WinMD-файлов, таких как обычные модули содержат метаданные, которые могут быть прочитаны через [API-интерфейсы метаданных](../../../../docs/framework/unmanaged-api/metadata/index.md). Тем не менее среда CLR сопоставляет типы среды выполнения Windows с типами .NET Framework, при чтении файлов WinMD, таким образом, чтобы разработчики, программирования в управляемом коде и использовать файл WinMD может иметь более фактический опыт программирования. Некоторые из этих сопоставлений, см. в разделе [поддержка платформы .NET Framework для Windows Store приложений и среды выполнения Windows](../../../../docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md).

Так какие представлении ваш профилировщик получит при использовании интерфейсов API метаданных: базовое представление среды выполнения Windows, или сопоставленный представления .NET Framework?  Ответ: именно вам.

При вызове [ICorProfilerInfo::GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) метод WinMD для получения интерфейс метаданных, таких как [IMetaDataImport](../../../../docs/framework/unmanaged-api/metadata/imetadataimport-interface.md), вы можете задать [ofNoTransform](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md)в `dwOpenFlags` параметр, чтобы отключить это сопоставление. В противном случае по умолчанию, сопоставление возможно. Как правило профилировщик сохранит включен, сопоставление, чтобы строки, библиотеки DLL Profiler получает из метаданных WinMD (например, имена типов) будет выглядеть знакомо и естественным для пользователя профилировщик.

### <a name="modifying-metadata-from-winmds"></a>Изменения метаданных из файлы Winmd

Изменения метаданных в файлы Winmd не поддерживается. При вызове метода [ICorProfilerInfo::GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) метод для winmd-файлом файла и укажите [ofWrite](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) в `dwOpenFlags` параметр или обратиться за интерфейс для записи метаданных, таких как [ IMetaDataEmit](../../../../docs/framework/unmanaged-api/metadata/imetadataemit-interface.md), [GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) завершится ошибкой. Это очень важен для перезаписи IL средства профилирования, в которых требуется для изменения метаданных для поддержки свой инструментарий (например, чтобы добавить AssemblyRefs или новых методов). Поэтому следует выполнять проверку для [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) сначала (как обсуждалось в предыдущем разделе) и не запрашиваются интерфейсы для записи метаданных в таких модулей.

### <a name="resolving-assembly-references-with-winmds"></a>Разрешение ссылок на сборки с файлы Winmd

Многие средства профилирования должны разрешать ссылки метаданных вручную для инструментирования или проверки типа. Такие средства профилирования необходимо помнить о том, как среда CLR разрешает ссылки на сборки, которые указывают на файлы Winmd, так как эти ссылки разрешаются в совершенно иначе, чем стандартные ссылки на сборки.

## <a name="memory-profilers"></a>Профайлеры памяти

Сборщик мусора и управляемой кучи не отличаются фундаментально в приложениях Windows Store и приложения для настольных систем. Однако существуют некоторые незначительные отличия, которые должны учитывать разработчики профилировщика.

### <a name="forcegc-creates-a-managed-thread"></a>ForceGC создает управляемый поток

При выполнении профилирования памяти, библиотеки DLL Profiler обычно создает отдельный поток, из которой вызывается [метод ForceGC](icorprofilerinfo-forcegc-method.md) метод. В этом нет ничего нового. Но что может быть удивительно, что само действие сбор мусора в приложении Windows Store могут преобразовывать потока в управляемый поток (например, API ThreadID профилирования создается для этого потока).

Чтобы понять последствия этого, важно понимать различия между синхронными и асинхронными вызовами в соответствии с определением API профилирования CLR. Обратите внимание, что это сильно отличается от концепции асинхронные вызовы в приложениях Windows Store. См. в записи блога [почему у нас есть CORPROF_E_UNSUPPORTED_CALL_SEQUENCE](https://blogs.msdn.microsoft.com/davbr/2008/12/23/why-we-have-corprof_e_unsupported_call_sequence/) Дополнительные сведения.

Соответствующие дело в том, что вызовы, выполняемые для потоков, созданных средой ваш профилировщик всегда считаются синхронным, даже если эти вызовы будут осуществляться за пределами реализация одного из библиотеки DLL Profiler [ICorProfilerCallback](icorprofilercallback-interface.md) методы. По крайней мере, который используется так. Теперь, когда среда CLR отключил ваш профилировщик потока в управляемый поток из-за вызов [метод ForceGC](icorprofilerinfo-forcegc-method.md), что поток больше не считается ваш профилировщик потока. Таким образом, среда CLR обеспечивает более строгое определение что рассматривается как синхронные, для этого потока, — а именно, вызов должен инициироваться внутри одного из библиотеки DLL Profiler [ICorProfilerCallback](icorprofilercallback-interface.md) методы для определения, как синхронный.

Что это означает на практике? Большинство [ICorProfilerInfo](icorprofilerinfo-interface.md) методы только можно безопасно вызывать асинхронно и сразу же не удастся иначе. Таким образом, если библиотека DLL Profiler повторно использует ваш [метод ForceGC](icorprofilerinfo-forcegc-method.md) потока для других вызовов, обычно выполняется в потоках, созданных с помощью профилировщика (к примеру, чтобы [RequestProfilerDetach](icorprofilerinfo3-requestprofilerdetach-method.md), [RequestReJIT](icorprofilerinfo4-requestrejit-method.md), или [RequestRevert](icorprofilerinfo4-requestrevert-method.md)), будет трудно. Даже асинхронной строго типизированную функцию как [DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) есть специальные правила, при вызове из управляемых потоков. (См. в записи блога [пошаговый анализ стеков Profiler: основы и более](https://blogs.msdn.microsoft.com/davbr/2005/10/06/profiler-stack-walking-basics-and-beyond/) подробнее.)

Таким образом, рекомендуется, чтобы любой поток, создает библиотеки DLL Profiler для вызова [метод ForceGC](icorprofilerinfo-forcegc-method.md) следует использовать *только* для запуска сборки мусора и последующего ответа на обратные вызовы сборки Мусора. Его не следует вызывать в API профилирования для выполнения других задач, таких как стек выборки или отсоединения.

### <a name="conditionalweaktablereferences"></a>ConditionalWeakTableReferences

Начиная с .NET Framework 4.5, имеется новый обратного вызова сборщика Мусора, [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md), которое содержит профилировщик более подробная информация о *зависимые дескрипторы*. Эти маркеры эффективно добавьте ссылку на целевой объект для управления жизненным циклом сборки Мусора из исходного объекта. Зависимые дескрипторы ничего нового, и разработчики, использующие в управляемом коде остаются возможность создавать свои собственные зависимые маркеры с помощью <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602?displayProperty=nameWithType> класса даже до Windows 8 и .NET Framework 4.5.

Тем не менее управляемых приложений Windows Store XAML теперь сильно загружают зависимые дескрипторов. В частности среда CLR использует их для помощи в управлении циклы ссылок между управляемыми объектами и неуправляемые объекты среды выполнения Windows. Это означает, что важнее, теперь чем когда-либо для Профайлеры памяти быть в курсе обрабатывает эти зависимые запросы, чтобы их можно визуализировать вместе с остальными ребрах в графе кучи. Следует использовать библиотеки DLL Profiler [RootReferences2](icorprofilercallback2-rootreferences2-method.md), [ObjectReferences](icorprofilercallback-objectreferences-method.md), и [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md) для формирования получить полное представление о graph кучи .

## <a name="conclusion"></a>Заключение

Это можно использовать API профилирования CLR для анализа управляемый код, выполняемый в приложениях Windows Store. На самом деле можно использовать существующий профилировщик, которое вы разрабатываете и внести некоторые конкретные изменения, таким образом, могут работать приложения Windows Store. Пользовательский Интерфейс Profiler следует использовать новые интерфейсы API для активации приложения Windows Store в режиме отладки. Убедитесь, что библиотека DLL Profiler использует только тех интерфейсов API применимо для приложений Windows Store. Механизм взаимодействия между Profiler DLL и Profiler пользовательского интерфейса должны быть написаны с ограничениями API Windows Store в виду и ограниченные разрешения на месте для приложений Windows Store. Библиотеки DLL Profiler следует помнить о том, как среда CLR рассматривает файлы Winmd, и каким образом сборщик мусора поведение отличается по отношению к управляемых потоков.

## <a name="resources"></a>Ресурсы

**Среда CLR**

- [Профилирование (Справочник по неуправляемым API)](index.md)

- [Метаданные (Справочник по неуправляемым API)](../metadata/index.md)

**CLR взаимодействия со средой выполнения Windows**

- [Поддержка платформы .NET Framework для приложений магазина Windows и среды выполнения Windows](../../../../docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)

**Приложения для Магазина Windows**

- [Доступ к файлам и разрешения (приложения среды выполнения Windows](https://msdn.microsoft.com/library/windows/apps/hh967755.aspx)

- [Получить лицензию разработчика](https://msdn.microsoft.com/library/windows/apps/Hh974578.aspx)

- [Интерфейс IPackageDebugSettings](https://msdn.microsoft.com/library/hh438393\(v=vs.85\).aspx)
