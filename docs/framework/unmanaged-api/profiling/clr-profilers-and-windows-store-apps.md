---
title: Профилировщики CLR и приложения для Магазина Windows
ms.date: 03/30/2017
dev_langs:
- csharp
applies_to:
- Windows 10
- Windows 8
helpviewer_keywords:
- profiling API
- profiling API [.NET Framework]
- profiling managed code
- profiling managed code [Windows Store Apps]
ms.assetid: 1c8eb2e7-f20a-42f9-a795-71503486a0f5
ms.openlocfilehash: a3e60f715c4c61e671980e4f36813e864469d28e
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/25/2019
ms.locfileid: "75344771"
---
# <a name="clr-profilers-and-windows-store-apps"></a>Профилировщики CLR и приложения для Магазина Windows

В этом разделе обсуждаются вопросы, которые необходимо учесть при написании средств диагностики для анализа управляемого кода, выполняемого в приложении для Магазина Windows. Здесь также приводятся рекомендации по изменению существующих средств разработки, чтобы они продолжали работать при их запуске в приложениях Магазина Windows. Для понимания этой информации лучше всего, если вы знакомы с API профилирования среды CLR, вы уже использовали этот API в средстве диагностики, которое правильно работает с настольными приложениями Windows, и теперь заинтересованы в изменении этого средства. для правильной работы в приложениях Магазина Windows.

## <a name="introduction"></a>Введение

Если вы сделали это в начальном абзаце, то знакомы с API профилирования CLR. Вы уже написали диагностическое средство, которое хорошо подходит для управляемых классических приложений. Теперь вам интересно, что делать, чтобы ваше средство работало с управляемым приложением для Магазина Windows. Возможно, вы уже попытались выполнить эту работу и обнаружили, что это не простая задача. Действительно, существует ряд рекомендаций, которые могут быть не очевидны для разработчиков инструментов. Например:

- Приложения для Магазина Windows выполняются в контексте с серьезными ограниченными разрешениями.

- Файлы метаданных Windows имеют уникальные характеристики по сравнению с традиционными управляемыми модулями.

- Приложения для Магазина Windows могут приостанавливать себя, когда взаимодействие выходит из строя.

- Механизмы взаимодействия между процессами могут перестать работать по различным причинам.

В этом разделе перечислены вещи, которые необходимо учитывать, и как правильно работать с ними.

Если вы не знакомы с API профилирования CLR, перейдите к ресурсам в конце этого раздела, чтобы найти более подробные сведения о вводе.

Предоставление сведений о конкретных интерфейсах API Windows и о том, как они должны использоваться, также выходит за рамки данного раздела. Рассмотрим этот раздел в качестве отправной точки и ознакомьтесь с MSDN, чтобы узнать больше о любых API Windows, упоминаемых здесь.

## <a name="architecture-and-terminology"></a>Архитектура и терминология

Как правило, средство диагностики имеет архитектуру, подобную показанной на следующем рисунке. В нем используется термин "профилировщик", но многие такие средства хорошо выходят за рамки типичной производительности или профилирования памяти в области, такие как покрытие кода, структурные объекты макетов, отладка по времени, отслеживание приложений и т. д. Для простоты этот раздел будет продолжать ссылаться на все эти средства как профилировщики.

В этом разделе используется следующая терминология:

**Приложение**

Это приложение, которое анализирует профилировщик. Как правило, разработчик этого приложения теперь использует профилировщик для диагностики проблем с приложением. Обычно это приложение классического приложения Windows, но в этом разделе мы рассмотрим приложения Магазина Windows.

**Библиотека DLL профилировщика**

Это компонент, который загружает в пространство процесса анализируемого приложения. Этот компонент, также известный как агент, реализует интерфейсы (2, 3 и т. д.), реализующие интерфейс [ICorProfilerCallback](icorprofilercallback-interface.md)[ICorProfilerCallback](icorprofilercallback-interface.md), и использует интерфейсы [ICorProfilerInfo](icorprofilerinfo-interface.md)(2, 3 и т. д.) для получения данных о проанализированном приложении и потенциально изменяя аспекты поведения приложения.

**Пользовательский интерфейс профилировщика**

Это классическое приложение, с которым взаимодействует пользователь профилировщика. Он отвечает за отображение состояния приложения для пользователя и предоставление пользователю средств для управления поведением проанализированного приложения. Этот компонент всегда запускается в своем собственном пространстве процесса, отделенном от пространства процесса профилированного приложения. Пользовательский интерфейс профилировщика также может действовать как "триггер присоединения", который вызывает метод [иклрпрофилинг:: AttachProfiler](iclrprofiling-attachprofiler-method.md) для того, чтобы анализируемое приложение ЗАГРУЖАЛО библиотеку DLL профилировщика в тех случаях, когда библиотека DLL профилировщика не была загружена при запуске.

> [!IMPORTANT]
> Пользовательский интерфейс профилировщика должен оставаться настольным приложением Windows, даже если оно используется для управления и отчетов в приложении Магазина Windows. Не предполагають возможность упаковки и поставки средства диагностики в магазине Windows. Ваше средство должно выполнять действия, которые не могут делать приложения Магазина Windows, и многие из них находятся в пользовательском интерфейсе профилировщика.

В этом документе пример кода предполагает, что:

- Библиотека DLL вашего профилировщика написана в C++, так как она должна быть собственной библиотекой DLL в соответствии с требованиями API профилирования CLR.

- Пользовательский интерфейс профилировщика написан на C#языке. Это не обязательно, но поскольку нет никаких требований к языку для процесса вашего пользовательского интерфейса профилировщика, почему бы не выбрать краткий и простой язык?

### <a name="windows-rt-devices"></a>Устройства Windows RT

Устройства Windows RT достаточно заблокированы. Сторонние профилировщики просто не могут быть загружены на таких устройствах. Этот документ посвящен компьютерам под управлением Windows 8.

## <a name="consuming-windows-runtime-apis"></a>Использование API-интерфейсов среда выполнения Windows

В ряде сценариев, описанных в следующих разделах, классическое приложение пользовательского интерфейса профилировщика должно использовать некоторые новые API среда выполнения Windows. Необходимо обратиться к документации, чтобы понять, какие среда выполнения Windows интерфейсы API могут использоваться из настольных приложений, а также повлиять ли их поведение при вызове из классических приложений и приложений Магазина Windows.

Если пользовательский интерфейс профилировщика написан на управляемом коде, потребуется выполнить несколько действий, чтобы упростить использование этих среда выполнения Windows интерфейсов API. Дополнительные сведения см. в статье [управляемые классические приложения и среда выполнения Windows](https://go.microsoft.com/fwlink/?LinkID=271858) .

## <a name="loading-the-profiler-dll"></a>Загрузка библиотеки DLL профилировщика

В этом разделе описывается, как пользовательский интерфейс профилировщика заставляет приложение Магазина Windows загрузить библиотеку DLL профилировщика. Код, обсуждаемый в этом разделе, относится к пользовательскому классу пользовательского интерфейса профилировщика и, следовательно, использует интерфейсы API Windows, которые являются надежными для настольных приложений, но не обязательно защищены для приложений Магазина Windows.

Пользовательский интерфейс профилировщика может вызвать загрузку библиотеки DLL профилировщика в пространство процесса приложения двумя способами:

- При запуске приложения, контролируемом переменными среды.

- Путем присоединения к приложению после завершения запуска, вызвав метод [иклрпрофилинг:: AttachProfiler](iclrprofiling-attachprofiler-method.md) .

Одна из первых препятствий будет получать данные о загрузке и загрузке библиотеки DLL профилировщика для правильной работы с приложениями Магазина Windows. Обе формы загрузки совместно используют некоторые особые рекомендации, поэтому начнем с них.

### <a name="common-considerations-for-startup-and-attach-loads"></a>Распространенные рекомендации по загрузке и присоединению загрузок

**Подписывание DLL-файла профилировщика**

Когда Windows пытается загрузить библиотеку DLL профилировщика, она проверяет, правильно ли подписан DLL-файл профилировщика. В противном случае загрузка завершается ошибкой по умолчанию. Это можно сделать двумя способами.

- Убедитесь, что DLL-файл профилировщика подписан.

- Сообщите пользователю, что он должен установить лицензию разработчика на компьютере с Windows 8, прежде чем использовать средство. Это можно сделать автоматически в Visual Studio или вручную из командной строки. Дополнительные сведения см. [в статье получение лицензии разработчика](https://docs.microsoft.com/previous-versions/windows/apps/hh974578(v=win.10)).

**Разрешения файловой системы**

Приложение Магазина Windows должно иметь разрешение на загрузку и выполнение библиотеки DLL профилировщика из расположения в файловой системе, в которой она Ресидесби по умолчанию, приложение Магазина Windows не имеет такого разрешения для большинства каталогов, а также любые неудачные попытки загрузить библиотеку DLL профилировщика. создаст запись в журнале событий приложений Windows, которая выглядит примерно так:

```output
NET Runtime version 4.0.30319.17929 - Loading profiler failed during CoCreateInstance.  Profiler CLSID: '{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}'.  HRESULT: 0x80070005.  Process ID (decimal): 4688.  Message ID: [0x2504].
```

Как правило, приложениям Магазина Windows предоставляется доступ только к ограниченному набору расположений на диске. Каждое приложение Магазина Windows может обращаться к собственным папкам данных приложений, а также к некоторым другим областям файловой системы, для которых доступ предоставляется всем приложениям Магазина Windows. Лучше всего установить библиотеку DLL профилировщика и ее зависимости где-либо в разделе Program Files или Program Files (x86), так как все приложения Магазина Windows по умолчанию имеют разрешения на чтение и выполнение.

### <a name="startup-load"></a>Загрузка при загрузке

Как правило, в классическом приложении пользовательский интерфейс профилировщика запрашивает загрузку библиотеки DLL профилировщика путем инициализации блока среды, содержащего необходимые переменные среды API профилирования CLR (т. е. `COR_PROFILER`, `COR_ENABLE_PROFILING`и `COR_PROFILER_PATH`), а затем создает новый процесс с этим блоком среды. То же самое относится к приложениям Магазина Windows, но механизмы отличаются.

**Не запускать с повышенными правами**

Если процесс A пытается попытаться создать процесс приложения Магазина Windows, процесс A должен выполняться на среднем уровне целостности, а не на высоком уровне целостности (т. е. без повышения прав). Это означает, что пользовательский интерфейс профилировщика должен выполняться на среднем уровне целостности, или же он должен порождать другой процесс на среднем уровне целостности, чтобы выполнять запуск приложения для Магазина Windows.

**Выбор приложения Магазина Windows для профилирования**

Сначала нужно попросить пользователя профилировщика, какое приложение Магазина Windows запустить. Для классических приложений, возможно, отображается диалоговое окно обзора файлов, и пользователь может найти и выбрать exe-файл. Но приложения Магазина Windows отличаются, и использование диалогового окна обзора не имеет смысла. Вместо этого лучше показывать пользователю список приложений Магазина Windows, установленных для выбора пользователем.

Для создания этого списка можно использовать класс <xref:Windows.Management.Deployment.PackageManager>. `PackageManager` — это среда выполнения Windows класс, доступный для настольных приложений, и на самом деле он доступен *только* для настольных приложений.

Следующий пример кода из гипотетического пользовательского интерфейса профилировщика, написанного как классическое приложение C# в, использует `PackageManager` для создания списка приложений Windows:

```csharp
string currentUserSID = WindowsIdentity.GetCurrent().User.ToString();
IAppxFactory appxFactory = (IAppxFactory) new AppxFactory();
PackageManager packageManager = new PackageManager();
IEnumerable<Package> packages = packageManager.FindPackagesForUser(currentUserSID);
```

**Указание пользовательского блока среды**

Новый COM-интерфейс [ипаккажедебугсеттингс](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipackagedebugsettings)позволяет настроить поведение приложения для Магазина Windows, чтобы упростить некоторые формы диагностики. Один из его методов, [енабледебуггинг](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging), позволяет передать блок среды в приложение Магазина Windows при запуске, а также другие полезные эффекты, такие как отключение автоматической приостановки процесса. Блок среды важен, так как для загрузки DLL-библиотеки профилировщика необходимо указать переменные среды (`COR_PROFILER`, `COR_ENABLE_PROFILING`и `COR_PROFILER_PATH)`), используемые средой CLR.

Рассмотрим следующий фрагмент кода:

```csharp
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();
pkgDebugSettings.EnableDebugging(packageFullName, debuggerCommandLine,
                                                                 (IntPtr)fixedEnvironmentPzz);
```

Существует несколько элементов, которые необходимо получить правильно:

- `packageFullName` можно определить во время итерации пакетов и захвата `package.Id.FullName`.

- `debuggerCommandLine` немного более интересно. Чтобы передать пользовательский блок среды в приложение Магазина Windows, необходимо написать собственный, упрощенный фиктивный отладчик. Windows порождает приложение Магазина Windows, которое приостановило работу, а затем присоединяет ваш отладчик, запустив отладчик с помощью командной строки, как в следующем примере:

    ```console
    MyDummyDebugger.exe -p 1336 -tid 1424
    ```

     где `-p 1336` означает, что приложение Магазина Windows имеет идентификатор процесса 1336, а `-tid 1424` означает, что поток с ИДЕНТИФИКАТОРом 1424 является приостановленным потоком. Фиктивный отладчик будет анализировать ThreadID из командной строки, возобновить поток и выйти из него.

     Вот пример C++ кода для этого (не забудьте добавить проверку ошибок):

    ```cpp
    int wmain(int argc, wchar_t* argv[])
    {
        // …
        // Parse command line here
        // …

        HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,
                                                                  FALSE /* bInheritHandle */, nThreadID);
        ResumeThread(hThread);
        CloseHandle(hThread);
        return 0;
    }
    ```

     Вам потребуется развернуть этот фиктивный отладчик в процессе установки средства диагностики, а затем указать путь к этому отладчику в параметре `debuggerCommandLine`.

**Запуск приложения для Магазина Windows**

Время запуска приложения для Магазина Windows, наконец, пришло. Если вы уже пробовали сделать это самостоятельно, возможно, вы заметили, что при создании приложения для Магазина Windows процесс [CreateProcess](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) не представляется. Вместо этого необходимо использовать метод [иаппликатионактиватионманажер:: активатеаппликатион](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iapplicationactivationmanager-activateapplication) . Для этого необходимо получить идентификатор модели пользователя приложения для приложения Магазина Windows, которое вы запускаете. И это означает, что вам потребуется немного продвигаясь вглубь через манифест.

При итерации пакетов (см. раздел "Выбор приложения Магазина Windows для профилирования" в разделе [Загрузка](#startup-load) загрузки выше) необходимо захватить набор приложений, содержащихся в манифесте текущего пакета:

```csharp
string manifestPath = package.InstalledLocation.Path + "\\AppxManifest.xml";

AppxPackaging.IStream manifestStream;
SHCreateStreamOnFileEx(
                    manifestPath,
                    0x00000040,     // STGM_READ | STGM_SHARE_DENY_NONE
                    0,              // file creation attributes
                    false,          // fCreate
                    null,           // reserved
                    out manifestStream);

IAppxManifestReader manifestReader = appxFactory.CreateManifestReader(manifestStream);

IAppxManifestApplicationsEnumerator appsEnum = manifestReader.GetApplications();
```

Да, один пакет может иметь несколько приложений, а каждое приложение имеет собственный идентификатор модели пользователя приложения. Поэтому вам нужно попросить пользователя о том, какое приложение профилировать, и взять идентификатор модели пользователя приложения из этого конкретного приложения:

```csharp
while (appsEnum.GetHasCurrent() != 0)
{
    IAppxManifestApplication app = appsEnum.GetCurrent();
    string appUserModelId = app.GetAppUserModelId();
    //...
}
```

Наконец, теперь у вас есть необходимые для запуска приложения Магазина Windows:

```csharp
IApplicationActivationManager appActivationMgr = new ApplicationActivationManager();
appActivationMgr.ActivateApplication(appUserModelId, appArgs, ACTIVATEOPTIONS.AO_NONE, out pid);
```

**Не забудьте вызвать Дисабледебуггинг**

При вызове [ипаккажедебугсеттингс:: енабледебуггинг](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging)вы сделали обещание, которое можно очистить после вызова метода [Ипаккажедебугсеттингс::D исабледебуггинг](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging) , поэтому не забудьте сделать это при завершении сеанса профилирования.

### <a name="attach-load"></a>Присоединить нагрузку

Когда пользовательский интерфейс профилировщика хочет подключить свой DLL-файл профилировщика к приложению, которое уже запущено, оно использует [иклрпрофилинг:: AttachProfiler](iclrprofiling-attachprofiler-method.md). То же самое относится и к приложениям Магазина Windows. Но в дополнение к распространенным вопросам, перечисленным выше, убедитесь, что целевое приложение Магазина Windows не приостановлено.

**енабледебуггинг**

Как и при запуске загрузки, вызовите метод [ипаккажедебугсеттингс:: енабледебуггинг](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging) . Он не нужен для передачи блока среды, но требуется одна из других функций: отключение автоматической приостановки процесса. В противном случае, когда пользовательский интерфейс профилировщика вызывает [AttachProfiler](iclrprofiling-attachprofiler-method.md), целевое приложение Магазина Windows может быть приостановлено. Фактически, это может быть вызвано тем, что пользователь взаимодействует с вашим ИНТЕРФЕЙСом профилировщика, а приложение Магазина Windows не активно ни на одном из экранов пользователя. Если приложение Магазина Windows приостановлено, оно не сможет ответить на любой сигнал, отправляемый средой CLR для подключения библиотеки DLL профилировщика.

Итак, вы захотите сделать что-то вроде этого:

```csharp
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();
pkgDebugSettings.EnableDebugging(packageFullName, null /* debuggerCommandLine */,
                                                                 IntPtr.Zero /* environment */);
```

Это тот же вызов, что и для стартового варианта загрузки, за исключением того, что вы не укажете командную строку отладчика или блок среды.

**дисабледебуггинг**

Как всегда, не забудьте вызвать [ипаккажедебугсеттингс::D исабледебуггинг](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging) по завершении сеанса профилирования.

## <a name="running-inside-the-windows-store-app"></a>Работа в приложении для Магазина Windows

Поэтому приложение Магазина Windows, наконец, загрузило вашу библиотеку DLL профилировщика. Теперь ваша библиотека DLL профилировщика должна научиться воспринимать различные правила, необходимые для приложений Магазина Windows, в том числе какие API являются допустимыми и как работать с ограниченными разрешениями.

### <a name="stick-to-the-windows-store-app-apis"></a>Прикрепить к API приложения Магазина Windows

При просмотре API Windows вы заметите, что каждый API является применимым для классических приложений, приложений Магазина Windows или и того, и другого. Например, раздел **требований** в документации по функции [инитиализекритикалсектионандспинкаунт](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) указывает, что функция применяется только к классическим приложениям. В отличие от этого функция [инитиализекритикалсектионекс](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex) доступна как для классических приложений, так и для приложений Магазина Windows.

При разработке библиотеки DLL профилировщика следует рассматривать ее как приложение для Магазина Windows и использовать только интерфейсы API, которые задокументированы как доступные для приложений Магазина Windows. Проанализируйте зависимости (например, вы можете запустить `link /dump /imports` с библиотекой DLL профилировщика для аудита), а затем выполните поиск по документации, чтобы узнать, какие из зависимостей имеют значение OK, а какие нет. В большинстве случаев нарушения можно устранить, просто заменив их более новой формой API, которая задокументирована как безопасность (например, замените [инитиализекритикалсектионандспинкаунт](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) на [инитиализекритикалсектионекс](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex)).

Вы можете заметить, что библиотека DLL профилировщика вызывает некоторые API, которые применяются только к классическим приложениям, но они работают даже при загрузке библиотеки DLL профилировщика в приложение Магазина Windows. Имейте в виду, что при загрузке в процесс приложения Магазина Windows не следует использовать API, которые не документированы для использования с приложениями Магазина Windows в библиотеке DLL профилировщика.

- Такие API не гарантированно будут работать при вызове в уникальном контексте, в котором работают приложения Магазина Windows.

- Такие API могут не работать согласованно при вызове из различных процессов приложения Магазина Windows.

- Такие API-интерфейсы могут работать отлично от приложений Магазина Windows в текущей версии Windows, но могут быть повреждены или отключены в будущих выпусках Windows.

Лучшим Советом является устранение всех нарушений и избежание риска.

Возможно, вы обнаружите, что вы не можете ничего делать без определенного API и не сможете найти замену, подходящую для приложений Магазина Windows. В этом случае, как минимум:

- Протестируйте, протестируйте и протестируйте на летнем занятии использование этого API.

- Понимание того, что API может внезапно прерываться или исчезать, если он вызывается из приложений Магазина Windows в будущих выпусках Windows. Это не будет рассматриваться как вопрос о совместимости корпорацией Майкрософт, и его использование не будет приоритетным.

### <a name="reduced-permissions"></a>Ограниченные разрешения

За пределами этого раздела вы можете перечислить все способы разрешения приложений для Магазина Windows от классических приложений. Но, безусловно, поведение будет отличаться каждый раз, когда библиотека DLL профилировщика (при загрузке в приложение Магазина Windows по сравнению с классом настольного приложения) пытается получить доступ к любым ресурсам. Файловая система является наиболее распространенным примером. На диске есть несколько мест, к которым может получить доступ данное приложение Магазина Windows (см. раздел [доступ к файлам и разрешения (среда выполнения Windows приложения](https://docs.microsoft.com/previous-versions/windows/apps/hh967755(v=win.10))), а библиотека DLL профилировщика будет иметь те же ограничения. Тщательно протестируйте код.

### <a name="inter-process-communication"></a>Взаимодействие между процессами

Как показано на схеме в начале этого документа, Библиотека DLL профилировщика (загруженная в пространство процессов приложения Магазина Windows), скорее всего, должна взаимодействовать с пользовательским ИНТЕРФЕЙСом профилировщика (запущенным в отдельном пространстве процесса приложения) с помощью собственного настраиваемого межпроцессного взаимодействия. канал связи (IPC). Пользовательский интерфейс профилировщика отправляет сигналы в библиотеку DLL профилировщика для изменения его поведения, а библиотека DLL профилировщика отправляет данные из проанализированного приложения Магазина Windows в пользовательский интерфейс профилировщика для последующей обработки и отображения пользователю профилировщика.

Большинство профилировщиков должны работать таким образом, но выбор механизмов IPC более ограничен, если DLL-файл профилировщика загружен в приложение Магазина Windows. Например, именованные каналы не входят в пакет SDK для приложений Магазина Windows, поэтому их нельзя использовать.

Конечно, файлы по-прежнему находятся в, хотя и более ограниченны. Также доступны события.

**Обмен данными через файлы**

Скорее всего, большая часть данных будет передаваться между библиотекой DLL профилировщика и профилировщиком с помощью файлов. Ключ заключается в том, чтобы выбрать расположение файла, в котором у вашего DLL-файла профилировщика (в контексте приложения Магазина Windows) и пользовательского интерфейса профилировщика есть доступ на чтение и запись. Например, путь к временной папке — это расположение, к которому может получить доступ Библиотека DLL профилировщика и пользовательский интерфейс профилировщика, но другие пакеты приложений для Магазина Windows не могут получить доступ (таким образом, экранирование любых сведений, которые вы регистрируете в других пакетах приложений Магазина Windows).

Как пользовательский интерфейс профилировщика, так и библиотека DLL профилировщика могут определять этот путь независимо. Пользовательский интерфейс профилировщика, когда он проходит по всем пакетам, установленным для текущего пользователя (см. пример кода выше), получает доступ к классу `PackageId`, из которого путь к временной папке может быть производным с помощью кода, аналогичного этому фрагменту. (Как всегда, для краткости опущена проверка ошибок.)

```csharp
// C# code for the Profiler UI.
ApplicationData appData =
    ApplicationDataManager.CreateForPackageFamily(
        packageId.FamilyName);

tempDir = appData.TemporaryFolder.Path;
```

В то же время библиотека DLL профилировщика может сделать то же самое, хотя она может легко получить <xref:Windows.Storage.ApplicationData> классу с помощью свойства [ApplicationData. Current](xref:Windows.Storage.ApplicationData.Current%2A) .

**Обмен данными через события**

Если вы хотите использовать простую семантику сигнализации между пользовательским интерфейсом профилировщика и библиотекой DLL профилировщика, можно воспользоваться событиями внутри приложений для Магазина Windows, а также для классических приложений.

Из библиотеки DLL профилировщика можно просто вызвать функцию [креативентекс](/windows/desktop/api/synchapi/nf-synchapi-createeventexa) , чтобы создать именованное событие с любым именем. Например:

```cpp
// Profiler DLL in Windows Store app (C++).
CreateEventEx(
    NULL,  // Not inherited
    "MyNamedEvent"
    CREATE_EVENT_MANUAL_RESET, /* explicit ResetEvent() required; leave initial state unsignaled */
    EVENT_ALL_ACCESS);
```

Затем пользовательский интерфейс профилировщика должен найти это именованное событие в пространстве имен приложения Магазина Windows. Например, Пользовательский интерфейс профилировщика может вызвать [креативентекс](/windows/desktop/api/synchapi/nf-synchapi-createeventexa), указав имя события как

`AppContainerNamedObjects\<acSid>\MyNamedEvent`

`<acSid>` — это идентификатор безопасности AppContainer приложения Магазина Windows. В предыдущем разделе этого раздела было показано, как выполнить итерацию по пакетам, установленным для текущего пользователя. Из этого примера кода можно получить packageId. И из packageId можно получить `<acSid>` с кодом, аналогичным следующему:

```csharp
IntPtr acPSID;
DeriveAppContainerSidFromAppContainerName(packageId.FamilyName, out acPSID);

string acSid;
ConvertSidToStringSid(acPSID, out acSid);

string acDir;
GetAppContainerFolderPath(acSid, out acDir);
```

### <a name="no-shutdown-notifications"></a>Уведомления о завершении работы отсутствуют

При работе в приложении для Магазина Windows библиотека DLL профилировщика не должна полагаться на метод [ICorProfilerCallback:: Shutdown](icorprofilercallback-shutdown-method.md) или даже [DllMain](/windows/desktop/Dlls/dllmain) (с `DLL_PROCESS_DETACH`), чтобы уведомить библиотеку DLL профилировщика о выходе приложения из Магазина Windows. На самом деле следует предполагать, что они никогда не будут вызываться. Исторически многие библиотеки DLL профилировщика использовали эти уведомления в качестве удобных мест для записи кэша на диск, закрытия файлов, отправки уведомлений обратно в пользовательский интерфейс профилировщика и т. д. Но теперь ваша библиотека DLL профилировщика должна быть организована несколько иначе.

Библиотека DLL профилировщика должна заносить в журнал данные по мере их возникновения. Из соображений производительности может потребоваться Пакетная информация в памяти и их сброс на диск, так как размер пакета превышает некоторое пороговое значение. Но предполагается, что все данные, которые еще не сброшены на диск, могут быть потеряны. Это означает, что вам нужно полагаться на пороговое значение, а пользовательский интерфейс профилировщика должен быть защищен для работы с неполными сведениями, записанными библиотекой DLL профилировщика.

## <a name="windows-runtime-metadata-files"></a>Файлы метаданных среда выполнения Windows

Он выходит за рамки этого документа, чтобы подробно узнать о том, какие файлы метаданных среда выполнения Windows (WinMD). Этот раздел ограничен тем, как API профилирования CLR реагирует, когда файлы WinMD загружаются приложением Магазина Windows, анализируемым библиотекой DLL профилировщика.

### <a name="managed-and-non-managed-winmds"></a>Управляемые и неуправляемые WinMD-файлы

Если разработчик использует Visual Studio для создания нового проекта среда выполнения Windows компонента, сборка этого проекта создает WinMD-файл, описывающий метаданные (описания типов классов, интерфейсов и т. д.), созданных разработчиком. Если проект управляемого языка написан на C# или Visual Basic, то этот файл WinMD также содержит реализацию этих типов (то есть содержит все IL-файлы, скомпилированные из исходного кода разработчика). Такие файлы называются управляемыми WinMD-файлами. Они интересны тем, что они содержат как среда выполнения Windows метаданные, так и базовую реализацию.

Напротив, если разработчик создает проект среда выполнения Windows компонента для C++, сборка этого проекта создает WINMD-файл, который содержит только метаданные, а реализация компилируется в отдельную собственную библиотеку DLL. Аналогичным образом файлы WinMD, поставляющиеся в Windows SDK, содержат только метаданные, а реализация компилируется в отдельные библиотеки DLL, которые поставляются в составе Windows.

Приведенные ниже сведения относятся к управляемым WinMD-данным, которые содержат метаданные и реализацию, а также к неуправляемым WinMD-, которые содержат только метаданные.

### <a name="winmd-files-look-like-clr-modules"></a>WinMD-файлы выглядят как модули CLR

С точки зрения среды CLR все файлы WinMD являются модулями. Поэтому API профилирования CLR сообщает библиотеке DLL профилировщика о загрузке файлов WinMD и о том, что они Модулеидс, так же, как и для других управляемых модулей.

Библиотека DLL профилировщика может отличать файлы WinMD от других модулей путем вызова метода [ICorProfilerInfo3:: GetModuleInfo2](icorprofilerinfo3-getmoduleinfo2-method.md) и проверки параметра вывода `pdwModuleFlags` для флага [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) . (Он устанавливается только в том случае, если он представляет WinMD-объект.)

### <a name="reading-metadata-from-winmds"></a>Чтение метаданных из WinMD-файлы

Файлы WinMD, как и обычные модули, содержат метаданные, которые можно считать с помощью [API метаданных](../../../../docs/framework/unmanaged-api/metadata/index.md). Однако среда CLR сопоставляет среда выполнения Windows типы с .NET Framework типами при считывании WinMD-файлов, чтобы разработчики, которые программировать в управляемом коде и использовать файл WinMD, могли использовать более естественный интерфейс программирования. Некоторые примеры этих сопоставлений см. в разделе [поддержка .NET Framework для приложений Магазина Windows и среда выполнения Windows](../../../standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md).

Итак, какое представление будет получать профилировщик при использовании API метаданных: необработанное среда выполнения Windows представление или сопоставленное .NET Framework представление?  Ответ. это все, что вам нужно.

При вызове метода [ICorProfilerInfo:: жетмодулеметадата](icorprofilerinfo-getmodulemetadata-method.md) для WinMD для получения интерфейса метаданных, например [IMetaDataImport](../../../../docs/framework/unmanaged-api/metadata/imetadataimport-interface.md), можно задать [офнотрансформ](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) в параметре `dwOpenFlags`, чтобы отключить это сопоставление. В противном случае сопоставление будет включено по умолчанию. Как правило, профилировщик сохранит включенное сопоставление, чтобы строки, получаемые библиотекой DLL профилировщика из метаданных WinMD (например, имена типов), были привычными и естественными для пользователя профилировщика.

### <a name="modifying-metadata-from-winmds"></a>Изменение метаданных из WinMD-файлы

Изменение метаданных в WinMD-файлы не поддерживается. Если вызвать метод [ICorProfilerInfo:: жетмодулеметадата](icorprofilerinfo-getmodulemetadata-method.md) для WINMD-файла и указать [офврите](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) в параметре `dwOpenFlags` или запросить доступный для записи интерфейс метаданных, например [IMetaDataEmit](../../../../docs/framework/unmanaged-api/metadata/imetadataemit-interface.md), [жетмодулеметадата](icorprofilerinfo-getmodulemetadata-method.md) завершится ошибкой. Это конкретная важность для профилировщиков, которые требуют изменения метаданных для поддержки инструментирования (например, для добавления Ассемблирефс или новых методов). Поэтому сначала следует проверить [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) (как описано в предыдущем разделе) и не запрашивать доступные для записи интерфейсы метаданных в таких модулях.

### <a name="resolving-assembly-references-with-winmds"></a>Разрешение ссылок на сборки в WinMD-файлы

Многим профилировщикам необходимо вручную разрешать ссылки на метаданные для помощи при инструментировании или проверке типов. Такие профилировщики должны знать, как среда CLR разрешает ссылки на сборки, указывающие на WinMD-файлы, так как эти ссылки разрешаются совершенно иначе, чем стандартные ссылки на сборки.

## <a name="memory-profilers"></a>Профилировщики памяти

Сборщик мусора и управляемая куча не являются принципиально разными в приложениях для Магазина Windows и классических приложениях. Однако существуют некоторые небольшие отличия, которые должны быть осведомлены авторам профилировщика.

### <a name="forcegc-creates-a-managed-thread"></a>ForceGC создает управляемый поток

При профилировании памяти библиотека DLL профилировщика обычно создает отдельный поток, из которого вызывается метод [метода ForceGC](icorprofilerinfo-forcegc-method.md) . Ничего нового. Но что может быть удивительно, поскольку процесс сборки мусора внутри приложения для Магазина Windows может преобразовать поток в управляемый поток (например, для этого потока создается потоковый интерфейс API профилирования).

Чтобы понять последствия этого, важно понимать различия между синхронными и асинхронными вызовами, определенными API профилирования CLR. Обратите внимание, что это сильно отличается от концепции асинхронных вызовов в приложениях для Магазина Windows. Дополнительные сведения см. в записи блога о [CORPROF_E_UNSUPPORTED_CALL_SEQUENCE](https://blogs.msdn.microsoft.com/davbr/2008/12/23/why-we-have-corprof_e_unsupported_call_sequence/) .

Соответствующая точка заключается в том, что вызовы, выполняемые в потоках, созданных профилировщиком, всегда считаются синхронными, даже если эти вызовы выполняются вне реализации одного из методов [ICorProfilerCallback](icorprofilercallback-interface.md) библиотеки DLL профилировщика. По крайней мере, это используется в качестве варианта. Теперь, когда среда CLR включила поток профилировщика в управляемый поток из-за вызова [метода ForceGC](icorprofilerinfo-forcegc-method.md), этот поток больше не считается потоком профилировщика. Таким образом, среда CLR применяет более строгое определение того, что определяет как синхронное для этого потока, а именно, что вызов должен исходить из одного из методов [ICorProfilerCallback](icorprofilercallback-interface.md) библиотеки DLL профилировщика, чтобы считаться синхронным.

Что это означает на практике? Большинство методов [ICorProfilerInfo](icorprofilerinfo-interface.md) можно вызывать только синхронно, и в противном случае произойдет сбой. Поэтому, если библиотека DLL профилировщика повторно использует поток [метода ForceGC](icorprofilerinfo-forcegc-method.md) для других вызовов, обычно сделанных в потоках, созданных профилировщиком (например, в [рекуестпрофилердетач](icorprofilerinfo3-requestprofilerdetach-method.md), [рекуестрежит](icorprofilerinfo4-requestrejit-method.md)или [рекуестреверт](icorprofilerinfo4-requestrevert-method.md)), возникают проблемы. Даже асинхронная функция, такая как [DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) , имеет специальные правила при вызове из управляемых потоков. (Дополнительные сведения см. в записи блога анализ [стека профилировщика: основы и дополнение](https://blogs.msdn.microsoft.com/davbr/2005/10/06/profiler-stack-walking-basics-and-beyond/) .)

Поэтому рекомендуется использовать любой поток, создаваемый библиотекой DLL профилировщика для вызова [метода ForceGC](icorprofilerinfo-forcegc-method.md) , *только* в целях активации GC и последующего реагирования на обратные вызовы GC. Он не должен вызывать API профилирования для выполнения других задач, таких как выборка стека или отсоединение.

### <a name="conditionalweaktablereferences"></a>кондитионалвеактаблереференцес

Начиная с .NET Framework 4,5 существует новый обратный вызов GC, [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md), который предоставляет профилировщику более полные сведения о *зависимых дескрипторах*. Эти дескрипторы эффективно добавляют ссылку из исходного объекта в целевой объект с целью управления жизненным циклом сборки мусора. Зависимые дескрипторы ничего не появились, и разработчики, которые программировать в управляемом коде, могли создавать собственные зависимые дескрипторы с помощью класса <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602?displayProperty=nameWithType>, даже до Windows 8 и .NET Framework 4,5.

Однако управляемые приложения для Магазина Windows в XAML теперь сильно используют зависимые дескрипторы. В частности, среда CLR использует их для упрощения управления циклами ссылок между управляемыми и неуправляемыми среда выполнения Windowsными объектами. Это означает, что теперь профилировщикам памяти важнее знать о таких зависимых маркерах, чтобы их можно было визуально отобразить вместе с остальными краями в графе кучи. Библиотека DLL профилировщика должна использовать [RootReferences2](icorprofilercallback2-rootreferences2-method.md), [ObjectReferences](icorprofilercallback-objectreferences-method.md)и [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md) вместе для формирования полного представления графа кучи.

## <a name="conclusion"></a>Заключение

API профилирования CLR можно использовать для анализа управляемого кода, выполняющегося в приложениях для Магазина Windows. Фактически, можно взять существующий профилировщик, который вы разрабатываете, и внести некоторые изменения, чтобы он мог ориентироваться на приложения для Магазина Windows. Пользовательский интерфейс профилировщика должен использовать новые API для активации приложения Магазина Windows в режиме отладки. Убедитесь, что библиотека DLL профилировщика использует только те интерфейсы API, которые применимы к приложениям Магазина Windows. Механизм связи между библиотекой DLL профилировщика и ИНТЕРФЕЙСом профилировщика должен быть написан с учетом ограничений API приложений Магазина Windows и осведомленности об ограниченных разрешениях для приложений Магазина Windows. Библиотека DLL профилировщика должна знать, как среда CLR обрабатывает WinMD-файлы, и как поведение сборщика мусора отличается в отношении управляемых потоков.

## <a name="resources"></a>Ресурсы

**Среда CLR**

- [Профилирование (Справочник по неуправляемым интерфейсам API)](index.md)

- [Метаданные (Справочник по неуправляемым интерфейсам API)](../metadata/index.md)

**Взаимодействие CLR с среда выполнения Windows**

- [Поддержка платформы .NET Framework для приложений магазина Windows и среды выполнения Windows](../../../standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)

**Приложения для Магазина Windows**

- [Доступ к файлам и разрешения (среда выполнения Windows приложения](https://docs.microsoft.com/previous-versions/windows/apps/hh967755%28v=win.10%29)

- [Получить лицензию разработчика](https://docs.microsoft.com/previous-versions/windows/apps/hh974578%28v=win.10%29)

- [Интерфейс Ипаккажедебугсеттингс](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipackagedebugsettings)
