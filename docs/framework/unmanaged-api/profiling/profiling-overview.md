---
title: Общие сведения о профилировании
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: aa8bff374e9698d4b7e032428ec1bdc66901e05d
ms.sourcegitcommit: b11efd71c3d5ce3d9449c8d4345481b9f21392c6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2020
ms.locfileid: "76860919"
---
# <a name="profiling-overview"></a>Общие сведения о профилировании

Профилировщик — это инструмент, который наблюдает за выполнением другого приложения. Профилировщик среды CLR — это библиотека DLL, содержащая функции, которые получают сообщения из среды CLR и отправляют сообщения в среду CLR с помощью API профилирования. Библиотека DLL профилировщика загружается средой CLR во время выполнения.

Традиционные средства профилирования основное внимание уделяют измерению выполнения приложения. То есть они измеряют время, затраченное на каждую функцию, или использование памяти приложением за период времени. API профилирования предназначен для более широкого класса диагностических средств, таких как служебные программы с покрытием кода и расширенные средства отладки. Сфера их применения — вся диагностика в природе. API профилирования не только измеряет, но также наблюдает за выполнением приложения. По этой причине API профилирования никогда не должен использоваться самим приложением, и выполнение приложения не должно ни зависеть от профилировщика, ни подвергаться его влиянию.

Для профилирования приложения среды CLR требуется дополнительная поддержка по сравнению с профилированием стандартно скомпилированного машинного кода. Это объясняется тем, что в среде CLR вводятся такие понятия, как домены приложений, сборка мусора, обработка управляемых исключений, JIT-компиляция кода (преобразование кода MSIL в машинный код) и другие аналогичные возможности. Механизмы традиционного профилирования не могут обнаруживать эти возможности или предоставлять полезные сведения о них. API профилирования эффективно предоставляет эти отсутствующие сведения с минимальным влиянием на производительность среды CLR и профилируемого приложения.

JIT-компиляция во время выполнения обеспечивает прекрасные возможности для профилирования. API профилирования позволяет профилировщику вносить изменения потока кода MSIL в памяти для подпрограммы перед ее JIT-компиляцией. Таким образом, профилировщик может динамически добавлять код инструментирования в определенные подпрограммы, требующие более глубокого анализа. Хотя такой подход возможен в обычных сценариях, его гораздо проще реализовать для среды CLR с помощью API профилирования.

## <a name="the-profiling-api"></a>API профилирования

Как правило, API профилирования используется для написания *профилировщика кода*, который является программой, отслеживающей выполнение управляемого приложения.

API профилирования используется библиотекой DLL профилировщика, которая загружается в один процесс с профилируемым приложением. Библиотека DLL профилировщика реализует интерфейс обратного вызова ([ICorProfilerCallback](icorprofilercallback-interface.md) в .NET Framework версии 1,0 и 1,1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) в версии 2,0 и более поздних). Среда CLR вызывает методы этого интерфейса для уведомления профилировщика о событиях в процессе профилирования. Профилировщик может выполнить обратный вызов в среду выполнения, используя методы в интерфейсах [ICorProfilerInfo](icorprofilerinfo-interface.md) и [ICorProfilerInfo2](icorprofilerinfo2-interface.md) для получения сведений о состоянии профилированного приложения.

> [!NOTE]
> В одном процессе с профилируемым приложением должна запускаться только часть решения профилировщика, отвечающая за сбор данных. Весь анализ пользовательского интерфейса и данных должен выполняться в отдельном процессе.

На следующем рисунке показано, как библиотека DLL профилировщика взаимодействует с профилируемым приложением и средой CLR.

![Снимок экрана, на котором показана архитектура профилирования.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a>Интерфейсы уведомлений

[ICorProfilerCallback](icorprofilercallback-interface.md) и [ICorProfilerCallback2](icorprofilercallback2-interface.md) могут считаться интерфейсами уведомления. Эти интерфейсы состоят из таких методов, как [класслоадстартед](icorprofilercallback-classloadstarted-method.md), [класслоадфинишед](icorprofilercallback-classloadfinished-method.md)и [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md). Каждый раз, когда среда CLR загружает или выгружает класс, компилирует функцию и т. д., она вызывает соответствующий метод в интерфейсе `ICorProfilerCallback` или `ICorProfilerCallback2` профилировщика.

Например, профилировщик может измерять производительность кода с помощью двух функций уведомления: [FunctionEnter2](functionenter2-function.md) и [FunctionLeave2](functionleave2-function.md). Он просто устанавливает метки времени для каждого уведомления, собирает результаты и выводит список, в котором указывается, на какие функции было затрачено больше ресурсов ЦП или физического времени во время выполнения приложения.

### <a name="the-information-retrieval-interfaces"></a>Интерфейсы для извлечения сведений

Другими основными интерфейсами, участвующими в профилировании, являются [ICorProfilerInfo](icorprofilerinfo-interface.md) и [ICorProfilerInfo2](icorprofilerinfo2-interface.md). Профилировщик вызывает эти интерфейсы по мере необходимости для получения дополнительных сведений, помогающих выполнить анализ. Например, всякий раз, когда среда CLR вызывает функцию [FunctionEnter2](functionenter2-function.md) , она предоставляет идентификатор функции. Профилировщик может получить дополнительные сведения об этой функции, вызвав метод [ICorProfilerInfo2:: GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) , чтобы обнаружить родительский класс функции, его имя и т. д.

## <a name="supported-features"></a>Поддерживаемые компоненты

API профилирования предоставляет сведения о различных событиях и действиях, которые происходят в среде CLR. Эти сведения можно использовать для мониторинга внутренней работы процессов и анализа производительности приложения .NET Framework.

API профилирования извлекает сведения о следующих действиях и событиях, происходящих в среде CLR.

- События запуска и завершения работы среды CLR.

- События создания и завершения работы домена приложения.

- События загрузки и выгрузки сборки.

- События загрузки и выгрузки модуля.

- События создания и удаления таблицы VTable COM.

- События JIT-компиляции и пошагового выполнения кода.

- События загрузки и выгрузки класса.

- События создания и удаления потока.

- События входа и выхода функции.

- Исключения.

- Переходы между выполнением управляемого и неуправляемого кода.

- Переходы между различными контекстами среды выполнения.

- Сведения о приостановках среды выполнения.

- Сведения о действиях сборки мусора и кучи в памяти времени выполнения.

API профилирования можно вызывать из любого (неуправляемого) языка, совместимого с COM.

Этот API является эффективным с точки зрения потребления ресурсов ЦП и памяти. Профилирование не влечет за собой изменения профилируемого приложения, которые могут привести к недостоверным результатам.

API профилирования полезен для профилировщиков как с выборкой, так и без выборки. *Профилировщик с выборкой* проверяет профиль по регулярным тактовым импульсам, скажем, через 5 миллисекунд. *Профилировщик без выборки* уведомляется о событии синхронно с потоком, вызвавшим событие.

### <a name="unsupported-functionality"></a>Неподдерживаемые функциональные возможности

API профилирования не поддерживает следующие функциональные возможности.

- Неуправляемый код, который необходимо профилировать с помощью стандартных методов Win32. Однако профилировщик среды CLR включает события переходов для определения границ между управляемым и неуправляемым кодом.

- Самоизменяющиеся приложения, которые изменяют собственный код приложения, которые изменяют собственный код, например в целях аспектно-ориентированного программирования.

- Проверка привязок, поскольку API профилирования не предоставляет эти сведения. Среда CLR предоставляет существенную поддержку для проверки границ всего управляемого кода.

- Удаленное профилирование, которое не поддерживается по следующим причинам.

  - Удаленное профилирование увеличивает время выполнения. При использовании интерфейсов профилирования необходимо минимизировать время выполнения, чтобы оно не слишком сильно сказывалось на результатах профилирования. Это особенно важно при мониторинге производительности. Тем не менее удаленное профилирование не является ограничением при использовании интерфейсов профилирования для мониторинга использования памяти или для получения сведений времени выполнения о кадрах стека, объектах и т. п.

  - Профилировщик кода среды CLR должен зарегистрировать один или несколько интерфейсов обратного вызова в среде выполнения на локальном компьютере, на котором выполняется профилируемое приложение. Это ограничивает возможность создания удаленного профилировщика кода.

- Профилирование в производственных средах с требованиями высокой доступности. API профилирования создавался для поддержки диагностики во время разработки. Он не проходил строгие испытания, необходимые для поддержки производственных сред.

## <a name="notification-threads"></a>Потоки уведомлений

В большинстве случаев поток, который создает событие, также выполняет уведомления. Такие уведомления (например, [FunctionEnter](functionenter-function.md) и [FunctionLeave](functionleave-function.md)) не требуют предоставления явных `ThreadID`. Кроме того, профилировщик может использовать локальное хранилище потока для хранения и обновления своих блоков анализа вместо индексирования этих блоков в глобальном хранилище на основе `ThreadID` затронутого потока.

Обратите внимание, что эти обратные вызовы не сериализуются. Пользователи должны защищать свой код, путем создания потокобезопасных структур данных и путем блокировки кода профилировщика в тех случаях, когда необходимо предотвратить параллельный доступ из нескольких потоков. Таким образом, в некоторых случаях можно получить необычную последовательность обратных вызовов. Например, предположим, что управляемое приложение порождает два потока, выполняющие идентичный код. В этом случае можно получить событие [ICorProfilerCallback:: JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) для некоторой функции из одного потока и обратный вызов `FunctionEnter` из другого потока перед получением обратного вызова [ICorProfilerCallback:: JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) . В этом случае пользователь получит обратный вызов `FunctionEnter` для функции, которая могла быть не полностью JIT-скомпилирована.

## <a name="security"></a>по безопасности

Библиотека DLL профилировщика — это неуправляемая библиотека DLL, которая выполняется в рамках подсистемы выполнения среды CLR. В результате на код в библиотеке DLL профилировщика DLL не налагаются ограничения управления доступом для управляемого кода. Для библиотеки DLL профилировщика действуют только ограничения, накладываемые операционной системой на пользователя, запускающего профилируемое приложение.

Разработчики профилировщика должны принять соответствующие меры предосторожности, чтобы избежать проблем, связанных с безопасностью. Например, во время установки библиотека DLL профилировщика должна добавляться в список управления доступом (ACL), чтобы злоумышленник не мог изменить ее.

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a>Объединение управляемого и неуправляемого кода в коде профилировщика

Неправильно написанный профилировщик может вызвать циклические ссылки на себя, что приводит к непредсказуемому поведению.

Обзор API профилирования среды CLR может создать впечатление, что можно написать профилировщик, содержащий управляемые и неуправляемые компоненты, которые вызывают друг друга посредством COM-взаимодействия или непрямых вызовов.

Хотя это возможно с точки зрения проектирования, API профилирования не поддерживает управляемые компоненты. Профилировщик среды CLR должен быть полностью неуправляемым. Попытки объединить управляемый и неуправляемый код в профилировщике среды CLR могут привести к нарушениям прав доступа, сбоям программы или взаимоблокировкам. Управляемые компоненты профилировщика будут возвращать события обратно их неуправляемым компонентам, что будет затем вызывать управляемые компоненты снова, и таким образом будут создаваться циклические ссылки.

Единственное место, где профилировщик CLR может безопасно вызывать управляемый код, это текст MSIL в теле метода. Рекомендуемым методом изменения тела MSIL является использование методов JIT-компиляции в интерфейсе [ICorProfilerCallback4](icorprofilercallback4-interface.md) .

Кроме того, для изменения MSIL можно использовать старые методы инструментирования. Перед завершением JIT-компиляции функции профилировщик может вставить управляемые вызовы в текст MSIL метода, а затем выполнить JIT-компиляцию (см. метод [ICorProfilerInfo:: GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) ). Этот способ можно успешно использовать для выборочного инструментирования управляемого кода или для сбора статистики и данных производительности касательно JIT.

Кроме того, профилировщик кода может вставлять собственные обработчики в текст MSIL любой управляемой функции, которая вызывает неуправляемый код. Этот способ можно использовать для инструментирования и покрытия. Например, профилировщик кода может вставить обработчики инструментирования после каждого блока MSIL для обеспечения выполнения блока. Изменение текста MSIL метода следует выполнять очень аккуратно и принимать во внимание множество факторов.

## <a name="profiling-unmanaged-code"></a>Профилирование неуправляемого кода

API профилирования среды CLR предоставляет минимальную поддержку профилирования неуправляемого кода. Предоставляются следующие функциональные возможности.

- Перечисление цепочек стека. Эта возможность позволяет профилировщику кода определить границу между управляемым и неуправляемым кодом.

- Определение, соответствует ли цепочка стека управляемому коду или машинному коду.

В .NET Framework версий 1.0 и 1.1 эти методы доступны через внутрипроцессное подмножество API отладки среды CLR. Они определяются в файле CorDebug.idl.

В .NET Framework 2,0 и более поздних версиях для этой функции можно использовать метод [ICorProfilerInfo2::D остаккснапшот](icorprofilerinfo2-dostacksnapshot-method.md) .

## <a name="using-com"></a>Использование модели COM

Хотя интерфейсы профилирования определяются как COM-интерфейсы, среда CLR в действительности не инициализирует модель COM для использования этих интерфейсов. Причина заключается в том, чтобы не задавать модель потоков с помощью функции [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) , прежде чем управляемое приложение сможет указать требуемую потоковую модель. Аналогично, сам профилировщик не должен вызывать `CoInitialize`, поскольку он может выбрать потоковую модель, несовместимую с профилируемым приложением, что может привести к сбою приложения.

## <a name="call-stacks"></a>Стеки вызовов

API профилирования предоставляет два способа получения стеков вызова: метод моментальных снимков стека, который позволяет реже выполнять сбор стеков вызовов, и метод теневого стека, который отслеживает стек вызовов в каждый момент времени.

### <a name="stack-snapshot"></a>Моментальный снимок стека

Моментальный снимок стека — это трассировка стека потока в момент времени. API профилирования поддерживает трассировку управляемых функций в стеке, но оставляет трассировку неуправляемых функций собственному обходчику стека профилировщика.

Дополнительные сведения о программировании профилировщика для прохода по управляемым стекам см. в описании метода [ICorProfilerInfo2::D остаккснапшот](icorprofilerinfo2-dostacksnapshot-method.md) в этом наборе документации и [в стеке профилировщика в .NET Framework 2,0: основы и за пределами](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).

### <a name="shadow-stack"></a>Теневой стек

Слишком частое использование метода моментального снимка может быстро создавать проблемы производительности. Если вы хотите часто получать трассировки стека, профилировщик должен создать теневой стек с помощью обратных вызовов исключений [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md)и [ICorProfilerCallback2](icorprofilercallback2-interface.md) . Теневой стек всегда является текущим, и его можно быстро скопировать в хранилище каждый раз, когда требуется моментальный снимок стека.

Теневой стек может получать аргументы функций, возвращать значения и сведения об универсальных экземплярах. Эти сведения доступны только посредством теневого стека и могут быть получены, когда управление передается в функцию. Однако эти сведения могут оказаться недоступны позднее, во время выполнения функции.

## <a name="callbacks-and-stack-depth"></a>Обратные вызовы и глубина стека вызовов

Обратные вызовы профилировщика могут осуществляться в условиях очень ограниченного стека, и переполнение стека в обратном вызове профилировщика приведет к немедленному завершению выполнения процесса. В ответ на обратные вызовы профилировщик должен гарантированно использовать минимально возможный стек. Если профилировщик предназначен для использования в процессах, устойчивых к переполнению стека, сам профилировщик должен также избегать активации переполнения стека.

## <a name="related-topics"></a>Связанные разделы

|Заголовок|Описание|
|-----------|-----------------|
|[Настройка среды профилирования](setting-up-a-profiling-environment.md)|В этом разделе объясняется, как можно инициализировать профилировщик, установить уведомления о событиях и профилировать службу Windows.|
|[Интерфейсы профилирования](profiling-interfaces.md)|В этом разделе описываются неуправляемые интерфейсы, которые использует API профилирования.|
|[Глобальные статические функции профилирования](profiling-global-static-functions.md)|В этом разделе описываются неуправляемые глобальные статистические функции, которые использует API профилирования.|
|[Перечисления профилирования](profiling-enumerations.md)|В этом разделе описываются неуправляемые перечисления, которые использует API профилирования.|
|[Структуры профилирования](profiling-structures.md)|В этом разделе описываются неуправляемые структуры, которые использует API профилирования.|
