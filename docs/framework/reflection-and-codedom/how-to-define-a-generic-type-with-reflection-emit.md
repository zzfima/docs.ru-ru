---
title: Практическое руководство. Определение универсального типа с порождаемым отражением
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- generics [.NET Framework], reflection emit
- generics [.NET Framework], dynamic types
- reflection emit, generic types
ms.assetid: 07d5f01a-7b5b-40ea-9b15-f21561098fe4
ms.openlocfilehash: b553fd2235c73cf879474dc4f44f958dddcb649c
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73130156"
---
# <a name="how-to-define-a-generic-type-with-reflection-emit"></a><span data-ttu-id="ce180-102">Практическое руководство. Определение универсального типа с порождаемым отражением</span><span class="sxs-lookup"><span data-stu-id="ce180-102">How to: Define a Generic Type with Reflection Emit</span></span>
<span data-ttu-id="ce180-103">В этом разделе приведено описание способов создания простого универсального типа с двумя параметрами типа, порядка применения ограничений класса, ограничений интерфейса и специальных ограничений параметров типа, создания элементов, использующих параметры типа класса в качестве типов параметров и возвращаемых типов.</span><span class="sxs-lookup"><span data-stu-id="ce180-103">This topic shows how to create a simple generic type with two type parameters, how to apply class constraints, interface constraints, and special constraints to the type parameters, and how to create members that use the type parameters of the class as parameter types and return types.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="ce180-104">Метод не может являться универсальным только потому, что он принадлежит универсальному типу и использует параметры этого типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-104">A method is not generic just because it belongs to a generic type and uses the type parameters of that type.</span></span> <span data-ttu-id="ce180-105">Метод является универсальным только в том случае, если он имеет свой собственный список параметров типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-105">A method is generic only if it has its own type parameter list.</span></span> <span data-ttu-id="ce180-106">Большинство методов в универсальных типах не являются универсальными, как в этом примере.</span><span class="sxs-lookup"><span data-stu-id="ce180-106">Most methods on generic types are not generic, as in this example.</span></span> <span data-ttu-id="ce180-107">Пример выпуска универсального метода см. в разделе [Практическое руководство. Определение универсального метода с порождаемым отражением](how-to-define-a-generic-method-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="ce180-107">For an example of emitting a generic method, see [How to: Define a Generic Method with Reflection Emit](how-to-define-a-generic-method-with-reflection-emit.md).</span></span>  
  
### <a name="to-define-a-generic-type"></a><span data-ttu-id="ce180-108">Определение универсального типа</span><span class="sxs-lookup"><span data-stu-id="ce180-108">To define a generic type</span></span>  
  
1. <span data-ttu-id="ce180-109">Определите динамическую сборку с именем `GenericEmitExample1`.</span><span class="sxs-lookup"><span data-stu-id="ce180-109">Define a dynamic assembly named `GenericEmitExample1`.</span></span> <span data-ttu-id="ce180-110">В этом примере сборка выполняется и сохраняется на диске, так что указан флаг <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce180-110">In this example, the assembly is executed and saved to disk, so <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> is specified.</span></span>  
  
     [!code-cpp[EmitGenericType#2](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#2)]
     [!code-csharp[EmitGenericType#2](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#2)]
     [!code-vb[EmitGenericType#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#2)]  
  
2. <span data-ttu-id="ce180-111">Определите динамический модуль.</span><span class="sxs-lookup"><span data-stu-id="ce180-111">Define a dynamic module.</span></span> <span data-ttu-id="ce180-112">Сборка состоит из выполняемых модулей.</span><span class="sxs-lookup"><span data-stu-id="ce180-112">An assembly is made up of executable modules.</span></span> <span data-ttu-id="ce180-113">Для сборки с одним модулем именем модуля является имя сборки, а именем файла — имя сборки с расширением.</span><span class="sxs-lookup"><span data-stu-id="ce180-113">For a single-module assembly, the module name is the same as the assembly name, and the file name is the module name plus an extension.</span></span>  
  
     [!code-cpp[EmitGenericType#3](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#3)]
     [!code-csharp[EmitGenericType#3](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#3)]
     [!code-vb[EmitGenericType#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#3)]  
  
3. <span data-ttu-id="ce180-114">Определите класс.</span><span class="sxs-lookup"><span data-stu-id="ce180-114">Define a class.</span></span> <span data-ttu-id="ce180-115">В этом примере класс называется `Sample`.</span><span class="sxs-lookup"><span data-stu-id="ce180-115">In this example, the class is named `Sample`.</span></span>  
  
     [!code-cpp[EmitGenericType#4](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#4)]
     [!code-csharp[EmitGenericType#4](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#4)]
     [!code-vb[EmitGenericType#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#4)]  
  
4. <span data-ttu-id="ce180-116">Определите параметры универсального типа метода `Sample` посредством передачи массива строк, содержащего имена параметров, в метод <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce180-116">Define the generic type parameters of `Sample` by passing an array of strings containing the names of the parameters to the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="ce180-117">Этот класс станет универсального типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-117">This makes the class a generic type.</span></span> <span data-ttu-id="ce180-118">Возвращаемое значение — это массив объектов <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, представляющих параметры типа, который может использоваться в выпущенном коде.</span><span class="sxs-lookup"><span data-stu-id="ce180-118">The return value is an array of <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects representing the type parameters, which can be used in your emitted code.</span></span>  
  
     <span data-ttu-id="ce180-119">В следующем коде `Sample` становится универсальным типом с параметрами типа `TFirst` и `TSecond`.</span><span class="sxs-lookup"><span data-stu-id="ce180-119">In the following code, `Sample` becomes a generic type with type parameters `TFirst` and `TSecond`.</span></span> <span data-ttu-id="ce180-120">Чтобы сделать код более удобными для чтения, каждый объект <xref:System.Reflection.Emit.GenericTypeParameterBuilder> помещается в переменную с тем же именем, что параметр типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-120">To make the code easier to read, each <xref:System.Reflection.Emit.GenericTypeParameterBuilder> is placed in a variable with the same name as the type parameter.</span></span>  
  
     [!code-cpp[EmitGenericType#5](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#5)]
     [!code-csharp[EmitGenericType#5](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#5)]
     [!code-vb[EmitGenericType#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#5)]  
  
5. <span data-ttu-id="ce180-121">Добавьте специальные ограничения параметров типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-121">Add special constraints to the type parameters.</span></span> <span data-ttu-id="ce180-122">В этом примере параметр типа `TFirst` ограничен типами, имеющими конструкторы без параметров, а также ссылочными типами.</span><span class="sxs-lookup"><span data-stu-id="ce180-122">In this example, type parameter `TFirst` is constrained to types that have parameterless constructors, and to reference types.</span></span>  
  
     [!code-cpp[EmitGenericType#6](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#6)]
     [!code-csharp[EmitGenericType#6](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#6)]
     [!code-vb[EmitGenericType#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#6)]  
  
6. <span data-ttu-id="ce180-123">Дополнительно добавьте ограничения класса и интерфейса в параметры типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-123">Optionally add class and interface constraints to the type parameters.</span></span> <span data-ttu-id="ce180-124">В этом примере параметр типа `TFirst` ограничен типами, которые являются производными из базового класса, представленного объектом <xref:System.Type>, содержащимся в переменной `baseType`, а также которые реализуют интерфейсы, содержащие типы в переменных `interfaceA` и `interfaceB`.</span><span class="sxs-lookup"><span data-stu-id="ce180-124">In this example, type parameter `TFirst` is constrained to types that derive from the base class represented by the <xref:System.Type> object contained in the variable `baseType`, and that implement the interfaces whose types are contained in the variables `interfaceA` and `interfaceB`.</span></span> <span data-ttu-id="ce180-125">Объявление и назначение этих переменных см. в примере кода.</span><span class="sxs-lookup"><span data-stu-id="ce180-125">See the code example for the declaration and assignment of these variables.</span></span>  
  
     [!code-cpp[EmitGenericType#7](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#7)]
     [!code-csharp[EmitGenericType#7](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#7)]
     [!code-vb[EmitGenericType#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#7)]  
  
7. <span data-ttu-id="ce180-126">Определите поле.</span><span class="sxs-lookup"><span data-stu-id="ce180-126">Define a field.</span></span> <span data-ttu-id="ce180-127">В этом примере тип поля задается параметром типа `TFirst`.</span><span class="sxs-lookup"><span data-stu-id="ce180-127">In this example, the type of the field is specified by type parameter `TFirst`.</span></span> <span data-ttu-id="ce180-128"><xref:System.Reflection.Emit.GenericTypeParameterBuilder> является производным от <xref:System.Type>, поэтому параметры универсального типа можно использовать везде, где можно использовать тип.</span><span class="sxs-lookup"><span data-stu-id="ce180-128"><xref:System.Reflection.Emit.GenericTypeParameterBuilder> derives from <xref:System.Type>, so you can use generic type parameters anywhere a type can be used.</span></span>  
  
     [!code-cpp[EmitGenericType#21](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#21)]
     [!code-csharp[EmitGenericType#21](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#21)]
     [!code-vb[EmitGenericType#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#21)]  
  
8. <span data-ttu-id="ce180-129">Определите метод, который использует параметры типа, относящиеся к универсальному типу.</span><span class="sxs-lookup"><span data-stu-id="ce180-129">Define a method that uses the type parameters of the generic type.</span></span> <span data-ttu-id="ce180-130">Обратите внимание, что такие методы не являются универсальными, если только они не имеют собственный список параметров типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-130">Note that such methods are not generic unless they have their own type parameter lists.</span></span> <span data-ttu-id="ce180-131">В следующем примере кода определяется метод `static` (`Shared` в Visual Basic), который принимает массив `TFirst` и возвращает `List<TFirst>` (`List(Of TFirst)` в Visual Basic), содержащий все элементы массива.</span><span class="sxs-lookup"><span data-stu-id="ce180-131">The following code defines a `static` method (`Shared` in Visual Basic) that takes an array of `TFirst` and returns a `List<TFirst>` (`List(Of TFirst)` in Visual Basic) containing all the elements of the array.</span></span> <span data-ttu-id="ce180-132">Чтобы определить этот метод, необходимо создать тип `List<TFirst>` путем вызова метода <xref:System.Type.MakeGenericType%2A> в определении универсального типа `List<T>`.</span><span class="sxs-lookup"><span data-stu-id="ce180-132">To define this method, it is necessary to create the type `List<TFirst>` by calling <xref:System.Type.MakeGenericType%2A> on the generic type definition, `List<T>`.</span></span> <span data-ttu-id="ce180-133">(`T` пропускается при использовании оператора `typeof` (`GetType` в Visual Basic) для получения определения универсального типа.) Тип параметра создается с помощью метода <xref:System.Type.MakeArrayType%2A>.</span><span class="sxs-lookup"><span data-stu-id="ce180-133">(The `T` is omitted when you use the `typeof` operator (`GetType` in Visual Basic) to get the generic type definition.) The parameter type is created by using the <xref:System.Type.MakeArrayType%2A> method.</span></span>  
  
     [!code-cpp[EmitGenericType#22](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#22)]
     [!code-csharp[EmitGenericType#22](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#22)]
     [!code-vb[EmitGenericType#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#22)]  
  
9. <span data-ttu-id="ce180-134">Выпустите основную часть метода.</span><span class="sxs-lookup"><span data-stu-id="ce180-134">Emit the method body.</span></span> <span data-ttu-id="ce180-135">Основная часть метода состоит из трех кодов операции, которые загружает входной массив в стек, вызывают конструктор `List<TFirst>`, который принимает `IEnumerable<TFirst>` (выполняет всю работу по помещению входных элементов в список), и возвращается (оставляя новый объект <xref:System.Collections.Generic.List%601> в стеке).</span><span class="sxs-lookup"><span data-stu-id="ce180-135">The method body consists of three opcodes that load the input array onto the stack, call the `List<TFirst>` constructor that takes `IEnumerable<TFirst>` (which does all the work of putting the input elements into the list), and return (leaving the new <xref:System.Collections.Generic.List%601> object on the stack).</span></span> <span data-ttu-id="ce180-136">Трудной частью выпуска этого кода является получение конструктора.</span><span class="sxs-lookup"><span data-stu-id="ce180-136">The difficult part of emitting this code is getting the constructor.</span></span>  
  
     <span data-ttu-id="ce180-137">Метод <xref:System.Type.GetConstructor%2A> не поддерживается для <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, так что невозможно напрямую получить конструктор `List<TFirst>`.</span><span class="sxs-lookup"><span data-stu-id="ce180-137">The <xref:System.Type.GetConstructor%2A> method is not supported on a <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, so it is not possible to get the constructor of `List<TFirst>` directly.</span></span> <span data-ttu-id="ce180-138">Сначала необходимо получить конструктор определения универсального типа `List<T>`, а затем вызвать метод, который преобразует его в соответствующий конструктор `List<TFirst>`.</span><span class="sxs-lookup"><span data-stu-id="ce180-138">First, it is necessary to get the constructor of the generic type definition `List<T>` and then to call a method that converts it to the corresponding constructor of `List<TFirst>`.</span></span>  
  
     <span data-ttu-id="ce180-139">Конструктор, используемый для этого примера кода принимает `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="ce180-139">The constructor used for this code example takes an `IEnumerable<T>`.</span></span> <span data-ttu-id="ce180-140">Но обратите внимание, что это не определение универсального типа универсального интерфейса <xref:System.Collections.Generic.IEnumerable%601>; вместо этого параметр типа `T` из `List<T>` должен быть замещен для параметра типа `T` объекта `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="ce180-140">Note, however, that this is not the generic type definition of the <xref:System.Collections.Generic.IEnumerable%601> generic interface; instead, the type parameter `T` from `List<T>` must be substituted for the type parameter `T` of `IEnumerable<T>`.</span></span> <span data-ttu-id="ce180-141">(Это кажется запутанным только потому, что оба типа имеют параметры типа с именем `T`.</span><span class="sxs-lookup"><span data-stu-id="ce180-141">(This seems confusing only because both types have type parameters named `T`.</span></span> <span data-ttu-id="ce180-142">Именно поэтому в этом примере кода используются имена `TFirst` и `TSecond`.) Чтобы получить тип аргумента конструктора, начните с определения универсального типа `IEnumerable<T>` и вызовите <xref:System.Type.MakeGenericType%2A> с первым параметром универсального типа `List<T>`.</span><span class="sxs-lookup"><span data-stu-id="ce180-142">That is why this code example uses the names `TFirst` and `TSecond`.) To get the type of the constructor argument, start with the generic type definition `IEnumerable<T>` and call <xref:System.Type.MakeGenericType%2A> with the first generic type parameter of `List<T>`.</span></span> <span data-ttu-id="ce180-143">В этом случае список аргументов конструктора должен быть передан в качестве массива только с одним аргументом.</span><span class="sxs-lookup"><span data-stu-id="ce180-143">The constructor argument list must be passed as an array, with just one argument in this case.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="ce180-144">Определение общего типа выражается как `IEnumerable<>` при использовании оператора `typeof` в C# или `IEnumerable(Of )` при использовании оператора `GetType` в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ce180-144">The generic type definition is expressed as `IEnumerable<>` when you use the `typeof` operator in C#, or `IEnumerable(Of )` when you use the `GetType` operator in Visual Basic.</span></span>  
  
     <span data-ttu-id="ce180-145">Теперь возможно получить конструктор `List<T>` путем вызова метода <xref:System.Type.GetConstructor%2A> в определении универсального типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-145">Now it is possible to get the constructor of `List<T>` by calling <xref:System.Type.GetConstructor%2A> on the generic type definition.</span></span> <span data-ttu-id="ce180-146">Чтобы преобразовать этот конструктор в соответствующий конструктор `List<TFirst>`, передайте `List<TFirst>` и конструктор из `List<T>` в статический метод <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ce180-146">To convert this constructor to the corresponding constructor of `List<TFirst>`, pass `List<TFirst>` and the constructor from `List<T>` to the static <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29?displayProperty=nameWithType> method.</span></span>  
  
     [!code-cpp[EmitGenericType#23](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#23)]
     [!code-csharp[EmitGenericType#23](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#23)]
     [!code-vb[EmitGenericType#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#23)]  
  
10. <span data-ttu-id="ce180-147">Создайте тип и сохраните файл.</span><span class="sxs-lookup"><span data-stu-id="ce180-147">Create the type and save the file.</span></span>  
  
     [!code-cpp[EmitGenericType#8](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#8)]
     [!code-csharp[EmitGenericType#8](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#8)]
     [!code-vb[EmitGenericType#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#8)]  
  
11. <span data-ttu-id="ce180-148">Вызовите метод.</span><span class="sxs-lookup"><span data-stu-id="ce180-148">Invoke the method.</span></span> <span data-ttu-id="ce180-149">`ExampleMethod` не является универсальным, но тип, которому он принадлежит, является универсальным. Поэтому для получения объекта <xref:System.Reflection.MethodInfo>, который может быть вызван, необходимо создать сконструированный тип из определения типа для `Sample`.</span><span class="sxs-lookup"><span data-stu-id="ce180-149">`ExampleMethod` is not generic, but the type it belongs to is generic, so in order to get a <xref:System.Reflection.MethodInfo> that can be invoked it is necessary to create a constructed type from the type definition for `Sample`.</span></span> <span data-ttu-id="ce180-150">Сконструированный тип использует класс `Example`, который согласуется с ограничениями `TFirst`, так как он является ссылочным типом и имеет конструктор без параметров по умолчанию, а также класс `ExampleDerived`, который соответствует ограничениям `TSecond`.</span><span class="sxs-lookup"><span data-stu-id="ce180-150">The constructed type uses the `Example` class, which satisfies the constraints on `TFirst` because it is a reference type and has a default parameterless constructor, and the `ExampleDerived` class which satisfies the constraints on `TSecond`.</span></span> <span data-ttu-id="ce180-151">(Код для `ExampleDerived` можно найти в разделе «пример кода».) Эти два типа передаются <xref:System.Type.MakeGenericType%2A> для создания сконструированного типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-151">(The code for `ExampleDerived` can be found in the example code section.) These two types are passed to <xref:System.Type.MakeGenericType%2A> to create the constructed type.</span></span> <span data-ttu-id="ce180-152">Затем получается объект <xref:System.Reflection.MethodInfo> с помощью метода <xref:System.Type.GetMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="ce180-152">The <xref:System.Reflection.MethodInfo> is then obtained using the <xref:System.Type.GetMethod%2A> method.</span></span>  
  
     [!code-cpp[EmitGenericType#9](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#9)]
     [!code-csharp[EmitGenericType#9](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#9)]
     [!code-vb[EmitGenericType#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#9)]  
  
12. <span data-ttu-id="ce180-153">В следующем коде создается массив объектов `Example`, затем этот массив размещается в массиве типа <xref:System.Object>, представленном аргументами вызываемого метода, после чего они передаются в метод <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29>.</span><span class="sxs-lookup"><span data-stu-id="ce180-153">The following code creates an array of `Example` objects, places that array in an array of type <xref:System.Object> representing the arguments of the method to be invoked, and passes them to the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> method.</span></span> <span data-ttu-id="ce180-154">Первый аргумент метода <xref:System.Reflection.MethodBase.Invoke%2A> — это пустая ссылка, так как метод является `static`.</span><span class="sxs-lookup"><span data-stu-id="ce180-154">The first argument of the <xref:System.Reflection.MethodBase.Invoke%2A> method is a null reference because the method is `static`.</span></span>  
  
     [!code-cpp[EmitGenericType#10](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#10)]
     [!code-csharp[EmitGenericType#10](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#10)]
     [!code-vb[EmitGenericType#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#10)]  
  
## <a name="example"></a><span data-ttu-id="ce180-155">Пример</span><span class="sxs-lookup"><span data-stu-id="ce180-155">Example</span></span>  
 <span data-ttu-id="ce180-156">В следующем примере кода определяется класс с именем `Sample` наряду с базовым классом и двумя интерфейсами.</span><span class="sxs-lookup"><span data-stu-id="ce180-156">The following code example defines a class named `Sample`, along with a base class and two interfaces.</span></span> <span data-ttu-id="ce180-157">Программа определяет два параметра универсального типа для `Sample`, преобразуя его в универсальный тип.</span><span class="sxs-lookup"><span data-stu-id="ce180-157">The program defines two generic type parameters for `Sample`, turning it into a generic type.</span></span> <span data-ttu-id="ce180-158">Параметры типа — это единственный фактор, делающий тип универсальным.</span><span class="sxs-lookup"><span data-stu-id="ce180-158">Type parameters are the only thing that makes a type generic.</span></span> <span data-ttu-id="ce180-159">Программа отображает это посредством сообщения проверки до и после определения параметров типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-159">The program shows this by displaying a test message before and after the definition of the type parameters.</span></span>  
  
 <span data-ttu-id="ce180-160">Параметр типа `TSecond` используется для демонстрации ограничений класса и интерфейса с помощью базовых классов и интерфейсов, а параметр типа `TFirst` применяется для демонстрации специальных ограничений.</span><span class="sxs-lookup"><span data-stu-id="ce180-160">The type parameter `TSecond` is used to demonstrate class and interface constraints, using the base class and interfaces, and the type parameter `TFirst` is used to demonstrate special constraints.</span></span>  
  
 <span data-ttu-id="ce180-161">В примере кода определяется поле и метод с использованием параметров типа класса для типа поля и параметра, а также возвращаемый тип метода.</span><span class="sxs-lookup"><span data-stu-id="ce180-161">The code example defines a field and a method using the class's type parameters for the field type and for the parameter and return type of the method.</span></span>  
  
 <span data-ttu-id="ce180-162">После создания класса `Sample` вызывается этот метод.</span><span class="sxs-lookup"><span data-stu-id="ce180-162">After the `Sample` class has been created, the method is invoked.</span></span>  
  
 <span data-ttu-id="ce180-163">Программа содержит метод, который отображает сведения об универсальном типе, и метод, который отображает список специальных ограничений для параметра типа.</span><span class="sxs-lookup"><span data-stu-id="ce180-163">The program includes a method that lists information about a generic type, and a method that lists the special constraints on a type parameter.</span></span> <span data-ttu-id="ce180-164">Эти методы используются для отображения сведений о завершенном классе `Sample`.</span><span class="sxs-lookup"><span data-stu-id="ce180-164">These methods are used to display information about the finished `Sample` class.</span></span>  
  
 <span data-ttu-id="ce180-165">Программа сохраняет завершенный модуль на диске как `GenericEmitExample1.dll`, чтобы его можно было открыть с помощью [Ildasm.exe (дизассемблер IL)](../tools/ildasm-exe-il-disassembler.md) и изучить MSIL для класса `Sample`.</span><span class="sxs-lookup"><span data-stu-id="ce180-165">The program saves the finished module to disk as `GenericEmitExample1.dll`, so you can open it with the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md) and examine the MSIL for the `Sample` class.</span></span>  
  
 [!code-cpp[EmitGenericType#1](../../../samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](../../../samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
## <a name="see-also"></a><span data-ttu-id="ce180-166">См. также</span><span class="sxs-lookup"><span data-stu-id="ce180-166">See also</span></span>

- <xref:System.Reflection.Emit.GenericTypeParameterBuilder>
- <span data-ttu-id="ce180-167">[Использование порождаемого отражения](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/3y322t50(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="ce180-167">[Using Reflection Emit](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/3y322t50(v=vs.100))</span></span>
- <span data-ttu-id="ce180-168">[Сценарии динамических сборок порождаемого отражения](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/tt9483fk(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="ce180-168">[Reflection Emit Dynamic Assembly Scenarios](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/tt9483fk(v=vs.100))</span></span>
