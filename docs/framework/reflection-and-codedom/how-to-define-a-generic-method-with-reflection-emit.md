---
title: Практическое руководство. Определение универсального метода с порождаемым отражением
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics [.NET Framework], reflection emit
- reflection emit, generic methods
- generics [.NET Framework], dynamic types
ms.assetid: 93892fa4-90b3-4ec4-b147-4bec9880de2b
ms.openlocfilehash: d16f6728b01583fe3ffb8d892522f3892444c537
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73130178"
---
# <a name="how-to-define-a-generic-method-with-reflection-emit"></a><span data-ttu-id="1f72a-102">Практическое руководство. Определение универсального метода с порождаемым отражением</span><span class="sxs-lookup"><span data-stu-id="1f72a-102">How to: Define a Generic Method with Reflection Emit</span></span>

<span data-ttu-id="1f72a-103">В первой процедуре показано, как создать простой универсальный метод с двумя типами параметров и как применить ограничения класса, интерфейса, а также особые ограничения параметров типа.</span><span class="sxs-lookup"><span data-stu-id="1f72a-103">The first procedure shows how to create a simple generic method with two type parameters, and how to apply class constraints, interface constraints, and special constraints to the type parameters.</span></span>

<span data-ttu-id="1f72a-104">Во второй процедуре показано, как вывести основную часть метода и как использовать параметры типа в универсальном методе для создания экземпляров универсального типа и вызова соответствующих методов.</span><span class="sxs-lookup"><span data-stu-id="1f72a-104">The second procedure shows how to emit the method body, and how to use the type parameters of the generic method to create instances of generic types and to call their methods.</span></span>

<span data-ttu-id="1f72a-105">В третьей процедуре показано, как вызывать универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="1f72a-105">The third procedure shows how to invoke the generic method.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1f72a-106">Метод не может являться универсальным только потому, что он принадлежит универсальному типу и использует параметры этого типа.</span><span class="sxs-lookup"><span data-stu-id="1f72a-106">A method is not generic just because it belongs to a generic type and uses the type parameters of that type.</span></span> <span data-ttu-id="1f72a-107">Метод является универсальным только в том случае, если он имеет свой собственный список параметров типа.</span><span class="sxs-lookup"><span data-stu-id="1f72a-107">A method is generic only if it has its own type parameter list.</span></span> <span data-ttu-id="1f72a-108">Универсальный метод может появиться в неуниверсальном типе, как показано в этом примере.</span><span class="sxs-lookup"><span data-stu-id="1f72a-108">A generic method can appear on a nongeneric type, as in this example.</span></span> <span data-ttu-id="1f72a-109">Пример использования неуниверсального метода для универсального типа см. в разделе [Практическое руководство. Определение универсального типа с порождаемым отражением](how-to-define-a-generic-type-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="1f72a-109">For an example of a nongeneric method on a generic type, see [How to: Define a Generic Type with Reflection Emit](how-to-define-a-generic-type-with-reflection-emit.md).</span></span>

### <a name="to-define-a-generic-method"></a><span data-ttu-id="1f72a-110">Определение универсального метода</span><span class="sxs-lookup"><span data-stu-id="1f72a-110">To define a generic method</span></span>

1. <span data-ttu-id="1f72a-111">Прежде чем приступить к работе, стоит рассмотреть, как универсальный метод выглядит при его создании на высокоуровневом языке.</span><span class="sxs-lookup"><span data-stu-id="1f72a-111">Before beginning, it is useful to look at how the generic method appears when written using a high-level language.</span></span> <span data-ttu-id="1f72a-112">Следующий код включен в код примера из этого раздела вместе с кодом вызова универсального метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-112">The following code is included in the example code for this topic, along with code to call the generic method.</span></span> <span data-ttu-id="1f72a-113">Этот метод содержит параметры двух типов — `TInput` и `TOutput`. Последний должен быть ссылочным типом (`class`), должен иметь конструктор без параметров (`new`) и должен реализовывать `ICollection(Of TInput)` (`ICollection<TInput>` в C#).</span><span class="sxs-lookup"><span data-stu-id="1f72a-113">The method has two type parameters, `TInput` and `TOutput`, the second of which must be a reference type (`class`), must have a parameterless constructor (`new`), and must implement `ICollection(Of TInput)` (`ICollection<TInput>` in C#).</span></span> <span data-ttu-id="1f72a-114">Это ограничение интерфейса обеспечивает использование метода <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> для добавления элементов в коллекцию `TOutput`, созданную этим методом.</span><span class="sxs-lookup"><span data-stu-id="1f72a-114">This interface constraint ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method can be used to add elements to the `TOutput` collection that the method creates.</span></span> <span data-ttu-id="1f72a-115">Этот метод имеет один формальный параметр `input`, который является массивом `TInput`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-115">The method has one formal parameter, `input`, which is an array of `TInput`.</span></span> <span data-ttu-id="1f72a-116">Этот метод создает коллекцию типа `TOutput` и копирует в нее элементы `input`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-116">The method creates a collection of type `TOutput` and copies the elements of `input` to the collection.</span></span>

    [!code-csharp[GenericMethodHowTo#20](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#20)]
    [!code-vb[GenericMethodHowTo#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#20)]

2. <span data-ttu-id="1f72a-117">Определите динамическую сборку и динамический модуль, содержащие тип, которому принадлежит универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="1f72a-117">Define a dynamic assembly and a dynamic module to contain the type the generic method belongs to.</span></span> <span data-ttu-id="1f72a-118">В этом случае сборка имеет только один модуль, который называется `DemoMethodBuilder1`. Имя модуля является идентичным имени сборки с добавленным расширением.</span><span class="sxs-lookup"><span data-stu-id="1f72a-118">In this case, the assembly has only one module, named `DemoMethodBuilder1`, and the module name is the same as the assembly name plus an extension.</span></span> <span data-ttu-id="1f72a-119">В этом примере сборка сохраняется на диск и также выполняется, поэтому указывается <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-119">In this example, the assembly is saved to disk and also executed, so <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> is specified.</span></span> <span data-ttu-id="1f72a-120">Можно использовать [Ildasm.exe (дизассемблер IL)](../tools/ildasm-exe-il-disassembler.md) для проверки DemoMethodBuilder1.dll и сравнения этой библиотеки с языком MSIL для метода, показанного на этапе 1.</span><span class="sxs-lookup"><span data-stu-id="1f72a-120">You can use the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md) to examine DemoMethodBuilder1.dll and to compare it to the Microsoft intermediate language (MSIL) for the method shown in step 1.</span></span>

    [!code-csharp[GenericMethodHowTo#2](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#2)]
    [!code-vb[GenericMethodHowTo#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#2)]

3. <span data-ttu-id="1f72a-121">Определите тип, которому принадлежит универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="1f72a-121">Define the type the generic method belongs to.</span></span> <span data-ttu-id="1f72a-122">Тип не обязательно должен быть универсальным.</span><span class="sxs-lookup"><span data-stu-id="1f72a-122">The type does not have to be generic.</span></span> <span data-ttu-id="1f72a-123">Универсальный метод может принадлежать универсальному или неуниверсальному типу.</span><span class="sxs-lookup"><span data-stu-id="1f72a-123">A generic method can belong to either a generic or nongeneric type.</span></span> <span data-ttu-id="1f72a-124">В этом примере тип представляет собой класс, не является универсальным и называется `DemoType`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-124">In this example, the type is a class, is not generic, and is named `DemoType`.</span></span>

    [!code-csharp[GenericMethodHowTo#3](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#3)]
    [!code-vb[GenericMethodHowTo#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#3)]

4. <span data-ttu-id="1f72a-125">Определите универсальный метод.</span><span class="sxs-lookup"><span data-stu-id="1f72a-125">Define the generic method.</span></span> <span data-ttu-id="1f72a-126">Если типы формальных параметров универсального метода указаны с помощью параметров универсального типа универсального метода, используйте перегрузку метода <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> для определения метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-126">If the types of a generic method's formal parameters are specified by generic type parameters of the generic method, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> method overload to define the method.</span></span> <span data-ttu-id="1f72a-127">Параметры универсального типа этого метода еще не определены, поэтому невозможно указать типы формальных параметров метода в вызове перегрузки <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-127">The generic type parameters of the method are not yet defined, so you cannot specify the types of the method's formal parameters in the call to <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A>.</span></span> <span data-ttu-id="1f72a-128">В этом примере метод называется `Factory`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-128">In this example, the method is named `Factory`.</span></span> <span data-ttu-id="1f72a-129">Метод является открытым и `static` (`Shared` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="1f72a-129">The method is public and `static` (`Shared` in Visual Basic).</span></span>

    [!code-csharp[GenericMethodHowTo#4](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#4)]
    [!code-vb[GenericMethodHowTo#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#4)]

5. <span data-ttu-id="1f72a-130">Определите параметры универсального типа метода `DemoMethod` посредством передачи массива строк, содержащего имена параметров, в метод <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-130">Define the generic type parameters of `DemoMethod` by passing an array of strings containing the names of the parameters to the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1f72a-131">Таким образом, этот метод станет универсальным.</span><span class="sxs-lookup"><span data-stu-id="1f72a-131">This makes the method a generic method.</span></span> <span data-ttu-id="1f72a-132">В следующем коде создается универсальный метод `Factory` с параметрами типа `TInput` и `TOutput`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-132">The following code makes `Factory` a generic method with type parameters `TInput` and `TOutput`.</span></span> <span data-ttu-id="1f72a-133">Чтобы сделать код более удобным для чтения, создаются переменные с этими именами для хранения объектов <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, представляющих два типа параметров.</span><span class="sxs-lookup"><span data-stu-id="1f72a-133">To make the code easier to read, variables with these names are created to hold the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects representing the two type parameters.</span></span>

    [!code-csharp[GenericMethodHowTo#5](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#5)]
    [!code-vb[GenericMethodHowTo#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#5)]

6. <span data-ttu-id="1f72a-134">Дополнительно добавьте особые ограничения параметров типа.</span><span class="sxs-lookup"><span data-stu-id="1f72a-134">Optionally add special constraints to the type parameters.</span></span> <span data-ttu-id="1f72a-135">Особые объекты добавляются с помощью метода <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-135">Special constraints are added using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="1f72a-136">В этом примере `TOutput` ограничивается ссылочным типом и конструктором без параметров.</span><span class="sxs-lookup"><span data-stu-id="1f72a-136">In this example, `TOutput` is constrained to be a reference type and to have a parameterless constructor.</span></span>

    [!code-csharp[GenericMethodHowTo#6](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#6)]
    [!code-vb[GenericMethodHowTo#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#6)]

7. <span data-ttu-id="1f72a-137">Дополнительно добавьте ограничения класса и интерфейса в параметры типа.</span><span class="sxs-lookup"><span data-stu-id="1f72a-137">Optionally add class and interface constraints to the type parameters.</span></span> <span data-ttu-id="1f72a-138">В этом примере параметр типа `TOutput` ограничен типами, которые реализуют интерфейс `ICollection(Of TInput)` (`ICollection<TInput>` в C#).</span><span class="sxs-lookup"><span data-stu-id="1f72a-138">In this example, type parameter `TOutput` is constrained to types that implement the `ICollection(Of TInput)` (`ICollection<TInput>` in C#) interface.</span></span> <span data-ttu-id="1f72a-139">Это гарантирует, что метод <xref:System.Collections.Generic.ICollection%601.Add%2A> можно использовать для добавления элементов.</span><span class="sxs-lookup"><span data-stu-id="1f72a-139">This ensures that the <xref:System.Collections.Generic.ICollection%601.Add%2A> method can be used to add elements.</span></span>

    [!code-csharp[GenericMethodHowTo#7](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#7)]
    [!code-vb[GenericMethodHowTo#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#7)]

8. <span data-ttu-id="1f72a-140">Определите формальные параметры метода, используя метод <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-140">Define the formal parameters of the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method.</span></span> <span data-ttu-id="1f72a-141">В этом примере метод `Factory` имеет один параметр — массив `TInput`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-141">In this example, the `Factory` method has one parameter, an array of `TInput`.</span></span> <span data-ttu-id="1f72a-142">Этот тип создается путем вызова метода <xref:System.Type.MakeArrayType%2A> для <xref:System.Reflection.Emit.GenericTypeParameterBuilder>, который представляет `TInput`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-142">This type is created by calling the <xref:System.Type.MakeArrayType%2A> method on the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> that represents `TInput`.</span></span> <span data-ttu-id="1f72a-143">Аргументом метода <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> является массив объектов <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-143">The argument of <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> is an array of <xref:System.Type> objects.</span></span>

    [!code-csharp[GenericMethodHowTo#8](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#8)]
    [!code-vb[GenericMethodHowTo#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#8)]

9. <span data-ttu-id="1f72a-144">Определить тип возвращаемого значения для этого метода с помощью метода <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-144">Define the return type for the method, using the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method.</span></span> <span data-ttu-id="1f72a-145">В этом примере возвращается экземпляр `TOutput`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-145">In this example, an instance of `TOutput` is returned.</span></span>

    [!code-csharp[GenericMethodHowTo#9](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#9)]
    [!code-vb[GenericMethodHowTo#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#9)]

10. <span data-ttu-id="1f72a-146">Выпустите основную часть метода с помощью <xref:System.Reflection.Emit.ILGenerator>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-146">Emit the method body, using <xref:System.Reflection.Emit.ILGenerator>.</span></span> <span data-ttu-id="1f72a-147">Дополнительные сведения см. в сопутствующей процедуре для создания тела метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-147">For details, see the accompanying procedure for emitting the method body.</span></span>

    > [!IMPORTANT]
    > <span data-ttu-id="1f72a-148">При выпуске вызовов методов универсального типа, если аргументы типа для этих типов являются параметрами типа универсального метода, необходимо использовать перегрузки метода `static` <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29> и <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> класса <xref:System.Reflection.Emit.TypeBuilder> для получения созданных форм этих методов.</span><span class="sxs-lookup"><span data-stu-id="1f72a-148">When you emit calls to methods of generic types, and the type arguments of those types are type parameters of the generic method, you must use the `static`<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29> method overloads of the <xref:System.Reflection.Emit.TypeBuilder> class to obtain constructed forms of the methods.</span></span> <span data-ttu-id="1f72a-149">Это показано в сопутствующей процедуре выпуска основной части метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-149">The accompanying procedure for emitting the method body demonstrates this.</span></span>

11. <span data-ttu-id="1f72a-150">Завершите тип, который содержит метод, и сохраните сборку.</span><span class="sxs-lookup"><span data-stu-id="1f72a-150">Complete the type that contains the method and save the assembly.</span></span> <span data-ttu-id="1f72a-151">В сопутствующей процедуре вызова универсального метода показаны два способа вызова завершенного метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-151">The accompanying procedure for invoking the generic method shows two ways to invoke the completed method.</span></span>

    [!code-csharp[GenericMethodHowTo#14](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#14)]
    [!code-vb[GenericMethodHowTo#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#14)]

<a name="procedureSection1"></a>

### <a name="to-emit-the-method-body"></a><span data-ttu-id="1f72a-152">Выпуск основной части метода</span><span class="sxs-lookup"><span data-stu-id="1f72a-152">To emit the method body</span></span>

1. <span data-ttu-id="1f72a-153">Получите генератор кода и объявите локальные переменные и метки.</span><span class="sxs-lookup"><span data-stu-id="1f72a-153">Get a code generator and declare local variables and labels.</span></span> <span data-ttu-id="1f72a-154">Для объявления локальных переменных используется метод <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-154">The <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%2A> method is used to declare local variables.</span></span> <span data-ttu-id="1f72a-155">Метод `Factory` содержит четыре локальных переменных: `retVal` для хранения нового объекта `TOutput`, возвращенного методом, `ic` для хранения объекта `TOutput` при приведении его к `ICollection(Of TInput)` (`ICollection<TInput>` в C#), `input` для хранения входного массива объектов `TInput` и `index` для итерации в массиве.</span><span class="sxs-lookup"><span data-stu-id="1f72a-155">The `Factory` method has four local variables: `retVal` to hold the new `TOutput` that is returned by the method, `ic` to hold the `TOutput` when it is cast to `ICollection(Of TInput)` (`ICollection<TInput>` in C#), `input` to hold the input array of `TInput` objects, and `index` to iterate through the array.</span></span> <span data-ttu-id="1f72a-156">Этот метод также содержит две метки: одна для входа в цикл (`enterLoop`) и одна для вершины цикла (`loopAgain`), определенные с помощью метода <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-156">The method also has two labels, one to enter the loop (`enterLoop`) and one for the top of the loop (`loopAgain`), defined using the <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> method.</span></span>

    <span data-ttu-id="1f72a-157">Первым действием этого метода является загрузка аргумента с помощью кода операции <xref:System.Reflection.Emit.OpCodes.Ldarg_0> и для хранения этого аргумента в локальной переменной `input` с помощью кода операции <xref:System.Reflection.Emit.OpCodes.Stloc_S>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-157">The first thing the method does is to load its argument using <xref:System.Reflection.Emit.OpCodes.Ldarg_0> opcode and to store it in the local variable `input` using <xref:System.Reflection.Emit.OpCodes.Stloc_S> opcode.</span></span>

    [!code-csharp[GenericMethodHowTo#10](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#10)]
    [!code-vb[GenericMethodHowTo#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#10)]

2. <span data-ttu-id="1f72a-158">Выпустите код для создания экземпляра `TOutput` с помощью перегрузки универсального метода <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-158">Emit code to create an instance of `TOutput`, using the generic method overload of the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1f72a-159">При использовании этой перегрузки требуется наличие конструктора без параметров для указанного типа, что является причиной добавления ограничения к `TOutput`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-159">Using this overload requires the specified type to have a parameterless constructor, which is the reason for adding that constraint to `TOutput`.</span></span> <span data-ttu-id="1f72a-160">Создайте универсальный метод, передав `TOutput` в метод <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-160">Create the constructed generic method by passing `TOutput` to <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span></span> <span data-ttu-id="1f72a-161">После выпуска кода для вызова метода выпустите код для хранения его в локальной переменной `retVal` с помощью параметра <xref:System.Reflection.Emit.OpCodes.Stloc_S>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-161">After emitting code to call the method, emit code to store it in the local variable `retVal` using <xref:System.Reflection.Emit.OpCodes.Stloc_S></span></span>

    [!code-csharp[GenericMethodHowTo#11](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#11)]
    [!code-vb[GenericMethodHowTo#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#11)]

3. <span data-ttu-id="1f72a-162">Выпустите код для приведения нового объекта `TOutput` к `ICollection(Of TInput)` и сохранения его в локальной переменной `ic`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-162">Emit code to cast the new `TOutput` object to `ICollection(Of TInput)` and store it in the local variable `ic`.</span></span>

    [!code-csharp[GenericMethodHowTo#31](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#31)]
    [!code-vb[GenericMethodHowTo#31](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#31)]

4. <span data-ttu-id="1f72a-163">Получите объект <xref:System.Reflection.MethodInfo>, представляющий метод <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-163">Get a <xref:System.Reflection.MethodInfo> representing the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1f72a-164">Этот метод работает с `ICollection(Of TInput)` (`ICollection<TInput>` в C#), поэтому необходимо получить метод `Add`, относящийся к этому сконструированному типу.</span><span class="sxs-lookup"><span data-stu-id="1f72a-164">The method is acting on an `ICollection(Of TInput)` (`ICollection<TInput>` in C#), so it is necessary to get the `Add` method specific to that constructed type.</span></span> <span data-ttu-id="1f72a-165">Невозможно использовать метод <xref:System.Type.GetMethod%2A>, чтобы получить этот объект <xref:System.Reflection.MethodInfo> напрямую из `icollOfTInput`, так как <xref:System.Type.GetMethod%2A> не поддерживается для типа, который был сконструирован с <xref:System.Reflection.Emit.GenericTypeParameterBuilder>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-165">You cannot use the <xref:System.Type.GetMethod%2A> method to get this <xref:System.Reflection.MethodInfo> directly from `icollOfTInput`, because <xref:System.Type.GetMethod%2A> is not supported on a type that has been constructed with a <xref:System.Reflection.Emit.GenericTypeParameterBuilder>.</span></span> <span data-ttu-id="1f72a-166">Вместо этого вызовите <xref:System.Type.GetMethod%2A> для `icoll`, который содержит определение универсального типа для универсального интерфейса <xref:System.Collections.Generic.ICollection%601>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-166">Instead, call <xref:System.Type.GetMethod%2A> on `icoll`, which contains the generic type definition for the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span> <span data-ttu-id="1f72a-167">Затем с помощью метода <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` создайте <xref:System.Reflection.MethodInfo> для сконструированного типа.</span><span class="sxs-lookup"><span data-stu-id="1f72a-167">Then use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>`static` method to produce the <xref:System.Reflection.MethodInfo> for the constructed type.</span></span> <span data-ttu-id="1f72a-168">Это демонстрируется в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="1f72a-168">The following code demonstrates this.</span></span>

    [!code-csharp[GenericMethodHowTo#12](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#12)]
    [!code-vb[GenericMethodHowTo#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#12)]

5. <span data-ttu-id="1f72a-169">Выпустите код для инициализации переменной `index` путем загрузки 32-разрядного целого числа 0 и хранения его в переменной.</span><span class="sxs-lookup"><span data-stu-id="1f72a-169">Emit code to initialize the `index` variable, by loading a 32-bit integer 0 and storing it in the variable.</span></span> <span data-ttu-id="1f72a-170">Выпустите код перехода на метку `enterLoop`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-170">Emit code to branch to the label `enterLoop`.</span></span> <span data-ttu-id="1f72a-171">Эта метка еще не была отмечена, так как она находится внутри цикла.</span><span class="sxs-lookup"><span data-stu-id="1f72a-171">This label has not yet been marked, because it is inside the loop.</span></span> <span data-ttu-id="1f72a-172">Код для цикла выпускается на следующем этапе.</span><span class="sxs-lookup"><span data-stu-id="1f72a-172">Code for the loop is emitted in the next step.</span></span>

    [!code-csharp[GenericMethodHowTo#32](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#32)]
    [!code-vb[GenericMethodHowTo#32](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#32)]

6. <span data-ttu-id="1f72a-173">Выпустите код для цикла.</span><span class="sxs-lookup"><span data-stu-id="1f72a-173">Emit code for the loop.</span></span> <span data-ttu-id="1f72a-174">Первым действием является маркировка вершины цикла посредством вызова метода <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> с меткой `loopAgain`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-174">The first step is to mark the top of the loop, by calling <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> with the `loopAgain` label.</span></span> <span data-ttu-id="1f72a-175">Операторы перехода, которые используют метку, теперь будут переходить на эту точку в коде.</span><span class="sxs-lookup"><span data-stu-id="1f72a-175">Branch statements that use the label will now branch to this point in the code.</span></span> <span data-ttu-id="1f72a-176">Следующим действием является передача объекта `TOutput`, приведенного к `ICollection(Of TInput)`, в стек.</span><span class="sxs-lookup"><span data-stu-id="1f72a-176">The next step is to push the `TOutput` object, cast to `ICollection(Of TInput)`, onto the stack.</span></span> <span data-ttu-id="1f72a-177">Это не является необходимым в данный момент, но должно быть подготовлено для вызова метода `Add`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-177">It is not needed immediately, but needs to be in position for calling the `Add` method.</span></span> <span data-ttu-id="1f72a-178">Затем входной массив передается в стек, после чего в массив передается переменная `index`, содержащая текущий индекс.</span><span class="sxs-lookup"><span data-stu-id="1f72a-178">Next the input array is pushed onto the stack, then the `index` variable containing the current index into the array.</span></span> <span data-ttu-id="1f72a-179">Код операции <xref:System.Reflection.Emit.OpCodes.Ldelem> принимает индекс и массив из стека и передает индексированный элемент массива в стек.</span><span class="sxs-lookup"><span data-stu-id="1f72a-179">The <xref:System.Reflection.Emit.OpCodes.Ldelem> opcode pops the index and the array off the stack and pushes the indexed array element onto the stack.</span></span> <span data-ttu-id="1f72a-180">Теперь стек готов для вызова метода <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType>, который принимает коллекцию и новый элемент из стека и добавляет элемент в коллекцию.</span><span class="sxs-lookup"><span data-stu-id="1f72a-180">The stack is now ready for the call to the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method, which pops the collection and the new element off the stack and adds the element to the collection.</span></span>

    <span data-ttu-id="1f72a-181">В оставшейся части кода цикла увеличивается индекс и проверяется, завершился ли цикл. Индекс и 32-разрядное целое число 1 передается в стек и суммируется, после чего сумма остается в стеке; сумма сохраняется в `index`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-181">The rest of the code in the loop increments the index and tests to see whether the loop is finished: The index and a 32-bit integer 1 are pushed onto the stack and added, leaving the sum on the stack; the sum is stored in `index`.</span></span> <span data-ttu-id="1f72a-182">Метод <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> вызывается для задания этой точки в качестве точки входа цикла.</span><span class="sxs-lookup"><span data-stu-id="1f72a-182"><xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A> is called to set this point as the entry point for the loop.</span></span> <span data-ttu-id="1f72a-183">Снова загружается индекс.</span><span class="sxs-lookup"><span data-stu-id="1f72a-183">The index is loaded again.</span></span> <span data-ttu-id="1f72a-184">Входной массив передается в стек, и выпускается <xref:System.Reflection.Emit.OpCodes.Ldlen> для получения его длины.</span><span class="sxs-lookup"><span data-stu-id="1f72a-184">The input array is pushed on the stack, and <xref:System.Reflection.Emit.OpCodes.Ldlen> is emitted to get its length.</span></span> <span data-ttu-id="1f72a-185">Теперь в стеке находятся индекс и длина, выпускается <xref:System.Reflection.Emit.OpCodes.Clt> для их сравнения.</span><span class="sxs-lookup"><span data-stu-id="1f72a-185">The index and the length are now on the stack, and <xref:System.Reflection.Emit.OpCodes.Clt> is emitted to compare them.</span></span> <span data-ttu-id="1f72a-186">Если индекс меньше длины, <xref:System.Reflection.Emit.OpCodes.Brtrue_S> переходит обратно к началу цикла.</span><span class="sxs-lookup"><span data-stu-id="1f72a-186">If the index is less than the length, <xref:System.Reflection.Emit.OpCodes.Brtrue_S> branches back to the beginning of the loop.</span></span>

    [!code-csharp[GenericMethodHowTo#13](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#13)]
    [!code-vb[GenericMethodHowTo#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#13)]

7. <span data-ttu-id="1f72a-187">Выпустите код для передачи объекта `TOutput` в стек и возврата из метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-187">Emit code to push the `TOutput` object onto the stack and return from the method.</span></span> <span data-ttu-id="1f72a-188">Локальные переменные `retVal` и `ic` содержат ссылки на новый объект `TOutput`; `ic` используется только для доступа к методу <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-188">The local variables `retVal` and `ic` both contain references to the new `TOutput`; `ic` is used only to access the <xref:System.Collections.Generic.ICollection%601.Add%2A?displayProperty=nameWithType> method.</span></span>

    [!code-csharp[GenericMethodHowTo#33](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#33)]
    [!code-vb[GenericMethodHowTo#33](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#33)]

<a name="procedureSection2"></a>

### <a name="to-invoke-the-generic-method"></a><span data-ttu-id="1f72a-189">Вызов универсального метода</span><span class="sxs-lookup"><span data-stu-id="1f72a-189">To invoke the generic method</span></span>

1. <span data-ttu-id="1f72a-190">`Factory` — это определение универсального метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-190">`Factory` is a generic method definition.</span></span> <span data-ttu-id="1f72a-191">Чтобы вызывать его, необходимо назначить типы для его параметров универсального типа.</span><span class="sxs-lookup"><span data-stu-id="1f72a-191">In order to invoke it, you must assign types to its generic type parameters.</span></span> <span data-ttu-id="1f72a-192">Для этого используется метод <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-192">Use the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method to do this.</span></span> <span data-ttu-id="1f72a-193">В следующем коде создается сконструированный универсальный метод, указывая <xref:System.String> для `TInput` и `List(Of String)` (`List<string>` в C#) для `TOutput`, а также отображает строковое представление метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-193">The following code creates a constructed generic method, specifying <xref:System.String> for `TInput` and `List(Of String)` (`List<string>` in C#) for `TOutput`, and displays a string representation of the method.</span></span>

    [!code-csharp[GenericMethodHowTo#21](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#21)]
    [!code-vb[GenericMethodHowTo#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#21)]

2. <span data-ttu-id="1f72a-194">Чтобы вызвать позднюю привязку метода, используйте метод <xref:System.Reflection.MethodBase.Invoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-194">To invoke the method late-bound, use the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span> <span data-ttu-id="1f72a-195">В следующем коде создается массив объектов <xref:System.Object>, в качестве единственного элемента содержащий массив строк, и передает его в качестве списка аргументов для универсального метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-195">The following code creates an array of <xref:System.Object>, containing as its only element an array of strings, and passes it as the argument list for the generic method.</span></span> <span data-ttu-id="1f72a-196">Первый параметр <xref:System.Reflection.MethodBase.Invoke%2A> — это пустая ссылка, так как метод является `static`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-196">The first parameter of <xref:System.Reflection.MethodBase.Invoke%2A> is a null reference because the method is `static`.</span></span> <span data-ttu-id="1f72a-197">Возвращаемое значение приводится к `List(Of String)`, затем отображается первый элемент.</span><span class="sxs-lookup"><span data-stu-id="1f72a-197">The return value is cast to `List(Of String)`, and its first element is displayed.</span></span>

    [!code-csharp[GenericMethodHowTo#22](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#22)]
    [!code-vb[GenericMethodHowTo#22](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#22)]

3. <span data-ttu-id="1f72a-198">Чтобы вызвать метод с помощью делегата, необходимо иметь делегат, который соответствует сигнатуре сконструированного универсального метода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-198">To invoke the method using a delegate, you must have a delegate that matches the signature of the constructed generic method.</span></span> <span data-ttu-id="1f72a-199">Простым способом выполнения этой задачи является создание универсального делегата.</span><span class="sxs-lookup"><span data-stu-id="1f72a-199">An easy way to do this is to create a generic delegate.</span></span> <span data-ttu-id="1f72a-200">В следующем коде создается экземпляр универсального делегата `D`, определенного в примере кода, с помощью перегрузки метода <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType>, а затем вызывается делегат.</span><span class="sxs-lookup"><span data-stu-id="1f72a-200">The following code creates an instance of the generic delegate `D` defined in the example code, using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29?displayProperty=nameWithType> method overload, and invokes the delegate.</span></span> <span data-ttu-id="1f72a-201">По своим возможностям делегаты превосходят вызовы с поздней привязкой.</span><span class="sxs-lookup"><span data-stu-id="1f72a-201">Delegates perform better than late-bound calls.</span></span>

    [!code-csharp[GenericMethodHowTo#23](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#23)]
    [!code-vb[GenericMethodHowTo#23](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#23)]

4. <span data-ttu-id="1f72a-202">Выпущенный метод также может быть вызван из программы, которая ссылается на сохраненную сборку.</span><span class="sxs-lookup"><span data-stu-id="1f72a-202">The emitted method can also be called from a program that refers to the saved assembly.</span></span>

## <a name="example"></a><span data-ttu-id="1f72a-203">Пример</span><span class="sxs-lookup"><span data-stu-id="1f72a-203">Example</span></span>

<span data-ttu-id="1f72a-204">В следующем примере кода создается неуниверсальный тип `DemoType` с универсальным методом `Factory`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-204">The following code example creates a nongeneric type, `DemoType`, with a generic method, `Factory`.</span></span> <span data-ttu-id="1f72a-205">Этот метод имеет два параметра универсального типа: `TInput` для указания входного типа и `TOutput` для указания выходного типа.</span><span class="sxs-lookup"><span data-stu-id="1f72a-205">This method has two generic type parameters, `TInput` to specify an input type and `TOutput` to specify an output type.</span></span> <span data-ttu-id="1f72a-206">Параметр типа `TOutput` ограничен для реализации `ICollection<TInput>` (`ICollection(Of TInput)` в Visual Basic) в качестве ссылочного типа и для содержания конструктора без параметров.</span><span class="sxs-lookup"><span data-stu-id="1f72a-206">The `TOutput` type parameter is constrained to implement `ICollection<TInput>` (`ICollection(Of TInput)` in Visual Basic), to be a reference type, and to have a parameterless constructor.</span></span>

<span data-ttu-id="1f72a-207">Этот метод имеет один формальный параметр, который является массивом `TInput`.</span><span class="sxs-lookup"><span data-stu-id="1f72a-207">The method has one formal parameter, which is an array of `TInput`.</span></span> <span data-ttu-id="1f72a-208">Метод возвращает экземпляр класса `TOutput`, содержащий все элементы входного массива.</span><span class="sxs-lookup"><span data-stu-id="1f72a-208">The method returns an instance of `TOutput` that contains all the elements of the input array.</span></span> <span data-ttu-id="1f72a-209">Экземпляр класса `TOutput` может быть любым универсальным типом коллекции, реализующим универсальный интерфейс <xref:System.Collections.Generic.ICollection%601>.</span><span class="sxs-lookup"><span data-stu-id="1f72a-209">`TOutput` can be any generic collection type that implements the <xref:System.Collections.Generic.ICollection%601> generic interface.</span></span>

<span data-ttu-id="1f72a-210">При выполнении этого кода динамическая сборка сохраняется как DemoGenericMethod1.dll и может быть проанализирована с помощью [Ildasm.exe (дизассемблера IL)](../tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="1f72a-210">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](../tools/ildasm-exe-il-disassembler.md).</span></span>

> [!NOTE]
> <span data-ttu-id="1f72a-211">Хорошим способом изучения способов выпуска кода является написание программы на языке Visual Basic, C# или Visual C++, которая будет выполнять программу и использовать дизассемблер для изучения MSIL, созданного компилятором.</span><span class="sxs-lookup"><span data-stu-id="1f72a-211">A good way to learn how to emit code is to write a Visual Basic, C#, or Visual C++ program that performs the task you are trying to emit, and use the disassembler to examine the MSIL produced by the compiler.</span></span>

<span data-ttu-id="1f72a-212">В примере кода содержится исходный код, который эквивалентен выпущенному методу.</span><span class="sxs-lookup"><span data-stu-id="1f72a-212">The code example includes source code that is equivalent to the emitted method.</span></span> <span data-ttu-id="1f72a-213">Выпущенный метод вызывается с поздней привязкой, а также с помощью универсального делегата, объявленного в примере кода.</span><span class="sxs-lookup"><span data-stu-id="1f72a-213">The emitted method is invoked late-bound and also by using a generic delegate declared in the code example.</span></span>

[!code-csharp[GenericMethodHowTo#1](../../../samples/snippets/csharp/VS_Snippets_CLR/GenericMethodHowTo/CS/source.cs#1)]
[!code-vb[GenericMethodHowTo#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodHowTo/VB/source.vb#1)]

## <a name="see-also"></a><span data-ttu-id="1f72a-214">См. также</span><span class="sxs-lookup"><span data-stu-id="1f72a-214">See also</span></span>

- <xref:System.Reflection.Emit.MethodBuilder>
- [<span data-ttu-id="1f72a-215">Практическое руководство. Определение универсального типа с порождаемым отражением</span><span class="sxs-lookup"><span data-stu-id="1f72a-215">How to: Define a Generic Type with Reflection Emit</span></span>](how-to-define-a-generic-type-with-reflection-emit.md)
