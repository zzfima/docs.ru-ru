---
title: Mgmtclassgen.exe (генератор строго типизированных классов управления)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- CIM types
- Management Strongly Typed Class Generator
- WMI class
- Mgmtclassgen.exe
- early-bound managed classes
ms.assetid: 02ce6699-49b5-4a0b-b0d5-1003c491232e
ms.openlocfilehash: 5002d7a180e480b0e1d38f1c1180fe565dc5e1dc
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73105023"
---
# <a name="mgmtclassgenexe-management-strongly-typed-class-generator"></a>Mgmtclassgen.exe (генератор строго типизированных классов управления)
Генератор классов управления со строгим типом позволяет быстро создавать управляемые классы с ранней привязкой для указанного класса инструментария управления Windows (WMI). Создаваемый класс упрощает код, необходимый для доступа к экземпляру класса WMI.  
  
## <a name="syntax"></a>Синтаксис  
  
```console  
mgmtclassgen   
WMIClass [options]   
```  
  
|Аргумент|ОПИСАНИЕ|  
|--------------|-----------------|  
|*WMIClass*|Класс WMI, для которого создается управляемый класс с ранней привязкой.|  
  
|Параметр|ОПИСАНИЕ|  
|------------|-----------------|  
|**/l**  *язык*|Задает язык, на котором создается управляемый класс с ранней привязкой. В качестве аргумента, задающего язык, можно указать **CS** (C#, используется по умолчанию), **VB** (Visual Basic), **MC** (C++) или **VS** (JScript).|  
|**/m**  *компьютер*|Задает компьютер, к которому следует подключиться и на котором находится соответствующий класс WMI. По умолчанию это локальный компьютер.|  
|**/n**  *path*|Задает путь к пространству имен WMI, в котором содержится класс WMI. Если этот параметр не указан, программа создает код для *WMIClass* в пространстве имен по умолчанию **Root\cimv2**.|  
|**/o** *пространство_имен_класса*|Задает пространство имен .NET, в котором создается класс управляемого кода. Если этот параметр не указан, программа создает пространство имен, используя пространство имен WMI и префикс схемы. Префикс схемы представляет собой часть имени класса перед знаком подчеркивания. Например, для класса **Win32_OperatingSystem** в пространстве имен **Root\cimv2** программа создает класс в пространстве имен **ROOT.CIMV2.Win32**.|  
|**/p**  *путь_к_файлу*|Задает путь к файлу, в который будет записан созданный код. Если этот параметр не задан, программа создаст файл в текущем каталоге. Имена класса и файла, в котором он будет храниться, присваиваются на основе аргумента *WMIClass*. Имена класса и файла будут совпадать с именем *WMIClass*. Если *WMIClass* содержит знак подчеркивания, будет использована часть имени класса после этого знака. Например, если *WMIClass* имеет вид **Win32_LogicalDisk**, созданным классу и файлу будет присвоено имя "logicaldisk". Если файл с таким именем уже существует, новый файл будет записан поверх старого.|  
|**/pw**  *пароль*|Задает пароль, используемый для подключения к компьютеру, заданному в параметре **/m**.|  
|**/u**  *имя_пользователя*|Задает имя пользователя, используемое для подключения к компьютеру, заданному в параметре **/m**.|  
|**/?**|Отображает синтаксис команд и параметров программы.|  
  
## <a name="remarks"></a>Примечания  
 Программа Mgmtclassgen.exe использует метод <xref:System.Management.ManagementClass.GetStronglyTypedClassCode%2A?displayProperty=nameWithType>. Поэтому для генерации кода на управляемом языке, отличном от C#, Visual Basic и JScript, можно использовать любой нестандартный поставщик кода.  
  
 Следует заметить, что создаваемые классы связаны со схемой, для которой они были созданы. Если базовая схема изменяется, для отображения внесенных изменений в схеме класс следует создать повторно.  
  
 В следующей таблице приводится соответствие типов модели CIM WMI и типов данных в создаваемых классах.  
  
|Тип CIM|Тип данных создаваемого класса|  
|--------------|--------------------------------------|  
|CIM_SINT8|**SByte**|  
|CIM_UINT8|**Byte**|  
|CIM_SINT16|**Int16**|  
|CIM_UINT16|**UInt16**|  
|CIM_SINT32|**Int32**|  
|SIM_UINT32|**UInt32**|  
|CIM_SINT64|**Int64**|  
|CIM_UINT64|**UInt64**|  
|CIM_REAL32|**Single**|  
|CIM_REAL64|**Double**|  
|CIM_BOOLEAN|**Boolean**|  
|CIM_String|**String**|  
|CIM_DATETIME|**DateTime** или **TimeSpan**|  
|CIM_REFERENCE|**ManagementPath**|  
|CIM_CHAR16|**Char**|  
|CIM_OBJECT|**ManagementBaseObject**|  
|CIM_IUNKNOWN|**Объект**|  
|CIM_ARRAY|Массив указанных выше объектов|  
  
 Отметим следующие особенности процесса создания классов WMI.  
  
- Стандартное открытое свойство или метод может иметь имя, совпадающее с именем существующего свойства или метода. В этом случае программа изменит имя свойства или метода в создаваемом классе, чтобы избежать конфликта имен.  
  
- Свойство или метод создаваемого класса может иметь имя, совпадающее с зарезервированным ключевым словом используемого языка программирования. В этом случае программа изменит имя свойства или метода в создаваемом классе, чтобы избежать конфликта имен.  
  
- В WMI квалификаторами называются модификаторы, которые содержат информацию, описывающую класс, экземпляр, свойство или метод. В WMI для описания свойств создаваемого класса используются стандартные квалификаторы, такие как **Read**, **Write** и **Key**. Например, свойство, измененное квалификатором **Read**, определяется только совместно со свойством метода доступа **get** в создаваемом классе. Так как свойство, помеченное квалификатором **Read**, предназначено только для чтения, метод доступа **set** не определяется.  
  
- Числовое свойство можно изменить с помощью квалификаторов **Values** и **ValueMaps**, которые указывают, что свойство может принимать только указанные допустимые значения. Перечисление создается на основе квалификаторов **Values** и **ValueMaps**, а свойство сопоставляется с этим перечислением.  
  
- Класс, который может иметь только один экземпляр, в WMI называется одноэлементным. Таким образом, конструктор без параметров для отдельного класса инициализирует класс в единственном экземпляре.  
  
- У класса WMI могут быть свойства, которые являются объектами. При создании класса со строгим типом для данного типа класса WMI следует по возможности создавать классы со строгими типами для типов свойств внедренных объектов. Благодаря этому станет возможен доступ к внедренным объектам в режиме строгой типизации. Следует заметить, что создаваемый код не всегда может определить тип внедренного объекта. В этом случае в созданном коде будет создан комментарий с уведомлением об этой ситуации. Обнаружив такое уведомление, можно изменить созданный код, приписав свойство другому созданному классу.  
  
- В WMI значение данных типа CIM_DATETIME может быть представлено как в виде определенной даты и времени, так и в виде временного интервала. Если значение данных представляет собой время и дату, в созданном классе ему будет соответствовать тип данных **DateTime**. Если значение данных представляет собой временной интервал, в созданном классе ему будет соответствовать тип данных **TimeSpan**.  
  
 Управляемые классы со строгим типом можно создавать также с помощью Server Explorer Management Extension в Visual Studio .NET.  
  
 Дополнительные сведения о WMI см. в разделе **Инструментарий управления Windows** в документации по продукту Platform SDK.  
  
## <a name="examples"></a>Примеры  
 При выполнении следующей команды создается управляемый класс на языке C# для класса WMI **Win32_LogicalDisk** в пространстве имен **Root\cimv2**. Программа записывает управляемый класс в исходный файл, расположенный в "c:\disk.cs", в пространстве имен **ROOT.CIMV2.Win32**.  
  
```console  
mgmtclassgen Win32_LogicalDisk /n root\cimv2 /l CS /p c:\disk.cs  
```  
  
 В следующем примере кода показано, как использовать созданный класс в программе. Сначала экземпляр класса перечисляется, и к нему печатается путь. Затем создается экземпляр инициализируемого класса с экземпляром WMI. `Process` — это класс, созданный для **Win32_Process**, а `LogicalDisk` — это класс, созданный для **Win32_LogicalDisk** в пространстве имен **Root\cimv2**.  
  
```vb  
Imports System  
Imports System.Management  
Imports ROOT.CIMV2.Win32  
  
Public Class App     
   Public Shared Sub Main()        
      ' Enumerate instances of the Win32_process.  
      ' Print the Name property of the instance.  
      Dim ps As Process     
      For Each ps In  Process.GetInstances()  
         Console.WriteLine(ps.Name)  
      Next ps  
  
      ' Initialize the instance of LogicalDisk with  
      ' the WMI instance pointing to logical drive d:.  
      Dim dskD As New LogicalDisk(New _  
         ManagementPath("win32_LogicalDisk.DeviceId=""d:"""))  
      Console.WriteLine(dskD.Caption)  
   End Sub  
End Class  
```  
  
```csharp  
using System;  
using System.Management;  
using ROOT.CIMV2.Win32;  
  
public class App  
{  
   public static void Main()  
   {  
      // Enumerate instances of the Win32_process.  
      // Print the Name property of the instance.  
      foreach(Process ps in Process.GetInstances())  
      {  
         Console.WriteLine(ps.Name);  
      }  
  
      // Initialize the instance of LogicalDisk with  
      // the WMI instance pointing to logical drive d:.  
      LogicalDisk dskD = new LogicalDisk(new ManagementPath(  
        "win32_LogicalDisk.DeviceId=\"d:\""));  
      Console.WriteLine(dskD.Caption);  
   }  
}  
```  
  
## <a name="see-also"></a>См. также

- <xref:System.Management>
- <xref:System.Management.ManagementClass.GetStronglyTypedClassCode%2A?displayProperty=nameWithType>
- <xref:System.CodeDom.Compiler.CodeDomProvider?displayProperty=nameWithType>
- [Инструменты](index.md)
- [Командные строки](developer-command-prompt-for-vs.md)
