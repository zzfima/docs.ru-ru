---
title: Ngen.exe (генератор образов в машинном коде)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- Native Image Generator
- images [.NET Framework], native
- side-by-side execution, native images
- assemblies [.NET Framework], native image
- Ngen.exe
- native image generation
- native image cache
- publisher policy applied for native images
- invalid images
- BypassNGenAttribute
- System.Runtime.BypassNGenAttribute
ms.assetid: 44bf97aa-a9a4-4eba-9a0d-cfaa6fc53a66
ms.openlocfilehash: e6c4baae854e5997b153e1363ca8ed4204e10e2b
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/30/2019
ms.locfileid: "73085211"
---
# <a name="ngenexe-native-image-generator"></a>Ngen.exe (генератор образов в машинном коде)

Генератор образов в машинном коде (Ngen.exe) — это средство повышения быстродействия управляемых приложений. Программа Ngen.exe создает образы в машинном коде, представляющие собой файлы, содержащие компилированный, специфический для процессора машинный код, и устанавливает их в кэш образов в машинном коде на локальном компьютере. Среда выполнения может использовать образы в машинном коде, находящиеся в кэше, вместо использования JIT-компилятора для компиляции исходной сборки.

> [!NOTE]
> Ngen.exe компилирует образы в машинном коде для сборок, предназначенных только для .NET Framework. Аналогичным генератором образов в машинном коде для .NET Core является [CrossGen](https://github.com/dotnet/coreclr/blob/master/Documentation/building/crossgen.md). 

Изменения в программе NGen.exe для .NET Framework 4:

- Теперь программа NGen.exe компилирует сборки с полным доверием, и политика разграничения доступа кода (CAS) больше не вычисляется.

- Образы в машинном коде, созданные с помощью NGen.exe, нельзя загружать в приложения, выполняющиеся в режиме частичного доверия.

Изменения в программе NGen.exe для .NET Framework версии 2.0.

- При установке сборки также устанавливаются ее зависимости, что упрощает синтаксис Ngen.exe.

- Образы в машинном коде теперь могут использоваться совместно в различных доменах приложений.

- Новое действие, `update`, заново создает образы, ставшие недействительными.

- Служба может отложить выполнение действий, используя для создания и установки образов время простоя компьютера.

- Были устранены некоторые причины недействительности образов.

Для Windows 8 см. раздел [Задача образов в машинном коде](#native-image-task).

Подробнее об использовании программы Ngen.exe и службы образов в машинном коде см. в разделе [Служба образов в машинном коде](#native-image-service).

> [!NOTE]
> Синтаксис Ngen.exe для .NET Framework версий 1.0 и 1.1 см. в разделе [Генератор образов в машинном коде (Ngen.exe), традиционный синтаксис](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms165073(v=vs.100)).

Эта программа автоматически устанавливается вместе с Visual Studio. Чтобы применить этот инструмент, воспользуйтесь командной строкой разработчика для Visual Studio (или командной строкой Visual Studio в Windows 7). Дополнительные сведения см. в разделе [Командные строки](developer-command-prompt-for-vs.md).

В командной строке введите следующее.

## <a name="syntax"></a>Синтаксис

```console
ngen action [options]
```

```console
ngen /? | /help
```

## <a name="actions"></a>Действия

В следующей таблице показан синтаксис каждого из действий `action`. Описания отдельных частей параметра `action` см. в таблицах [Аргументы](#ArgumentTable), [Уровни приоритета](#PriorityTable), [Сценарии](#ScenarioTable) и [Конфигурации](#ConfigTable). В таблице [Параметры](#OptionTable) описываются параметр `options` и ключи справки.

|Действие|ОПИСАНИЕ|
|------------|-----------------|
|`install` [`assemblyName` &#124; `assemblyPath`] [`scenarios`] [`config`] [`/queue`[`:`{`1`&#124;`2`&#124;`3`}]]|Формирует образы в машинном коде для сборки и ее зависимостей, а затем устанавливает образы в кэш образов в машинном коде.<br /><br /> Если задан ключ `/queue`, действие помещается в очередь службы образов в машинном коде. Приоритет по умолчанию равен 3. См. таблицу [Уровни приоритета](#PriorityTable).|
|`uninstall` [`assemblyName` &#124; `assemblyPath`] [`scenarios`] [`config`]|Удаляет образы в машинном коде для сборки и ее зависимостей из кэша образов в машинном коде.<br /><br /> Для удаления одного образа и его зависимостей используются те же аргументы командной строки, что и для установки образа. **Примечание.**  Начиная с .NET Framework 4, действие `uninstall` * не поддерживается.|
|`update` [`/queue`]|Обновляет образы в машинном коде, ставшие недействительными.<br /><br /> Если указан ключ `/queue`, обновления помещаются в очередь службы образов в машинном коде. Обновления всегда планируются с приоритетом 3, поэтому они выполняются во время простоя компьютера.|
|`display` [`assemblyName` &#124; `assemblyPath`]|Отображает состояние образов в машинном коде для сборки и ее зависимостей.<br /><br /> Если аргумент не указан, отображается все содержимое кэша образов в машинном коде.|
|`executeQueuedItems` [<code>1&#124;2&#124;3</code>]<br /><br /> -или-<br /><br /> `eqi` [1&#124;2&#124;3]|Выполняет поставленные в очередь задания компиляции.<br /><br /> Если указан приоритет, выполняются задания компиляции с большим или равным приоритетом. Если приоритет не задан, выполняются все поставленные в очередь задания компиляции.|
|`queue` {`pause` &#124; `continue` &#124; `status`}|Приостанавливает работу службы образов в машинном коде, разрешает продолжение выполнения приостановленной службы или запрашивает состояние службы.|

<a name="ArgumentTable"></a>

## <a name="arguments"></a>Аргументы

|Аргумент|ОПИСАНИЕ|
|--------------|-----------------|
|`assemblyName`|Полное отображаемое имя сборки. Например, `"myAssembly, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0038abc9deabfle5"`. **Примечание.**  Для действий `myAssembly` и `display` разработчик может предоставить имя частичной сборки, например `uninstall`. <br /><br /> В командной строке программы Ngen.exe может быть указана только одна сборка.|
|`assemblyPath`|Явный путь для сборки. Можно указать полный или относительный путь.<br /><br /> Если имя файла задано без пути, сборка должна находиться в текущем каталоге.<br /><br /> В командной строке программы Ngen.exe может быть указана только одна сборка.|

<a name="PriorityTable"></a>

## <a name="priority-levels"></a>Уровни приоритета

|Приоритет|ОПИСАНИЕ|
|--------------|-----------------|
|`1`|Образы в машинном коде создаются и устанавливаются немедленно, не дожидаясь периода простоя.|
|`2`|Образы в машинном коде генерируются и устанавливаются, не дожидаясь периода простоя, но после завершения всех действий и их зависимостей действий с приоритетом 1.|
|`3`|Образы в машинном коде устанавливаются, когда служба образов в машинном коде обнаружит, что компьютер находится в режиме простоя. См. раздел [Служба образов в машинном коде](#native-image-service).|

<a name="ScenarioTable"></a>

## <a name="scenarios"></a>Сценарии

|Сценарий|ОПИСАНИЕ|
|--------------|-----------------|
|`/Debug`|Создает образы в машинном коде, которые можно использовать с отладчиком.|
|`/Profile`|Создает образы в машинном коде, которые можно использовать с профилировщиком.|
|`/NoDependencies`|Создает минимальное число образов в машинном коде, которое требуется в соответствии с параметрами конкретного сценария.|

<a name="ConfigTable"></a>

## <a name="config"></a>Config

|Конфигурация|ОПИСАНИЕ|
|-------------------|-----------------|
|`/ExeConfig:` `exePath`|Используется конфигурация указанной исполняемой сборки.<br /><br /> При привязке к зависимостям программа Ngen.exe должна принимать те же решения, что и загрузчик. Когда общий компонент загружается во время выполнения с помощью метода <xref:System.Reflection.Assembly.Load%2A>, файл конфигурации приложения определяет зависимости, загруженные для общего компонента, например версию загруженной зависимости. Ключ `/ExeConfig` указывает программе Ngen.exe, какие зависимости будут загружаться во время выполнения.|
|`/AppBase:` `directoryPath`|При обнаружении зависимостей используйте указанный каталог в качестве базовой папки приложения.|

<a name="OptionTable"></a>

## <a name="options"></a>Параметры

|Параметр|ОПИСАНИЕ|
|------------|-----------------|
|`/nologo`|Отключает загрузочный баннер корпорации Майкрософт при запуске.|
|`/silent`|Отключает отображение сообщений об успешно выполненных операциях.|
|`/verbose`|Отображает подробные сведения для отладки. **Примечание.**  Из-за ограничений операционных систем Windows 98 и Windows Millennium Edition этот параметр отображает намного меньше сведений.|
|`/help`, `/?`|Отображает синтаксис команды и параметры для текущего выпуска.|

## <a name="remarks"></a>Примечания

Для запуска Ngen.exe требуются права администратора.

> [!CAUTION]
> Не запускайте программу NGen.exe в сборках с неполным доверием. Начиная с .NET Framework 4, программа NGen.exe компилирует сборки с полным доверием, а политика управления доступом для кода (CAS) больше не вычисляется.

Начиная с .NET Framework 4 образы в машинном коде, созданные с помощью NGen.exe, нельзя загружать в приложения, выполняющиеся в режиме частичного доверия. Вместо этого вызывается JIT-компилятор.

Программа Ngen.exe создает образы в машинном коде для сборки, указанной аргументом `assemblyname`, для действия `install` и всех его зависимостей. Зависимости определяются по ссылкам в манифесте сборки. Единственный сценарий, в котором необходимо задавать зависимость отдельно, — это когда приложение загружает зависимость с помощью отражения, например путем вызова метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>.

> [!IMPORTANT]
> Не используйте метод <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> с образами в машинном коде. Образ, загруженный этим методом, не может использоваться другими сборками в контексте выполнения.

Программа Ngen.exe ведет подсчет зависимостей. Например, пусть и `MyAssembly.exe` и `YourAssembly.exe` установлены в кэше образов в машинном коде и содержат ссылки на `OurDependency.dll`. При удалении `MyAssembly.exe` библиотека `OurDependency.dll` не удаляется. Она удаляется только после удаления `YourAssembly.exe`.

При создании образа в машинном коде для сборки из глобального кэша сборок необходимо указать ее отображаемое имя. См. раздел <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>.

Образы в машинном коде, созданные программой Ngen.exe, могут совместно использоваться в доменах приложений. Это означает, что программу Ngen.exe можно использовать в сценариях приложений, требующих совместного использования сборок в доменах приложений. Чтобы определить независимость от домена, выполните следующие действия.

- Примените к своему приложению атрибут <xref:System.LoaderOptimizationAttribute>.

- При создании сведений о настройке для нового домена приложений задайте свойство <xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>.

При загрузке одной и той же сборки в несколько доменов приложений всегда используйте программный код, независимый от домена. Если образ в машинном коде, загруженный в общий домен приложения, загружается в неиспользуемый совместно домен, его использование невозможно.

> [!NOTE]
> Независимый от домена код не может быть выгружен, и быстродействие может слегка снизиться, особенно при доступе к статическим членам.

В этом разделе примечаний

- [Формирование образов для различных сценариев](#Scenarios)

- [Определение случаев использования образов в машинном коде](#WhenToUse)

  - [Оптимизация использования памяти](#Memory)

  - [Ускорение запуска приложения](#Startup)

  - [Обзор аспектов использования](#UsageSummary)

- [Важность базовых адресов сборок](#BaseAddresses)

- [Жесткая привязка](#HardBinding)

  - [Задание для зависимости подсказки, касающейся привязки](#DependencyHint)

  - [Задание для сборки подсказки для привязки по умолчанию](#AssemblyHint)

- [Отложенная обработка](#Deferred)

- [Образы в машинном коде и JIT-компиляция](#JITCompilation)

  - [Недействительные образы](#InvalidImages)

- [Устранение неполадок](#Troubleshooting)

  - [Средство просмотра журнала привязки сборок](#Fusion)

  - [Помощник по отладке управляемого кода JITCompilationStart](#MDA)

  - [Отказ от формирования образа в машинном коде](#OptOut)

<a name="Scenarios"></a>

## <a name="generating-images-for-----different-scenarios"></a>Формирование образов для различных сценариев

После создания образа в машинном коде для сборки среда выполнения автоматически пытается обнаружить и использовать этот образ в машинном коде при каждом запуске сборки. В зависимости от сценариев использования может быть создано несколько образов.

Например, при запуске сборки в рамках сценария отладки или профилирования среда выполнения ищет образ в машинном коде, созданный с параметрами `/Debug` или `/Profile`. Если найти соответствующий образ в машинном коде не удается, среда выполнения возвращается к стандартной схеме JIT-компиляции. Единственным способом отладки образов в машинном коде является создание образа в машинном коде с параметром `/Debug`.

Действие `uninstall` также распознает сценарии, позволяя удалить все или только выбранные сценарии.

<a name="WhenToUse"></a>

## <a name="determining-when-to-use-native-images"></a>Определение случаев использования образов в машинном коде

Образы в машинном коде могут повысить производительность в двух областях: оптимизация использования памяти и уменьшение времени запуска.

> [!NOTE]
> Производительность образов в машинном коде зависит от множества факторов, усложняющих анализ, например: шаблоны доступа к коду и данным, количество вызовов, выполняемых через границы модуля, и количество зависимостей, уже загруженных другими приложениями. Единственным способом определить, обеспечивают ли образы в машинном коде преимущество для конкретного приложения, являются тщательные измерения производительности в основных сценариях развертывания.

<a name="Memory"></a>

### <a name="improved-memory-use"></a>Оптимизация использования памяти

Использование образов в машинном коде может заметно повысить эффективность использования памяти в ситуациях, когда код используется одновременно несколькими процессами. Образы в машинном коде являются файлами Windows PE, поэтому несколько процессов могут совместно использовать одну копию DLL-файла. Напротив, образ в машинном коде, созданный JIT-компилятором, хранится в выделенной памяти и не может быть использован совместно.

Преимущества совместно используемых кодовых страниц также распространяются на приложения, выполняемые с использованием служб терминалов.

Кроме того, отсутствие необходимости загружать JIT-компилятор экономит определенный объем памяти для каждого экземпляра приложения.

<a name="Startup"></a>

### <a name="faster-application-startup"></a>Ускорение запуска приложения

Предварительная компиляция сборок с помощью программы Ngen.exe может уменьшить время запуска некоторых приложений. В общем случае, преимущество достигается благодаря тому, что приложения совместно используют сборки компонентов, так как после запуска первого приложения общие компоненты оказываются уже загруженными в память для последующих приложений. При холодном запуске, когда все сборки в приложении должны загружаться с жесткого диска, использование образов в машинном коде не обеспечивает таких преимуществ, поскольку основное значение имеет время доступа к жесткому диску.

На время запуска может повлиять жесткая привязка, поскольку все образы, жестко привязанные к главной сборке приложения, должны загружаться в одно и то же время.

> [!NOTE]
> До .NET Framework 3.5 с пакетом обновления 1 (SP1) необходимо было помещать общие компоненты со строгими именами в глобальный кэш сборок, так как загрузчик выполняет дополнительную проверку сборок со строгими именами, отсутствующих в глобальном кэше сборок, фактически сводя на нет уменьшение времени запуска, создаваемое за счет использования образов в машинном коде. За счет ряда усовершенствований, которые впервые появились в NET Framework 3.5 SP1, была исключена дополнительная проверка.

<a name="UsageSummary"></a>

### <a name="summary-of-usage-considerations"></a>Обзор аспектов использования

Следующие общие положения и аспекты использования приложений могут помочь принять решение, следует ли тратить ресурсы на оценку применения образов в машинном коде для разрабатываемого приложения.

- Образы в машинном коде загружаются быстрее чем CIL, поскольку они не требуют множества операций запуска, таких как JIT-компиляция и проверка безопасности типа.

- За счет устранения JIT-компилятора из процесса разработки образы в машинном коде требуют меньшего первоначального объема работы.

- Образы в машинном коде обеспечивают совместное использование кода несколькими процессами.

- Образам в машинном коде требуется больше места на жестком диске по сравнению со сборками CIL. Кроме того, их создание может занимать значительное время.

- Образы в машинном коде необходимо обслуживать.

  - При обслуживании исходной сборки или одной из ее зависимостей образы необходимо создавать заново.

  - Для одной сборки может понадобиться несколько образов в машинном коде, используемых в различных приложениях или различных сценариях. Например, сведения о конфигурации в двух приложениях могут привести к различным решениям привязки для одной и той же зависимой сборки.

  - Образы в машинном коде должны создаваться администратором, то есть под учетной записью Windows в группе "Администраторы".

Помимо этих общих положений, при рассмотрении преимуществ использования образов в машинном коде с точки зрения производительности необходимо учитывать суть разрабатываемого приложения.

- Если приложение выполняется в среде, в которой используется множество общих компонентов, образы в машинном коде обеспечивают совместное использование компонентов несколькими процессами.

- Если приложение использует несколько доменов приложений, образы в машинном коде обеспечивают совместное использование кодовых страниц в нескольких доменах.

    > [!NOTE]
    > В .NET Framework версий 1.0 и 1.1 совместное использование образов в машинном коде в нескольких доменах приложений невозможно. Однако в версии 2.0 и более поздних версиях ситуация изменилась.

- Если приложение работает в среде сервера терминалов, образы в машинном коде обеспечивают совместное использование кодовых страниц.

- При компиляции в образы в машинном коде большие приложения обычно получают ряд преимуществ. В свою очередь, небольшие приложения особой выгоды обычно не получают.

- Для приложений с длительным сроком выполнения JIT-компиляция во время выполнения обеспечивает немного лучшую производительность, чем образы в машинном коде. (Жесткая привязка может в определенной степени уменьшить эту разницу в производительности.)

<a name="BaseAddresses"></a>

## <a name="importance-of-assembly-base-addresses"></a>Важность базовых адресов сборок

Поскольку образы в машинном коде являются файлами Windows PE, они подвержены тем же проблемам изменения базовых адресов, что и другие исполняемые файлы. При использовании жесткой привязки влияние перемещения на производительность становится еще более заметным.

Чтобы задать базовый адрес для образа в машинном коде, с помощью соответствующего параметра компилятора можно задать базовый адрес сборки. Программа Ngen.exe использует этот базовый адрес для образа в машинном коде.

> [!NOTE]
> Образы в машинном коде по размеру больше управляемых сборок, используемых для их создания. Базовые адреса должны быть рассчитаны с учетом таких увеличенных размеров.

Для просмотра предпочитаемого базового адреса образа в машинном коде можно использовать такую программу, как dumpbin.exe.

<a name="HardBinding"></a>

## <a name="hard-binding"></a>Жесткая привязка

Жесткая привязка увеличивает производительность и уменьшает объем работы для образов в машинном коде. Недостаток жесткой привязки состоит в том, что при загрузке сборки должны загружаться все образы, жестко привязанные к сборке. Для большого приложения это может заметно увеличить время запуска.

Жесткая привязка подходит для зависимостей, загруженных во всех сценариях приложения, критичных для производительности. Как и для других аспектов использования образов в машинном коде, единственным способом определить, повышает ли жесткая привязка производительность приложения, являются тщательные измерения производительности.

Атрибуты <xref:System.Runtime.CompilerServices.DependencyAttribute> и <xref:System.Runtime.CompilerServices.DefaultDependencyAttribute> позволяют предоставить программе Ngen.exe подсказки, касающиеся жесткой привязки.

> [!NOTE]
> Эти атрибуты являются подсказками для программы Ngen.exe, а не командами. Их использование не гарантирует выполнения жесткой привязки. В будущих выпусках значение этих атрибутов может измениться.

<a name="DependencyHint"></a>

### <a name="specifying-a-binding-hint-for-a-dependency"></a>Задание для зависимости подсказки, касающейся привязки

Примените атрибут <xref:System.Runtime.CompilerServices.DependencyAttribute> к сборке, чтобы указать вероятность того, что указанная зависимость будет загружаться. <xref:System.Runtime.CompilerServices.LoadHint.Always?displayProperty=nameWithType> указывает, что жесткая привязка подходит, <xref:System.Runtime.CompilerServices.LoadHint.Default> указывает, что для зависимости должно использоваться значение по умолчанию, и <xref:System.Runtime.CompilerServices.LoadHint.Sometimes> указывает, что жесткая привязка не подходит.

В следующем коде показаны атрибуты для сборки с двумя зависимостями. Первая зависимость (Assembly1) является подходящим кандидатом для жесткой привязки, а вторая (Assembly2) — нет.

```vb
Imports System.Runtime.CompilerServices
<Assembly:DependencyAttribute("Assembly1", LoadHint.Always)>
<Assembly:DependencyAttribute("Assembly2", LoadHint.Sometimes)>
```

```csharp
using System.Runtime.CompilerServices;
[assembly:DependencyAttribute("Assembly1", LoadHint.Always)]
[assembly:DependencyAttribute("Assembly2", LoadHint.Sometimes)]
```

```cpp
using namespace System::Runtime::CompilerServices;
[assembly:DependencyAttribute("Assembly1", LoadHint.Always)];
[assembly:DependencyAttribute("Assembly2", LoadHint.Sometimes)];
```

Имя сборки не включает в себя расширение имени файла. Разрешается использовать отображаемые имена.

<a name="AssemblyHint"></a>

### <a name="specifying-a-default-binding-hint-for-an-assembly"></a>Задание для сборки подсказки для привязки по умолчанию

Подсказки для привязки по умолчанию необходимы только для сборок, которые будут использоваться немедленно и часто любым приложением, связанным с этими сборками зависимостями. Чтобы определить необходимость использования жесткой привязки, к таким сборкам можно применить атрибут <xref:System.Runtime.CompilerServices.DefaultDependencyAttribute> с <xref:System.Runtime.CompilerServices.LoadHint.Always?displayProperty=nameWithType>.

> [!NOTE]
> Не стоит применять атрибут <xref:System.Runtime.CompilerServices.DefaultDependencyAttribute> к DLL-сборкам, не подпадающим под эту категорию, поскольку применение атрибута с любым значением, отличным от <xref:System.Runtime.CompilerServices.LoadHint.Always?displayProperty=nameWithType>, аналогично полному отсутствию атрибута.

Корпорация Майкрософт использует атрибут <xref:System.Runtime.CompilerServices.DefaultDependencyAttribute> для указания того, что жесткая привязка является значением по умолчанию для очень небольшого числа сборок в .NET Framework, например "mscorlib.dll".

<a name="Deferred"></a>

## <a name="deferred-processing"></a>Отложенная обработка

Создание образов в машинном коде для очень большого приложения может занять значительное время. Аналогичным образом, изменения общего компонента или настроек компьютера могут потребовать обновления многих образов в машинном коде. Для действий `install` и `update` предусмотрен параметр `/queue`, который помещает операцию в очередь для отложенного выполнения службой образов в машинном коде. Кроме того, программа Ngen.exe предусматривает действия `queue` и `executeQueuedItems`, которые дают определенные возможности управления этой службой. Подробнее см. в разделе [Служба образов в машинном коде](#native-image-service).

<a name="JITCompilation"></a>

## <a name="native-images-and-jit-compilation"></a>Образы в машинном коде и JIT-компиляция

Если программа Ngen.exe обнаруживает в сборке методы, которые она не может создать, эти методы исключаются из этого образа. Когда среда выполнения выполняет сборку, то при обнаружении метода, отсутствующего в образе в машинном коде, выполняется JIT-компиляция.

Кроме того, образы в машинном коде не используются, если сборка была модернизирована или по какой-либо причине стала недействительной.

<a name="InvalidImages"></a>

### <a name="invalid-images"></a>Недействительные образы

При использовании программы Ngen.exe для создания образа сборки в машинном коде результат зависит от заданных параметров командной строки и определенных настроек компьютера. В число этих параметров входят следующие характеристики.

- Версия .NET Framework.

- Версия операционной системы в случае перехода с семейства Windows 9x на семейство Windows NT.

- Полное удостоверение сборки (оно изменяется при перекомпиляции).

- Полное удостоверение всех сборок, на которые ссылается данная сборка (оно изменяется при перекомпиляции).

- Факторы безопасности.

Программа Ngen.exe сохраняет эти сведения при создании образа в машинном коде. При выполнении сборки среда выполнения просматривает созданный образ в машинном коде на предмет таких параметров и сравнивает их с текущими параметрами среды компьютера. Если среда выполнения не находит соответствующий образ в машинном коде, выполняется JIT-компиляция. Изменения следующих параметров компьютера и среды приводят к тому, что образы устаревают, то есть становятся непригодными для использования.

- Версия .NET Framework.

     При обновлении .NET Framework все образы в машинном коде, созданные с помощью программы Ngen.exe, становятся недействительными. По этой причине, чтобы гарантировать повторное создание всех образов в машинном коде, все обновления .NET Framework выполняют команду `Ngen Update`. Платформа .NET Framework автоматически создает новые образы в машинном коде для библиотек .NET Framework, которые она устанавливает.

- Версия операционной системы в случае перехода с семейства Windows 9x на семейство Windows NT.

     Например, при изменении версии операционной системы компьютера с Windows 98 на Windows XP все образы в машинном коде, хранящиеся в кэше образов в машинном коде, становятся недействительными. Тем не менее при изменении версии операционной системы с Windows 2000 на Windows XP образы остаются действительными.

- Полное удостоверение сборки.

     При перекомпиляции сборки соответствующий образ в машинном коде устаревает.

- Полное удостоверение всех сборок, на которые ссылается данная сборка.

     При обновлении управляемой сборки все образы в машинном коде, прямо или косвенно зависящие от этой сборки, становятся недействительными и требуют повторного создания. Это относится и к обычным ссылкам, и к зависимостям с жесткой привязкой. При любом обновлении программного обеспечения программа установки должна выполнить команду `Ngen Update`, чтобы гарантировать повторное создание всех зависимых образов в машинном коде.

- Факторы безопасности.

     Изменение политики безопасности на компьютере, сопровождающееся отменой разрешений, выданных сборке ранее, может привести к устареванию ранее скомпилированного образа сборки.

     Подробную информацию об управлении доступом для кода в среде CLR и об использовании разрешений см. в разделе [Управление доступом для кода](../misc/code-access-security.md).

<a name="Troubleshooting"></a>

## <a name="troubleshooting"></a>Устранение неполадок

Следующие разделы по устранению неполадок позволяют понять, какие образы в машинном коде используются, а какие — не могут использоваться для вашего приложения, определить, когда JIT-компилятор начинает компиляцию метода, а также демонстрируют, как отказаться от компиляции образов в машинном коде указанных методов.

<a name="Fusion"></a>

### <a name="assembly-binding-log-viewer"></a>средство просмотра журнала привязки сборок

Проверить, используются ли в приложении образы в машинном коде, можно с помощью [Fuslogvw.exe (средства просмотра журнала привязок сборки)](fuslogvw-exe-assembly-binding-log-viewer.md). Выберите **Образы в машинном коде** в поле **Категории журнала** в окне средства просмотра журнала привязок. Программа Fuslogvw.exe предоставляет сведения о причинах отклонения образа в машинном коде.

<a name="MDA"></a>

### <a name="the-jitcompilationstart-managed-debugging-assistant"></a>Помощник по отладке управляемого кода JITCompilationStart

Чтобы определить, когда JIT-компилятор начинает компиляцию функции, можно использовать помощник по отладке управляемого кода [jitCompilationStart](../debug-trace-profile/jitcompilationstart-mda.md).

<a name="OptOut"></a>

### <a name="opting-out-of-native-image-generation"></a>Отказ от формирования образа в машинном коде

В некоторых случаях NGen.exe может испытывать трудности при создании образа в машинном коде для конкретного метода. Кроме того, может быть удобнее выполнить JIT-компиляцию метода вместо компиляции в образ в машинном коде. В этом случае можно использовать атрибут `System.Runtime.BypassNGenAttribute`, чтобы запретить программе NGen.exe формирование образа в машинном коде для конкретного метода. Атрибут необходимо применять по отдельности к каждому методу, код которого не нужно включать в образ в машинном коде. NGen.exe распознает атрибут и не создает код в образе в машинном коде для соответствующего метода.

Тем не менее обратите внимание, что `BypassNGenAttribute` не определен как тип в библиотеке классов .NET Framework. Для использования атрибута в коде, его необходимо сначала определить следующим образом.

[!code-csharp[System.Runtime.BypassNGenAttribute#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/System.Runtime.BypassNGenAttribute/cs/Optout1.cs#1)]
[!code-vb[System.Runtime.BypassNGenAttribute#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Runtime.BypassNGenAttribute/vb/Optout1.vb#1)]

Затем можно применить атрибут индивидуально для каждого метода. Следующий пример указывает генератору образов в машинном коде, что ему не следует формировать образ в машинном коде для метода `ExampleClass.ToJITCompile`.

[!code-csharp[System.Runtime.BypassNGenAttribute#2](../../../samples/snippets/csharp/VS_Snippets_CLR_System/System.Runtime.BypassNGenAttribute/cs/Optout1.cs#2)]
[!code-vb[System.Runtime.BypassNGenAttribute#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Runtime.BypassNGenAttribute/vb/Optout1.vb#2)]

## <a name="examples"></a>Примеры

Следующая команда создает образ в машинном коде для приложения `ClientApp.exe`, расположенного в текущем каталоге, и устанавливает образ в кэш образов в машинном коде. Если для сборки существует файл конфигурации, программа Ngen.exe использует его. Кроме того, образы в машинном коде создаются для всех DLL-файлов, на которые ссылается программа `ClientApp.exe`.

```console
ngen install ClientApp.exe
```

Образ, установленный с программой Ngen.exe, также называется корнем. Корень может быть приложением или общим компонентом.

Следующая команда создает образ в машинном коде для `MyAssembly.exe` с указанным путем.

```console
ngen install c:\myfiles\MyAssembly.exe
```

При поиске сборок и их зависимостей программа Ngen.exe использует ту же самую логику тестирования, что и среда CLR. По умолчанию каталог, содержащий приложение `ClientApp.exe`, используется в качестве базового каталога приложения, с которого начинается тестирование всех сборок. Это поведение можно переопределить с помощью параметра `/AppBase`.

> [!NOTE]
> Поведение программы Ngen.exe было изменено по сравнению с .NET Framework версий 1.0 и 1.1, где в качестве базового каталога приложения использовался текущий каталог.

Сборка может использовать зависимость без ссылки, например, если она загружает DLL-файл с помощью метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. С помощью параметра `/ExeConfig` для такого DLL-файла можно создать образ в машинном коде, используя сведения о конфигурации для сборки приложения. Следующая команда создает образ в машинном коде для `MyLib.dll,`, используя сведения о конфигурации из `MyApp.exe`.

```console
ngen install c:\myfiles\MyLib.dll /ExeConfig:c:\myapps\MyApp.exe
```

Сборки, установленные таким способом, не удаляются при удалении приложения.

Чтобы удалить зависимость, следует использовать те же параметры командной строки, которые использовались при ее установке. Следующая команда удаляет `MyLib.dll` из предыдущего примера.

```console
ngen uninstall c:\myfiles\MyLib.dll /ExeConfig:c:\myapps\MyApp.exe
```

Чтобы создать образ в машинном коде для сборки в глобальном кэше сборок, следует использовать отображаемое имя сборки. Например:

```console
ngen install "ClientApp, Version=1.0.0.0, Culture=neutral,
  PublicKeyToken=3c7ba247adcd2081, processorArchitecture=MSIL"
```

Программа NGen.exe создает отдельный набор образов для каждого устанавливаемого сценария. Например, следующие команды устанавливают полный набор образов в машинном коде для обычной работы, другой полный набор для отладки, а третий — для профилирования.

```console
ngen install MyApp.exe
ngen install MyApp.exe /debug
ngen install MyApp.exe /profile
```

### <a name="displaying-the-native-image-cache"></a>Отображение кэша образов в машинном коде

Образы в машинном коде, установленные в кэш, можно отобразить с помощью программы Ngen.exe. Следующая команда отображает все образы в машинном коде, находящиеся в кэше образов в машинном коде.

```console
ngen display
```

Действие `display` выводит сначала все корневые сборки, а затем выводит список всех образов в машинном коде на компьютере.

Чтобы отобразить сведения только об этой сборке, можно использовать простое имя сборки. Следующая команда выводит все образы в кэше образов в машинном коде, соответствующие неполному имени `MyAssembly`, их зависимости и все корни с зависимостями от `MyAssembly`:

```console
ngen display MyAssembly
```

Знание того, что корни зависят от общей сборки компонентов, полезно при определении влияния действия `update` после обновления общего компонента.

Если задано расширение файла сборки, необходимо либо указать путь, либо выполнить программу Ngen.exe из каталога, в котором находится сборка.

```console
ngen display c:\myApps\MyAssembly.exe
```

Следующая команда выводит все образы в машинном коде с именем `MyAssembly` и версией 1.0.0.0, содержащиеся в кэше образов в машинном коде.

```console
ngen display "myAssembly, version=1.0.0.0"
```

### <a name="updating-images"></a>Обновление образов

Образы обычно обновляются после обновления общего компонента. Для обновления всех образов в машинном коде, которые были изменены или для которых были изменены зависимости, используется действие `update` без аргументов.

```console
ngen update
```

Обновление всех образов может занять длительное время. С помощью параметра `/queue` можно поставить обновления в очередь выполнения службы образов в машинном коде. Подробнее о параметре `/queue` и приоритетах установки см. в разделе [Служба образов в машинном коде](#native-image-service).

```console
ngen update /queue
```

### <a name="uninstalling-images"></a>Удаление образов

Программа Ngen.exe поддерживает список зависимостей, поэтому общие компоненты удаляются, только когда удалены все сборки, зависимые от этих компонентов. Кроме того, общий компонент не удаляется, если он установлен как корень.

Следующая команда удаляет все сценарии для корня `ClientApp.exe`:

```console
ngen uninstall ClientApp
```

Удалить конкретные сценарии можно с помощью действия `uninstall`. Следующая команда удаляет все сценарии отладки для `ClientApp.exe`:

```console
ngen uninstall ClientApp /debug
```

> [!NOTE]
> При удалении сценариев `/debug` не удаляется сценарий, включающий и `/profile`, и `/debug.`

Следующая команда удаляет все сценарии для конкретной версии `ClientApp.exe`:

```console
ngen uninstall "ClientApp, Version=1.0.0.0"
```

Следующая команда удаляет все сценарии для `"ClientApp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=3c7ba247adcd2081, processorArchitecture=MSIL",` или только сценарий отладки для этой сборки.

```console
ngen uninstall "ClientApp, Version=1.0.0.0, Culture=neutral,
  PublicKeyToken=3c7ba247adcd2081, processorArchitecture=MSIL"
ngen uninstall "ClientApp, Version=1.0.0.0, Culture=neutral,
  PublicKeyToken=3c7ba247adcd2081, processorArchitecture=MSIL" /debug
```

Как и в случае действия `install`, предоставление расширения требует либо выполнения программы Ngen.exe из каталога, содержащего сборку, либо указания полного пути.

Примеры, связанные со службой образов в машинном коде, см. в разделе [Служба образов в машинном коде](#native-image-service).

## <a name="native-image-task"></a>Задача образов в машинном коде

Задача образов в машинном коде — это задача Windows, которая создает и поддерживает образы в машинном коде. Задача образов в машинном коде автоматически создает и освобождает образы в машинном коде в поддерживаемых сценариях. Она также позволяет установщикам использовать программу [Ngen.exe (генератор образов в машинном коде)](ngen-exe-native-image-generator.md) для отложенного создания и обновления образов в машинном коде.

Задача образов в машинном коде регистрируется однократно для каждой архитектуры ЦП, поддерживаемой на компьютере, чтобы обеспечить компиляцию приложений для каждой целевой архитектуры.

|Имя задачи|32-разрядный компьютер|64-разрядный компьютер|
|---------------|----------------------|----------------------|
|NET Framework NGEN v4.0.30319|Yes|Yes|
|NET Framework NGEN v4.0.30319 64|Нет|Yes|

Задача образов в машинном коде доступна в .NET Framework 4.5 и более поздних версий при выполнении в ОС Windows 8 или более поздних версий. В более ранних версиях Windows платформа .NET Framework использует [службу образов в машинном коде](#native-image-service).

### <a name="task-lifetime"></a>Время жизни задачи

Как правило, планировщик заданий Windows запускает задачу образов в машинном коде каждую ночь, когда компьютер бездействует. Задача проверяет любые отложенные действия, помещенные в очередь установщиками приложений, любые отложенные запросы на обновление образов в машинном коде и любые операции автоматического создания образов. Задача завершает невыполненные операции, а затем завершает работу. Если компьютер выводится из состояния бездействия во время выполнении задачи, она прерывается.

Задачу образов в машинном коде можно также запустить вручную из интерфейса планировщика заданий или посредством вызовов NGen.exe. Если задача запускается одним из этих способов, ее выполнение продолжается при выводе компьютера из состояния бездействия. Образам, созданным вручную с помощью NGen.exe, назначаются приоритеты, что обеспечивает предсказуемость поведения установщиков приложений.

## <a name="native-image-service"></a>Служба образов в машинном коде

Служба образов в машинном коде — это служба Windows, которая создает и поддерживает образы в машинном коде. Она позволяет разработчикам откладывать установку и обновление образов в машинном коде и выполнять эти процедуры позже, когда компьютер простаивает.

Как правило, служба образов в машинном коде запускается программой установки (установщиком) приложения или обновления. Для действий с приоритетом 3 служба выполняется во время простоя компьютера. Служба сохраняет свое состояние и может при необходимости возобновлять работу после перезагрузки. Для нескольких компиляций образов может быть организована очередь.

Служба также взаимодействует с командой Ngen.exe, выполняемой вручную. Команды, выполняемые вручную, имеют приоритет над фоновыми действиями.

> [!NOTE]
> В операционной системе Windows Vista служба образов в машинном коде имеет имя "Microsoft.NET Framework NGEN v2.0.50727_X86" или "Microsoft.NET Framework NGEN v2.0.50727_X64". Во всех более ранних версиях Microsoft Windows ее имя — ".NET Runtime Optimization Service v2.0.50727_X86" или ".NET Runtime Optimization Service v2.0.50727_X64".

### <a name="launching-deferred-operations"></a>Запуск отложенных операций

Перед началом установки или обновления рекомендуется приостановить службу. Это позволит заблокировать ее на время, пока установщик будет копировать файлы или помещать сборки в глобальный кэш сборок. Для приостановки службы используется следующая командная строка Ngen.exe:

```console
ngen queue pause
```

После того как все отложенные операции поставлены в очередь, работу службы можно возобновить с помощью следующей команды:

```console
ngen queue continue
```

Чтобы отложить создание образов в машинном коде при установке нового приложения или обновлении общего компонента, используйте параметр `/queue` с действием `install` или `update`. Следующие командные строки Ngen.exe позволяют установить образ общего компонента в машинном коде и выполнить обновление всех корней, которых это может касаться:

```console
ngen install MyComponent /queue
ngen update /queue
```

Действие `update` заново создает все образы в машинном коде, которые стали недействительными, а не только те, которые используют `MyComponent`.

Если в приложении слишком много корней, можно учитывать приоритеты отложенных действий. Приведенные ниже команды создают очередь для установки трех корней. Первой устанавливается сборка `Assembly1`, не дожидаясь периода бездействия. Сборка `Assembly2` также устанавливается без ожидания бездействия, но после завершения всех действий с приоритетом 1. Сборка `Assembly3` устанавливается, когда служба обнаруживает, что компьютер бездействует.

```console
ngen install Assembly1 /queue:1
ngen install Assembly2 /queue:2
ngen install Assembly3 /queue:3
```

Вы можете задать синхронное выполнение действий, находящихся в очереди, с помощью действия `executeQueuedItems`. Если задать необязательный приоритет, это действие затронет только те действия в очереди, которые имеют такой же или более низкий приоритет. По умолчанию подразумевается приоритет 3, поэтому следующая команда Ngen.exe обработает все действия в очереди немедленно и не вернет управление, пока они не закончатся:

```console
ngen executeQueuedItems
```

Синхронные команды выполняются программой Ngen.exe и не используют службу образов в машинном коде. Можно выполнять действия с помощью Ngen.exe, пока служба образов в машинном коде работает.

### <a name="service-shutdown"></a>Завершение работы службы

После того как служба инициирована выполнением команды Ngen.exe с параметром `/queue`, она продолжает работать в фоновом режиме, пока не будут завершены все действия. Служба сохраняет свое состояние и может при необходимости возобновлять работу после перезагрузки. Как только служба обнаруживает, что в очереди больше нет действий, она сбрасывает свое состояние, чтобы не запускаться повторно после очередной перезагрузки компьютера, и затем завершает работу.

### <a name="service-interaction-with-clients"></a>Взаимодействие службы с клиентами

В версии .NET Framework 2.0 взаимодействие со службой образов в машинном коде может осуществляться только через программу командной строки Ngen.exe. Используйте эту программу в скриптах установки для управления очередями действий, выполняемых службой образов в машинном коде, и для взаимодействия с этой службой.

## <a name="see-also"></a>См. также

- [Инструменты](index.md)
- [Процесс управляемого выполнения](../../standard/managed-execution-process.md)
- [Обнаружение сборок в среде выполнения](../deployment/how-the-runtime-locates-assemblies.md)
- [Командные строки](developer-command-prompt-for-vs.md)
