---
title: Рекомендации для загрузки сборок
ms.date: 03/30/2017
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
ms.openlocfilehash: 7575c40edf47e977335bcc34fcd9e49debab0980
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/15/2020
ms.locfileid: "79181700"
---
# <a name="best-practices-for-assembly-loading"></a><span data-ttu-id="eca41-102">Рекомендации для загрузки сборок</span><span class="sxs-lookup"><span data-stu-id="eca41-102">Best Practices for Assembly Loading</span></span>
<span data-ttu-id="eca41-103">В этой статье рассматриваются способы избежания проблем с идентификацией типов, способных привести к исключениям <xref:System.InvalidCastException>, <xref:System.MissingMethodException> и другим ошибкам.</span><span class="sxs-lookup"><span data-stu-id="eca41-103">This article discusses ways to avoid problems of type identity that can lead to <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, and other errors.</span></span> <span data-ttu-id="eca41-104">В статье рассматриваются следующие рекомендации:</span><span class="sxs-lookup"><span data-stu-id="eca41-104">The article discusses the following recommendations:</span></span>  
  
- [<span data-ttu-id="eca41-105">Понимание преимуществ и недостатков контекстов загрузки.</span><span class="sxs-lookup"><span data-stu-id="eca41-105">Understand the advantages and disadvantages of load contexts</span></span>](#load_contexts)  
  
- [<span data-ttu-id="eca41-106">Избежание привязки к частичным именам сборок.</span><span class="sxs-lookup"><span data-stu-id="eca41-106">Avoid binding on partial assembly names</span></span>](#avoid_partial_names)  
  
- [<span data-ttu-id="eca41-107">Избежание загрузки сборок в нескольких контекстах.</span><span class="sxs-lookup"><span data-stu-id="eca41-107">Avoid loading an assembly into multiple contexts</span></span>](#avoid_loading_into_multiple_contexts)  
  
- [<span data-ttu-id="eca41-108">Избежание загрузки нескольких версий сборки в том же контексте.</span><span class="sxs-lookup"><span data-stu-id="eca41-108">Avoid loading multiple versions of an assembly into the same context</span></span>](#avoid_loading_multiple_versions)  
  
- [<span data-ttu-id="eca41-109">Рассмотрение возможности перехода к использованию контекста загрузки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="eca41-109">Consider switching to the default load context</span></span>](#switch_to_default)  
  
 <span data-ttu-id="eca41-110">Первая рекомендация, касающаяся [преимуществ и недостатков контекстов загрузки](#load_contexts), предоставляет базовые сведения для всех прочих рекомендаций, так как все они полагаются на понимание сути контекстов загрузки.</span><span class="sxs-lookup"><span data-stu-id="eca41-110">The first recommendation, [understand the advantages and disadvantages of load contexts](#load_contexts), provides background information for the other recommendations, because they all depend on a knowledge of load contexts.</span></span>  
  
<a name="load_contexts"></a>
## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a><span data-ttu-id="eca41-111">Понимание преимуществ и недостатков контекстов загрузки</span><span class="sxs-lookup"><span data-stu-id="eca41-111">Understand the Advantages and Disadvantages of Load Contexts</span></span>  
 <span data-ttu-id="eca41-112">В рамках домена приложения сборки могут загружаться в одном из трех контекстов либо могут быть загружены без контекста:</span><span class="sxs-lookup"><span data-stu-id="eca41-112">Within an application domain, assemblies can be loaded into one of three contexts, or they can be loaded without context:</span></span>  
  
- <span data-ttu-id="eca41-113">Контекст загрузки по умолчанию содержит сборки, обнаруженные в результате поиска в глобальном кэше сборок, в хранилище сборок главного узла, если среда выполнения является размещенной (например, в SQL Server), либо в свойствах <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения.</span><span class="sxs-lookup"><span data-stu-id="eca41-113">The default load context contains assemblies found by probing the global assembly cache, the host assembly store if the runtime is hosted (for example, in SQL Server), and the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="eca41-114">В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.</span><span class="sxs-lookup"><span data-stu-id="eca41-114">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
- <span data-ttu-id="eca41-115">Контекст, из которого ведется загрузка, содержит сборки из расположений, в которых загрузчик не ведет поиск.</span><span class="sxs-lookup"><span data-stu-id="eca41-115">The load-from context contains assemblies that are loaded from locations that are not searched by the loader.</span></span> <span data-ttu-id="eca41-116">Например, надстройки могут устанавливаться в каталоге, не относящемся к пути приложения.</span><span class="sxs-lookup"><span data-stu-id="eca41-116">For example, add-ins might be installed in a directory that is not under the application path.</span></span> <span data-ttu-id="eca41-117">К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType> и <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eca41-117"><xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType>, and <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType> are examples of methods that load by path.</span></span>  
  
- <span data-ttu-id="eca41-118">Контекст только для отражения содержит сборки, загружаемые с помощью методов <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="eca41-118">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods.</span></span> <span data-ttu-id="eca41-119">Код, загруженный в этом контексте, не может быть выполнен, поэтому далее он не рассматривается.</span><span class="sxs-lookup"><span data-stu-id="eca41-119">Code in this context cannot be executed, so it is not discussed here.</span></span> <span data-ttu-id="eca41-120">Дополнительные сведения см. в разделе [Практическое руководство. Загрузка сборок в контекст, предназначенный только для отражения](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="eca41-120">For more information, see [How to: Load Assemblies into the Reflection-Only Context](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
- <span data-ttu-id="eca41-121">В случае создания временной динамической сборки с помощью эмиссии отражения сборка не попадет ни в один контекст.</span><span class="sxs-lookup"><span data-stu-id="eca41-121">If you generated a transient dynamic assembly by using reflection emit, the assembly is not in any context.</span></span> <span data-ttu-id="eca41-122">Кроме того, большинство сборок, загружаемых с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>, загружаются без контекста, а сборки, загружаемые из байтовых массивов, также загружаются без контекста, если только их идентификаторы (после применения политики) не указывают на то, что они расположены в глобальном кэше сборок.</span><span class="sxs-lookup"><span data-stu-id="eca41-122">In addition, most assemblies that are loaded by using the <xref:System.Reflection.Assembly.LoadFile%2A> method are loaded without context, and assemblies that are loaded from byte arrays are loaded without context unless their identity (after policy is applied) establishes that they are in the global assembly cache.</span></span>  
  
 <span data-ttu-id="eca41-123">Контексты выполнения имеют преимущества и недостатки, описанные в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="eca41-123">The execution contexts have advantages and disadvantages, as discussed in the following sections.</span></span>  
  
### <a name="default-load-context"></a><span data-ttu-id="eca41-124">Контекст загрузки по умолчанию</span><span class="sxs-lookup"><span data-stu-id="eca41-124">Default Load Context</span></span>  
 <span data-ttu-id="eca41-125">При загрузке сборок в контексте загрузки по умолчанию также автоматически загружаются сборки, от которых они зависят.</span><span class="sxs-lookup"><span data-stu-id="eca41-125">When assemblies are loaded into the default load context, their dependencies are loaded automatically.</span></span> <span data-ttu-id="eca41-126">Загружаемые таким образом в контексте загрузки по умолчанию сборки автоматически обнаруживаются для сборок в контексте загрузки по умолчанию или в контексте, из которого ведется загрузка.</span><span class="sxs-lookup"><span data-stu-id="eca41-126">Dependencies that are loaded into the default load context are found automatically for assemblies in the default load context or the load-from context.</span></span> <span data-ttu-id="eca41-127">Загрузка сборок по идентификатору повышает стабильность приложений, позволяя гарантировать, что не будут использоваться неизвестные версии сборок (см. раздел [Избежание привязки к именам частичных сборок](#avoid_partial_names)).</span><span class="sxs-lookup"><span data-stu-id="eca41-127">Loading by assembly identity increases the stability of applications by ensuring that unknown versions of assemblies are not used (see the [Avoid Binding on Partial Assembly Names](#avoid_partial_names) section).</span></span>  
  
 <span data-ttu-id="eca41-128">Использование контекста загрузки по умолчанию имеет следующие недостатки:</span><span class="sxs-lookup"><span data-stu-id="eca41-128">Using the default load context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="eca41-129">Недоступны необходимые для других сборок сборки, загруженные в других контекстах.</span><span class="sxs-lookup"><span data-stu-id="eca41-129">Dependencies that are loaded into other contexts are not available.</span></span>  
  
- <span data-ttu-id="eca41-130">В контексте загрузки по умолчанию нельзя загружать сборки из расположений, не относящихся к пути поиска сборок.</span><span class="sxs-lookup"><span data-stu-id="eca41-130">You cannot load assemblies from locations outside the probing path into the default load context.</span></span>  
  
### <a name="load-from-context"></a><span data-ttu-id="eca41-131">Контекст, из которого ведется загрузка</span><span class="sxs-lookup"><span data-stu-id="eca41-131">Load-From Context</span></span>  
 <span data-ttu-id="eca41-132">Контекст, из которого ведется загрузка, позволяет загрузить сборку, путь которой не относится к пути приложения и, соответственно, не включается в область поиска.</span><span class="sxs-lookup"><span data-stu-id="eca41-132">The load-from context lets you load an assembly from a path that is not under the application path, and therefore is not included in probing.</span></span> <span data-ttu-id="eca41-133">Это позволяет находить и загружать требуемые сборки, расположенные по этому пути, так как сведения о пути хранятся в контексте.</span><span class="sxs-lookup"><span data-stu-id="eca41-133">It enables dependencies to be located and loaded from that path, because the path information is maintained by the context.</span></span> <span data-ttu-id="eca41-134">Кроме того, сборки в этом контексте могут использовать необходимые сборки, загруженные в контекст загрузки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="eca41-134">In addition, assemblies in this context can use dependencies that are loaded into the default load context.</span></span>  
  
 <span data-ttu-id="eca41-135">Загрузка сборок с помощью метода <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> или другого метода, использующего для загрузки путь, имеет следующие недостатки:</span><span class="sxs-lookup"><span data-stu-id="eca41-135">Loading assemblies by using the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method, or one of the other methods that load by path, has the following disadvantages:</span></span>  
  
- <span data-ttu-id="eca41-136">Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.</span><span class="sxs-lookup"><span data-stu-id="eca41-136">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
- <span data-ttu-id="eca41-137">Если сборка загружается с использованием метода <xref:System.Reflection.Assembly.LoadFrom%2A>, после чего сборка в контексте загрузки по умолчанию предпринимает попытку загрузить ту же сборку по отображаемому имени, попытка загрузки завершится неудачей.</span><span class="sxs-lookup"><span data-stu-id="eca41-137">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the default load context tries to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="eca41-138">Это может произойти при десериализации сборки.</span><span class="sxs-lookup"><span data-stu-id="eca41-138">This can occur when an assembly is deserialized.</span></span>  
  
- <span data-ttu-id="eca41-139">Если сборка загружена с использованием метода <xref:System.Reflection.Assembly.LoadFrom%2A>, но путь поиска сборок включает сборку с тем же идентификатором, находящуюся в другом расположении, то может возникнуть исключение <xref:System.InvalidCastException>, <xref:System.MissingMethodException> или другое непредусмотренное поведение.</span><span class="sxs-lookup"><span data-stu-id="eca41-139">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but in a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
- <span data-ttu-id="eca41-140">Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.</span><span class="sxs-lookup"><span data-stu-id="eca41-140"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
- <span data-ttu-id="eca41-141">Если для сборки существует машинный образ, то он не используется.</span><span class="sxs-lookup"><span data-stu-id="eca41-141">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="eca41-142">Сборка не может быть загружена как доменно-нейтральная.</span><span class="sxs-lookup"><span data-stu-id="eca41-142">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="eca41-143">На платформе .NET Framework версий 1.0 и 1.1 политика не применяется.</span><span class="sxs-lookup"><span data-stu-id="eca41-143">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
### <a name="no-context"></a><span data-ttu-id="eca41-144">Загрузка без контекста</span><span class="sxs-lookup"><span data-stu-id="eca41-144">No Context</span></span>  
 <span data-ttu-id="eca41-145">Загрузка без контекста — это единственный доступный вариант для временных сборок, порождаемых с помощью эмиссии отражения.</span><span class="sxs-lookup"><span data-stu-id="eca41-145">Loading without context is the only option for transient assemblies that are generated with reflection emit.</span></span> <span data-ttu-id="eca41-146">Загрузка без контекста — это единственная возможность загрузки нескольких сборок с одним и тем же идентификатором в одном домене приложения.</span><span class="sxs-lookup"><span data-stu-id="eca41-146">Loading without context is the only way to load multiple assemblies that have the same identity into one application domain.</span></span> <span data-ttu-id="eca41-147">Затраты, связанные с поиском сборок, в этом случае устраняются.</span><span class="sxs-lookup"><span data-stu-id="eca41-147">The cost of probing is avoided.</span></span>  
  
 <span data-ttu-id="eca41-148">Сборки, загружаемые из байтовых массивов, загружаются без контекста, если только идентификатор сборки, определяемый после применения политики, не совпадет с идентификатором сборки из глобального кэша сборок; в этом случае сборка загружается из глобального кэша сборок.</span><span class="sxs-lookup"><span data-stu-id="eca41-148">Assemblies that are loaded from byte arrays are loaded without context unless the identity of the assembly, which is established when policy is applied, matches the identity of an assembly in the global assembly cache; in that case, the assembly is loaded from the global assembly cache.</span></span>  
  
 <span data-ttu-id="eca41-149">Загрузка сборок без контекста имеет следующие недостатки:</span><span class="sxs-lookup"><span data-stu-id="eca41-149">Loading assemblies without context has the following disadvantages:</span></span>  
  
- <span data-ttu-id="eca41-150">Другие сборки не могут привязываться к сборкам, загруженным без контекста, если только приложение не обрабатывает событие <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eca41-150">Other assemblies cannot bind to assemblies that are loaded without context, unless you handle the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="eca41-151">Зависимости не загружаются автоматически.</span><span class="sxs-lookup"><span data-stu-id="eca41-151">Dependencies are not loaded automatically.</span></span> <span data-ttu-id="eca41-152">Их можно предварительно загрузить без контекста, загрузить в контексте загрузки по умолчанию или загрузить их в обработчике событий <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eca41-152">You can preload them without context, preload them into the default load context, or load them by handling the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event.</span></span>  
  
- <span data-ttu-id="eca41-153">Загрузка нескольких сборок с одним и тем же идентификатором без контекста может привести к проблемам с идентификацией типов, аналогичным тем, что возникают при загрузке сборок с одним и тем же идентификатором в нескольких контекстах.</span><span class="sxs-lookup"><span data-stu-id="eca41-153">Loading multiple assemblies with the same identity without context can cause type identity problems similar to those caused by loading assemblies with the same identity into multiple contexts.</span></span> <span data-ttu-id="eca41-154">См. раздел [Избежание загрузки сборок в нескольких контекстах](#avoid_loading_into_multiple_contexts).</span><span class="sxs-lookup"><span data-stu-id="eca41-154">See [Avoid Loading an Assembly into Multiple Contexts](#avoid_loading_into_multiple_contexts).</span></span>  
  
- <span data-ttu-id="eca41-155">Если для сборки существует машинный образ, то он не используется.</span><span class="sxs-lookup"><span data-stu-id="eca41-155">If a native image exists for the assembly, it is not used.</span></span>  
  
- <span data-ttu-id="eca41-156">Сборка не может быть загружена как доменно-нейтральная.</span><span class="sxs-lookup"><span data-stu-id="eca41-156">The assembly cannot be loaded as domain-neutral.</span></span>  
  
- <span data-ttu-id="eca41-157">На платформе .NET Framework версий 1.0 и 1.1 политика не применяется.</span><span class="sxs-lookup"><span data-stu-id="eca41-157">In the .NET Framework versions 1.0 and 1.1, policy is not applied.</span></span>  
  
<a name="avoid_partial_names"></a>
## <a name="avoid-binding-on-partial-assembly-names"></a><span data-ttu-id="eca41-158">Избежание привязки к частичным именам сборок</span><span class="sxs-lookup"><span data-stu-id="eca41-158">Avoid Binding on Partial Assembly Names</span></span>  
 <span data-ttu-id="eca41-159">Частичная привязка имен происходит при указании лишь одной из частей отображаемого имени сборки (<xref:System.Reflection.Assembly.FullName%2A>) при ее загрузке.</span><span class="sxs-lookup"><span data-stu-id="eca41-159">Partial name binding occurs when you specify only part of the assembly display name (<xref:System.Reflection.Assembly.FullName%2A>) when you load an assembly.</span></span> <span data-ttu-id="eca41-160">Например, метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> можно вызвать с простым именем сборки, не указывая ее версию, язык и региональные параметры, а также маркер открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="eca41-160">For example, you might call the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method with only the simple name of the assembly, omitting the version, culture, and public key token.</span></span> <span data-ttu-id="eca41-161">Также можно вызвать метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>, который сначала вызывает метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, а затем, если ему не удалось найти сборку, проводит поиск по глобальному кэшу сборок и загружает последнюю версию сборки из доступных.</span><span class="sxs-lookup"><span data-stu-id="eca41-161">Or you might call the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method, which first calls the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and, if that fails to locate the assembly, searches the global assembly cache and loads the latest available version of the assembly.</span></span>  
  
 <span data-ttu-id="eca41-162">Частичная привязка имен может вызывать самые разнообразные проблемы, включая следующие:</span><span class="sxs-lookup"><span data-stu-id="eca41-162">Partial name binding can cause many problems, including the following:</span></span>  
  
- <span data-ttu-id="eca41-163">Метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> может загрузить другую сборку с тем же простым именем.</span><span class="sxs-lookup"><span data-stu-id="eca41-163">The <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method might load a different assembly with the same simple name.</span></span> <span data-ttu-id="eca41-164">Например, два приложения могут установить в глобальном кэше сборок две разные сборки с простым именем `GraphicsLibrary`.</span><span class="sxs-lookup"><span data-stu-id="eca41-164">For example, two applications might install two completely different assemblies that both have the simple name `GraphicsLibrary` into the global assembly cache.</span></span>  
  
- <span data-ttu-id="eca41-165">Фактически загружаемая сборка может быть несовместимой с предыдущими версиями.</span><span class="sxs-lookup"><span data-stu-id="eca41-165">The assembly that is actually loaded might not be backward-compatible.</span></span> <span data-ttu-id="eca41-166">Например, не указав версию, можно загрузить более позднюю версию сборки, на использование которой программа не рассчитана.</span><span class="sxs-lookup"><span data-stu-id="eca41-166">For example, not specifying the version might result in the loading of a much later version than the version your program was originally written to use.</span></span> <span data-ttu-id="eca41-167">Изменения в более поздних версиях сборки могут вызывать ошибки приложения.</span><span class="sxs-lookup"><span data-stu-id="eca41-167">Changes in the later version might cause errors in your application.</span></span>  
  
- <span data-ttu-id="eca41-168">Фактически загружаемая сборка может быть несовместима с последующими версиями.</span><span class="sxs-lookup"><span data-stu-id="eca41-168">The assembly that is actually loaded might not be forward-compatible.</span></span> <span data-ttu-id="eca41-169">Например, приложение могло строиться и тестироваться с последней версией сборки, но при частичной привязке могла загрузиться существенно более ранняя ее версия, не поддерживающая функции, которые использует приложение.</span><span class="sxs-lookup"><span data-stu-id="eca41-169">For example, you might have built and tested your application with the latest version of an assembly, but partial binding might load a much earlier version that lacks features your application uses.</span></span>  
  
- <span data-ttu-id="eca41-170">Установка новых приложений может нарушать работу уже имеющихся приложений.</span><span class="sxs-lookup"><span data-stu-id="eca41-170">Installing new applications can break existing applications.</span></span> <span data-ttu-id="eca41-171">Работа приложения, использующего метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A>, может быть нарушена в результате установки новой несовместимой версии совместно используемой сборки.</span><span class="sxs-lookup"><span data-stu-id="eca41-171">An application that uses the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method can be broken by installing a newer, incompatible version of a shared assembly.</span></span>  
  
- <span data-ttu-id="eca41-172">При загрузке необходимых сборок может возникать непредвиденное поведение.</span><span class="sxs-lookup"><span data-stu-id="eca41-172">Unexpected dependency loading can occur.</span></span> <span data-ttu-id="eca41-173">Загрузка двух сборок, совместно зависящих от одной сборки, с использованием частичной привязки имен может привести к тому, что одна из сборок будет использовать компонент, с которым она не строилась и не тестировалась.</span><span class="sxs-lookup"><span data-stu-id="eca41-173">It you load two assemblies that share a dependency, loading them with partial binding might result in one assembly using a component that it was not built or tested with.</span></span>  
  
 <span data-ttu-id="eca41-174">Ввиду потенциальных проблем метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A> был помечен как устаревший.</span><span class="sxs-lookup"><span data-stu-id="eca41-174">Because of the problems it can cause, the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method has been marked obsolete.</span></span> <span data-ttu-id="eca41-175">Вместо него рекомендуется использовать метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, указывая полные отображаемые имена сборок.</span><span class="sxs-lookup"><span data-stu-id="eca41-175">We recommend that you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method instead, and specify full assembly display names.</span></span> <span data-ttu-id="eca41-176">См. разделы [Понимание преимуществ и недостатков контекстов загрузки](#load_contexts) и [Рассмотрение возможности перехода в контекст загрузки по умолчанию](#switch_to_default).</span><span class="sxs-lookup"><span data-stu-id="eca41-176">See [Understand the Advantages and Disadvantages of Load Contexts](#load_contexts) and [Consider Switching to the Default Load Context](#switch_to_default).</span></span>  
  
 <span data-ttu-id="eca41-177">Если вы хотите использовать метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A>, потому что он упрощает загрузку сборок, учтите, что сбой приложения с сообщением, содержащим полный идентификатор необходимой сборки, — это лучше для пользователя, чем автоматическое использование неизвестной версии сборки, способной вызвать непредвиденное поведение и бреши в системе безопасности.</span><span class="sxs-lookup"><span data-stu-id="eca41-177">If you want to use the <xref:System.Reflection.Assembly.LoadWithPartialName%2A> method because it makes assembly loading easy, consider that having your application fail with an error message that identifies the missing assembly is likely to provide a better user experience than automatically using an unknown version of the assembly, which might cause unpredictable behavior and security holes.</span></span>  
  
<a name="avoid_loading_into_multiple_contexts"></a>
## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a><span data-ttu-id="eca41-178">Избежание загрузки сборок в нескольких контекстах</span><span class="sxs-lookup"><span data-stu-id="eca41-178">Avoid Loading an Assembly into Multiple Contexts</span></span>  
 <span data-ttu-id="eca41-179">Загрузка сборок в нескольких контекстах может вызывать проблемы с идентификацией типов.</span><span class="sxs-lookup"><span data-stu-id="eca41-179">Loading an assembly into multiple contexts can cause type identity problems.</span></span> <span data-ttu-id="eca41-180">Загрузка одного и того же типа из одной и той же сборки в двух разных контекстах аналогична загрузке двух разных типов с одним и тем же именем.</span><span class="sxs-lookup"><span data-stu-id="eca41-180">If the same type is loaded from the same assembly into two different contexts, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="eca41-181">При попытке приведения из одного такого типа в другой возникнет исключение <xref:System.InvalidCastException>, а в сообщении об ошибке при этом будет несколько туманно сказано, что тип `MyType` нельзя привести к типу `MyType`.</span><span class="sxs-lookup"><span data-stu-id="eca41-181">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="eca41-182">Например, предположим, что в сборке `ICommunicate` объявлен интерфейс `Utility`, который используется в программе и в других сборках, загружаемых программой.</span><span class="sxs-lookup"><span data-stu-id="eca41-182">For example, suppose that the `ICommunicate` interface is declared in an assembly named `Utility`, which is referenced by your program and also by other assemblies that your program loads.</span></span> <span data-ttu-id="eca41-183">Эти другие сборки содержат типы, реализующие интерфейс `ICommunicate`, позволяя программе их использовать.</span><span class="sxs-lookup"><span data-stu-id="eca41-183">These other assemblies contain types that implement the `ICommunicate` interface, allowing your program to use them.</span></span>  
  
 <span data-ttu-id="eca41-184">Теперь подумаем о том, что произойдет при запуске программы.</span><span class="sxs-lookup"><span data-stu-id="eca41-184">Now consider what happens when your program is run.</span></span> <span data-ttu-id="eca41-185">Сборки, на которые ссылается программа, будут загружены в контексте загрузки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="eca41-185">Assemblies that are referenced by your program are loaded into the default load context.</span></span> <span data-ttu-id="eca41-186">Если загрузить целевую сборку по идентификатору с помощью метода <xref:System.Reflection.Assembly.Load%2A>, то она попадет в контекст загрузки по умолчанию вместе со сборками, от которых она зависит.</span><span class="sxs-lookup"><span data-stu-id="eca41-186">If you load a target assembly by its identity, using the <xref:System.Reflection.Assembly.Load%2A> method, it will be in the default load context, and so will its dependencies.</span></span> <span data-ttu-id="eca41-187">Как программа, так и целевая сборка будут использовать сборку `Utility`.</span><span class="sxs-lookup"><span data-stu-id="eca41-187">Both your program and the target assembly will use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="eca41-188">Предположим теперь, что целевая сборка загружается по файловому пути с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="eca41-188">However, suppose you load the target assembly by its file path, using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="eca41-189">В этом случае сборка загружается без контекста, поэтому необходимые для нее сборки не будут загружены автоматически.</span><span class="sxs-lookup"><span data-stu-id="eca41-189">The assembly is loaded without any context, so its dependencies are not automatically loaded.</span></span> <span data-ttu-id="eca41-190">Можно создать обработчик событий <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>, разрешающий подобные зависимости; он может загрузить сборку `Utility` без контекста с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="eca41-190">You might have a handler for the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event to supply the dependency, and it might load the `Utility` assembly with no context by using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="eca41-191">В этом случае при создании экземпляра типа, содержащегося в целевой сборке, и попытке его присвоения переменной типа `ICommunicate` будет порождено исключение <xref:System.InvalidCastException>, так как среда выполнения рассматривает интерфейсы `ICommunicate` в двух копиях сборки `Utility` как разные типы.</span><span class="sxs-lookup"><span data-stu-id="eca41-191">Now when you create an instance of a type that is contained in the target assembly and try to assign it to a variable of type `ICommunicate`, an <xref:System.InvalidCastException> is thrown because the runtime considers the `ICommunicate` interfaces in the two copies of the `Utility` assembly to be different types.</span></span>  
  
 <span data-ttu-id="eca41-192">Существует множество других сценариев, в которых сборка может загружаться в нескольких контекстах.</span><span class="sxs-lookup"><span data-stu-id="eca41-192">There are many other scenarios in which an assembly can be loaded into multiple contexts.</span></span> <span data-ttu-id="eca41-193">Оптимальный подход состоит в устранении потенциальных конфликтов путем перемещения целевой сборки в путь приложения и использования метода <xref:System.Reflection.Assembly.Load%2A> с полным отображаемым именем.</span><span class="sxs-lookup"><span data-stu-id="eca41-193">The best approach is to avoid conflicts by relocating the target assembly in your application path and using the <xref:System.Reflection.Assembly.Load%2A> method with the full display name.</span></span> <span data-ttu-id="eca41-194">При этом сборка будет загружаться в контексте загрузки по умолчанию, и обе сборки будут использовать одну и ту же копию сборки `Utility`.</span><span class="sxs-lookup"><span data-stu-id="eca41-194">The assembly is then loaded into the default load context, and both assemblies use the same `Utility` assembly.</span></span>  
  
 <span data-ttu-id="eca41-195">Если целевая сборка должна находиться вне пути приложения, то можно использовать метод <xref:System.Reflection.Assembly.LoadFrom%2A> для ее загрузки в контексте, из которого ведется загрузка.</span><span class="sxs-lookup"><span data-stu-id="eca41-195">If the target assembly must remain outside your application path, you can use the <xref:System.Reflection.Assembly.LoadFrom%2A> method to load it into the load-from context.</span></span> <span data-ttu-id="eca41-196">Если целевая сборка компилировалась со ссылкой на сборку `Utility` приложения, то она будет использовать сборку `Utility`, которую приложение загрузило в контексте загрузки по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="eca41-196">If the target assembly was compiled with a reference to your application's `Utility` assembly, it will use the `Utility` assembly that your application has loaded into the default load context.</span></span> <span data-ttu-id="eca41-197">Обратите внимание, что в случае, если целевая сборка зависит от копии сборки `Utility`, расположенной вне пути приложения, могут возникнуть проблемы.</span><span class="sxs-lookup"><span data-stu-id="eca41-197">Note that problems can occur if the target assembly has a dependency on a copy of the `Utility` assembly located outside your application path.</span></span> <span data-ttu-id="eca41-198">Если эта сборка загружается в контекст, из которого ведется загрузка, перед тем, как приложение загрузит сборку `Utility`, загрузка приложения завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="eca41-198">If that assembly is loaded into the load-from context before your application loads the `Utility` assembly, your application's load will fail.</span></span>  
  
 <span data-ttu-id="eca41-199">В разделе [Рассмотрение возможности перехода к использованию контекста загрузки по умолчанию](#switch_to_default) описаны альтернативы использованию загрузки по файловому пути, например <xref:System.Reflection.Assembly.LoadFile%2A> и <xref:System.Reflection.Assembly.LoadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="eca41-199">The [Consider Switching to the Default Load Context](#switch_to_default) section discusses alternatives to using file path loads such as <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A>.</span></span>  
  
<a name="avoid_loading_multiple_versions"></a>
## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a><span data-ttu-id="eca41-200">Избежание загрузки нескольких версий сборки в том же контексте</span><span class="sxs-lookup"><span data-stu-id="eca41-200">Avoid Loading Multiple Versions of an Assembly into the Same Context</span></span>  
 <span data-ttu-id="eca41-201">Загрузка нескольких версий сборки в одном контексте загрузки может вызвать проблемы с идентификацией типов.</span><span class="sxs-lookup"><span data-stu-id="eca41-201">Loading multiple versions of an assembly into one load context can cause type identity problems.</span></span> <span data-ttu-id="eca41-202">Загрузка одного и того же типа из двух версий одной и той же сборки аналогична загрузке двух разных типов с одним и тем же именем.</span><span class="sxs-lookup"><span data-stu-id="eca41-202">If the same type is loaded from two versions of the same assembly, it is as if two different types with the same name had been loaded.</span></span> <span data-ttu-id="eca41-203">При попытке приведения из одного такого типа в другой возникнет исключение <xref:System.InvalidCastException>, а в сообщении об ошибке при этом будет несколько туманно сказано, что тип `MyType` нельзя привести к типу `MyType`.</span><span class="sxs-lookup"><span data-stu-id="eca41-203">An <xref:System.InvalidCastException> is thrown if you try to cast one type to the other, with the confusing message that type `MyType` cannot be cast to type `MyType`.</span></span>  
  
 <span data-ttu-id="eca41-204">Предположим, программа загружает одну версию сборки `Utility` напрямую, а потом загружает другую версию сборки `Utility`.</span><span class="sxs-lookup"><span data-stu-id="eca41-204">For example, your program might load one version of the `Utility` assembly directly, and later it might load another assembly that loads a different version of the `Utility` assembly.</span></span> <span data-ttu-id="eca41-205">Приложение также может загрузить две разные версии сборки, если в коде приложения имеется ошибка.</span><span class="sxs-lookup"><span data-stu-id="eca41-205">Or a coding error might cause two different code paths in your application to load different versions of an assembly.</span></span>  
  
 <span data-ttu-id="eca41-206">В контексте загрузки по умолчанию эта проблема может возникать при использовании метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> с указанием полных отображаемых имен сборок, включающих разные версии.</span><span class="sxs-lookup"><span data-stu-id="eca41-206">In the default load context, this problem can occur when you use the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and specify complete assembly display names that include different version numbers.</span></span> <span data-ttu-id="eca41-207">В случае загрузки сборок вне контекста проблема может возникать, если метод <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> используется для загрузки одной и той же сборки по нескольким путям.</span><span class="sxs-lookup"><span data-stu-id="eca41-207">For assemblies that are loaded without context, the problem can be caused by using the <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> method to load the same assembly from different paths.</span></span> <span data-ttu-id="eca41-208">Среда выполнения считает две сборки, загруженные из разных путей, разными, даже если они имеют одинаковые идентификаторы.</span><span class="sxs-lookup"><span data-stu-id="eca41-208">The runtime considers two assemblies that are loaded from different paths to be different assemblies, even if their identities are the same.</span></span>  
  
 <span data-ttu-id="eca41-209">Помимо проблем с идентификацией типов, наличие нескольких версий сборки может привести к исключению <xref:System.MissingMethodException>, если тип, загруженный из одной версии сборки, передается в код, ожидающий тип из другой версии сборки.</span><span class="sxs-lookup"><span data-stu-id="eca41-209">In addition to type identity problems, multiple versions of an assembly can cause a <xref:System.MissingMethodException> if a type that is loaded from one version of the assembly is passed to code that expects that type from a different version.</span></span> <span data-ttu-id="eca41-210">Например, код может рассчитывать на метод, добавленный в более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="eca41-210">For example, the code might expect a method that was added to the later version.</span></span>  
  
 <span data-ttu-id="eca41-211">Если поведение типа меняется от версии к версии, также могут возникать менее заметные ошибки.</span><span class="sxs-lookup"><span data-stu-id="eca41-211">More subtle errors can occur if the behavior of the type changed between versions.</span></span> <span data-ttu-id="eca41-212">К примеру, метод может породить непредвиденное исключение или вернуть непредвиденное значение.</span><span class="sxs-lookup"><span data-stu-id="eca41-212">For example, a method might throw an unexpected exception or return an unexpected value.</span></span>  
  
 <span data-ttu-id="eca41-213">Тщательно проанализируйте свой код и убедитесь, что загружается только одна версия сборки.</span><span class="sxs-lookup"><span data-stu-id="eca41-213">Carefully review your code to ensure that only one version of an assembly is loaded.</span></span> <span data-ttu-id="eca41-214">В любой момент времени можно использовать метод <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> для определения фактически загруженных сборок.</span><span class="sxs-lookup"><span data-stu-id="eca41-214">You can use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method to determine which assemblies are loaded at any given time.</span></span>  
  
<a name="switch_to_default"></a>
## <a name="consider-switching-to-the-default-load-context"></a><span data-ttu-id="eca41-215">Возможность перехода к использованию контекста загрузки по умолчанию</span><span class="sxs-lookup"><span data-stu-id="eca41-215">Consider Switching to the Default Load Context</span></span>  
 <span data-ttu-id="eca41-216">Рассмотрите способы загрузки и развертывания сборок в вашем приложении.</span><span class="sxs-lookup"><span data-stu-id="eca41-216">Examine your application's assembly loading and deployment patterns.</span></span> <span data-ttu-id="eca41-217">Можно ли устранить сборки, загружаемые из байтовых массивов?</span><span class="sxs-lookup"><span data-stu-id="eca41-217">Can you eliminate assemblies that are loaded from byte arrays?</span></span> <span data-ttu-id="eca41-218">Можно ли перенести сборки в путь поиска сборок?</span><span class="sxs-lookup"><span data-stu-id="eca41-218">Can you move assemblies into the probing path?</span></span> <span data-ttu-id="eca41-219">Если сборки загружаются из глобального кэша сборок или пути поиска сборок домена приложения (то есть <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A>), то сборку можно загрузить по идентификатору.</span><span class="sxs-lookup"><span data-stu-id="eca41-219">If assemblies are located in the global assembly cache or in the application domain's probing path (that is, its <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A>), you can load the assembly by its identity.</span></span>  
  
 <span data-ttu-id="eca41-220">Если перенести все сборки в путь поиска сборок невозможно, рассмотрите альтернативы: использование модели надстроек платформы .NET Framework, размещение сборок в глобальном кэше сборок или создание доменов приложения.</span><span class="sxs-lookup"><span data-stu-id="eca41-220">If it is not possible to put all your assemblies in the probing path, consider alternatives such as using the .NET Framework add-in model, placing assemblies into the global assembly cache, or creating application domains.</span></span>  
  
### <a name="consider-using-the-net-framework-add-in-model"></a><span data-ttu-id="eca41-221">Использование модели надстроек платформы .NET Framework</span><span class="sxs-lookup"><span data-stu-id="eca41-221">Consider Using the .NET Framework Add-In Model</span></span>  
 <span data-ttu-id="eca41-222">При использовании контекста, из которого ведется загрузка, для реализации надстроек, которые обычно устанавливаются вне базовой папки приложения, используйте модель надстроек платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="eca41-222">If you are using the load-from context to implement add-ins, which typically are not installed in the application base, use the .NET Framework add-in model.</span></span> <span data-ttu-id="eca41-223">Она обеспечивает изоляцию на уровне доменов приложений и процессов, не требуя самостоятельно управлять доменами приложений.</span><span class="sxs-lookup"><span data-stu-id="eca41-223">This model provides isolation at the application domain or process level, without requiring you to manage application domains yourself.</span></span> <span data-ttu-id="eca41-224">Сведения о модели надстроек см. в разделе [Надстройки и расширения среды](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span><span class="sxs-lookup"><span data-stu-id="eca41-224">For information about the add-in model, see [Add-ins and Extensibility](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).</span></span>  
  
### <a name="consider-using-the-global-assembly-cache"></a><span data-ttu-id="eca41-225">Использование глобального кэша сборок</span><span class="sxs-lookup"><span data-stu-id="eca41-225">Consider Using the Global Assembly Cache</span></span>  
 <span data-ttu-id="eca41-226">Разместив сборки в глобальном кэше сборок, можно использовать общий путь для сборок, находящихся вне базовой папки приложения, не теряя преимуществ контекста загрузки по умолчанию и не сталкиваясь с недостатками других контекстов.</span><span class="sxs-lookup"><span data-stu-id="eca41-226">Place assemblies in the global assembly cache to get the benefit of a shared assembly path that is outside the application base, without losing the advantages of the default load context or taking on the disadvantages of the other contexts.</span></span>  
  
### <a name="consider-using-application-domains"></a><span data-ttu-id="eca41-227">Использование доменов приложений</span><span class="sxs-lookup"><span data-stu-id="eca41-227">Consider Using Application Domains</span></span>  
 <span data-ttu-id="eca41-228">Если выяснится, что некоторые сборки нельзя разместить в пути поиска сборок приложения, подумайте, нельзя ли создать для них отдельный домен приложения.</span><span class="sxs-lookup"><span data-stu-id="eca41-228">If you determine that some of your assemblies cannot be deployed in the application's probing path, consider creating a new application domain for those assemblies.</span></span> <span data-ttu-id="eca41-229">Используйте тип <xref:System.AppDomainSetup> для создания нового домена приложения и укажите с помощью свойства <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> путь, по которому расположены сборки, которые требуется загрузить.</span><span class="sxs-lookup"><span data-stu-id="eca41-229">Use an <xref:System.AppDomainSetup> to create the new application domain, and use the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property to specify the path that contains the assemblies you want to load.</span></span> <span data-ttu-id="eca41-230">При наличии нескольких таких каталогов можно задать в <xref:System.AppDomainSetup.ApplicationBase%2A> корневой каталог и использовать свойство <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> для указания подкаталогов, в которых нужно вести поиск.</span><span class="sxs-lookup"><span data-stu-id="eca41-230">If you have multiple directories to probe, you can set the <xref:System.AppDomainSetup.ApplicationBase%2A> to a root directory and use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property to identify the subdirectories to probe.</span></span> <span data-ttu-id="eca41-231">Также можно создать несколько доменов приложения и задать в свойстве <xref:System.AppDomainSetup.ApplicationBase%2A> каждого из них необходимый путь для соответствующих сборок.</span><span class="sxs-lookup"><span data-stu-id="eca41-231">Alternatively, you can create multiple application domains and set the <xref:System.AppDomainSetup.ApplicationBase%2A> of each application domain to the appropriate path for its assemblies.</span></span>  
  
 <span data-ttu-id="eca41-232">Обратите внимание, что для загрузки таких сборок можно использовать метод <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="eca41-232">Note that you can use the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method to load these assemblies.</span></span> <span data-ttu-id="eca41-233">Так как они теперь расположены в пути поиска, они будут загружены в контексте загрузки по умолчанию, а не в контексте, из которого ведется загрузка.</span><span class="sxs-lookup"><span data-stu-id="eca41-233">Because they are now in the probing path, they will be loaded into the default load context instead of the load-from context.</span></span> <span data-ttu-id="eca41-234">Тем не менее рекомендуется перейти к использованию метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> и полных отображаемых имен сборок, чтобы гарантировать, что всегда используются только правильные их версии.</span><span class="sxs-lookup"><span data-stu-id="eca41-234">However, we recommend that you switch to the <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method and supply full assembly display names to ensure that correct versions are always used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="eca41-235">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="eca41-235">See also</span></span>

- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>
- <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>
