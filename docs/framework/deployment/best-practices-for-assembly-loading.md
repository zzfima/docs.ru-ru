---
title: Рекомендации для загрузки сборок
ms.date: 03/30/2017
helpviewer_keywords:
- assemblies,binding
- LoadFrom method
- default load context
- TypeLoadException class,causes
- assembly loading errors
- load contexts
- assemblies,loading
- LoadWithPartialName method
- load-from context
ms.assetid: 68d1c539-6a47-4614-ab59-4b071c9d4b4c
ms.openlocfilehash: d1b6c2cd9f96a4acf48cbced48a86bc3e3409562
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2020
ms.locfileid: "75716578"
---
# <a name="best-practices-for-assembly-loading"></a>Рекомендации для загрузки сборок
В этой статье рассматриваются способы избежания проблем с идентификацией типов, способных привести к исключениям <xref:System.InvalidCastException>, <xref:System.MissingMethodException> и другим ошибкам. В статье рассматриваются следующие рекомендации:  
  
- [Понимание преимуществ и недостатков контекстов загрузки.](#load_contexts)  
  
- [Избежание привязки к частичным именам сборок.](#avoid_partial_names)  
  
- [Избежание загрузки сборок в нескольких контекстах.](#avoid_loading_into_multiple_contexts)  
  
- [Избежание загрузки нескольких версий сборки в том же контексте.](#avoid_loading_multiple_versions)  
  
- [Рассмотрение возможности перехода к использованию контекста загрузки по умолчанию.](#switch_to_default)  
  
 Первая рекомендация, касающаяся [преимуществ и недостатков контекстов загрузки](#load_contexts), предоставляет базовые сведения для всех прочих рекомендаций, так как все они полагаются на понимание сути контекстов загрузки.  
  
<a name="load_contexts"></a>   
## <a name="understand-the-advantages-and-disadvantages-of-load-contexts"></a>Понимание преимуществ и недостатков контекстов загрузки  
 В рамках домена приложения сборки могут загружаться в одном из трех контекстов либо могут быть загружены без контекста:  
  
- Контекст загрузки по умолчанию содержит сборки, обнаруженные в результате поиска в глобальном кэше сборок, в хранилище сборок главного узла, если среда выполнения является размещенной (например, в SQL Server), либо в свойствах <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A> домена приложения. В большинстве перегруженных версий метода <xref:System.Reflection.Assembly.Load%2A> сборки загружаются именно в этот контекст.  
  
- Контекст, из которого ведется загрузка, содержит сборки из расположений, в которых загрузчик не ведет поиск. Например, надстройки могут устанавливаться в каталоге, не относящемся к пути приложения. К примерам методов, которые выполняют загрузку по указанному пути, относятся методы <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>, <xref:System.AppDomain.CreateInstanceFrom%2A?displayProperty=nameWithType> и <xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=nameWithType>.  
  
- Контекст только для отражения содержит сборки, загружаемые с помощью методов <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> и <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>. Код, загруженный в этом контексте, не может быть выполнен, поэтому далее он не рассматривается. Дополнительные сведения см. в разделе [Практическое руководство. Загрузка сборок в контекст, предназначенный только для отражения](../reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
- В случае создания временной динамической сборки с помощью эмиссии отражения сборка не попадет ни в один контекст. Кроме того, большинство сборок, загружаемых с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>, загружаются без контекста, а сборки, загружаемые из байтовых массивов, также загружаются без контекста, если только их идентификаторы (после применения политики) не указывают на то, что они расположены в глобальном кэше сборок.  
  
 Контексты выполнения имеют преимущества и недостатки, описанные в следующих разделах.  
  
### <a name="default-load-context"></a>Контекст загрузки по умолчанию  
 При загрузке сборок в контексте загрузки по умолчанию также автоматически загружаются сборки, от которых они зависят. Загружаемые таким образом в контексте загрузки по умолчанию сборки автоматически обнаруживаются для сборок в контексте загрузки по умолчанию или в контексте, из которого ведется загрузка. Загрузка сборок по идентификатору повышает стабильность приложений, позволяя гарантировать, что не будут использоваться неизвестные версии сборок (см. раздел [Избежание привязки к именам частичных сборок](#avoid_partial_names)).  
  
 Использование контекста загрузки по умолчанию имеет следующие недостатки:  
  
- Недоступны необходимые для других сборок сборки, загруженные в других контекстах.  
  
- В контексте загрузки по умолчанию нельзя загружать сборки из расположений, не относящихся к пути поиска сборок.  
  
### <a name="load-from-context"></a>Контекст, из которого ведется загрузка  
 Контекст, из которого ведется загрузка, позволяет загрузить сборку, путь которой не относится к пути приложения и, соответственно, не включается в область поиска. Это позволяет находить и загружать требуемые сборки, расположенные по этому пути, так как сведения о пути хранятся в контексте. Кроме того, сборки в этом контексте могут использовать необходимые сборки, загруженные в контекст загрузки по умолчанию.  
  
 Загрузка сборок с помощью метода <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> или другого метода, использующего для загрузки путь, имеет следующие недостатки:  
  
- Если сборка с тем же идентификатором уже загружена, метод <xref:System.Reflection.Assembly.LoadFrom%2A> возвращает загруженную сборку даже в том случае, если был задан другой путь.  
  
- Если сборка загружается с использованием метода <xref:System.Reflection.Assembly.LoadFrom%2A>, после чего сборка в контексте загрузки по умолчанию предпринимает попытку загрузить ту же сборку по отображаемому имени, попытка загрузки завершится неудачей. Это может произойти при десериализации сборки.  
  
- Если сборка загружена с использованием метода <xref:System.Reflection.Assembly.LoadFrom%2A>, но путь поиска сборок включает сборку с тем же идентификатором, находящуюся в другом расположении, то может возникнуть исключение <xref:System.InvalidCastException>, <xref:System.MissingMethodException> или другое непредусмотренное поведение.  
  
- Метод <xref:System.Reflection.Assembly.LoadFrom%2A> требует наличия флагов <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> или <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> либо наличия объекта <xref:System.Net.WebPermission> для заданного пути.  
  
- Если для сборки существует машинный образ, то он не используется.  
  
- Сборка не может быть загружена как доменно-нейтральная.  
  
- На платформе .NET Framework версий 1.0 и 1.1 политика не применяется.  
  
### <a name="no-context"></a>Загрузка без контекста  
 Загрузка без контекста — это единственный доступный вариант для временных сборок, порождаемых с помощью эмиссии отражения. Загрузка без контекста — это единственная возможность загрузки нескольких сборок с одним и тем же идентификатором в одном домене приложения. Затраты, связанные с поиском сборок, в этом случае устраняются.  
  
 Сборки, загружаемые из байтовых массивов, загружаются без контекста, если только идентификатор сборки, определяемый после применения политики, не совпадет с идентификатором сборки из глобального кэша сборок; в этом случае сборка загружается из глобального кэша сборок.  
  
 Загрузка сборок без контекста имеет следующие недостатки:  
  
- Другие сборки не могут привязываться к сборкам, загруженным без контекста, если только приложение не обрабатывает событие <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.  
  
- Зависимости не загружаются автоматически. Их можно предварительно загрузить без контекста, загрузить в контексте загрузки по умолчанию или загрузить их в обработчике событий <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>.  
  
- Загрузка нескольких сборок с одним и тем же идентификатором без контекста может привести к проблемам с идентификацией типов, аналогичным тем, что возникают при загрузке сборок с одним и тем же идентификатором в нескольких контекстах. См. раздел [Избежание загрузки сборок в нескольких контекстах](#avoid_loading_into_multiple_contexts).  
  
- Если для сборки существует машинный образ, то он не используется.  
  
- Сборка не может быть загружена как доменно-нейтральная.  
  
- На платформе .NET Framework версий 1.0 и 1.1 политика не применяется.  
  
<a name="avoid_partial_names"></a>   
## <a name="avoid-binding-on-partial-assembly-names"></a>Избежание привязки к частичным именам сборок  
 Частичная привязка имен происходит при указании лишь одной из частей отображаемого имени сборки (<xref:System.Reflection.Assembly.FullName%2A>) при ее загрузке. Например, метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> можно вызвать с простым именем сборки, не указывая ее версию, язык и региональные параметры, а также маркер открытого ключа. Также можно вызвать метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>, который сначала вызывает метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, а затем, если ему не удалось найти сборку, проводит поиск по глобальному кэшу сборок и загружает последнюю версию сборки из доступных.  
  
 Частичная привязка имен может вызывать самые разнообразные проблемы, включая следующие:  
  
- Метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> может загрузить другую сборку с тем же простым именем. Например, два приложения могут установить в глобальном кэше сборок две разные сборки с простым именем `GraphicsLibrary`.  
  
- Фактически загружаемая сборка может быть несовместимой с предыдущими версиями. Например, не указав версию, можно загрузить более позднюю версию сборки, на использование которой программа не рассчитана. Изменения в более поздних версиях сборки могут вызывать ошибки приложения.  
  
- Фактически загружаемая сборка может быть несовместима с последующими версиями. Например, приложение могло строиться и тестироваться с последней версией сборки, но при частичной привязке могла загрузиться существенно более ранняя ее версия, не поддерживающая функции, которые использует приложение.  
  
- Установка новых приложений может нарушать работу уже имеющихся приложений. Работа приложения, использующего метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A>, может быть нарушена в результате установки новой несовместимой версии совместно используемой сборки.  
  
- При загрузке необходимых сборок может возникать непредвиденное поведение. Загрузка двух сборок, совместно зависящих от одной сборки, с использованием частичной привязки имен может привести к тому, что одна из сборок будет использовать компонент, с которым она не строилась и не тестировалась.  
  
 Ввиду потенциальных проблем метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A> был помечен как устаревший. Вместо него рекомендуется использовать метод <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, указывая полные отображаемые имена сборок. См. разделы [Понимание преимуществ и недостатков контекстов загрузки](#load_contexts) и [Рассмотрение возможности перехода в контекст загрузки по умолчанию](#switch_to_default).  
  
 Если вы хотите использовать метод <xref:System.Reflection.Assembly.LoadWithPartialName%2A>, потому что он упрощает загрузку сборок, учтите, что сбой приложения с сообщением, содержащим полный идентификатор необходимой сборки, — это лучше для пользователя, чем автоматическое использование неизвестной версии сборки, способной вызвать непредвиденное поведение и бреши в системе безопасности.  
  
<a name="avoid_loading_into_multiple_contexts"></a>   
## <a name="avoid-loading-an-assembly-into-multiple-contexts"></a>Избежание загрузки сборок в нескольких контекстах  
 Загрузка сборок в нескольких контекстах может вызывать проблемы с идентификацией типов. Загрузка одного и того же типа из одной и той же сборки в двух разных контекстах аналогична загрузке двух разных типов с одним и тем же именем. При попытке приведения из одного такого типа в другой возникнет исключение <xref:System.InvalidCastException>, а в сообщении об ошибке при этом будет несколько туманно сказано, что тип `MyType` нельзя привести к типу `MyType`.  
  
 Например, предположим, что в сборке `ICommunicate` объявлен интерфейс `Utility`, который используется в программе и в других сборках, загружаемых программой. Эти другие сборки содержат типы, реализующие интерфейс `ICommunicate`, позволяя программе их использовать.  
  
 Теперь подумаем о том, что произойдет при запуске программы. Сборки, на которые ссылается программа, будут загружены в контексте загрузки по умолчанию. Если загрузить целевую сборку по идентификатору с помощью метода <xref:System.Reflection.Assembly.Load%2A>, то она попадет в контекст загрузки по умолчанию вместе со сборками, от которых она зависит. Как программа, так и целевая сборка будут использовать сборку `Utility`.  
  
 Предположим теперь, что целевая сборка загружается по файловому пути с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>. В этом случае сборка загружается без контекста, поэтому необходимые для нее сборки не будут загружены автоматически. Можно создать обработчик событий <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>, разрешающий подобные зависимости; он может загрузить сборку `Utility` без контекста с помощью метода <xref:System.Reflection.Assembly.LoadFile%2A>. В этом случае при создании экземпляра типа, содержащегося в целевой сборке, и попытке его присвоения переменной типа `ICommunicate` будет порождено исключение <xref:System.InvalidCastException>, так как среда выполнения рассматривает интерфейсы `ICommunicate` в двух копиях сборки `Utility` как разные типы.  
  
 Существует множество других сценариев, в которых сборка может загружаться в нескольких контекстах. Оптимальный подход состоит в устранении потенциальных конфликтов путем перемещения целевой сборки в путь приложения и использования метода <xref:System.Reflection.Assembly.Load%2A> с полным отображаемым именем. При этом сборка будет загружаться в контексте загрузки по умолчанию, и обе сборки будут использовать одну и ту же копию сборки `Utility`.  
  
 Если целевая сборка должна находиться вне пути приложения, то можно использовать метод <xref:System.Reflection.Assembly.LoadFrom%2A> для ее загрузки в контексте, из которого ведется загрузка. Если целевая сборка компилировалась со ссылкой на сборку `Utility` приложения, то она будет использовать сборку `Utility`, которую приложение загрузило в контексте загрузки по умолчанию. Обратите внимание, что в случае, если целевая сборка зависит от копии сборки `Utility`, расположенной вне пути приложения, могут возникнуть проблемы. Если эта сборка загружается в контекст, из которого ведется загрузка, перед тем, как приложение загрузит сборку `Utility`, загрузка приложения завершится ошибкой.  
  
 В разделе [Рассмотрение возможности перехода к использованию контекста загрузки по умолчанию](#switch_to_default) описаны альтернативы использованию загрузки по файловому пути, например <xref:System.Reflection.Assembly.LoadFile%2A> и <xref:System.Reflection.Assembly.LoadFrom%2A>.  
  
<a name="avoid_loading_multiple_versions"></a>   
## <a name="avoid-loading-multiple-versions-of-an-assembly-into-the-same-context"></a>Избежание загрузки нескольких версий сборки в том же контексте  
 Загрузка нескольких версий сборки в одном контексте загрузки может вызвать проблемы с идентификацией типов. Загрузка одного и того же типа из двух версий одной и той же сборки аналогична загрузке двух разных типов с одним и тем же именем. При попытке приведения из одного такого типа в другой возникнет исключение <xref:System.InvalidCastException>, а в сообщении об ошибке при этом будет несколько туманно сказано, что тип `MyType` нельзя привести к типу `MyType`.  
  
 Предположим, программа загружает одну версию сборки `Utility` напрямую, а потом загружает другую версию сборки `Utility`. Приложение также может загрузить две разные версии сборки, если в коде приложения имеется ошибка.  
  
 В контексте загрузки по умолчанию эта проблема может возникать при использовании метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> с указанием полных отображаемых имен сборок, включающих разные версии. В случае загрузки сборок вне контекста проблема может возникать, если метод <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> используется для загрузки одной и той же сборки по нескольким путям. Среда выполнения считает две сборки, загруженные из разных путей, разными, даже если они имеют одинаковые идентификаторы.  
  
 Помимо проблем с идентификацией типов, наличие нескольких версий сборки может привести к исключению <xref:System.MissingMethodException>, если тип, загруженный из одной версии сборки, передается в код, ожидающий тип из другой версии сборки. Например, код может рассчитывать на метод, добавленный в более поздней версии.  
  
 Если поведение типа меняется от версии к версии, также могут возникать менее заметные ошибки. К примеру, метод может породить непредвиденное исключение или вернуть непредвиденное значение.  
  
 Тщательно проанализируйте свой код и убедитесь, что загружается только одна версия сборки. В любой момент времени можно использовать метод <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> для определения фактически загруженных сборок.  
  
<a name="switch_to_default"></a>   
## <a name="consider-switching-to-the-default-load-context"></a>Возможность перехода к использованию контекста загрузки по умолчанию  
 Рассмотрите способы загрузки и развертывания сборок в вашем приложении. Можно ли устранить сборки, загружаемые из байтовых массивов? Можно ли перенести сборки в путь поиска сборок? Если сборки загружаются из глобального кэша сборок или пути поиска сборок домена приложения (то есть <xref:System.AppDomainSetup.ApplicationBase%2A> и <xref:System.AppDomainSetup.PrivateBinPath%2A>), то сборку можно загрузить по идентификатору.  
  
 Если перенести все сборки в путь поиска сборок невозможно, рассмотрите альтернативы: использование модели надстроек платформы .NET Framework, размещение сборок в глобальном кэше сборок или создание доменов приложения.  
  
### <a name="consider-using-the-net-framework-add-in-model"></a>Использование модели надстроек платформы .NET Framework  
 При использовании контекста, из которого ведется загрузка, для реализации надстроек, которые обычно устанавливаются вне базовой папки приложения, используйте модель надстроек платформы .NET Framework. Она обеспечивает изоляцию на уровне доменов приложений и процессов, не требуя самостоятельно управлять доменами приложений. Сведения о модели надстроек см. в разделе [Надстройки и расширения среды](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb384200(v%3dvs.100)).  
  
### <a name="consider-using-the-global-assembly-cache"></a>Использование глобального кэша сборок  
 Разместив сборки в глобальном кэше сборок, можно использовать общий путь для сборок, находящихся вне базовой папки приложения, не теряя преимуществ контекста загрузки по умолчанию и не сталкиваясь с недостатками других контекстов.  
  
### <a name="consider-using-application-domains"></a>Использование доменов приложений  
 Если выяснится, что некоторые сборки нельзя разместить в пути поиска сборок приложения, подумайте, нельзя ли создать для них отдельный домен приложения. Используйте тип <xref:System.AppDomainSetup> для создания нового домена приложения и укажите с помощью свойства <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> путь, по которому расположены сборки, которые требуется загрузить. При наличии нескольких таких каталогов можно задать в <xref:System.AppDomainSetup.ApplicationBase%2A> корневой каталог и использовать свойство <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> для указания подкаталогов, в которых нужно вести поиск. Также можно создать несколько доменов приложения и задать в свойстве <xref:System.AppDomainSetup.ApplicationBase%2A> каждого из них необходимый путь для соответствующих сборок.  
  
 Обратите внимание, что для загрузки таких сборок можно использовать метод <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>. Так как они теперь расположены в пути поиска, они будут загружены в контексте загрузки по умолчанию, а не в контексте, из которого ведется загрузка. Тем не менее рекомендуется перейти к использованию метода <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> и полных отображаемых имен сборок, чтобы гарантировать, что всегда используются только правильные их версии.  
  
## <a name="see-also"></a>См. также

- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType>
- <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>
