---
title: Вопросы безопасности при удаленном взаимодействии
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 7a56c9894da88382f40dcd475e89776a83a59322
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2020
ms.locfileid: "77215772"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="f85a3-102">Вопросы безопасности при удаленном взаимодействии</span><span class="sxs-lookup"><span data-stu-id="f85a3-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="f85a3-103">Удаленное взаимодействие позволяет установить прозрачные вызовы между доменами приложений, процессами или компьютерами.</span><span class="sxs-lookup"><span data-stu-id="f85a3-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="f85a3-104">Однако обход стека управления доступом для кода не может выходить за границы процесса или компьютера (применяется между доменами приложения того же процесса).</span><span class="sxs-lookup"><span data-stu-id="f85a3-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="f85a3-105">Любой класс, поддерживающий удаленное взаимодействие (производный от класса <xref:System.MarshalByRefObject>), должен отвечать за обеспечение безопасности.</span><span class="sxs-lookup"><span data-stu-id="f85a3-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="f85a3-106">Код должен использоваться только в закрытых средах, где вызывающий код имеет полное доверие, либо удаленные вызовы должны разрабатываться таким образом, чтобы они не подвергали защищенный код опасности при вводе внешних данных, которые могут быть использованы злоумышленниками.</span><span class="sxs-lookup"><span data-stu-id="f85a3-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="f85a3-107">Как правило, никогда не следует предоставлять методы, свойства или события, защищенные декларативными [LinkDemand](link-demands.md) и <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> проверками безопасности.</span><span class="sxs-lookup"><span data-stu-id="f85a3-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="f85a3-108">При удаленном взаимодействии эти проверки не применяются в обязательном порядке.</span><span class="sxs-lookup"><span data-stu-id="f85a3-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="f85a3-109">Другие проверки безопасности, такие как <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md)и т. д., работают между доменами приложений внутри процесса, но не работают в сценариях между процессами или между компьютерами.</span><span class="sxs-lookup"><span data-stu-id="f85a3-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="f85a3-110">Защищенные объекты</span><span class="sxs-lookup"><span data-stu-id="f85a3-110">Protected objects</span></span>  
 <span data-ttu-id="f85a3-111">Некоторые объекты сохраняют в себе состояние безопасности.</span><span class="sxs-lookup"><span data-stu-id="f85a3-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="f85a3-112">Эти объекты не должны передаваться в ненадежный код, который при этом смог бы получить авторизацию, выходящую за рамки собственных разрешений.</span><span class="sxs-lookup"><span data-stu-id="f85a3-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="f85a3-113">Примером является создание объекта <xref:System.IO.FileStream>.</span><span class="sxs-lookup"><span data-stu-id="f85a3-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="f85a3-114">Во время создания запрашивается <xref:System.Security.Permissions.FileIOPermission>, и, если он завершается успешно, то возвращается файловый объект.</span><span class="sxs-lookup"><span data-stu-id="f85a3-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="f85a3-115">Тем не менее, если ссылка на этот объект передается в коде без разрешения для файлов, то объект будет иметь возможность чтения и записи в этот конкретный файл.</span><span class="sxs-lookup"><span data-stu-id="f85a3-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="f85a3-116">Простейшая защита такого объекта заключается в необходимости получения такого же **FileIOPermission** для любого кода, который ищет ссылку на объект через открытый интерфейс API.</span><span class="sxs-lookup"><span data-stu-id="f85a3-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="f85a3-117">Проблемы пересечения доменов приложений</span><span class="sxs-lookup"><span data-stu-id="f85a3-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="f85a3-118">Для изоляции кода в управляемых средах размещения обычно создают несколько дочерних доменов приложения с явно определенной политикой, ограничивающей уровни разрешений для различных сборок.</span><span class="sxs-lookup"><span data-stu-id="f85a3-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="f85a3-119">Однако в домене приложения по умолчанию политика для этих сборок остается неизменной.</span><span class="sxs-lookup"><span data-stu-id="f85a3-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="f85a3-120">Если один из дочерних доменов приложения может заставить домен приложения по умолчанию загрузить сборку, то эффект от изоляции кода теряется и типы в принудительно загруженной сборке смогут запустить код с высоким уровнем доверия.</span><span class="sxs-lookup"><span data-stu-id="f85a3-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="f85a3-121">Домен приложения может заставить другой домен приложения загрузить сборку и выполнить код, содержащийся в ней вызовом прокси-объекта, находящегося в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="f85a3-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="f85a3-122">Чтобы получить прокси-объект между доменами приложений, домен приложения, содержащий объект, должен передать ему параметр метода вызова или возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="f85a3-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="f85a3-123">Либо, если домен приложения был только что создан, его создатель получает прокси-объект для объекта <xref:System.AppDomain> по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f85a3-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="f85a3-124">Таким образом, чтобы избежать нарушения изоляции кода, домен приложения с высоким уровнем доверия не должен передавать ссылки на маршалируемые по ссылке объекты (экземпляры классов, производные от <xref:System.MarshalByRefObject>) в своем домене для доменов приложений с более низкими уровнями доверия.</span><span class="sxs-lookup"><span data-stu-id="f85a3-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="f85a3-125">Как правило, домен приложения по умолчанию создает дочерние домены приложения с управляющим объектом в каждом из них.</span><span class="sxs-lookup"><span data-stu-id="f85a3-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="f85a3-126">Объект управления управляет новым доменом приложения и иногда принимает указания от домена приложения по умолчанию, но он не может взаимодействовать с доменом напрямую.</span><span class="sxs-lookup"><span data-stu-id="f85a3-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="f85a3-127">В некоторых случаях домен приложения по умолчанию обращается через свой прокси-объект к объекту управления.</span><span class="sxs-lookup"><span data-stu-id="f85a3-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="f85a3-128">Однако могут быть случаи, когда домену приложения по умолчанию необходимо осуществить обратный вызов объекта управления.</span><span class="sxs-lookup"><span data-stu-id="f85a3-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="f85a3-129">В этих случаях домен приложения по умолчанию передает объект обратного вызова, маршалируемый по ссылке, конструктору объекта элемента управления.</span><span class="sxs-lookup"><span data-stu-id="f85a3-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="f85a3-130">Он отвечает за защиту прокси-объекта управления.</span><span class="sxs-lookup"><span data-stu-id="f85a3-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="f85a3-131">Если объект управления разместит прокси-объект в поле public static общего класса или иным способом предоставит прокси-объект, то внешнему коду будет открыт небезопасный механизм для выполнения обратного вызова домена приложения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f85a3-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="f85a3-132">По этой причине объекты управления всегда должны оставлять прокси-объекты частными.</span><span class="sxs-lookup"><span data-stu-id="f85a3-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f85a3-133">См. также:</span><span class="sxs-lookup"><span data-stu-id="f85a3-133">See also</span></span>

- [<span data-ttu-id="f85a3-134">Правила написания безопасного кода</span><span class="sxs-lookup"><span data-stu-id="f85a3-134">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
