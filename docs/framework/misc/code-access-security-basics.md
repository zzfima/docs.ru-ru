---
title: Основы управления доступом для кода
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- security [.NET Framework], code access security
ms.assetid: 4eaa6535-d9fe-41a1-91d8-b437cfc16921
ms.openlocfilehash: 08d708e8f98bd2fe06757df3033a512e2fe1f3c2
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2020
ms.locfileid: "77215910"
---
# <a name="code-access-security-basics"></a>Основы управления доступом для кода

[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]

Каждое приложение, ориентированное на среду CLR (то есть каждое управляемое приложение), должно взаимодействовать с ее системой безопасности. Когда управляемое приложение загружается, его узел автоматически предоставляет ему набор разрешений. Эти разрешения определяются параметрами локальной безопасности узла или изоляцией приложения. В зависимости от этих разрешений приложение либо запускается, либо вызывает исключение безопасности.

Узел по умолчанию для классических приложений позволяет коду выполняться в режиме полного доверия. По этой причине, если приложение предназначено для настольных компьютеров, оно имеет неограниченный набор разрешений. Другие узлы или "песочницы" предоставляют ограниченный набор разрешений для приложений. Набор разрешений может меняться от узла к узлу, поэтому приложение должно быть разработано для использования только тех разрешений, которые допускаются целевым узлом.

Чтобы писать эффективные приложения, нацеленные на среду CLR, нужно быть знакомым с приведенными ниже принципами управления доступом для кода.

- Строго **типизированный код**: строго типизированный код — это код, который обращается к типам только в строго определенных, допустимых способах. Например, имея действительную ссылку на объект, типобезопасный код может осуществлять доступ к памяти по фиксированным смещениям, соответствующим реальным членам-полям. Если код производит доступ к памяти по произвольным смещениям за пределами диапазона памяти, принадлежащего открытым полям этого объекта, он не является типобезопасным. Чтобы иметь возможность пользоваться преимуществами управления доступом для кода, необходимо использовать компилятор, создающий проверяемый типобезопасный код. Дополнительные сведения см. в подразделе [Создание проверяемого](#typesafe_code) строго типизированного кода далее в этом разделе.

- **Императивный и декларативный синтаксис**. код, предназначенный для среды CLR, может взаимодействовать с системой безопасности, запрашивая разрешения, требуя, что вызывающие объекты имеют определенные разрешения, и переопределяя определенные параметры безопасности (учитывая достаточные привилегии). Можно использовать две различные формы синтаксиса для программного взаимодействия с системой безопасности .NET Framework: декларативный синтаксис и принудительный синтаксис. Декларативные вызовы выполняются с использованием атрибутов; принудительные вызовы выполняются с использованием новых экземпляров классов в вашем коде. Некоторые вызовы могут выполняться только принудительно, другие — только декларативно, а некоторые — любым способом.

- **Безопасные библиотеки классов**. Защищенная библиотека классов использует требования безопасности, чтобы убедиться, что вызывающие объекты библиотеки имеют разрешение на доступ к ресурсам, предоставляемым библиотекой. Например, безопасная библиотека классов может содержать метод для создания файлов, который будет требовать, чтобы вызывающие его объекты обладали разрешениями на создание файлов. Платформа .NET Framework включает в себя безопасные библиотеки классов. Вам необходимо учитывать разрешения, требуемые для доступа к любой библиотеке, используемой кодом. Дополнительные сведения см. в подразделе [Использование безопасных библиотек классов](#secure_library) далее в этом разделе.

- **Прозрачный код**. начиная с .NET Framework 4, помимо определения конкретных разрешений, необходимо также определить, должен ли код выполняться как прозрачный для безопасности. Прозрачный с точки зрения безопасности код не может вызывать типы или члены, которые определены как критические с точки зрения безопасности. Это правило относится к приложениям как с полным, так и с частичным доверием. Дополнительные сведения см. в разделе [прозрачный для системы безопасности код](security-transparent-code.md).

<a name="typesafe_code"></a>

## <a name="writing-verifiably-type-safe-code"></a>Написание проверяемого типобезопасного кода

JIT-компиляция выполняет процесс проверки, который анализирует код и пытается определить, является ли он типобезопасным. Код, проверенный во время проверки на строго типизированный, называется *проверяемым строго типизированным кодом*. Код может быть типобезопасным, но не проверяемым типобезопасным из-за ограничений процесса проверки его компилятором. Не все языки являются типобезопасными, и компиляторы некоторых языков, таких как Microsoft Visual C++, не могут создавать проверяемый типобезопасный код. Чтобы определить, создает ли компилятор языка, который вы используете, проверяемый типобезопасный код, нужно свериться с документацией по компилятору. Если вы используете компилятор языка, создающий проверяемый строго типизированный код только в том случае, если не используются определенные языковые конструкции, может потребоваться использовать [средство Peverify](../tools/peverify-exe-peverify-tool.md) , чтобы определить, является ли код проверяемым строго типизированным.

Код, не являющийся проверяемым типобезопасным, может осуществить попытку выполнения, если политика безопасности позволяет коду обойти проверку. Однако, так как строгая типизация является неотъемлемой частью механизма среды выполнения для изоляции сборок, безопасность не может уверенно соблюдаться, если код нарушает правила типобезопасности. По умолчанию код, не являющийся типобезопасным, допускается к выполнению, только если его источником является локальный компьютер. Поэтому мобильный код должен быть типобезопасным.

<a name="secure_library"></a>

## <a name="using-secure-class-libraries"></a>Использование безопасных библиотек классов

Если код запрашивает и получает разрешения, требуемые библиотекой классов, ему будет разрешен доступ к библиотеке и ресурс будет защищен от несанкционированного доступа. Если же код не будет обладать соответствующими разрешениями, он не сможет получить доступ к библиотеке и вредоносный код не сможет воспользоваться вашим кодом для непрямого доступа к защищенным ресурсам. Даже если ваш код получит разрешение на доступ к библиотеке, его запуск не будет разрешен, если код, вызвавший его, также не обладает разрешением на доступ к этой библиотеке.

Управление доступом для кода не исключает вероятности человеческой ошибки при написании кода. Но если приложение использует безопасные библиотеки классов для доступа к защищенным ресурсам, риск для безопасности кода приложения снижается, так как библиотеки классов тщательно изучаются на предмет потенциальных проблем безопасности.

## <a name="declarative-security"></a>Декларативная безопасность

Декларативный синтаксис безопасности использует [атрибуты](../../standard/attributes/index.md) для помещения сведений о безопасности в [метаданные](../../standard/metadata-and-self-describing-components.md) кода. Атрибуты могут быть указаны на уровне сборки, класса или члена для указания типа запроса, требования или переопределения, которые необходимо использовать. Запросы используются в приложениях, нацеленных на среду CLR, для информирования системы безопасности среды выполнения о разрешениях, которые нужны или не нужны вашему приложению. Требования и переопределения используются в библиотеках для защиты ресурсов от вызывающих объектов или переопределения поведения системы безопасности по умолчанию.

> [!NOTE]
> В .NET Framework 4 были внесены важные изменения в модель и терминологию безопасности .NET Framework. Дополнительные сведения об этих изменениях см. в разделе [изменения в системе безопасности](../security/security-changes.md).

Чтобы использовать декларативные вызовы безопасности, необходимо инициализировать данные состояния объекта разрешения таким образом, чтобы они представляли определенную форму необходимого разрешения. Каждое встроенное разрешение имеет атрибут, которому передается перечисление <xref:System.Security.Permissions.SecurityAction> для описания типа операции безопасности, которую нужно выполнить. Однако разрешения также принимают собственные параметры, являющиеся для них исключительными.

В приведенном ниже фрагменте кода показано использование декларативного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`. Это гипотетическое разрешение, которого не существует в .NET Framework. В этом примере декларативный вызов помещен непосредственно перед определением класса, указывая, что разрешение применяется на уровне класса. Атрибуту передается структура **SecurityAction. Demand** для указания того, что вызывающие объекты должны иметь это разрешение для выполнения.

```vb
<MyPermission(SecurityAction.Demand, Unrestricted = True)> Public Class MyClass1

   Public Sub New()
      'The constructor is protected by the security call.
   End Sub

   Public Sub MyMethod()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'This method is protected by the security call.
   End Sub
End Class
```

```csharp
[MyPermission(SecurityAction.Demand, Unrestricted = true)]
public class MyClass
{
   public MyClass()
   {
      //The constructor is protected by the security call.
   }

   public void MyMethod()
   {
      //This method is protected by the security call.
   }

   public void YourMethod()
   {
      //This method is protected by the security call.
   }
}
```

## <a name="imperative-security"></a>Принудительная безопасность

Принудительный синтаксис безопасности производит вызов безопасности, создавая экземпляр объекта разрешения, который нужно вызвать. Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов.

Прежде чем осуществить вызов безопасности, необходимо инициализировать данные состояния объекта разрешения, чтобы они представляли определенную форму необходимого разрешения. Например, при создании объекта <xref:System.Security.Permissions.FileIOPermission> можно использовать конструктор для инициализации объекта **FileIOPermission** таким образом, чтобы он обозначает либо неограниченный доступ ко всем файлам, либо не имеет доступа к файлам. Также можно использовать другой объект **FileIOPermission** , передающий параметры, указывающие тип доступа, который должен быть представлен объектом (т. е. чтение, добавление или запись), а также файлы, которые должен защищать объект.

Помимо вызова отдельного объекта безопасности, принудительный синтаксис безопасности можно использовать для инициализации группы разрешений, называемой набором разрешений. Например, этот способ является единственным способом надежного выполнения запросов [Assert](using-the-assert-method.md) для нескольких разрешений в одном методе. Используйте классы <xref:System.Security.PermissionSet> и <xref:System.Security.NamedPermissionSet> для создания группы разрешений, после чего вызовите соответствующий метод для выполнения желаемого вызова безопасности.

Принудительный синтаксис можно использовать для выполнения требований и переопределений, но не запросов. Вы можете использовать принудительный синтаксис для требований и переопределений вместо декларативного синтаксиса, когда информация, необходимая для инициализации состояния разрешения, становится известна только во время выполнения. Например, если нужно обеспечить наличие у вызывающих объектов разрешений на чтение определенного файла, но его имя неизвестно до запуска, используйте принудительное требование. Вы также можете выбрать использование принудительных проверок вместо декларативных, когда нужно во время выполнения определить, имеет ли место некоторое условие, и на основании результата проверки предъявить (или же не предъявлять) требование безопасности.

В приведенном ниже фрагменте кода показано использование принудительного синтаксиса для запроса наличия у вызывающих объектов кода пользовательского разрешения `MyPermission`. Это гипотетическое разрешение, которого не существует в .NET Framework. Экземпляр `MyPermission` создается в методе `MyMethod`, защищая вызовом безопасности только этот метод.

```vb
Public Class MyClass1

   Public Sub New()

   End Sub

   Public Sub MyMethod()
      'MyPermission is demanded using imperative syntax.
      Dim Perm As New MyPermission()
      Perm.Demand()
      'This method is protected by the security call.
   End Sub

   Public Sub YourMethod()
      'YourMethod 'This method is not protected by the security call.
   End Sub
End Class
```

```csharp
public class MyClass {
   public MyClass(){

   }

   public void MyMethod() {
       //MyPermission is demanded using imperative syntax.
       MyPermission Perm = new MyPermission();
       Perm.Demand();
       //This method is protected by the security call.
   }

   public void YourMethod() {
       //This method is not protected by the security call.
   }
}
```

## <a name="using-managed-wrapper-classes"></a>Использование управляемых классов-оболочек

Большинство приложений и компонентов (кроме безопасных библиотек) не должны напрямую вызывать неуправляемый код. Для этого есть несколько причин. Если код вызывает неуправляемый код напрямую, во многих ситуациях ему не будет разрешено выполняться, потому что он должен обладать высоким уровнем доверия, чтобы вызывать машинный код. Если политика будет изменена с целью разрешить запуск подобного приложения, это может заметно ослабить безопасность системы, так как приложение сможет выполнять практически любые операции.

Кроме того, код, имеющий разрешение на доступ к неуправляемому коду, может выполнить почти любую операцию, вызвав неуправляемый интерфейс API. Например, код, имеющий разрешение на вызов неуправляемого кода, не требует <xref:System.Security.Permissions.FileIOPermission> для доступа к файлу; Он может просто вызвать неуправляемый API файлов (Win32) напрямую, обходя управляемый файл API, требующий **FileIOPermission**. Если управляемый код имеет разрешение на вызов неуправляемого кода и производит его прямой вызов, система безопасности не может уверенно обеспечивать ограничения безопасности, так как среда выполнения не может применять эти ограничения к неуправляемому коду.

Если необходимо, чтобы приложение выполняло операции, требующие доступа к неуправляемому коду, оно должно делать это через доверенный управляемый класс, предоставляющий оболочку для требуемой функциональности (если такой класс существует). Не создавайте класс-оболочку самостоятельно, если он уже имеется в безопасной библиотеке классов. Класс-оболочка, которому нужно предоставить высокий уровень доверия, чтобы он мог вызывать неуправляемый код, отвечает за обеспечение наличия у вызывающих объектов соответствующих разрешений. Если вы используете класс-оболочку, коду необходимо запросить и получить только те разрешения, которые требуются этому классу.

## <a name="see-also"></a>См. также:

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.NamedPermissionSet>
- <xref:System.Security.Permissions.SecurityAction>
- [Assert](using-the-assert-method.md)
- [Управление доступом для кода](code-access-security.md)
- [Основы управления доступом для кода](code-access-security-basics.md)
- [Атрибуты](../../standard/attributes/index.md)
- [Метаданные и компоненты с самоописанием](../../standard/metadata-and-self-describing-components.md)
