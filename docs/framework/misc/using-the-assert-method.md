---
title: Использование метода Assert
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- granting permissions, overriding security checks
- code access security, overriding security checks
- overriding security checks
- security [.NET Framework], overriding security checks
- security [.NET Framework], assertions
- asserted permissions
- Assert method
- caller security checks
- permissions [.NET Framework], overriding security checks
- permissions [.NET Framework], assertions
ms.assetid: 1e40f4d3-fb7d-4f19-b334-b6076d469ea9
ms.openlocfilehash: 2bc46714a508990c5ae31b50e7d19a287da2c5c0
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2020
ms.locfileid: "77215822"
---
# <a name="using-the-assert-method"></a>Использование метода Assert
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 <xref:System.Security.CodeAccessPermission.Assert%2A> представляет собой метод, который может вызываться для классов разрешений доступа к коду и для класса <xref:System.Security.PermissionSet>. Можно использовать **Assert** , чтобы позволить коду (и нисходящим вызывающим объектам) выполнять действия, которые код имеет разрешение, но его вызывающие объекты могут не иметь разрешения на выполнение. Утверждение безопасности изменяет нормальный ход процесса, которому следует среда выполнения при проверке безопасности. Когда вы утверждаете разрешение, система безопасности не проверяет вызывающие объекты кода на наличие утвержденного разрешения.  
  
> [!CAUTION]
> Используйте утверждения осторожно, так как они могут открывать бреши в системе безопасности и подорвать работу механизма применения ограничений безопасности в среде выполнения.  
  
 Утверждения удобны в ситуациях, когда библиотека вызывает неуправляемый код или совершает вызов, требующий разрешение, связь которого с назначением библиотеки не очевидна. Например, весь управляемый код, который вызывает неуправляемый код, должен иметь **SecurityPermission** с указанным флагом **UnmanagedCode** . Код, источником которого не является локальный компьютер, например код, скачанный из локальной интрасети, не получает это разрешение по умолчанию. Таким образом, чтобы код, загруженный из локальной интрасети, мог вызывать библиотеку, использующую неуправляемый код, он должен иметь утвержденное библиотекой разрешение. Кроме того, некоторые библиотеки могут выполнять вызовы, которые не видны вызывающим объектам и требуют специальных разрешений.  
  
 Утверждения также можно использовать в ситуациях, когда код обращается к ресурсу способом, полностью скрытым от вызывающих объектов. Предположим, например, что ваша библиотека получает сведения из базы данных, но в процессе также считывает информацию из реестра компьютера. Поскольку разработчики, использующие вашу библиотеку, не имеют доступа к источнику, они не имеют возможности знать, что для использования кода требуется разрешение **RegistryPermission** . Если в такой ситуации вы решите, что неразумно или нерационально требовать наличия разрешения на доступ к реестру у вызывающих ваш код объектов, можно утвердить разрешение на чтение из реестра. В этом случае библиотека может утверждать разрешение, чтобы вызывающие объекты без **RegistryPermission** могли использовать библиотеку.  
  
 Утверждение влияет на обход стека только в том случае, если утвержденное разрешение и разрешение, затребованное подчиненным вызывающим объектом, имеют один и тот же тип, а запрошенное разрешение является подмножеством утвержденного разрешения. Например, если вы утверждаете **FileIOPermission** на чтение всех файлов на диске C и выполняется нисходящий запрос **FileIOPermission** на чтение файлов в C:\temp, утверждение может повлиять на проверку стека; Однако если для записи на диск C было установлено требование **FileIOPermission** , то утверждение не будет действовать.  
  
 Для выполнения утверждений коду должно быть назначено как разрешение, которое вы утверждаете, так и разрешение <xref:System.Security.Permissions.SecurityPermission>, представляющее право на выполнение утверждений. Хотя вы и можете утвердить разрешение, которое не было предоставлено коду, такое утверждение будет бессмысленным, так как проверка безопасности завершится со сбоем до того, как такое утверждение могло бы поспособствовать ее успешному завершению.  
  
 На следующем рисунке показано, что происходит при использовании **Assert**. Предположим, что справедливы следующие утверждения о сборках A, B, C, E и F, а также разрешениях P1 и P1A:  
  
- P1A предоставляет право чтения TXT-файлов на диске C.  
  
- P1 предоставляет право чтения всех файлов на диске C.  
  
- P1A и P1 являются типами **FileIOPermission** , а P1A — подмножеством P1.  
  
- Сборкам E и F назначено разрешение P1A.  
  
- Сборке C назначено разрешение P1.  
  
- Сборкам A и B не назначено ни разрешение P1, ни разрешение P1A.  
  
- Метод A содержится в сборке A, метод B содержится в сборке B и т. д.  
  
 ![Схема, на которой показаны сборки методов Assert.](./media/using-the-assert-method/assert-method-assemblies.gif)    
  
 В этом сценарии метод A вызывает B, B вызывает C, C вызывает E, а E вызывает F. метод C утверждает разрешение на чтение файлов на диске C (разрешение P1), а метод E требует разрешения на чтение TXT-файлов на диске C (разрешение P1A). Когда требование в F обнаруживается во время выполнения, выполняется проверка стека для проверки разрешений всех вызывающих объектов F, начиная с E. E было предоставлено разрешение P1A, поэтому проверка стека продолжает проверять разрешения в C, где обнаруживается утверждение C. Так как запрошенное разрешение (P1A) является подмножеством утвержденного разрешения (P1), обход стека останавливается, а проверка безопасности завершается успешно. То, что разрешение P1A не было назначено сборкам A и B, не имеет никакого значения. Утверждая P1, метод C позволяет вызывающим объектам обращаться к ресурсу, защищенному при помощи P1, даже если вызывающие объекты не имеют разрешения на доступ к этому ресурсу.  
  
 Если вы разрабатываете библиотеку классов и класс обращается к защищенному ресурсу, в большинстве случаев следует реализовать требование безопасности относительно наличия у вызывающих объектов этого класса соответствующего разрешения. Если класс выполняет операцию, для которой известно, что большинство вызывающих объектов не имеет разрешения, и если вы готовы принять ответственность за предоставление этим вызывающим объектам возможности вызова кода, можно утвердить разрешение, вызвав метод **Assert** для объекта разрешения, который представляет операцию, выполняемую в коде. Использование **Assert** таким образом позволяет вызывающим объектам, которые обычно не могли это сделать, вызывать ваш код. Таким образом, если вы утверждаете разрешение, следует обязательно заранее выполнить соответствующие проверки безопасности, чтобы предотвратить неправильное использование вашего компонента.  
  
 Например, предположим, что ваш в высшей степени доверенный класс библиотеки содержит метод, удаляющий файлы. Он обращается к файлу путем вызова неуправляемой функции Win32. Вызывающий объект вызывает метод **Delete** кода, передавая имя файла для удаления, к:\тест.ткст. В методе **Delete** код создает объект <xref:System.Security.Permissions.FileIOPermission>, представляющий доступ на запись к к:\тест.ткст. (Для удаления файла требуется доступ на запись.) Затем код вызывает императивную проверку безопасности, вызывая метод **Demand** объекта **FileIOPermission** . Если один из вызывающих объектов в стеке вызовов не имеет этого разрешения, возникает исключение <xref:System.Security.SecurityException>. Если исключение не выдается, вы можете быть уверены в том, что все вызывающие объекты имеют право доступа к C:\Test.txt. Так как вы считаете, что большинство вызывающих объектов не будут иметь разрешения на доступ к неуправляемому коду, код создает объект <xref:System.Security.Permissions.SecurityPermission>, который представляет право вызова неуправляемого кода и вызывает метод **Assert** объекта. Наконец он вызывает неуправляемую функцию Win32 для удаления файла C:\Text.txt и возвращает управление вызывающему объекту.  
  
> [!CAUTION]
> Необходимо убедиться, что код не использует утверждения в ситуациях, когда ваш код может использоваться другим кодом для доступа к ресурсу, защищенному утверждаемым вами разрешением. Например, в коде, который выполняет запись в файл, имя которого указывается вызывающим объектом в качестве параметра, вы не должны утверждать **FileIOPermission** для записи в файлы, так как ваш код будет открыт для неправильного использования сторонними производителями.  
  
 При использовании императивного синтаксиса безопасности вызов метода **Assert** для нескольких разрешений в одном методе приводит к возникновению исключения безопасности. Вместо этого следует создать объект **PermissionSet** , передать ему отдельные разрешения, которые требуется вызвать, а затем вызвать метод **Assert** для объекта **PermissionSet** . Метод **Assert** можно вызвать более одного раза при использовании декларативного синтаксиса безопасности.  
  
 В следующем примере показан декларативный синтаксис переопределения проверок безопасности с помощью метода **Assert** . Обратите внимание, что синтаксис **FileIOPermissionAttribute** принимает два значения: <xref:System.Security.Permissions.SecurityAction> перечисление и расположение файла или каталога, для которого должно быть предоставлено разрешение. Вызов **Assert** приводит к выполнению требований для доступа к `C:\Log.txt`, хотя вызывающие объекты не проверяются на разрешение доступа к файлу.  
  
```vb  
Option Explicit  
Option Strict  
  
Imports System  
Imports System.IO  
Imports System.Security.Permissions  
  
Namespace LogUtil  
   Public Class Log  
      Public Sub New()  
  
      End Sub  
  
     <FileIOPermission(SecurityAction.Assert, All := "C:\Log.txt")> Public Sub   
      MakeLog()  
         Dim TextStream As New StreamWriter("C:\Log.txt")  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now) '  
         TextStream.Close()  
      End Sub  
   End Class  
End Namespace  
```  
  
```csharp  
namespace LogUtil  
{  
   using System;  
   using System.IO;  
   using System.Security.Permissions;  
  
   public class Log  
   {  
      public Log()  
      {      
      }     
      [FileIOPermission(SecurityAction.Assert, All = @"C:\Log.txt")]  
      public void MakeLog()  
      {     
         StreamWriter TextStream = new StreamWriter(@"C:\Log.txt");  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now);  
         TextStream.Close();  
      }  
   }  
}   
```  
  
 В следующих фрагментах кода показан явный синтаксис переопределения проверок безопасности с помощью метода **Assert** . В этом примере объявляется экземпляр объекта **FileIOPermission** . Его конструктор передается **FileIOPermissionAccess. аллакцесс** для определения разрешенного типа доступа, за которым следует строка, описывающая расположение файла. После определения объекта **FileIOPermission** необходимо вызвать его метод **Assert** , чтобы переопределить проверку безопасности.  
  
```vb  
Option Explicit  
Option Strict  
Imports System  
Imports System.IO  
Imports System.Security.Permissions  
Namespace LogUtil  
   Public Class Log  
      Public Sub New()  
      End Sub 'New  
  
      Public Sub MakeLog()  
         Dim FilePermission As New FileIOPermission(FileIOPermissionAccess.AllAccess, "C:\Log.txt")  
         FilePermission.Assert()  
         Dim TextStream As New StreamWriter("C:\Log.txt")  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now)  
         TextStream.Close()  
      End Sub  
   End Class  
End Namespace  
```  
  
```csharp  
namespace LogUtil  
{  
   using System;  
   using System.IO;  
   using System.Security.Permissions;  
  
   public class Log  
   {  
      public Log()  
      {      
      }     
      public void MakeLog()  
      {  
         FileIOPermission FilePermission = new FileIOPermission(FileIOPermissionAccess.AllAccess,@"C:\Log.txt");   
         FilePermission.Assert();  
         StreamWriter TextStream = new StreamWriter(@"C:\Log.txt");  
         TextStream.WriteLine("This  Log was created on {0}", DateTime.Now);  
         TextStream.Close();  
      }  
   }  
}  
```  
  
## <a name="see-also"></a>См. также:

- <xref:System.Security.PermissionSet>
- <xref:System.Security.Permissions.SecurityPermission>
- <xref:System.Security.Permissions.FileIOPermission>
- <xref:System.Security.Permissions.SecurityAction>
- [Атрибуты](../../standard/attributes/index.md)
- [Управление доступом для кода](code-access-security.md)
