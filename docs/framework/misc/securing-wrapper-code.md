---
title: "Безопасность кода программы-оболочки"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
caps.latest.revision: "11"
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 5e29a2bdd0bfa338d0266c0841e11aa2ac366529
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="securing-wrapper-code"></a>Безопасность кода программы-оболочки
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 Код программы-оболочки, особенно когда она имеет более высокий уровень доверия, чем код, который ее использует, может открыть уникальный набор уязвимостей системы безопасности. Все, что делается от имени вызывающего объекта, когда его ограниченные разрешения не включаются в соответствующую проверку безопасности, является потенциальной уязвимостью и может быть использовано злоумышленником.  
  
 Никогда не позволяйте осуществлять с помощью программы-оболочки действия, которые вызывающий объект не может выполнить самостоятельно. Особую опасность представляют действия, подразумевающие ограниченную проверку безопасности, в отличие от требования полного обхода стека. При использовании одноуровневых проверок внедрение кода программы-оболочки между настоящим вызывающим объектом и элементом API может легко привести к успешному прохождению проверки безопасности, когда это не должно было произойти, что ослабляет защиту.  
  
## <a name="delegates"></a>Делегаты  
 Защита делегатов различается в разных версиях .NET Framework.  В этом разделе описывается различное поведение делегатов и соответствующие вопросы безопасности.  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a>В .NET Framework версий 1.0 и 1.1  
 В .NET Framework версий 1.0 и 1.1 с создателем делегата и вызывающим делегат объектом выполняются следующие действия по обеспечению безопасности.  
  
-   При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.  В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.  
  
-   При вызове делегата выполняются все существующие требования безопасности в вызывающем делегат объекте.  
  
 Каждый раз, когда код принимает <xref:System.Delegate> из менее доверенного кода, который может вызывать его, убедитесь, что менее доверенному коду не разрешено повышать уровень своих разрешений. Если делегат принимается, но используется позже, то код, создавший делегат, не находится в стеке вызовов, и его разрешения не будут проверяться, если код на уровне делегата или ниже попытается выполнить защищенную операцию. Если ваш код и код вызывающего объекта обладают более высокими привилегиями, чем создатель, то создатель может управлять путем вызова, не являясь частью стека вызовов.  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a>В версии 2.0 и более поздних версиях платформы .NET Framework  
 В отличие от предыдущих версий 2.0 и более поздних версиях платформы .NET Framework выполняет действие по обеспечению безопасности применяются к создателю делегата при создании и вызове делегата.  
  
-   При создании делегата требования связывания безопасности в целевом методе делегата выполняются по отношению к набору привилегий создателя делегата.  В результате сбоя при выполнении действия по обеспечению безопасности возникает исключение <xref:System.Security.SecurityException>.  
  
-   Набор прав создателя делегата также собирается при создании делегата и сохраняется с делегатом.  
  
-   При вызове делегата сохраненный набор прав создателя делегата сначала оценивается по отношению ко всем требованиям в текущем контексте, если создатель делегата и вызывающий делегат объект принадлежат разным сборкам.  Затем выполняются все существующие требования безопасности в вызывающем делегат объекте.  
  
## <a name="link-demands-and-wrappers"></a>Требования связывания и программы-оболочки  
 В инфраструктуре безопасности особая защита была усилена с помощью требований связывания, но она по-прежнему является источником уязвимости в коде.  
  
 Если полностью доверенный код вызывает свойство, событие или метод, защищенный с [LinkDemand](../../../docs/framework/misc/link-demands.md), то вызов выполняется успешно, если **LinkDemand** выполняется проверка разрешений вызывающего объекта. Кроме того, если полностью доверенный код предоставляет класс, который принимает имя свойства и вызывает его **получить** доступа с помощью отражения, этот вызов **получить** осуществляется, даже если пользовательский код не имеет прав на доступ к этому свойству. Это вызвано **LinkDemand** проверяет только непосредственный вызывающий код, который является полностью доверенным кодом. По существу полностью доверенный код выполняет привилегированный вызов от имени пользовательского кода, не убедившись в том, что пользовательский код имеет права для выполнения такого вызова.  
  
 Для предотвращения таких уязвимостей в системе безопасности среда расширяет проверку до требования полного обхода стека при любом непрямом вызове метода, конструктора, свойства или события, защищенного с **LinkDemand**. Такая защита влечет за собой некоторое снижение производительности, а также меняет семантику проверки безопасности; требование полного обхода стека может завершиться ошибкой там, где была бы пройдена более быстрая одноуровневая проверка.  
  
## <a name="assembly-loading-wrappers"></a>Программы-оболочки, загружающие сборки  
 Некоторые методы, используемые для загрузки управляемого кода, включая <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, загружают сборки со свидетельством вызывающего объекта. Если включить в программу-оболочку любой из этих методов, система безопасности может использовать для загрузки сборки предоставленные вашему коду разрешения вместо разрешений объекта, вызывающего вашу программу-оболочку. Не следует разрешать менее доверенному коду загружать код, который имеет более высокий уровень разрешений, чем объект, вызывающий вашу программу-оболочку.  
  
 Таким образом может быть ослаблена безопасность любого кода с полным уровнем доверия или значительно более высоким уровнем доверия, чем у потенциального вызывающего объекта (включая вызывающий объект уровня Интернет-разрешений). Если ваш код содержит открытый метод, который принимает массив байтов и передает их в **Assembly.Load**, тем самым создавая сборку от вызывающего объекта, безопасность может быть нарушена.  
  
 Эта проблема относится к следующим элементам API:  
  
-   <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
-   <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
-   <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a>Demand и  LinkDemand  
 Декларативная безопасность предлагает два вида проверки безопасности, которые похожи, но выполняют совершенно разные проверки. Проанализируйте обе формы, так как неправильный выбор может привести к ослаблению безопасности или потере производительности.  
  
 Декларативная безопасность предлагает следующие проверки безопасности.  
  
-   Проверка <xref:System.Security.Permissions.SecurityAction.Demand> указывает обход стека управления доступом для кода. Для прохождения этой проверки все вызывающие объекты в стеке должны иметь указанное разрешение или удостоверение. **Запросу** возникает при каждом вызове, так как стек может содержать различные вызывающие объекты. Если метод вызывается многократно, данная проверка безопасности происходит каждый раз. **Запросу** является хорошей защитой от атак с заманиванием; неавторизованный код, пытающийся пройти через его будут обнаружены.  
  
-   [LinkDemand](../../../docs/framework/misc/link-demands.md) происходит во время компиляции just-in-time (JIT) и проверяет только непосредственный вызывающий код. Эта проверка безопасности не проверяет вызывающий объект вызывающего объекта. После того как эта проверка пройдена, никакие дополнительные проверки не выполняются, независимо от того, сколько раз вызывающий объект может выполнять вызов. Однако эта проверка не обеспечивает защиту от атак с заманиванием. С **LinkDemand**, любой код, прошедший проверку и могущий ссылаться на ваш код может нарушить безопасность, позволив вредоносному коду осуществлять вызовы с использованием доверенного кода. Таким образом, следует использовать **LinkDemand** , если не все возможные слабые места могут быть полностью защищены.  
  
    > [!NOTE]
    >  В [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], требования связывания были заменены <xref:System.Security.SecurityCriticalAttribute> атрибута в <xref:System.Security.SecurityRuleSet.Level2> сборки. <xref:System.Security.SecurityCriticalAttribute> Эквивалентен требованию связывания для полного доверия; Однако он также влияет на правила наследования. Дополнительные сведения об этом изменении см. в разделе [прозрачный с точки зрения безопасности код, уровень 2](../../../docs/framework/misc/security-transparent-code-level-2.md).  
  
 Дополнительные меры предосторожности, необходимые при использовании **LinkDemand** должны программироваться в индивидуальном порядке; безопасность системы может помочь с их применением. Любая ошибка приводит к возникновению уязвимости в системе безопасности. Любой авторизованный код, использующий ваш код, должен отвечать за реализацию дополнительных мер защиты, выполняя следующие действия.  
  
-   Ограничение доступа вызывающего кода к классу или сборке.  
  
-   Размещение тех же проверок безопасности в вызывающем коде, который появляется в вызываемом коде, и принуждение вызывающих его объектов делать это. Например, если вы пишете код, вызывающий метод, который защищен с **LinkDemand** для <xref:System.Security.Permissions.SecurityPermission> с <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> флаг указан, ваш метод также должен выполнять **LinkDemand** (или **Запросу**, которая надежнее) для данного разрешения. Исключение, если ваш код использует **LinkDemand**-защищенный метод ограниченным способом, который вы считаете безопасным с учетом других механизмов обеспечения безопасности (например, требований) в коде. В этом исключительном случае вызывающий объект несет ответственность за понижение степени защиты в базовом коде.  
  
-   Обеспечение, чтобы вызывающие ваш код объекты не могли заставить его вызывать защищенный код от их имени. Другими словами, вызывающие объекты не должны иметь возможность заставить авторизованный код передавать определенные параметры в защищенный код или получить результаты из него.  
  
### <a name="interfaces-and-link-demands"></a>Интерфейсы и требования связывания  
 Если виртуальный метод, свойство или событие с **LinkDemand** переопределяет метод базового класса, метод базового класса также должен иметь ту же **LinkDemand** чтобы обеспечить эффективность переопределенного метода. Вредоносный код может выполнить обратное приведение к базовому типу и вызвать метод базового класса. Также обратите внимание, что требования связывания могут добавляться неявно в сборки, в которых отсутствует атрибут <xref:System.Security.AllowPartiallyTrustedCallersAttribute> уровня сборки.  
  
 Рекомендуется защищать реализации методов с помощью требований связывания, когда методы интерфейса также имеют требования связывания. Обратите внимание на следующие аспекты использования требований связывания с интерфейсами.  
  
-   Если поместить **LinkDemand** в открытый метод класса, который реализует метод интерфейса **LinkDemand** не будут применяться, если вы выполняете приведение к интерфейсу и вызвать метод. В этом случае поскольку выполнялось связывание с интерфейсом, только **LinkDemand** в интерфейсе является принят на обработку.  
  
 Изучите следующие элементы проблем безопасности.  
  
-   Явные требования связывания в методах интерфейса. Убедитесь, что эти требования связывания обеспечивают ожидаемую защиту. Определите, может ли вредоносный код использовать приведение, чтобы обойти требования связывания, как описано выше.  
  
-   Виртуальные методы с примененными требованиями связывания.  
  
-   Типы и интерфейсы, которые они реализуют. Они должны согласованно использовать требования связывания.  
  
## <a name="see-also"></a>См. также  
 [Правила написания безопасного кода](../../../docs/standard/security/secure-coding-guidelines.md)
