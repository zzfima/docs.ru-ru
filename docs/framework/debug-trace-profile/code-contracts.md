---
title: Контракты для кода
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: b60f992cf9d934ed622c89a49c491a80377fb6fe
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2020
ms.locfileid: "77216718"
---
# <a name="code-contracts"></a>Контракты для кода

Контракты для кода предоставляют способ указания предусловий, постусловий и инвариантов объектов в коде. Предусловия — это требования, которые должны быть выполнены при входе в метод или свойство. Постусловия описывают ожидания во время выхода из кода метода или свойства. Инварианты объектов описывают ожидаемое состояние класса, который находится в рабочем состоянии.

Контракты для кода содержат классы для маркировки кода, статический анализатор для анализа во время компиляции и анализатор времени выполнения. Классы для контрактов для кода можно найти в пространстве имен <xref:System.Diagnostics.Contracts>.

Среди преимуществ контрактов для кода можно назвать следующие.

- Улучшенное тестирование. Контракты для кода обеспечивают проверку статических контрактов, проверку во время выполнения и создание документации.

- Автоматические средства тестирования. Контракты для кода можно использовать для создания более осмысленных модульных тестов, отфильтровывая не имеющие значения аргументы тестирования, не удовлетворяющие предусловиям.

- Статическая проверка. Средство статической проверки может определять, имеются ли нарушения контракта, без запуска программы. Оно проверяет неявные контракты, такие как пустые разыменования и границы массивов, а также явные контракты.

- Справочная документация. Генератор документации расширяет существующие XML-файлы документации, добавляя сведения о контрактах. Со средством [Sandcastle](https://github.com/EWSoftware/SHFB) также можно использовать таблицы стилей, чтобы сформированные страницы документации содержали разделы контрактов.

Все языки платформы .NET Framework могут немедленно воспользоваться преимуществами контрактов; не требуется создавать специальное средство синтаксического анализа или компилятор. Надстройка Visual Studio позволяет задать уровень выполняемого анализа контракта для кода. Анализаторы могут подтвердить, что контракты сформированы правильно (путем проверки типов и разрешения имен), и могут создавать скомпилированную форму контрактов в формате MSIL. Разработка контрактов в Visual Studio позволяет использовать преимущества стандартной технологии IntelliSense, предоставляемой этим средством.

Большинство методов в классе контракта являются условно скомпилированными; то есть компилятор выдает вызовы этих методов, только если вы задаете специальный символ, CONTRACTS_FULL, с помощью директивы `#define`. CONTRACTS_FULL позволяет писать контракты в коде без использования директивы `#ifdef`; вы можете создавать различные сборки, как с контрактами, так и без.

Средства и подробные инструкции по использованию контрактов кода см. в разделе [контракты кода](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) на сайте Visual Studio Marketplace.

## <a name="preconditions"></a>Preconditions

Предусловия можно выразить с помощью метода <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType>. Предусловия задают состояние при вызове метода. Обычно они используются для указания допустимых значений параметров. Все члены, упомянутые в предусловиях, должны быть не менее доступны, чем сам метод; в противном случае предусловие может быть не понято всеми объектами, вызывающими метод. Условие не должно иметь побочных эффектов. Поведение невыполненных предусловий во время выполнения определяется анализатором времени выполнения.

Например, следующее предусловие указывает, что параметр `x` не должен иметь значение null.

```csharp
Contract.Requires(x != null);
```

Если код должен вызывать конкретное исключение при сбое предусловия, можно использовать универсальную перегрузку <xref:System.Diagnostics.Contracts.Contract.Requires%2A> следующим образом.

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a>Устаревшие операторы Requires

Большая часть кода содержит определенную проверку параметров в виде кода `if`-`then`-`throw`. Средства контракта распознают эти операторы как предусловия в следующих случаях:

- эти операторы появляются перед всеми остальными операторами в методе;

- после всего набора таких операторов следует явный вызов метода <xref:System.Diagnostics.Contracts.Contract>, например вызов метода <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> или <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.

Если операторы `if`-`then`-`throw` появляются в этой форме, средства распознают их как устаревшие операторы `requires`. Если за последовательностью `if`-`then`-`throw` не следуют никакие другие контракты, завершите код методом <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType>.

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

Обратите внимание, что условие в предыдущем тесте является предусловием с отрицанием. (Фактическое предусловие будет `x != null`.) Предварительное условие с отрицанием имеет высокий уровень ограничений: оно должно быть написано, как показано в предыдущем примере. то есть в нем не должно быть `else` предложений, а тело предложения `then` должно быть единственной инструкцией `throw`. Тест `if` подчиняется правилам чистоты и видимости (см. раздел [Правила использования](#usage_guidelines)), но выражение `throw` подчиняется только правилам чистоты. Однако тип вызываемого исключения должен быть так же видим, как и метод, в котором возникает контракт.

## <a name="postconditions"></a>Постусловия

Постусловия — это контракты для состояния метода при его завершении. Постусловие проверяется непосредственно перед выходом из метода. Поведение невыполненных постусловий во время выполнения определяется анализатором времени выполнения.

В отличие от предусловий постусловия могут ссылаться на члены с меньшей видимостью. Клиент может быть не в состоянии понять или использовать некоторые сведения, выраженные постусловием с помощью закрытого состояния, но это не влияет на возможность клиента правильно использовать этот метод.

### <a name="standard-postconditions"></a>Стандартные постусловия

Стандартные постусловия можно выразить с помощью метода <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>. Постусловия выражают условие, которое должно быть `true` при нормальном завершении метода.

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a>Исключительные постусловия

Исключительные постусловия — это постусловия, которые должны быть `true`, когда метод вызывает конкретное исключение. Эти постусловия можно задать с помощью метода <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType>, как показано в следующем примере.

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

Аргумент является условием, которое должно быть `true` всякий раз, когда вызывается исключение, являющееся подтипом `T`.

Существует несколько типов исключений, которые сложно использовать в исключительном постусловии. Например, чтобы использовать тип <xref:System.Exception> для `T`, необходимо, чтобы метод гарантировал выполнение условия независимо от типа вызываемого им исключения, даже если оно является переполнением стека или другим неконтролируемым исключением. Исключительные постусловия следует использовать только для определенных исключений, которые могут создаваться при вызове члена, например когда создается исключение <xref:System.InvalidTimeZoneException> для вызова метода <xref:System.TimeZoneInfo>.

### <a name="special-postconditions"></a>Особые постусловия

Следующие методы могут использоваться только в постусловиях.

- Вы можете ссылаться на возвращаемые значения метода в постусловиях с помощью выражения `Contract.Result<T>()`, где `T` заменяется типом возвращаемого значения метода. Когда компилятор не может вывести тип, необходимо предоставить его явно. Например, компилятор C# не может вывести типы для методов, которые не принимают аргументы, поэтому для него требуется следующее постусловие: `Contract.Ensures(0 <Contract.Result<int>())`. Методы с типом возвращаемого значения `void` не могут ссылаться на `Contract.Result<T>()` в своих постусловиях.

- Значение предсостояния в постусловии ссылается на значение выражения в начале метода или свойства. Оно использует выражение `Contract.OldValue<T>(e)`, где `T` — тип `e`. Вы можете опустить аргумент универсального типа там, где компилятор способен вывести его тип. (Например, C# компилятор всегда выводит тип, так как он принимает аргумент.) Существует несколько ограничений на то, что может произойти в `e` и контекстах, в которых может появиться старое выражение. Старое выражение не может содержать другое старое выражение. Самое главное, старое выражение должно ссылаться на значение, существовавшее в состоянии предусловия метода. Другими словами, это должно быть выражение, которое можно вычислить, пока предусловие метода имеет значение `true`. Вот несколько примеров этого правила.

  - Значение должно существовать в состоянии предусловия метода. Чтобы сослаться на поле объекта, предусловия должны гарантировать, что объект всегда имеет значение, отличное от NULL.

  - Нельзя ссылаться на возвращаемое значение метода в старом выражении:

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - Нельзя ссылаться на параметры `out` в старом выражении.

  - Старое выражение не может зависеть от переменной привязки квантификатора, если диапазон квантификатора зависит от возвращаемого значения метода:

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - Старое выражение не может ссылаться на параметр анонимного делегата в вызове метода <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> или <xref:System.Diagnostics.Contracts.Contract.Exists%2A>, если он не используется как индексатор или аргумент вызова метода:

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - Старое выражение не может возникать в тексте анонимного делегата, если значение старого выражения зависит от какого-либо параметра этого анонимного делегата, кроме случая, когда этот анонимный делегат является аргументом метода <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> или <xref:System.Diagnostics.Contracts.Contract.Exists%2A>:

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - Параметры `Out` являются проблемой, так как контракты появляются до текста метода, и большинство компиляторов не разрешает ссылки на параметры `out`в постусловиях. Для разрешения этой проблемы класс <xref:System.Diagnostics.Contracts.Contract> предоставляет метод <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>, который позволяет постусловие на основе параметра `out`.

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      Как и в методе <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, вы можете опустить параметр универсального типа там, где компилятор способен вывести его тип. Модуль переопределения контракта заменяет вызов метода значением параметра `out`. Метод <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> может появляться только в постусловиях. Аргумент метода должен быть параметром `out` или полем параметра `out` структуры. Последний вариант также полезен при ссылке на поля в постусловии конструктора структуры.

      > [!NOTE]
      > В настоящее время средства анализа контрактов для кода не проверяют правильность инициализации параметров `out` и игнорируют их упоминание в постусловии. Таким образом, если в предыдущем примере в строке после контракта использовалось значение `x` вместо назначения ей целого числа, компилятор не будет выдавать правильную ошибку. Однако в сборке, в которой не определен символ препроцессора CONTRACTS_FULL не определен (например в сборке выпуска), компилятор выдаст ошибку.

## <a name="invariants"></a>Инварианты

Инварианты объектов — это условия, которые должны выполняться для каждого экземпляра класса всегда, когда этот объект является видимым для клиента. Они выражают условия, при которых объект считается правильным.

Методы инвариантов идентифицируются по пометке атрибутом <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>. Методы инвариантов не должны содержать никакой код, кроме последовательности вызовов метода <xref:System.Diagnostics.Contracts.Contract.Invariant%2A>, каждый из которых определяет отдельный инвариант, как показано в следующем примере.

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

Инварианты условно определяются по символу препроцессора CONTRACTS_FULL. При проверке во время выполнения инварианты проверяются в конце каждого открытого метода. Если инвариант упоминает открытый метод в том же классе, проверка инварианта, которая обычно происходит в конце этого открытого метода, будет отключена. Вместо этого проверка будет выполняться только в конце самого внешнего вызова метода для этого класса. Это также происходит, если класс повторно вводится в результате вызова метода в другом классе. Инварианты не проверяются на метод завершения объекта и реализацию <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a>Рекомендации по использованию

### <a name="contract-ordering"></a>Упорядочение контрактов

В следующей таблице приведен порядок элементов, который следует использовать при создании контрактов методов.

|`If-then-throw statements`|Открытые предусловия с обратной совместимостью|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|Все открытые предусловия.|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|Все открытые (обычные) постусловия.|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|Все открытые исключительные постусловия.|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|Все закрытые/внутренние (обычные) постусловия.|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|Все закрытые/внутренние исключительные постусловия.|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|При использовании предусловий типа `if`-`then`-`throw` без каких-либо других контрактов разместите вызов метода <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>, чтобы указать, что все предыдущие проверки if являются предусловиями.|

<a name="purity"></a>

### <a name="purity"></a>Чистота

Все методы, которые вызываются в контракте, должны быть чистыми, то есть они не должны обновлять никакие предварительно существующие состояния. Чистому методу разрешается изменять объекты, которые были созданы после входа в этот чистый метод.

В настоящее время средства контрактов для кода предполагают, что чистыми являются следующие элементы кода.

- Методы, помеченные атрибутом <xref:System.Diagnostics.Contracts.PureAttribute>.

- Типы, помеченные атрибутом <xref:System.Diagnostics.Contracts.PureAttribute> (этот атрибут относится ко всем методам типа).

- Методы доступа get свойства.

- Операторы (статические методы, имена которых начинаются с op, имеющие один или два параметра и тип возвращаемого значения, отличный от void).

- Любой метод, полное имя которого начинается с System.Diagnostics.Contracts.Contract, System.String, System.IO.Path или System.Type.

- Любой вызванный делегат, при условии, что сам тип этого делегата помечен атрибутом <xref:System.Diagnostics.Contracts.PureAttribute>. Типы делегата <xref:System.Predicate%601?displayProperty=nameWithType> и <xref:System.Comparison%601?displayProperty=nameWithType> считаются чистыми.

<a name="visibility"></a>

### <a name="visibility"></a>Видимость

Все члены, упомянутые в контракте, должны быть не менее видимы, чем метод, в котором они появляются. Например, закрытое поле не может упоминаться в предусловии для открытого метода; клиенты не могут проверить такой контракт до вызова метода. Однако если это поле помечено атрибутом <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, оно исключается из данных правил.

## <a name="example"></a>Пример

В следующем примере показано использование контрактов для кода.

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
