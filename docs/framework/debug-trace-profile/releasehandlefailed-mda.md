---
title: releaseHandleFailed MDA
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
ms.openlocfilehash: 268acb01a6777315829378e6fd8c06c46d3136d2
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79181751"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="408cf-102">releaseHandleFailed MDA</span><span class="sxs-lookup"><span data-stu-id="408cf-102">releaseHandleFailed MDA</span></span>
<span data-ttu-id="408cf-103">Помощник по отладке управляемого кода (MDA) `releaseHandleFailed` активируется для уведомления разработчиков, когда метод <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> класса, производного от <xref:System.Runtime.InteropServices.SafeHandle> или <xref:System.Runtime.InteropServices.CriticalHandle>, возвращает значение `false`.</span><span class="sxs-lookup"><span data-stu-id="408cf-103">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="408cf-104">Симптомы</span><span class="sxs-lookup"><span data-stu-id="408cf-104">Symptoms</span></span>  
 <span data-ttu-id="408cf-105">Утечки памяти или ресурсов</span><span class="sxs-lookup"><span data-stu-id="408cf-105">Resource or memory leaks.</span></span>  <span data-ttu-id="408cf-106">Если метод <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> класса, производного от <xref:System.Runtime.InteropServices.SafeHandle> или <xref:System.Runtime.InteropServices.CriticalHandle> завершается с ошибкой, то ресурс, инкапсулированный этим классом, может быть не освобожден или не очищен.</span><span class="sxs-lookup"><span data-stu-id="408cf-106">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="408cf-107">Причина</span><span class="sxs-lookup"><span data-stu-id="408cf-107">Cause</span></span>  
 <span data-ttu-id="408cf-108">Пользователи должны предоставить реализацию метода <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, если они создают классы, производные от <xref:System.Runtime.InteropServices.SafeHandle> или <xref:System.Runtime.InteropServices.CriticalHandle>; таким образом, эти обстоятельства характерны для отдельных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="408cf-108">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="408cf-109">Однако действуют следующие требования.</span><span class="sxs-lookup"><span data-stu-id="408cf-109">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="408cf-110">Типы <xref:System.Runtime.InteropServices.SafeHandle> и <xref:System.Runtime.InteropServices.CriticalHandle> представляют оболочки важных ресурсов процессов.</span><span class="sxs-lookup"><span data-stu-id="408cf-110"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="408cf-111">Утечка памяти может со временем сделать процесс непригодным для использования.</span><span class="sxs-lookup"><span data-stu-id="408cf-111">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="408cf-112">Метод <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> должен работать без сбоев для выполнения своих функций.</span><span class="sxs-lookup"><span data-stu-id="408cf-112">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="408cf-113">Когда процесс запрашивает такой ресурс, метод <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> является единственным способом для его освобождения.</span><span class="sxs-lookup"><span data-stu-id="408cf-113">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="408cf-114">Таким образом, ошибка подразумевает утечку ресурсов.</span><span class="sxs-lookup"><span data-stu-id="408cf-114">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="408cf-115">Все ошибки, возникающие при выполнении метода <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> и препятствующие освобождению ресурса, представляют ошибку в реализации самого метода <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="408cf-115">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="408cf-116">Программист должен убедиться, что контракт будет выполнен, даже если этот код вызывает код, созданный другим разработчиком для выполнения своих функций.</span><span class="sxs-lookup"><span data-stu-id="408cf-116">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="408cf-117">Решение</span><span class="sxs-lookup"><span data-stu-id="408cf-117">Resolution</span></span>  
 <span data-ttu-id="408cf-118">Код, использующий конкретный тип <xref:System.Runtime.InteropServices.SafeHandle> (или <xref:System.Runtime.InteropServices.CriticalHandle>), вызвавший уведомление MDA, следует пересмотреть, найти места, где необработанное значение дескриптора извлекается из <xref:System.Runtime.InteropServices.SafeHandle> и копируется в другом месте.</span><span class="sxs-lookup"><span data-stu-id="408cf-118">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="408cf-119">Это обычная причина сбоев в реализации <xref:System.Runtime.InteropServices.SafeHandle> или <xref:System.Runtime.InteropServices.CriticalHandle>, так как использование необработанного значения дескриптора далее не отслеживается средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="408cf-119">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="408cf-120">Если копия необработанного дескриптора впоследствии закрывается, это может привести к сбою последующего вызова метода <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, поскольку попытка закрытия выполняется в том же дескрипторе, который теперь является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="408cf-120">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="408cf-121">Существует несколько путей, в которых может возникнуть дублирование неверного дескриптора.</span><span class="sxs-lookup"><span data-stu-id="408cf-121">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="408cf-122">Поиск вызовов метода <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="408cf-122">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="408cf-123">Вызовы этого метода должны быть крайне редки, и любой такой найденный вызов должны быть окружен вызовами методов <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> и <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="408cf-123">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="408cf-124">Эти последующие методы определяют участок кода, в котором можно безопасно использовать необработанное значение дескриптора.</span><span class="sxs-lookup"><span data-stu-id="408cf-124">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="408cf-125">Вне этой области или в случае если число ссылок вообще никогда не увеличивается, значение дескриптора может стать недействительным в любое время путем вызова метода <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> или <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> в другом потоке.</span><span class="sxs-lookup"><span data-stu-id="408cf-125">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="408cf-126">Если все случаи использования метода <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> отслеживаются, необходимо следовать пути, к которому прибегает необработанный дескриптор, чтобы гарантировать, что он не передан в компонент, который в конечном итоге вызывает `CloseHandle` или другой низкоуровневый собственный метод, который будет освобождать этот дескриптор.</span><span class="sxs-lookup"><span data-stu-id="408cf-126">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="408cf-127">Убедитесь, что код, который используется для инициализации <xref:System.Runtime.InteropServices.SafeHandle> с использованием допустимого необработанного значения дескриптора, владеет этим дескриптором.</span><span class="sxs-lookup"><span data-stu-id="408cf-127">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="408cf-128">При создании <xref:System.Runtime.InteropServices.SafeHandle> вокруг дескриптора, который не принадлежит коду без установки параметра `ownsHandle` в значение `false` в конструкторе базового класса, и <xref:System.Runtime.InteropServices.SafeHandle>, и реальный владелец дескриптора могут пытаться закрыть этот дескриптор, что приводит к ошибке в методе <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, если <xref:System.Runtime.InteropServices.SafeHandle> теряет состояние гонки.</span><span class="sxs-lookup"><span data-stu-id="408cf-128">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="408cf-129">Когда <xref:System.Runtime.InteropServices.SafeHandle> маршалируется между доменами приложений, подтвердите, что используемый вывод <xref:System.Runtime.InteropServices.SafeHandle> был помечен как сериализуемый.</span><span class="sxs-lookup"><span data-stu-id="408cf-129">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="408cf-130">В редких случаях, когда класс, производный от <xref:System.Runtime.InteropServices.SafeHandle>, был сделан сериализуемым, он должен реализовывать интерфейс <xref:System.Runtime.Serialization.ISerializable> или использовать один из других методов для управления процессом сериализации и десериализации вручную.</span><span class="sxs-lookup"><span data-stu-id="408cf-130">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="408cf-131">Это необходимо, поскольку действие сериализации по умолчанию заключается в создании побитового клона включенного необработанного значения дескриптора, в результате чего два экземпляра <xref:System.Runtime.InteropServices.SafeHandle> думают, что они владеют одним и тем же дескриптором.</span><span class="sxs-lookup"><span data-stu-id="408cf-131">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="408cf-132">Оба будут пытаться вызвать метод <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> в том же дескрипторе в определенный момент.</span><span class="sxs-lookup"><span data-stu-id="408cf-132">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="408cf-133">Второму <xref:System.Runtime.InteropServices.SafeHandle> это сделать не удастся.</span><span class="sxs-lookup"><span data-stu-id="408cf-133">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="408cf-134">Правильный способ действий при сериализации <xref:System.Runtime.InteropServices.SafeHandle> заключается в вызове функции `DuplicateHandle` или аналогичной функции для вашего собственного типа дескриптора, чтобы создать другую копию действительного дескриптора.</span><span class="sxs-lookup"><span data-stu-id="408cf-134">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="408cf-135">Если ваш тип дескриптора не поддерживает такое действие, то обертывающий его тип <xref:System.Runtime.InteropServices.SafeHandle> нельзя сделать сериализуемым.</span><span class="sxs-lookup"><span data-stu-id="408cf-135">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="408cf-136">Можно отслеживать, где дескриптор закрывается раньше, что приводит к возникновению ошибки при последнем вызове метода <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, установив точку останова отладчика в исходной программе, используемой для освобождения дескриптора, например в функции `CloseHandle`.</span><span class="sxs-lookup"><span data-stu-id="408cf-136">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="408cf-137">Это может оказаться невозможным в сценариях нагрузочных тестов или даже в функциональных тестах среднего размера из-за большого объема трафика, с которым часто сталкиваются подобные программы.</span><span class="sxs-lookup"><span data-stu-id="408cf-137">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="408cf-138">Может помочь инструментирование кода, который вызывает собственный метод освобождения, чтобы записывать удостоверение вызывающего объекта или возможно полную трассировку стека и значение дескриптора.</span><span class="sxs-lookup"><span data-stu-id="408cf-138">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="408cf-139">Значение дескриптора можно сравнивать со значением, предоставленным MDA.</span><span class="sxs-lookup"><span data-stu-id="408cf-139">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="408cf-140">Обратите внимание, что некоторые типы собственных дескрипторов, например все дескрипторы Win32, которые могут быть освобождены с помощью функции `CloseHandle`, совместно используют одно пространство имен дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="408cf-140">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="408cf-141">Ошибочное освобождение одного типа дескриптора может вызвать проблемы с другим.</span><span class="sxs-lookup"><span data-stu-id="408cf-141">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="408cf-142">Например, случайное закрытие дескриптора события Win32 дважды может привести к вероятному преждевременному закрытию несвязанного дескриптора файла.</span><span class="sxs-lookup"><span data-stu-id="408cf-142">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="408cf-143">Это происходит, когда дескриптор освобождается и значение дескриптора становится доступным для использования в целях отслеживания другого ресурса, возможно другого типа.</span><span class="sxs-lookup"><span data-stu-id="408cf-143">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="408cf-144">Если это происходит и приводит к ошибочному повторному освобождению, дескриптор несвязанного потока может стать недействительным.</span><span class="sxs-lookup"><span data-stu-id="408cf-144">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="408cf-145">Влияние на среду выполнения</span><span class="sxs-lookup"><span data-stu-id="408cf-145">Effect on the Runtime</span></span>  
 <span data-ttu-id="408cf-146">Этот помощник отладки управляемого кода не оказывает никакого влияния на среду CLR.</span><span class="sxs-lookup"><span data-stu-id="408cf-146">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="408cf-147">Выходные данные</span><span class="sxs-lookup"><span data-stu-id="408cf-147">Output</span></span>  
 <span data-ttu-id="408cf-148">Сообщение, указывающее, что <xref:System.Runtime.InteropServices.SafeHandle> или <xref:System.Runtime.InteropServices.CriticalHandle> не удалось должным образом освободить дескриптор.</span><span class="sxs-lookup"><span data-stu-id="408cf-148">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="408cf-149">Пример:</span><span class="sxs-lookup"><span data-stu-id="408cf-149">For example:</span></span>  
  
```output
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'
failed to properly release the handle with value 0x0000BEEF. This
usually indicates that the handle was released incorrectly via
another means (such as extracting the handle using DangerousGetHandle
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="408cf-150">Конфигурация</span><span class="sxs-lookup"><span data-stu-id="408cf-150">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="408cf-151">Пример</span><span class="sxs-lookup"><span data-stu-id="408cf-151">Example</span></span>  
 <span data-ttu-id="408cf-152">Ниже приведен пример кода, который может активировать MDA `releaseHandleFailed`.</span><span class="sxs-lookup"><span data-stu-id="408cf-152">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the
    // native handle wrapped by this SafeHandle. This method returns
    // false on failure, but should only fail if the input is invalid
    // (which should not happen here). The method specifically must not
    // fail simply because of lack of resources or other transient
    // failures beyond the user’s control. That would make it unacceptable
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="408cf-153">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="408cf-153">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="408cf-154">Диагностика ошибок посредством помощников по отладке управляемого кода</span><span class="sxs-lookup"><span data-stu-id="408cf-154">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="408cf-155">Маршалинг взаимодействия</span><span class="sxs-lookup"><span data-stu-id="408cf-155">Interop Marshaling</span></span>](../interop/interop-marshaling.md)
