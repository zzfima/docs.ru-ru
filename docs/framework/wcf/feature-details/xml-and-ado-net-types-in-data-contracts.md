---
title: "Типы XML и ADO.NET в контрактах данных"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
caps.latest.revision: "7"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: 9bc54b4f2a29f9fd082bafd7cf6007441365c35c
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2017
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="e6d2a-102">Типы XML и ADO.NET в контрактах данных</span><span class="sxs-lookup"><span data-stu-id="e6d2a-102">XML and ADO.NET Types in Data Contracts</span></span>
<span data-ttu-id="e6d2a-103">Модель контракта данных [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] поддерживает некоторые типы, которые непосредственно представляют XML.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-103">The [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="e6d2a-104">При сериализации данных типов в XML сериализатор сохраняет содержимое таких типов XML без какой-либо дополнительной обработки.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="e6d2a-105">Поддерживаемые типы: <xref:System.Xml.XmlElement>, массивы <xref:System.Xml.XmlNode> (но не сами типы `XmlNode`), а также типы, реализующие <xref:System.Xml.Serialization.IXmlSerializable>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="e6d2a-106">Типы <xref:System.Data.DataSet> и <xref:System.Data.DataTable>, а также типизированные наборы данных, чаще всего используются в программировании баз данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="e6d2a-107">Данные типы реализуют интерфейс `IXmlSerializable`, и, следовательно, сериализуются в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="e6d2a-108">Некоторые специальные рекомендации, относящиеся к данным типам, приведены в конце данного раздела.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="e6d2a-109">Типы XML</span><span class="sxs-lookup"><span data-stu-id="e6d2a-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="e6d2a-110">Элемент XML</span><span class="sxs-lookup"><span data-stu-id="e6d2a-110">Xml Element</span></span>  
 <span data-ttu-id="e6d2a-111">Тип `XmlElement` сериализуется с помощью содержимого XML.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="e6d2a-112">Например, с помощью следующего типа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="e6d2a-113">Данный тип сериализуется в XML следующим образом:</span><span class="sxs-lookup"><span data-stu-id="e6d2a-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="e6d2a-114">Обратите внимание, что элемент данных программы-оболочки `<myDataMember>` все еще присутствует.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="e6d2a-115">Удалить данный элемент в модели контракта данных невозможно.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="e6d2a-116">Сериализаторы, обрабатывающие данную модель (<xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.NetDataContractSerializer>), могут выдать специальные атрибуты в данный элемент программы-оболочки.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="e6d2a-117">Данные атрибуты включают атрибут "nil" экземпляра схемы XML (позволяющий `XmlElement` принимать значение `null`) и атрибут "type" (позволяющий использовать `XmlElement` полиморфно).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="e6d2a-118">Кроме того, для [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] характерны следующие атрибуты XML: "Id", "Ref", "Type" и "Assembly".</span><span class="sxs-lookup"><span data-stu-id="e6d2a-118">Also, the following XML attributes are specific to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="e6d2a-119">Данные атрибуты могут быть выданы для поддержки использования элемента `XmlElement` в режиме сохранения графов объектов или при обработке сериализатором <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="e6d2a-120">([!INCLUDE[crabout](../../../../includes/crabout-md.md)] режим сохранения графа объекта. в разделе [сериализации и десериализации](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="e6d2a-120">([!INCLUDE[crabout](../../../../includes/crabout-md.md)] the object graph preservation mode, see [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="e6d2a-121">Массивы коллекций `XmlElement` разрешены и обрабатываются так, как и любой другой массив или коллекция.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="e6d2a-122">Есть элемент программы-оболочки для всей коллекции и отдельный элемент программы-оболочки (подобный `<myDataMember>` из предыдущего примера) для каждого элемента `XmlElement` в массиве.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="e6d2a-123">При десериализации элемент `XmlElement` создается с помощью десериализатора из входящего кода XML.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="e6d2a-124">Допустимый родительский <xref:System.Xml.XmlDocument> предоставляется десериализатором.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="e6d2a-125">Убедитесь, что фрагмент XML, из которого десериализуется элемент `XmlElement`, определяет все префиксы, которые он использует, и не применяет какие-либо определения префикса из предков.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="e6d2a-126">Такая проблема возникает только при использовании `DataContractSerializer` для доступа к XML из отличного (не `DataContractSerializer`) источника.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="e6d2a-127">При использовании с `DataContractSerializer`, `XmlElement` может быть назначен полиморфно, но только элементу данных типа <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="e6d2a-128">Даже несмотря на то, что он реализует <xref:System.Collections.IEnumerable>, `XmlElement` не может быть использован как тип коллекции и не может быть назначен элементу данных <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="e6d2a-129">Как и со всеми полиморфными назначениями, `DataContractSerializer` передает имя контракта данных в результирующем XML-коде - в данном случае это "XmlElement" в пространстве имен "http://schemas.datacontract.org/2004/07/System.Xml".</span><span class="sxs-lookup"><span data-stu-id="e6d2a-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="e6d2a-130">С `NetDataContractSerializer` поддерживается любое допустимое полиморфное назначение `XmlElement` (в `Object` или `IEnumerable`).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="e6d2a-131">Не пытайтесь использовать ни один из сериализаторов для типов, унаследованных от `XmlElement`, независимо от того, полиморфно они назначены или нет.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="e6d2a-132">Массив типа XmlNode</span><span class="sxs-lookup"><span data-stu-id="e6d2a-132">Array of XmlNode</span></span>  
 <span data-ttu-id="e6d2a-133">Использование массивов <xref:System.Xml.XmlNode> очень похоже на использование `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="e6d2a-134">Использование массивов `XmlNode` обеспечивает большую гибкость, чем использование `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="e6d2a-135">Можно записать несколько элементов внутри элемента программы-оболочки элемента данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="e6d2a-136">Кроме того, можно вставить содержимое, которое отличается от элементов внутри элемента программы-оболочки элемента данных, например комментарии XML.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="e6d2a-137">И наконец, в элемент программы-оболочки элемента данных можно поместить атрибуты.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="e6d2a-138">Все это можно сделать путем указания массива `XmlNode` со специальными унаследованными классами `XmlNode`, такими как <xref:System.Xml.XmlAttribute>, `XmlElement` или <xref:System.Xml.XmlComment>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="e6d2a-139">Например, с помощью следующего типа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="e6d2a-140">При сериализации получаемый код XML подобен приведенному ниже коду.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="e6d2a-141">Обратите внимание, что элемент программы-оболочки элемента данных `<myDataMember>` включает атрибут, комментарий и два элемента.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="e6d2a-142">Это четыре сериализированные экземпляра `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="e6d2a-143">Массив `XmlNode`, который получается в недопустимом XML-коде, не может быть сериализован.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="e6d2a-144">Например, массив из двух экземпляров `XmlNode`, из которых один - `XmlElement`, а другой - <xref:System.Xml.XmlAttribute>, является недействительным, поскольку данная последовательность не соответствует какому-либо допустимому экземпляру XML (в нем нет места, чтобы вложить атрибут).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="e6d2a-145">При десериализации массива `XmlNode` узлы создаются и заполняются информацией из входящего XML-кода.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="e6d2a-146">Допустимый родительский <xref:System.Xml.XmlDocument> предоставляется десериализатором.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="e6d2a-147">Все узлы десериализуются, включая любые атрибуты элемента данных программы-оболочки, кроме атрибутов, размещенных в них сериализаторами [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] (например, атрибутов, используемых для указания на полиморфное назначение).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="e6d2a-148">Примечание об определении всех префиксов пространства имен во фрагменте XML-кода применяется к десериализации массивов `XmlNode` точно так же, как при десериализации `XmlElement`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="e6d2a-149">При использовании сериализаторов с включенным режимом сохранения графов объектов равенство объектов сохраняется только на уровне массивов `XmlNode`, а не отдельных экземпляров `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="e6d2a-150">Не пытайтесь сериализовать массив `XmlNode`, где один или более узлов установлены в значение `null`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="e6d2a-151">Значение `null` разрешено применять ко всему элементу массива, а не к отдельному `XmlNode`, содержащемуся в массиве.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="e6d2a-152">Если весь элемент данных массива пуст, элемент данных программы-оболочки содержит специальный атрибут, указывающий, что элемент данных массива пуст.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="e6d2a-153">При десериализации весь элемент данных массива также становится пустым.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="e6d2a-154">Специально обрабатываются сериализатором только обычные массивы `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="e6d2a-155">Элементы данных, объявленные как другие типы коллекций, содержащие `XmlNode`, или элементы данных, объявленные как массивы типов, унаследованных от `XmlNode`, специально не обрабатываются.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="e6d2a-156">Это означает, что обычно они не сериализуются, кроме случаев, когда они также соответствуют одному из других критериев для сериализации.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="e6d2a-157">Массивы или коллекции массивов `XmlNode` разрешены.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="e6d2a-158">Есть элемент программы-оболочки для всей коллекции и отдельный элемент программы-оболочки (подобный `<myDataMember>` из предыдущего примера) для каждого массива `XmlNode` во внешнем массиве или коллекции.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="e6d2a-159">Указание элемента данных типа <xref:System.Array> класса `Object` или `Array` интерфейса `IEnumerable` с экземплярами `XmlNode` не приводит к обработке элемента данных как экземпляров `Array` класса `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="e6d2a-160">Каждый элемент данных сериализуется отдельно.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="e6d2a-161">При использовании с `DataContractSerializer` массивы `XmlNode` могут быть назначены полиморфно, но только элементу данных типа `Object`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="e6d2a-162">Даже несмотря на реализацию интерфейса `IEnumerable` массив `XmlNode` не может быть использован как тип коллекции и не может быть назначен элементу данных `IEnumerable`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="e6d2a-163">Как и со всеми полиморфными назначениями, `DataContractSerializer` передает имя контракта данных в получаемый код XML – в данном случае, это "ArrayOfXmlNode" в пространстве имен "http://schemas.datacontract.org/2004/07/System.Xml".</span><span class="sxs-lookup"><span data-stu-id="e6d2a-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="e6d2a-164">При использовании с `NetDataContractSerializer`, любое действительное назначение `XmlNode` массив поддерживается.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="e6d2a-165">Замечания по схемам</span><span class="sxs-lookup"><span data-stu-id="e6d2a-165">Schema Considerations</span></span>  
 <span data-ttu-id="e6d2a-166">Дополнительные сведения о сопоставлении схемы XML типов см. в разделе [Справочник по схеме контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="e6d2a-167">В данном разделе приводится обзор важных моментов.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="e6d2a-168">Элемент данных типа `XmlElement` с элементом, определенным с помощью следующего анонимного типа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="e6d2a-169">Элемент данных типа массива `XmlNode` сопоставлен с элементом, определенным с помощью следующего анонимного типа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="e6d2a-170">Типы, реализующие интерфейс IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="e6d2a-170">Types Implementing the IXmlSerializable Interface</span></span>  
 <span data-ttu-id="e6d2a-171">Типы, реализующие интерфейс `IXmlSerializable`, полностью поддерживаются сериализатором `DataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="e6d2a-172">К данным типам всегда нужно применять атрибут <xref:System.Xml.Serialization.XmlSchemaProviderAttribute>, необходимый для управления их схемой.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="e6d2a-173">Существует три разновидности типов, реализующих интерфейс `IXmlSerializable`: типы, представляющие производное содержимое; типы, представляющие одиночный элемент; устаревшие типы <xref:System.Data.DataSet>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
-   <span data-ttu-id="e6d2a-174">Типы содержимого используют метод поставщика схемы, заданный атрибутом `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="e6d2a-175">Метод не возвращает значение `null`, и свойство <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> атрибута остается в значении по умолчанию `false`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="e6d2a-176">Это наиболее распространенное использование типов `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
-   <span data-ttu-id="e6d2a-177">Типы элемента используется в том случае, когда тип `IXmlSerializable` должен управлять собственным именем корневого элемента.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="e6d2a-178">Чтобы отметить тип как тип элемента, свойство <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> атрибута <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> устанавливается в значение `true`, или из метода поставщика схемы возвращается значение null.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="e6d2a-179">Наличие метода поставщика схемы является необязательным для типов элементов – вместо имени метода в `XmlSchemaProviderAttribute` можно указать null.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="e6d2a-180">Однако, если `IsAny` имеет значение `true` и указан метод поставщика схемы, метод должен возвратить значение null.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
-   <span data-ttu-id="e6d2a-181">Устаревшие типы <xref:System.Data.DataSet> являются типами `IXmlSerializable`, не отмеченными атрибутом `XmlSchemaProviderAttribute`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="e6d2a-182">Вместо этого они используют для создания схемы метод <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="e6d2a-183">Данный шаблон используется для типа `DataSet`, и его типизированный набор данных наследует класс в более ранних версиях .NET Framework; в настоящее время он устарел и поддерживается только из соображений совместимости с более ранними версиями.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="e6d2a-184">Не используйте данный шаблон и всегда применяйте атрибут `XmlSchemaProviderAttribute` к своим типам `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="e6d2a-185">Типы содержимого IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="e6d2a-185">IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="e6d2a-186">При сериализации элемента данных соответствующего типа, который реализует `IXmlSerializable` и относится к определенному ранее типу содержимого, сериализатор записывает элемент программы-оболочки для элемента данных и передает управление методу <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="e6d2a-187">Реализация <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> может записать любой XML, включая добавление атрибутов в элемент программы-оболочки.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="e6d2a-188">После выполнения `WriteXml` сериализатор закрывает элемент.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="e6d2a-189">При десериализации элемента данных соответствующего типа, который реализует `IXmlSerializable` и относится к определенному ранее типу содержимого, десериализатор устанавливает средство чтения XML на элемент программы-оболочки для элемента данных и передает управление методу <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="e6d2a-190">Метод должен прочесть весь элемент, включая открывающий и закрывающий теги.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="e6d2a-191">Убедитесь, что код `ReadXml` обрабатывает случай, когда элемент пуст.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="e6d2a-192">Кроме того, реализация `ReadXml` не должна использовать элемент программы-оболочки, именованный особым образом.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="e6d2a-193">Имя, выбранное сериализатором, может изменяться.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="e6d2a-194">Разрешается полиморфно присваивать типы содержимого `IXmlSerializable`, например, элементам данных типа <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="e6d2a-195">Кроме того, для экземпляров типа разрешено значение null.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="e6d2a-196">И наконец, можно использовать типы `IXmlSerializable` с включенным режимом сохранения графов объектов и с <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="e6d2a-197">Для всех этих функций требуется, чтобы сериализатор [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] вложил некоторые атрибуты в элемент программы-оболочки ("nil" и "type" в пространстве имен экземпляра схемы XML и "Id", "Ref", "Type" и "Assembly" в пространстве имен [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-197">All these features require the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="e6d2a-198">Атрибуты, игнорируемые при реализации ReadXml</span><span class="sxs-lookup"><span data-stu-id="e6d2a-198">Attributes to Ignore when Implementing ReadXml</span></span>  
 <span data-ttu-id="e6d2a-199">Перед передачей управления коду `ReadXml` десериализатор проверяет XML-элемент, обнаруживает данные специальные атрибуты XML и работает с ними.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="e6d2a-200">Например, если "nil" имеет значение `true`, десериализуется значение null, и `ReadXml` не вызывается.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="e6d2a-201">Если обнаружен полиморфизм, содержимое десериализуется так, как если бы это был другой тип.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="e6d2a-202">Вызывается реализация `ReadXml` полиморфно назначенного типа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="e6d2a-203">В любом случае, реализация `ReadXml` игнорирует данные специальные атрибуты, поскольку они обрабатываются десериализатором.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="e6d2a-204">Замечания по схемам для типов содержимого IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="e6d2a-204">Schema Considerations for IXmlSerializable Content Types</span></span>  
 <span data-ttu-id="e6d2a-205">При экспорте схемы с типом содержимого `IXmlSerializable` вызывается метод поставщика схемы.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="e6d2a-206"><xref:System.Xml.Schema.XmlSchemaSet> передается в метод поставщика схемы.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="e6d2a-207">Метод может добавить любую допустимую схему в набор схем.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="e6d2a-208">Набор схем содержит схему, которая уже была известна на момент экспорта схемы.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="e6d2a-209">Если метод поставщика схем должен добавить элемент в набор схем, он должен определить, имеется ли в наборе <xref:System.Xml.Schema.XmlSchema> с соответствующим пространством имен.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="e6d2a-210">Если это так, метод поставщика схемы должен добавить новый элемент в существующую схему `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="e6d2a-211">В противном случае, метод создает новый экземпляр `XmlSchema`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="e6d2a-212">Это важно, если используются массивы типов `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="e6d2a-213">Например, если есть тип `IXmlSerializable`, который экспортируется как тип "A" в пространстве имен "Б", возможно, что к моменту вызова метода поставщика схем, набор схем уже содержит схему для "Б" для удержания типа "ArrayOfA".</span><span class="sxs-lookup"><span data-stu-id="e6d2a-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="e6d2a-214">Кроме добавления типов в <xref:System.Xml.Schema.XmlSchemaSet>, метод поставщика схемы для типов содержимого должен возвратить ненулевое значение.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="e6d2a-215">Метод может возвратить <xref:System.Xml.XmlQualifiedName>, указывающий имя типа схемы, которая будет использоваться для заданного типа `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="e6d2a-216">Полное имя также служит именем контракта данных и пространством имен для типа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="e6d2a-217">Не разрешается возвращать тип, не существующий в наборе схем, немедленно при возврате метода поставщика.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="e6d2a-218">Однако предполагается, что к моменту экспорта всех типов (метод <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> вызывается для всех соответствующих типов <xref:System.Runtime.Serialization.XsdDataContractExporter> и выполняется доступ к свойству <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A>) тип существует в наборе схем.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="e6d2a-219">Доступ к свойству `Schemas` до того, как были выполнены все соответствующие вызовы `Export`, может привести к созданию исключения <xref:System.Xml.Schema.XmlSchemaException>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="e6d2a-220">процесс экспорта. в разделе [Экспорт схем из классов](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-220"> the export process, see [Exporting Schemas from Classes](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="e6d2a-221">Метод поставщика схемы также может возвратить тип <xref:System.Xml.Schema.XmlSchemaType> для использования.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="e6d2a-222">Тип может быть или не быть анонимным.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="e6d2a-223">Если тип анонимный, схема для типа `IXmlSerializable` экспортируется как анонимный тип при каждом использовании типа `IXmlSerializable` в качестве элемента данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="e6d2a-224">Тип `IXmlSerializable` все еще имеет контракт данных и пространство имен.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="e6d2a-225">(Это определить, как описано в [имена контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-names.md) за исключением того, что <xref:System.Runtime.Serialization.DataContractAttribute> атрибут не может использоваться для пользовательского имени.) Если тип не анонимный, он должен быть одним из типов в наборе схем `XmlSchemaSet`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-225">(This is determined as described in [Data Contract Names](../../../../docs/framework/wcf/feature-details/data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="e6d2a-226">Данный случай эквивалентен возврату `XmlQualifiedName` типа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="e6d2a-227">Кроме того, для типа экспортируется глобальное объявление элемента.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="e6d2a-228">Если тип не имеет примененного к нему атрибута <xref:System.Xml.Serialization.XmlRootAttribute>, элемент имеет те же имя и пространство имен, что контракт данных, и его свойство "nillable" имеет значение "true".</span><span class="sxs-lookup"><span data-stu-id="e6d2a-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="e6d2a-229">Единственным исключением является схема пространства имен ("http://www.w3.org/2001/XMLSchema") - если контракт данных типа находится в данном пространстве имен, соответствующий глобальный элемент находится в пустом пространстве имен, поскольку добавлять новые элементы в схему пространства имен запрещается.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="e6d2a-230">Если тип имеет применяемый к нему атрибут `XmlRootAttribute`, глобальное объявление элемента экспортируется с помощью свойств <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> и <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="e6d2a-231">Значениями по умолчанию при применении атрибута `XmlRootAttribute` являются имя контракта данных, пустое пространство имен и параметр "nillable" в значении "true".</span><span class="sxs-lookup"><span data-stu-id="e6d2a-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="e6d2a-232">Те же правила объявления глобального элемента применяются и к устаревшим типам наборов данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="e6d2a-233">Важно отметить, что `XmlRootAttribute` не может переопределить объявления глобальных элементов, добавленных с помощью пользовательского кода или добавленных в набор схем `XmlSchemaSet` с помощью метода поставщика схем или посредством метода `GetSchema` для устаревших типов наборов данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="e6d2a-234">Типы элемента IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="e6d2a-234">IXmlSerializable Element Types</span></span>  
 <span data-ttu-id="e6d2a-235">Типы элементов `IXmlSerializable` либо имеют свойство `IsAny`, которому присвоено значение `true`, либо их метод поставщика схем возвращает значение `null`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="e6d2a-236">Сериализация и десериализация типа элемента очень похожа на сериализацию и десериализацию типа содержимого.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="e6d2a-237">Однако есть некоторые важные отличия.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-237">However, there are some important differences:</span></span>  
  
-   <span data-ttu-id="e6d2a-238">Как правило, реализация `WriteXml` записывает только один элемент (который, конечно, может содержать несколько дочерних элементов).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="e6d2a-239">Она не должна записывать атрибуты вне данного одиночного элемента, несколько родственных элементов или смешанное содержимое.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="e6d2a-240">Элемент может быть пустым.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-240">The element may be empty.</span></span>  
  
-   <span data-ttu-id="e6d2a-241">Реализация `ReadXml` не должна прочитывать элемент программы-оболочки.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="e6d2a-242">Как правило, реализация прочитывает один элемент, создаваемый методом `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
-   <span data-ttu-id="e6d2a-243">При регулярной сериализации типа элемента (например, как элемента данных в контракте данных) сериализатор, как и в случае с типами содержимого, выводит элемент программы-оболочки до вызова метода `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="e6d2a-244">Однако при сериализации типа элемента на верхнем уровне сериализатор обычно не выводит элемент программы-оболочки в окружение элемента, который выводится методом `WriteXml`, кроме случая, когда корневое имя и пространство имен были явно заданы при конструировании сериализатора в конструкторах `DataContractSerializer` или `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="e6d2a-245">[Сериализации и десериализации](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-245"> [Serialization and Deserialization](../../../../docs/framework/wcf/feature-details/serialization-and-deserialization.md).</span></span>  
  
-   <span data-ttu-id="e6d2a-246">При сериализации типа элемента на верхнем уровне без указания корневого имени и пространства имен во время создания <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> и <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> обычно не выполняют никаких операций, а <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> вызывает `WriteXml`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="e6d2a-247">В данном режиме сериализуемый объект не может иметь значение null и не может быть назначен полиморфно.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="e6d2a-248">Кроме того, не может быть включено сохранение графов объектов и не может использоваться `NetDataContractSerializer`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
-   <span data-ttu-id="e6d2a-249">При десериализации типа элемента на верхнем уровне без указания корневого имени и пространства имен во время построения <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> возвращает значение `true`, если не может найти начало хотя бы одного из элементов.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="e6d2a-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> с параметром `verifyObjectName`, установленным в значение `true`, работает таким же образом, как и `IsStartObject` перед фактическим считыванием объекта.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="e6d2a-251">Затем `ReadObject` передает управление методу `ReadXml`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="e6d2a-252">Схема, экспортированная для типов элементов, аналогична схеме для типа `XmlElement`, как описано в предыдущем разделе, за исключением того, что метод поставщика схемы может добавлять дополнительную схему в <xref:System.Xml.Schema.XmlSchemaSet> как типы содержимого.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="e6d2a-253">Использование атрибута `XmlRootAttribute` с типами элемента не разрешено, и для данных типов никогда не выдаются глобальные объявления элемента.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="e6d2a-254">Отличия от XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="e6d2a-254">Differences from the XmlSerializer</span></span>  
 <span data-ttu-id="e6d2a-255">Сериализатор `IXmlSerializable` также понимает интерфейс `XmlSchemaProviderAttribute` и атрибуты `XmlRootAttribute` и <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="e6d2a-256">Однако есть некоторые отличия в том, как данные атрибуты обрабатываются в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="e6d2a-257">Сводка важнейших отличий представлена ниже.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-257">The important differences are summarized in the following:</span></span>  
  
-   <span data-ttu-id="e6d2a-258">Метод поставщика схемы должен быть открытым для использования в `XmlSerializer`, но не должен быть открытым для использования в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
-   <span data-ttu-id="e6d2a-259">Метод поставщика схемы вызывается, если свойству `IsAny` присвоено значение true в модели контракта данных, но не с `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="e6d2a-260">Если атрибут `XmlRootAttribute` не присутствует в содержимом или устаревших типах набора данных, сериализатор `XmlSerializer` экспортирует глобальное объявление элемента в пустое пространство имени.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="e6d2a-261">В модели контракта данных используемым пространством имен обычно является пространство имен контракта данных, как было описано ранее.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="e6d2a-262">Помните об этих отличиях при создании типов, которые используются с обеими технологиями сериализации.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="e6d2a-263">Импорт схемы IXmlSerializable</span><span class="sxs-lookup"><span data-stu-id="e6d2a-263">Importing IXmlSerializable Schema</span></span>  
 <span data-ttu-id="e6d2a-264">При импорте схемы, созданной из типов `IXmlSerializable`, существует несколько возможностей.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
-   <span data-ttu-id="e6d2a-265">Созданная схема может быть действительной схемой контракта данных, как описано в [Справочник по схеме контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="e6d2a-266">В таком случае, схема может быть импортирована обычным образом, и создаются обычные типы контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
-   <span data-ttu-id="e6d2a-267">Созданная схема может не быть действительной схемой контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="e6d2a-268">Например, ваш собственный метод поставщика схемы может создать схему, которая включает атрибуты XML, не поддерживаемые в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="e6d2a-269">В данном случае можно импортировать схему как типы `IXmlSerializable`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="e6d2a-270">Этот режим импорта по умолчанию не установлен, но можно легко включить — например, с `/importXmlTypes` используйте параметр командной строки [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="e6d2a-271">Это подробно описан в [Импорт схемы для создания классов](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-271">This is described in detail in the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="e6d2a-272">Обратите внимание, что работать нужно непосредственно с XML собственных экземпляров типа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="e6d2a-273">Кроме того, следует принимать во внимание другую технологию сериализации, поддерживающую широкий диапазон схем - см. раздел, посвященный использованию `XmlSerializer`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
-   <span data-ttu-id="e6d2a-274">Возможно, вам понадобится повторно использовать существующие типы `IXmlSerializable` в прокси, вместо того чтобы создавать новые.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="e6d2a-275">В таком случае для указания типа для повторного использования может использоваться функция ссылочных типов, описанная в разделе «Импорт схемы для создания типов».</span><span class="sxs-lookup"><span data-stu-id="e6d2a-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="e6d2a-276">Это соответствует использованию `/reference` переключиться на svcutil.exe, указывающего на сборку, содержащую типы для повторного использования.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="e6d2a-277">Представление произвольного XML в контракте данных</span><span class="sxs-lookup"><span data-stu-id="e6d2a-277">Representing Arbitrary XML in Data Contracts</span></span>  
 <span data-ttu-id="e6d2a-278">Типы `XmlElement`, массив `XmlNode` и `IXmlSerializable` позволяют вводить производный XML в модель контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="e6d2a-279">`DataContractSerializer` и `NetDataContractSerializer`, не нарушая процесса, передают данное содержимое XML в используемое средство записи XML.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="e6d2a-280">Однако средства записи XML могут принудительно задать некоторые ограничения на записываемый ими XML.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="e6d2a-281">В частности, далее приводится несколько важных примеров.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-281">Specifically, here are some important examples:</span></span>  
  
-   <span data-ttu-id="e6d2a-282">Средства записи XML обычно не разрешают объявления XML-документа (например, \<? версия xml = "1.0"? >) в середине записи другого документа.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="e6d2a-283">Нельзя взять полный XML-документ и сериализовать его как `Array` элемента данных `XmlNode`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="e6d2a-284">Чтобы сделать это, нужно либо удалить объявление документа, либо использовать для его представления собственную схему кодирования.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
-   <span data-ttu-id="e6d2a-285">Все средства записи XML, поставляемых вместе с [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] отклоняют инструкции по обработке XML (\<?</span><span class="sxs-lookup"><span data-stu-id="e6d2a-285">All of the XML writers supplied with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] reject XML processing instructions (\<?</span></span> <span data-ttu-id="e6d2a-286">…</span><span class="sxs-lookup"><span data-stu-id="e6d2a-286">…</span></span> <span data-ttu-id="e6d2a-287">? >) и определения типа документа (\<!</span><span class="sxs-lookup"><span data-stu-id="e6d2a-287">?>) and document type definitions (\<!</span></span> <span data-ttu-id="e6d2a-288">…</span><span class="sxs-lookup"><span data-stu-id="e6d2a-288">…</span></span> <span data-ttu-id="e6d2a-289">>), так как они не разрешены в сообщениях SOAP.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-289">>), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="e6d2a-290">И, опять же, чтобы обойти данное ограничение, можно использовать собственный механизм кодирования.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-290">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="e6d2a-291">Если нужно включить их в готовый XML-код, можно написать пользовательский кодировщик, использующий поддерживающие их средства записи XML.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-291">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
-   <span data-ttu-id="e6d2a-292">При реализации метода `WriteXml` избегайте вызова метода в средстве записи XML <xref:System.Xml.XmlWriter.WriteRaw%2A>.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-292">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="e6d2a-293"> использует различные кодировки XML (включая двоичные), очень сложно или невозможно использовать `WriteRaw` таким образом, чтобы результат можно было использовать в какой-либо кодировке.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-293"> uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
-   <span data-ttu-id="e6d2a-294">При реализации `WriteXml` избегайте использования методов <xref:System.Xml.XmlWriter.WriteEntityRef%2A> и <xref:System.Xml.XmlWriter.WriteNmToken%2A>, которые не поддерживаются средствами записи XML, предоставляемыми с [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e6d2a-294">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="e6d2a-295">Использование наборов данных, типизированных наборов данных и таблиц данных</span><span class="sxs-lookup"><span data-stu-id="e6d2a-295">Using DataSet, Typed DataSet and DataTable</span></span>  
 <span data-ttu-id="e6d2a-296">Использование данных типов полностью поддерживается в модели контракта данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-296">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="e6d2a-297">При использовании данных типов необходимо учитывать следующие моменты.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-297">When using these types, consider the following points:</span></span>  
  
-   <span data-ttu-id="e6d2a-298">Схема для данных типов (особенно <xref:System.Data.DataSet> и его наследуемые типизированные классы) может не взаимодействовать с некоторыми платформами, не относящимися к [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], или может привести к снижению удобства использования при работе с данными платформами.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-298">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="e6d2a-299">Кроме того, использование типа `DataSet` может отрицательно влиять на производительность.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-299">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="e6d2a-300">Наконец, это усложняет создание новой версии вашего приложения в будущем.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-300">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="e6d2a-301">Рассмотрите вариант использования в ваших контрактах явным образом определенных типов контракта данных вместо типов `DataSet`.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-301">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
-   <span data-ttu-id="e6d2a-302">При импорте схем `DataSet` или `DataTable` важно сделать ссылку на эти типы.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-302">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="e6d2a-303">С помощью средства командной строки Svcutil.exe это можно сделать, передав имя сборки System.Data.dll `/reference` переключения.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-303">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="e6d2a-304">Если импортируется схема типизированного набора данных, необходимо создать ссылку на тип типизированного набора данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-304">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="e6d2a-305">С помощью Svcutil.exe, передать расположение сборки типизированного набора данных для `/reference` переключения.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-305">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="e6d2a-306">ссылки на типы, в разделе [Импорт схемы для создания классов](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-306"> referencing types, see the [Importing Schema to Generate Classes](../../../../docs/framework/wcf/feature-details/importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="e6d2a-307">Поддержка типизированных наборов данных в контракте данных ограничена.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-307">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="e6d2a-308">Типизированные наборы данных могут быть сериализованы и десериализованы, а также могут экспортировать свою схему.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-308">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="e6d2a-309">Однако импорт схемы контракта данных не способен создать новые типы типизированных наборов данных, поскольку в импорте могут повторно использоваться только уже существующие наборы данных.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-309">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="e6d2a-310">Можно указать на существующий типизированный набор данных с помощью параметра `/r` средства Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-310">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="e6d2a-311">При попытке использовать Svcutil.exe без параметра `/r` применительно к службе, которая использует типизированный набор данных, автоматически выбирается альтернативный сериализатор (XmlSerializer).</span><span class="sxs-lookup"><span data-stu-id="e6d2a-311">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="e6d2a-312">Если нужно использовать DataContractSerializer и создать наборы данных из схемы, можно воспользоваться следующей процедурой: создать типы типизированного набора данных (с помощью средства Xsd.exe с параметром `/d` применительно к службе), скомпилировать типы, а затем указать на них с помощью параметра `/r` средства Svcutil.exe.</span><span class="sxs-lookup"><span data-stu-id="e6d2a-312">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e6d2a-313">См. также</span><span class="sxs-lookup"><span data-stu-id="e6d2a-313">See Also</span></span>  
 <xref:System.Runtime.Serialization.DataContractSerializer>  
 <xref:System.Xml.Serialization.IXmlSerializable>  
 [<span data-ttu-id="e6d2a-314">Использование контрактов данных</span><span class="sxs-lookup"><span data-stu-id="e6d2a-314">Using Data Contracts</span></span>](../../../../docs/framework/wcf/feature-details/using-data-contracts.md)  
 [<span data-ttu-id="e6d2a-315">Типы, поддерживаемые сериализатором контракта данных</span><span class="sxs-lookup"><span data-stu-id="e6d2a-315">Types Supported by the Data Contract Serializer</span></span>](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)
