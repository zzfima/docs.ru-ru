---
title: Изолированная сериализация JSON с использованием DataContractJsonSerializer
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 39d3c0acd75ffd9a54c5e62a15487a2cd8c465cb
ms.sourcegitcommit: dfad244ba549702b649bfef3bb057e33f24a8fb2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/12/2020
ms.locfileid: "75904606"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a>Изолированная сериализация JSON с использованием DataContractJsonSerializer

> [!NOTE]
> Эта статья посвящена <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>. В большинстве сценариев, в которых участвует сериализация и десериализация JSON, мы рекомендуем использовать интерфейсы API в [пространстве имен System. Text. JSON](../../../standard/serialization/system-text-json-overview.md). 

JSON (JavaScript Object Notation, объектная нотация JavaScript) - формат данных, предназначенный специально для использования JavaScript-кодом, выполняемым на веб-страницах внутри браузера. Это формат данных по умолчанию, используемый службами ASP.NET AJAX, созданными в Windows Communication Foundation (WCF).

Его также можно использовать при создании служб AJAX без интеграции с ASP.NET; в данном случае форматом по умолчанию является XML, однако можно выбрать и JSON.

Наконец, если требуется поддержка JSON, однако создаваемая служба не является службой AJAX, сериализатор <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> позволяет непосредственно сериализовать объекты .NET в данные JSON и десериализовать такие данные обратно в экземпляры типов .NET. Описание того, как это сделать, см. [в разделе инструкции. Сериализация и десериализация данных JSON](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).

При работе с JSON поддерживаются те же (за некоторыми исключениями) типы .NET, что поддерживаются сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>. Список поддерживаемых типов см. в разделе Типы, [Поддерживаемые сериализатором контрактов данных](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md). К ним относится большинство примитивных типов, большинство типов массивов и коллекций, а также сложные типы, в которых используются атрибуты <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute>.

## <a name="mapping-net-types-to-json-types"></a>Сопоставление типов .NET типам JSON

В следующей таблице показано соответствие между типами .NET и типами JSON/JavaScript, используемое при сопоставлении в процедурах сериализации и десериализации.

|Типы .NET|JSON/JavaScript|Примечания|
|----------------|----------------------|-----------|
|Все числовые типы, например <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double>|Числовой|Специальные значения, такие как `Double.NaN`, `Double.PositiveInfinity` и `Double.NegativeInfinity`, не поддерживаются и приводят к получению недопустимых JSON-данных.|
|<xref:System.Enum>|Числовой|См. раздел «Перечисления и JSON» ниже.|
|<xref:System.Boolean>|Логическое значение .|--|
|<xref:System.String>, <xref:System.Char>|Строка|--|
|<xref:System.TimeSpan>значение <xref:System.Guid>значение <xref:System.Uri>|Строка|Формат этих типов в JSON такой же, как и в XML (по сути, TimeSpan в формате ISO 8601, GUID в формате "12345678-ABCD-ABCD-ABCD-1234567890AB" и URI в его форме естественной строки, например "http://www.example.com"). Точные сведения см. в разделе [Справочник по схеме контракта данных](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).|
|<xref:System.Xml.XmlQualifiedName>|Строка|Формат - «имя:пространство_имен» (все до первого двоеточия является именем). Имя или пространство имен может отсутствовать. При отсутствии пространства имен можно также опустить двоеточие.|
|<xref:System.Array> типа <xref:System.Byte>|Массив чисел|Каждое число представляет значение одного байта.|
|<xref:System.DateTime>|DateTime или String|См. раздел «Даты-времена и JSON» ниже.|
|<xref:System.DateTimeOffset>|Сложный тип|См. раздел «Даты-времена и JSON» ниже.|
|Типы XML и ADO.NET (<xref:System.Xml.XmlElement>,<br /><br /> <xref:System.Xml.Linq.XElement>. Массивы <xref:System.Xml.XmlNode>,<br /><br /> <xref:System.Runtime.Serialization.ISerializable>,<br /><br /> <xref:System.Data.DataSet>).|Строка|См. раздел «Типы XML и JSON» ниже.|
|<xref:System.DBNull>|Пустой сложный тип|--|
|Коллекции, словари и массивы|Массив|См. раздел «Коллекции, словари и массивы» ниже.|
|Сложные типы (с примененным атрибутом <xref:System.Runtime.Serialization.DataContractAttribute> или <xref:System.SerializableAttribute>)|Сложный тип|Элементы данных становятся элементами сложного типа JavaScript.|
|Сложные типы (реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>)|Сложный тип|Сопоставляется аналогично другим сложным типам, однако некоторые типы <xref:System.Runtime.Serialization.ISerializable> не поддерживаются; см. раздел «Поддержка интерфейса ISerializable» ниже, в разделе «Дополнительные сведения для опытных пользователей».|
|Значение `Null` для любого типа|Null|Типы, допускающие значение null, также поддерживаются и сопоставляются с JSON так же, как и типы, не допускающие значение null.|

### <a name="enumerations-and-json"></a>Перечисления и JSON

Значения элементов перечислений в JSON рассматриваются как числа в отличие от контрактов данных, куда они включаются как имена элементов. Дополнительные сведения о обработке контракта данных см. в разделе [типы перечислений в контрактах данных](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).

- Например, в случае перечисления `public enum Color {red, green, blue, yellow, pink}` при сериализации члена `yellow` получается число 3, а не строка "yellow".

- Все члены типа `enum` сериализуемы. Атрибуты <xref:System.Runtime.Serialization.EnumMemberAttribute> и <xref:System.NonSerializedAttribute> (если они используются) игнорируются.

- Также возможна десериализация несуществующего значения `enum` - например, значение 87 можно десериализовать в упомянутое выше перечисление Color, даже несмотря на отсутствие соответствующего определенного имени цвета.

- Флаговый тип `enum` не является особенным и рассматривается так же, как любой другой тип `enum`.

### <a name="datestimes-and-json"></a>Даты-времена и JSON

Формат JSON не предусматривает непосредственной поддержки дат и времен. Тем не менее, они очень часто используются, и в ASP.NET AJAX предусмотрена особая поддержка для этих типов. При использовании прокси-объектов ASP.NET AJAX тип <xref:System.DateTime> в .NET полностью соответствует типу `DateTime` в JavaScript.

- Если ASP.NET не используется, тип <xref:System.DateTime> представляется в JSON в виде строки особого формата, который описан в разделе "Дополнительные сведения для опытных пользователей" ниже.

- <xref:System.DateTimeOffset> представляется в JSON как сложный тип: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}. Член `offsetMinutes` - это смещение местного времени относительно времени по Гринвичу (GMT, теперь также называемого временем в формате UTC), связанное с местоположением интересующего события. Элемент `dateTime` представляет момент во времени, когда произошло интересующее событие (опять этот элемент становится типом `DateTime` в JavaScript, когда используется ASP.NET AJAX, и строкой, когда ASP.NET AJAX не используется). При сериализации член `dateTime` всегда сериализуется в GMT. Так, если описывается время 3:00 по Нью-Йорку, компонентом времени члена `dateTime` будет "8:00", а смещение в минутах `offsetMinutes` составит 300 (минус 300 минут, или 5 часов, относительно GMT).

  > [!NOTE]
  > В объектах <xref:System.DateTime> и <xref:System.DateTimeOffset> при сериализации в JSON информация сохраняется с точностью только до миллисекунд. Значения меньше миллисекунды (микро- и наносекунды) при сериализации теряются.

### <a name="xml-types-and-json"></a>Типы XML и JSON

Типы XML становятся строками JSON.

- Например, если элемент данных "q" типа XElement содержит \<ABC/>, JSON имеет вид {"q": "\<ABC/>"}.

- Существуют некоторые особые правила, определяющие, как XML-данные заключаются в оболочку; более подробные сведения см. в разделе "Дополнительные сведения для опытных пользователей" ниже.

- При использовании ASP.NET AJAX, если вместо строк JavaScript требуется использовать модель DOM XML, присвойте значение «XML» свойству <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebGetAttribute> или свойству <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> в атрибуте <xref:System.ServiceModel.Web.WebInvokeAttribute>.

### <a name="collections-dictionaries-and-arrays"></a>Коллекции, словари и массивы

Все коллекции, словари и массивы представляются в JSON в виде массивов.

- Все пользовательские типы с атрибутом <xref:System.Runtime.Serialization.CollectionDataContractAttribute> в JSON-представлении игнорируются.

- Словари не являются способом непосредственной работы с JSON. Словарь\<строка, объектная > может быть не поддерживается аналогичным образом в WCF, как ожидалось для работы с другими технологиями JSON. Например, если в словаре строка "abc" сопоставлена строке "xyz", а строка "def" строке 42, JSON-представление будет иметь вид не {"abc":"xyz","def":42}, а [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}].

- Если требуется работать непосредственно с JSON (обращаться к ключам и значениям динамически, без предварительного определения жесткого контракта), можно рассмотреть следующие варианты.

  - Рассмотрите возможность использования примера [слабо типизированной СЕРИАЛИЗАЦИИ JSON (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) .

  - Использование интерфейса <xref:System.Runtime.Serialization.ISerializable> и конструкторов десериализации - эти два механизма позволяют обращаться к парам "ключ-значение" JSON при сериализации и десериализации соответственно, однако не работают в сценариях с частичным доверием.

  - Рассмотрите возможность работы с [сопоставлением между JSON и XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) вместо использования сериализатора.

  - *Полиморфизм* в контексте сериализации относится к возможности сериализации производного типа, где ожидается его базовый тип. Существуют особые (только для JSON) правила, применяющиеся при полиморфном использовании коллекций, например при присвоении коллекции объекту <xref:System.Object>. Этот вопрос более подробно рассмотрен в разделе "Дополнительные сведения для опытных пользователей" ниже.

## <a name="additional-details"></a>Некоторые подробности

### <a name="order-of-data-members"></a>Порядок членов данных

Порядок членов данных при использовании JSON не имеет значения. В частности, даже если задан атрибут <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>, JSON-данные все равно можно сериализовать в любом порядке.

### <a name="json-types"></a>Типы JSON

Тип JSON при десериализации не обязательно должен соответствовать приведенной выше таблице. Например, тип `Int` обычно сопоставляется числу JSON, однако может быть успешно десериализован из строки JSON, при условии, что строка содержит допустимое число. То есть, и {"q":42}, и {"q":"42"} допустимы, если имеется член данных типа `Int` с именем "q".

### <a name="polymorphism"></a>Полиморфизм

Полиморфная сериализация состоит в возможности сериализовать производный тип там, где ожидается его базовый тип. Это поддерживается для сериализации JSON с помощью WCF, сравнимой с способом поддержки сериализации XML. Например, можно сериализовать `MyDerivedType`, где ожидается `MyBaseType`, или сериализовать `Int` там, где ожидается `Object`.

При десериализации производного типа там, где ожидается базовый тип, информация типа может быть потеряна, за исключением случаев десериализации сложных типов. Например, при сериализации типа <xref:System.Uri> там, где ожидается тип <xref:System.Object>, будет получена строка JSON. Если эту строку затем десериализовать обратно в тип <xref:System.Object>, будет возвращен .NET-тип <xref:System.String>. Десериализатор не знает, что строка изначально имела тип <xref:System.Uri>. Как правило, когда ожидается тип <xref:System.Object>, все строки JSON десериализуются как строки .NET, а все массивы JSON, используемые для сериализации коллекций, словарей и массивов .NET, десериализуются как .NET-объекты <xref:System.Array> типа <xref:System.Object>, вне зависимости от того, какими были исходные типы. Логический тип JSON сопоставляется .NET-типу <xref:System.Boolean>. Однако, когда ожидается тип <xref:System.Object>, числа JSON десериализуются в .NET-типы <xref:System.Int32>, <xref:System.Decimal> или <xref:System.Double> (наиболее подходящий тип выбирается автоматически).

При десериализации в тип интерфейса <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> выполняет десериализацию так, как будто объявленный тип - объект.

При работе со своими собственными базовыми и производными типами обычно требуется использовать атрибуты <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> или эквивалентный механизм. Например, если имеется операция, которая имеет `Animal` возвращаемое значение и фактически возвращает экземпляр `Cat` (производный от `Animal`), следует применить <xref:System.Runtime.Serialization.KnownTypeAttribute>к типу `Animal` или <xref:System.ServiceModel.ServiceKnownTypeAttribute> для операции и указать тип `Cat` в этих атрибутах. Дополнительные сведения см. в статье о [известных типах контрактов данных](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).

Подробное описание работы полиморфной сериализации и некоторых ограничений, которые необходимо принимать во внимание при ее использовании, см. в разделе "Дополнительные сведения для опытных пользователей" ниже.

### <a name="versioning"></a>Управление версиями

Возможности управления версиями контрактов данных, включая интерфейс <xref:System.Runtime.Serialization.IExtensibleDataObject>, полностью поддерживаются в JSON. Кроме того, в большинстве случаев можно десериализовать тип в один формат (например, XML) и затем сериализовать его в другой формат (например, JSON) и при этом сохранить данные в <xref:System.Runtime.Serialization.IExtensibleDataObject>. Дополнительные сведения о создании контрактов данных, обладающих прямой совместимостью, см. в разделе [Контракты данных, совместимые с любыми будущими изменениями](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md). Следует помнить, что JSON не придает значения порядку, поэтому любая информация о порядке будет потеряна. Кроме того, JSON не поддерживает множественные пары "ключ/значение" с одним и тем же именем ключа. Наконец, все операции над объектом <xref:System.Runtime.Serialization.IExtensibleDataObject> по своей природе полиморфны - то есть, их производные типы присваиваются типу <xref:System.Object>, базовому типу для всех типов.

## <a name="json-in-urls"></a>JSON в URL-адресах

При использовании конечных точек ASP.NET AJAX с командой GET HTTP (с помощью атрибута <xref:System.ServiceModel.Web.WebGetAttribute>), входящие параметры присутствуют в URL-адресе запроса, а не в теле сообщения. JSON поддерживается даже в URL-адресе запроса, поэтому при наличии операции, которая принимает `Int` с именем "Number" и `Person` сложного типа с именем "p", URL-адрес может выглядеть следующим образом.

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

При использовании диспетчера скриптов ASP.NET AJAX и прокси-объекта для вызова службы этот URL-адрес автоматически формируется прокси-объектом, и увидеть его нельзя. JSON нельзя использовать в URL-адресах на конечных точках, не являющихся конечными точками ASP.NET AJAX.

## <a name="advanced-information"></a>Дополнительные сведения для опытных пользователей

### <a name="iserializable-support"></a>Поддержка интерфейса ISerializable

#### <a name="supported-and-unsupported-iserializable-types"></a>Поддерживаемые и неподдерживаемые типы ISerializable

Как правило, типы, реализующие интерфейс <xref:System.Runtime.Serialization.ISerializable>, полностью поддерживаются при сериализации/десериализации JSON. Однако некоторые из этих типов (включая некоторые типы платформы .NET Framework) реализованы так, что некоторые аспекты, присущие именно сериализации в JSON, не позволяют им правильно десериализоваться:

- При использовании интерфейса <xref:System.Runtime.Serialization.ISerializable> тип отдельных членов данных никогда не известен заранее. Это ведет к полиморфной ситуации, аналогичной десериализации типов в объект. Как уже говорилось, это может привести к потере информации типов в JSON. Например, если тип сериализует в своей реализации `enum` тип <xref:System.Runtime.Serialization.ISerializable>, попытка десериализовать данные обратно в `enum` (без надлежащих приведений) завершится неудачей, поскольку тип `enum` сериализуется в JSON в виде чисел, а числа JSON десериализуются во встроенные числовые типы .NET (Int32, Decimal или Double). Поэтому тот факт, что число когда-то было значением перечисления (`enum`), теряется.

- Тип с интерфейсом <xref:System.Runtime.Serialization.ISerializable>, конструктор десериализации которого основан на определенном порядке десериализации, также может выдать ошибку при десериализации некоторых JSON-данных, поскольку большинство сериализаторов JSON не гарантируют никакого определенного порядка.

#### <a name="factory-types"></a>Типы производства

В то время как интерфейс <xref:System.Runtime.Serialization.IObjectReference> в общем случае поддерживается в JSON, все типы, требующие возможности "типа производства" (возвращения методом <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> экземпляра типа, отличного от типа, реализующего интерфейс), не поддерживаются.

### <a name="datetime-wire-format"></a>Формат DateTime при передаче по линиям связи

Значения типа <xref:System.DateTime> представляются строками JSON вида "/Date(700000+0500)/", где первое число (в данном случае 700000) - это число миллисекунд в часовом поясе GMT по обычному (не летнему) времени, прошедшее с 1 января 1970 г. Это число может быть отрицательным для представления более раннего времени. Часть строки "+0500" является необязательной и показывает, что это время в формате <xref:System.DateTimeKind.Local>, т. е. при десериализации оно должно быть преобразовано в местный часовой пояс. Если эта часть строки отсутствует, время десериализуется как <xref:System.DateTimeKind.Utc>. Собственно число (в данном случае "0500") и его знак (+ или -) игнорируются.

При сериализации времен формата <xref:System.DateTime>, <xref:System.DateTimeKind.Local> и <xref:System.DateTimeKind.Unspecified> времена записываются со смещением, а время формата <xref:System.DateTimeKind.Utc> записывается без смещения.

JavaScript-код клиента ASP.NET AJAX автоматически преобразует такие строки в экземпляры `DateTime` JavaScript. При наличии других строк аналогичного вида, не принадлежащих к типу <xref:System.DateTime> в .NET, они также преобразуются.

Преобразование выполняется только в том случае, если символы "/" экранированы (то есть JSON выглядит следующим образом: "\\/дате (700000 + 0500)\\/"), и по этой причине кодировщик JSON в WCF (включенный <xref:System.ServiceModel.WebHttpBinding>) всегда помещает символ "/" в escape-последовательность.

### <a name="xml-in-json-strings"></a>XML-данные в строках JSON

#### <a name="xmlelement"></a>XmlElement

Тип <xref:System.Xml.XmlElement> сериализуется "как есть", без оболочки. Например, элемент данных «x» типа <xref:System.Xml.XmlElement>, содержащий \<ABC/>, представлен следующим образом:

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a>Массивы типа XmlNode

Объекты <xref:System.Array> типа <xref:System.Xml.XmlNode> помещаются в элемент-оболочку ArrayOfXmlNode в стандартном пространстве имен контракта данных для данного типа. Если "x" - массив, содержащий узел атрибута "N" в пространстве имен "ns", который содержит "value", и пустой узел элемента "M", представление выглядит следующим образом.

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 Атрибуты в пустом пространстве имен в начале массивов XmlNode (перед другими элементами) не поддерживаются.

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a>Типы IXmlSerializable, включая XElement и DataSet

Типы <xref:System.Runtime.Serialization.ISerializable> делятся на "типы содержимого", "типы DataSet" и "типы элементов". Определения этих типов см. в разделе [типы XML и ADO.NET в контрактах данных](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).

Типы содержимого и типы "DataSet" сериализуются аналогично объектам <xref:System.Array> типа <xref:System.Xml.XmlNode>, рассмотренным в предыдущем разделе. Они помещаются в элемент-оболочку, имя и пространство имен которого соответствует имени контракта данных и пространству имен сериализуемого типа.

Типы элементов, такие как <xref:System.Xml.Linq.XElement> сериализуются "как есть", аналогично рассмотренному выше типу <xref:System.Xml.XmlElement>.

### <a name="polymorphism"></a>Полиморфизм

#### <a name="preserving-type-information"></a>Сохранение информации типов

Как уже говорилось, полиморфизм поддерживается в JSON с некоторыми ограничениями. JavaScript - слабо типизированный язык, и идентификация типа обычно не представляет проблем. Однако при использовании JSON для передачи данных между строго типизированной системой (.NET) и слабо типизированной системой (JavaScript) желательно сохранять удостоверение типа. Например, типы с именами контрактов данных "Square" и "Circle" наследуют от типа с именем контракта данных "Shape". Если значение Circle передается из .NET в JavaScript и возвращается в метод .NET, ожидающий тип Shape, то в компоненте .NET желательно знать, что данный объект изначально принадлежал к типу Circle; в противном случае может быть потеряна информация, присутствующая только в производном типе (например, элемент данных radius в типе Circle).

Для сохранения удостоверения типа при сериализации в JSON сложных типов можно добавить "намек на тип", чтобы десериализатор распознавал этот намек и действовал соответствующим образом. "Указание типа" — это пара "ключ-значение" JSON с именем ключа "\_тип \_" (два символа подчеркивания, за которыми следует слово "Type"). Значение представляет собой строку JSON вида "DataContractName:DataContractNamespace" (все до первого двоеточия является именем). Продолжая предыдущий пример, тип "Circle" можно сериализовать следующим образом.

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

Намек на тип очень похож на атрибут `xsi:type`, определенный в стандарте XML Schema Instance и используемый при сериализации/десериализации XML.

Элементы данных с именем "\_\_тип" запрещены из-за возможного конфликта с указанием типа.

#### <a name="reducing-the-size-of-type-hints"></a>Уменьшение размера намеков на тип

Чтобы уменьшить размер сообщений JSON, префикс пространства имен по умолчанию для контракта данных (`http://schemas.datacontract.org/2004/07/`) заменяется символом "#". (Чтобы сделать эту замену обратимой, используется правило экранирования: Если пространство имен начинается с символов "#" или "\\", к ним добавляется дополнительный символ "\\"). Таким же, если "Circle" является типом в пространстве имен "MyApp. Shapes" .NET, его пространство имен по умолчанию `http://schemas.datacontract.org/2004/07/MyApp`. Shapes, а его JSON-представление будет иметь следующий вид.

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

Усеченные (#MyApp. Shapes) и Full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) имена обучены при десериализации.

#### <a name="type-hint-position-in-json-objects"></a>Положение намека на тип в объектах JSON

Обратите внимание, что намек на тип в JSON-представлении должен стоять на первом месте. Это единственный случай, когда порядок пар "ключ/значение" в обработке JSON имеет значение. Например, следующий способ задания намека на тип допустимым не является.

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, используемые клиентскими страницами WCF и ASP.NET AJAX, всегда сначала выдают подсказку типа.

#### <a name="type-hints-apply-only-to-complex-types"></a>Намеки на тип применяются только к сложным типам

Способа выдавать намек на тип для несложных типов не существует. Например, если операция имеет тип возвращаемого значения <xref:System.Object>, однако возвращает тип "Circle", JSON-представление может выглядеть так, как показано выше, и информация типа сохраняется. Однако если возвращается универсальный код ресурса (URI), JSON-представление будет строкой, и тот факт, что строка используется для представления URI, теряется. Это относится не только к примитивным типам, но также к коллекциям и массивам.

#### <a name="when-are-type-hints-emitted"></a>Когда выдается намеки на тип

Намеки на тип могут значительно увеличить размер сообщения (один из способов борьбы с этим - использовать более короткие пространства имен контрактов данных, если это возможно). По этой причине выдача намеков на тип подчиняется следующим правилам.

- При использовании ASP.NET AJAX намеки на тип выдаются всегда, когда это возможно, даже при отсутствии присвоения базовый/производный - например, даже если тип "Circle" присваивается типу "Circle". (Это необходимо, чтобы в полной мере обеспечить возможность вызова из слабо типизированной среды JSON методов строго типизированной среды .NET без неожиданных потерь информации.)

- При использовании служб AJAX без интеграции с ASP.NET намеки на тип выдаются только при наличии присвоения базовый/производный - т. е. когда тип "Circle" присваивается типу "Shape" или типу <xref:System.Object>, но не при присвоении типа "Circle" типу "Circle". Это минимум информации, необходимый для правильной реализации клиента JavaScript, что повышает производительность, но не защищает от потери информации о типах в неправильно спроектированных клиентах. Избегайте присвоений базовый/производный на сервере в принципе, чтобы избежать необходимости решения этой проблемы на клиенте.

- При использовании типа <xref:System.Runtime.Serialization.DataContractSerializer> параметр конструктора `alwaysEmitTypeInformation` позволяет выбрать один из двух упомянутых выше режимов; по умолчанию используется значение "`false`" (выдавать намеки на тип только тогда, когда это необходимо).

#### <a name="duplicate-data-member-names"></a>Повторяющиеся имена членов данных

Информация производного типа присутствует в одном объекте JSON вместе с информацией базового типа и может следовать в любом порядке. Например, `Shape` можно представить следующим образом.

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

При этом тип "Circle" может быть представлен следующим образом.

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

Если базовый тип `Shape` также содержал элемент данных с именем "`radius`", это приводит к конфликту в обеих сериализации (поскольку объекты JSON не могут иметь повторяющиеся имена ключей) и десериализации (поскольку неясно, относится ли "RADIUS" к `Shape.radius` или `Circle.radius`). Следовательно, тогда как использовать принцип "сокрытия свойств" (члены данных с одинаковым именем в базовом и производном классах) в классах контрактов данных обычно не рекомендуется, в случае с JSON его использование прямо запрещено.

#### <a name="polymorphism-and-ixmlserializable-types"></a>Полиморфизм и типы IXmlSerializable

Типы <xref:System.Xml.Serialization.IXmlSerializable> можно полиморфно присваивать друг другу как обычно, при условии выполнения требований "известных типов" в соответствии с обычными правилами контракта данных. Однако сериализация типа <xref:System.Xml.Serialization.IXmlSerializable> вместо типа <xref:System.Object> приводит к потере информации типа, поскольку результатом сериализации является строка JSON.

#### <a name="polymorphism-and-certain-interface-types"></a>Полиморфизм и некоторые типы интерфейсов

Запрещается сериализовать тип коллекции или тип, реализующий интерфейс <xref:System.Xml.Serialization.IXmlSerializable>, там, где ожидается не являющийся коллекцией тип, который не сериализуется с использованием <xref:System.Xml.Serialization.IXmlSerializable> (за исключением <xref:System.Object>). Например, Пользовательский интерфейс с именем `IMyInterface` и `MyType` типа, реализующий как <xref:System.Collections.Generic.IEnumerable%601> типа `int`, так и `IMyInterface`. Запрещено возвращать `MyType` из операции, тип возвращаемого значения которой `IMyInterface`. Это обусловлено тем, что `MyType` должны быть сериализованы как массив JSON и требует указания типа, как указано перед включением указания типа с массивами, только со сложными типами.

#### <a name="known-types-and-configuration"></a>Известные типы и конфигурация

Все механизмы "известных типов", используемые сериализатором <xref:System.Runtime.Serialization.DataContractSerializer>, аналогичным образом поддерживаются сериализатором <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>. Оба сериализатора считывают один и тот же элемент конфигурации, [\<dataContractSerializer >](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) в [\<System. runtime. Serialization >](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md)для обнаружения известных типов, добавленных с помощью файла конфигурации.

#### <a name="collections-assigned-to-object"></a>Коллекции, присвоенные объекту

Коллекции, присвоенные объекту, сериализуются так, как будто они реализуют интерфейс <xref:System.Collections.Generic.IEnumerable%601>: в виде массива JSON, где каждая запись имеет намек на тип, если это сложный тип. Например, <xref:System.Collections.Generic.List%601> типа `Shape`, назначенный <xref:System.Object>, выглядит следующим образом.

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

При десериализации обратно в <xref:System.Object>:

- `Shape` должен быть в списке известных типов. Наличие <xref:System.Collections.Generic.List%601> типа `Shape` в известных типах не оказывает никакого влияния. Обратите внимание, что в этом случае не нужно добавлять `Shape` в известные типы для сериализации. Это выполняется автоматически.

- Коллекция десериализуется как <xref:System.Array> типа <xref:System.Object>, содержащего экземпляры `Shape`.

#### <a name="derived-collections-assigned-to-base-collections"></a>Производные коллекции, присвоенные базовым коллекциям

При присвоении производной коллекции базовой коллекции коллекция обычно сериализуется так, как если бы она была коллекцией базового типа. В то же время тип элемента производной коллекции нельзя присвоить типу элемента базовой коллекции: вызывается исключение.

#### <a name="type-hints-and-dictionaries"></a>Намеки на тип и словари

При присвоении словаря объекту <xref:System.Object> каждая запись "ключ" и "значение" в словаре рассматривается так, как если бы она была присвоена объекту <xref:System.Object>, и получает намек на тип.

При сериализации типов словарей на объект JSON, содержащий члены "Key" и "Value", не влияет значение параметра `alwaysEmitTypeInformation`: он содержит намек на тип только там, где этого требуют рассмотренные выше правила сериализации коллекций.

### <a name="valid-json-key-names"></a>Допустимые имена ключей JSON

Сериализатор кодирует в XML имена ключей, не являющиеся допустимыми XML-именами. Например, элемент данных с именем "123" будет иметь закодированное имя, например "\_x0031\_\_x0032\_\_x0033\_", так как "123" является недопустимым именем XML-элемента (начинается с цифры). Аналогичная ситуация может возникнуть с некоторыми международными кодировками, которые не допускаются в XML-именах. Объяснение этого влияния обработки XML на JSON см. в разделе [сопоставление JSON и XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).

## <a name="see-also"></a>См. также:

- [Поддержка JSON и других форматов передачи данных](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
