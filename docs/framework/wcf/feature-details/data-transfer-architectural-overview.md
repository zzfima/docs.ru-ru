---
title: "Общие сведения об архитектуре передачи данных"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
caps.latest.revision: "14"
author: Erikre
ms.author: erikre
manager: erikre
ms.openlocfilehash: a2adbc1e281e978c1f579d1e7b0cc0cf75cd36a6
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="data-transfer-architectural-overview"></a>Общие сведения об архитектуре передачи данных
[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] можно рассматривать как инфраструктуру обмена сообщениями, где происходит получение, обработка и направление сообщений в пользовательский код для дальнейших действий или создание сообщений из данных, предоставленных пользовательским кодом, и доставка этих сообщений по назначению. В данном разделе, предназначенном для опытных программистов, описывается архитектура для обработки сообщений и данных, которые в них содержатся. Упрощенное изложение практических аспектов отправки и получения данных приводится в разделе [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).  
  
> [!NOTE]
>  В данном разделе представлены сведения о реализации [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] , которые не видны при просмотре объектной модели [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] . Прежде чем приступать к описанию задокументированной реализации компонента, необходимо принять во внимание два замечания. Во-первых, все представленные описания упрощены, на практике реализация может быть более сложной из-за оптимизаций или по другим причинам. Во-вторых, никогда не стоит полагаться на определенные сведения о реализации (даже задокументированные), так как они могут изменяться без уведомления от версии к версии или даже в отдельных наборах исправлений.  
  
## <a name="basic-architecture"></a>Базовая архитектура  
 В основе возможности обработки сообщений [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] лежит класс <xref:System.ServiceModel.Channels.Message> , который подробно описывается в разделе [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md). Компоненты времени выполнения [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] можно разделить на две основные группы: стек каналов и инфраструктура служб, точкой подключения которых является класс <xref:System.ServiceModel.Channels.Message> .  
  
 Стек каналов отвечает за преобразование между допустимым экземпляром <xref:System.ServiceModel.Channels.Message> и определенным действием, соответствующим отправке или получению данных сообщения. На отправляющей стороне стек каналов берет допустимый экземпляр <xref:System.ServiceModel.Channels.Message> и после определенной обработки совершает некое действие, логически соответствующее отправке сообщения. Это действие может заключаться в отправке TCP- или HTTP-пакетов, постановке сообщения в очередь сообщений, записи сообщения в базу данных, сохранении его в общей папке или любой другой операции в зависимости от реализации. Наиболее распространенным действием является отправка сообщения по сетевому протоколу. На получающей стороне происходят противоположные процессы: стек каналов обнаруживает действие (например, прибытие TCP- или HTTP-пакетов или любое другое действие), обрабатывает его и преобразует в допустимый экземпляр <xref:System.ServiceModel.Channels.Message> .  
  
 Работа с [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] может осуществляться в форме непосредственного использования класса <xref:System.ServiceModel.Channels.Message> и стека каналов. Однако такой подход сложен и может занимать много времени. Более того, объект <xref:System.ServiceModel.Channels.Message> не поддерживает метаданные, поэтому при таком использовании [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] невозможно создавать строго типизированные клиенты [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] .  
  
 Поэтому [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] включает инфраструктуру службы, предоставляющую простую в использовании модель программирования, которую можно использовать для создания и получения объектов `Message` . Инфраструктура службы сопоставляет службы с типами [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] через понятие контрактов служб и направляет сообщения в операции пользователей, которые представляют собой методы [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] , отмеченные атрибутом <xref:System.ServiceModel.OperationContractAttribute> (дополнительные сведения см. в разделе [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md)). Эти методы могут содержать параметры и возвращать значения. На стороне службы инфраструктура службы преобразует входящие экземпляры <xref:System.ServiceModel.Channels.Message> в параметры, а возвращаемые значения - в исходящие экземпляры <xref:System.ServiceModel.Channels.Message> . На стороне клиента инфраструктура службы выполняет противоположные действия. Например, см. операцию `FindAirfare` ниже.  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 Предположим, операция `FindAirfare` вызывается на стороне клиента. Инфраструктура службы на стороне клиента преобразует параметры `FromCity` и `ToCity` в исходящий экземпляр <xref:System.ServiceModel.Channels.Message> и передает его стеку каналов для отправки.  
  
 Когда экземпляр <xref:System.ServiceModel.Channels.Message> прибывает из стека каналов, на стороне службы инфраструктура службы извлекает из сообщения необходимые для заполнения параметров `FromCity` и `ToCity` данные, а затем вызывает метод `FindAirfare` на стороне службы. Когда метод возвращается, инфраструктура службы создает из возвращенного целочисленного значения и выходного параметра `IsDirectFlight` экземпляр объекта <xref:System.ServiceModel.Channels.Message> , содержащий данную информацию. Затем инфраструктура службы передает экземпляр `Message` стеку каналов для отправки обратно клиенту.  
  
 На стороне клиента из стека каналов появляется экземпляр <xref:System.ServiceModel.Channels.Message> , содержащий ответное сообщение. Инфраструктура службы извлекает возвращаемое значение и значение `IsDirectFlight` и возвращает их вызывающему объекту на стороне клиента.  
  
## <a name="message-class"></a>Класс сообщений  
 Подразумевается, что класс <xref:System.ServiceModel.Channels.Message> является абстрактным представлением сообщения, однако его структура строго связана с сообщением SOAP. Сообщение <xref:System.ServiceModel.Channels.Message> содержит три основных элемента информации: текст сообщения, заголовки сообщения и свойства сообщения.  
  
## <a name="message-body"></a>Текст сообщения  
 В теле сообщения представляется фактическая полезная нагрузка данных сообщения. Текст сообщения всегда представляется как набор сведений XML. Это не означает, что все сообщения, создаваемые или получаемые в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] , должны иметь формат XML. Стек каналов определяет, как интерпретировать текст сообщения. Он может отобразить текст сообщения в формате XML, преобразовать в другой формат или даже опустить его. Конечно, с большинством поставляемых [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] привязок текст сообщения представляется в виде содержимого в формате XML в основном разделе конверта SOAP.  
  
 Следует помнить, что в классе `Message` не обязательно содержится буфер с представляющими текст данными в формате XML. Логически сообщение `Message` содержит набор сведений XML, однако этот набор данных может создаваться динамически и никогда физически не существовать в памяти.  
  
### <a name="putting-data-into-the-message-body"></a>Размещение данных в теле сообщения  
 Не существует универсального механизма размещения данных в теле сообщения. Класс <xref:System.ServiceModel.Channels.Message> имеет абстрактный метод ( <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>), который принимает <xref:System.Xml.XmlDictionaryWriter>. Каждый подкласс класса <xref:System.ServiceModel.Channels.Message> отвечает за переопределение этого метода и запись собственного содержимого. Текст сообщения логически содержит набор сведений XML, создаваемый `OnWriteBodyContent` . Например, рассмотрим следующий подкласс `Message` .  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 Физически экземпляр `AirfareRequestMessage` содержит только две строки ("fromCity" и "toCity"). Однако логически сообщение содержит следующий набор сведений XML:  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 Конечно, обычно сообщения не создаются таким образом, потому что сообщения, подобные предыдущему, создаются с помощью инфраструктуры службы из параметров контракта операций подобно предыдущему. Более того, класс <xref:System.ServiceModel.Channels.Message> содержит статические методы `CreateMessage` , которые могут использоваться для создания сообщений с содержимым стандартных типов: пустое сообщение, сообщение, которое содержит сериализованный в XML с <xref:System.Runtime.Serialization.DataContractSerializer>объект, сообщение, которое содержит ошибку SOAP, сообщение, которое содержит XML, представленный <xref:System.Xml.XmlReader>, и т. д.  
  
### <a name="getting-data-from-a-message-body"></a>Получение данных из тела сообщения  
 Данные, которые хранятся в теле сообщения, можно извлекать двумя основными способами:  
  
-   Вы можете получить весь текст сообщения одновременно, вызвав метод <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> и передавая в средство записи XML. Весь текст сообщения записывается в это средство записи. Получение всего тела сообщения одновременно также называется *запись сообщения*. Запись осуществляется в основном стеком каналов при отправке сообщений - как правило, какая-либо часть стека каналов получает доступ к всему телу сообщения, кодирует и отправляет его.  
  
-   Еще одним способом извлечения информации из тела сообщения является вызов <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> и получение средства чтения XML. В этом случае доступ к телу сообщения может осуществляться последовательно по мере необходимости посредством вызова методов для средства чтения. Получение тела сообщения по частям также называется *прочтение сообщения*. Прочтение сообщения в основном используется инфраструктурой службы при получении сообщений. Например, при использовании <xref:System.Runtime.Serialization.DataContractSerializer> инфраструктура службы размещает средство чтения XML над текстом сообщения, а затем передает его механизму десериализации, который начинает считывать сообщение по элементам и создавать соответствующий граф объекта.  
  
 Текст сообщения можно извлечь только один раз. Это позволяет работать с потоками только в прямом направлении. Например, вы можете записать переопределение <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> , выполняющее чтение из потока <xref:System.IO.FileStream> и возвращающее результаты в виде набора сведений XML. Никогда не потребуется «перемотке назад» в начало файла.  
  
 Методы `WriteBodyContents` и `GetReaderAtBodyContents` просто проверяют, что тело сообщения никогда ранее не извлекалось, а затем вызывают `OnWriteBodyContents` или `OnGetReaderAtBodyContents`соответственно.  
  
## <a name="message-usage-in-wcf"></a>Использование сообщений в WCF  
 Большинство сообщений можно разбить на две группы: *исходящие* (создаваемые инфраструктурой службы для отправки стеком каналов) или *входящие* (прибывающие из стека каналов и интерпретируемые инфраструктурой службы). Более того, стек каналов может работать в режиме буферизации или в режиме потока. Инфраструктура службы также может отображать потоковую или непотоковую модель программирования. В связи с этим необходимо привести следующую таблицу, в которой перечисляются различные варианты использования сообщений, а также сообщаются упрощенные сведения об их реализации.  
  
|Тип сообщения|Данные основного текста в сообщении|Реализация записи (OnWriteBodyContents)|Реализация чтения (OnGetReaderAtBodyContents)|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|Исходящие, созданные из непотоковой модели программирования|Данные, необходимые для записи сообщения (например, объект и экземпляр <xref:System.Runtime.Serialization.DataContractSerializer> , необходимый для его сериализации)*|Пользовательская логика для записи сообщения на основании сохраненных данных (например, вызов метода `WriteObject` сериализатора `DataContractSerializer` , если используется именно этот сериализатор)*|Вызов `OnWriteBodyContents`, буферизация результатов, возврат средства чтения XML над буфером|  
|Исходящие, созданные из потоковой модели программирования|Объект `Stream` с записываемыми данными*|Запись данных из сохраненного потока с помощью механизма <xref:System.Xml.IStreamProvider> *|Вызов `OnWriteBodyContents`, буферизация результатов, возврат средства чтения XML над буфером|  
|Входящие из потокового стека каналов|Объект `Stream` , который представляет поступающие через сеть данные с помощью <xref:System.Xml.XmlReader> над ним|Запись содержимого из сохраненного `XmlReader` с помощью `WriteNode`|Возвращает сохраненное средство чтения `XmlReader`.|  
|Входящие из непотокового стека каналов|Буфер, который содержит данные основного текста и `XmlReader` над ними|Записывает содержимое из сохраненного `XmlReader` с помощью `WriteNode`|Возвращает сохраненный атрибут lang|  
  
 \*Эти элементы не реализуются непосредственно в `Message` подклассов, а в подклассах <xref:System.ServiceModel.Channels.BodyWriter> класса. Дополнительные сведения о веб-службе <xref:System.ServiceModel.Channels.BodyWriter>см. в разделе [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).  
  
## <a name="message-headers"></a>Заголовки сообщений  
 Сообщение может содержать заголовки. Логически заголовок состоит из набора сведений XML, связанного с именем, пространством имен и несколькими другими свойствами. Доступ к заголовкам сообщения осуществляется с помощью свойства `Headers` сообщения <xref:System.ServiceModel.Channels.Message>. Каждый заголовок представляется классом <xref:System.ServiceModel.Channels.MessageHeader> . Как правило, заголовки сообщения сопоставляются с заголовками сообщения SOAP при использовании стека каналов, настроенного на работу с сообщениями SOAP.  
  
 Размещение данных в заголовке сообщения и извлечение данных из заголовка аналогичны использованию тела сообщения. Процесс несколько упрощается из-за того, что в заголовках не поддерживается потоковая передача. Доступ к содержимому одного и того же заголовка можно осуществлять более одного раза, кроме того, это можно делать в произвольном порядке, каждый раз принудительно вызывая буферизацию заголовков. Не существует универсального механизма, позволяющего получить средство чтения XML над заголовком, однако в `MessageHeader` имеется внутренний подкласс [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] , который представляет собой доступный для чтения заголовок с такой возможностью. Этот тип заголовка `MessageHeader` создается стеком каналов, когда приходит сообщение с заголовками пользовательского приложения. Это позволяет инфраструктуре службы использовать для интерпретации этих заголовков механизм десериализации, такой как <xref:System.Runtime.Serialization.DataContractSerializer>.  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).  
  
## <a name="message-properties"></a>Свойства сообщения  
 Сообщение может содержать свойства. *Свойство* - это любой объект [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] , связанный с именем строки. Доступ к свойствам осуществляется через свойство `Properties` сообщения `Message`.  
  
 В отличие от тела и заголовков сообщения (которые обычно сопоставляются с текстом и заголовками сообщения SOAP соответственно) свойства сообщения, как правило, не отправляются и не принимаются вместе с этими сообщениями. Свойства сообщения существуют в основном в качестве механизма связи для передачи данных о сообщении между различными каналами в стеке каналов, а также между стеком каналов и моделью служб.  
  
 Например, канал транспорта HTTP, включаемый в состав [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] , способен при отправке ответов клиентам создавать различные коды состояния HTTP, такие как состояние "404 (не найдено)" и "500 (внутренняя ошибка сервера)". До отправки ответного сообщения, проверяется ли `Properties` из `Message` содержат свойство с именем «httpResponse», который содержит объект типа <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>. Если это свойство найдено, канал транспорта обращается к свойству <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> и использует указанный код состояния. Если свойство не найдено, используется код по умолчанию - «200 (ОК)».  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).  
  
### <a name="the-message-as-a-whole"></a>Сообщение как единое целое  
 До сих пор мы обсуждали методы доступа к различным частям сообщения по отдельности. Однако класс <xref:System.ServiceModel.Channels.Message> также предоставляет методы для работы с сообщением как единым целым. Например, метод `WriteMessage` записывает все сообщение в средство записи XML.  
  
 Для этого необходимо задать сопоставление между всем экземпляром `Message` и набором сведений XML. Фактически, такое сопоставление уже существует: [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] использует стандарт SOAP для определения такого сопоставления. Когда экземпляр `Message` записывается как набор сведений XML, итоговый набор данных является допустимым конвертом SOAP, который содержит соответствующее сообщение. Следовательно, `WriteMessage` , как правило, выполняет следующие шаги:  
  
1.  записывает открывающий тег элемента конверта SOAP,  
  
2.  записывает открывающий тег элемента заголовка SOAP, записывает все заголовки и закрывает элемент заголовка,  
  
3.  записывает открывающий тег элемента тела сообщения SOAP,  
  
4.  вызывает `WriteBodyContents` или другой эквивалентный метод для записи тела сообщения,  
  
5.  закрывает элементы тела и конверта.  
  
 Описанные выше шаги тесно связаны со стандартом SOAP. Ситуация осложняется наличием нескольких версий SOAP, так как, например, невозможно правильно записать элемент конверта SOAP, не имея точной информации об используемой версии SOAP. В некоторых случаях, кроме того, желательно полностью отключить это сложное сопоставление с протоколом SOAP.  
  
 Для этих целей в сообщении `Version` предусмотрено свойство `Message`. Это свойство можно настроить на указание версии SOAP, которая должна использоваться при записи сообщения, или установить на `None` , чтобы запретить любые сопоставления с протоколом SOAP. Если свойство `Version` установлено на `None`, методы, работающие с целым сообщением, функционируют как если бы сообщение состояло только из тела, например метод `WriteMessage` в этом случае просто вызывает `WriteBodyContents` , а не выполняет описанную выше последовательность действий. Предполагается, что для входящих сообщений `Version` будет определяться автоматически и, следовательно, задаваться верно.  
  
## <a name="the-channel-stack"></a>Стек каналов  
  
### <a name="channels"></a>Каналы  
 Как уже говорилось выше, стек каналов отвечает за преобразование исходящих экземпляров <xref:System.ServiceModel.Channels.Message> в какое-либо действие (например, отправку пакетов по сети) или преобразование какого-либо действия (например, получения сетевых пакетов) во входящие экземпляры `Message` .  
  
 Стек каналов представляет собой один или более каналов, упорядоченных определенным образом. Исходящий экземпляр `Message` передается первому каналу стека (также называемому *верхним каналом*), который передает экземпляр следующему каналу стека (каналу более низкого уровня) и т. д. Завершение сообщения происходит в последнем канале, именуемом *канал транспорта*. Входящие сообщения создаются в канале транспорта и передаются в стеке от каналов более низкого уровня к каналам более высокого уровня. С верхнего канала сообщение, как правило, передается в инфраструктуру службы. Хотя это стандартная процедура обработки сообщений приложения, некоторые каналы могут работать по несколько иной схеме, например они могут отправлять собственные инфраструктурные сообщения, а не передавать сообщения, полученные от каналов более высокого уровня.  
  
 Каналы могут по-разному оперировать сообщениями при прохождении последних через стек. Наиболее распространенной операцией является добавление заголовка к исходящему сообщению и чтение заголовков входящего сообщения. Например, канал может вычислить цифровую подпись в сообщении и добавить ее в качестве заголовка. Канал также может проверить заголовок входящих сообщений, содержащий цифровую подпись, и заблокировать сообщения, которые не имеют действительной подписи (т. е. запретить их передачу по стеку каналов). Каналы часто используются для установки и проверки свойств сообщения. Текст сообщения, как правило, не изменяется, хотя это и допустимо (например, безопасный канал [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] может шифровать текст сообщения).  
  
### <a name="transport-channels-and-message-encoders"></a>Каналы транспорта и кодировщики сообщений  
 Самый нижний канал стека отвечает за фактическое преобразование исходящего сообщения <xref:System.ServiceModel.Channels.Message>, измененного другими каналами, в какое-либо действие. На принимающей стороне этот канал преобразует действие в сообщение `Message` , которое обрабатывается другими каналами.  
  
 Как уже говорилось ранее, действия могут быть самыми разнообразными: например, отправка или получение сетевых пакетов по различным протоколам, чтение или запись сообщений в базу данных, постановка сообщений в очередь сообщений или удаление сообщений из очереди. Все эти действия схожи в том, что их выполнение требует преобразования между экземпляром [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]`Message` и фактической группой байтов, которую можно отправлять, принимать, читать, записывать, ставить в очередь и удалять из нее. Процесс преобразования `Message` в группу байтов называется *кодированием*, а обратный процесс создания `Message` из группы байтов - *декодированием*.  
  
 Большинство каналов транспорта для кодирования и декодирования используют компоненты под названием *кодировщики сообщений* . Кодировщик сообщений - это подкласс класса <xref:System.ServiceModel.Channels.MessageEncoder> . `MessageEncoder` включает различные перегрузки метода `ReadMessage` и `WriteMessage` , позволяющие производить преобразование из `Message` в группу байтов и обратно.  
  
 На отправляющей стороне буферизующий канал транспорта передает объект `Message` , полученный от канала более высокого уровня, методу `WriteMessage`. Он возвращает массив байтов, который затем использует для выполнения действия (например, упаковки этих байтов в виде действительных TCP-пакетов и отправки их по назначению). Потоковый канал транспорта сначала создает поток `Stream` (например, через исходящее TCP-соединение), а затем передает поток `Stream` и сообщение `Message` , которые он должен отправить записывающей сообщение перегрузке соответствующего метода `WriteMessage` .  
  
 На получающей стороне буферизующий канал транспорта извлекает входящие байты (например, от входящих TCP-пакетов) в массив и вызывает метод `ReadMessage` , чтобы получить объект `Message` для передачи по стеку каналов. Потоковый канал транспорта создает объект `Stream` (например, сетевой поток по входящему TCP-подключению) и передает его `ReadMessage` , чтобы возвратить объект `Message` .  
  
 Разделение между каналами транспорта и кодировщиком сообщений не является обязательным; можно создать канал транспорта, который не использует кодировщик сообщений. Однако преимуществом подобного разделения является простота построения. Если канал транспорта использует только базу <xref:System.ServiceModel.Channels.MessageEncoder>, он может работать с кодировщиком сообщений [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] или любым сторонним кодировщиком. Аналогично, один и тот же кодировщик, как правило, можно использовать в любом канале транспорта.  
  
### <a name="message-encoder-operation"></a>Операции кодировщика сообщений  
 Для того чтобы описать стандартные операции, выполняемые кодировщиком сообщений, рекомендуется рассмотреть следующие четыре случая.  
  
|Операция|Комментарий|  
|---------------|-------------|  
|Кодирование (с буферизацией)|В режиме буферизации кодировщик, как правило, создает буфер с переменным размером, а затем создает над ним средство записи XML. После этого кодировщик вызывает метод <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> для кодируемого сообщения, который записывает заголовки и текст сообщения с помощью <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>(см. пояснение в предыдущем подразделе данного раздела, `Message` ). Содержимое буфера (представленное в виде массива байтов) затем возвращается каналу транспорта для дальнейшего использования.|  
|Кодирование (потоковое)|При работе в потоковом режиме операция также выполняется согласно данному выше описанию, при этом ситуация упрощается тем, что нет необходимости использовать буфер. Как правило, средство записи XML создается над потоком, а метод <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> вызывается для сообщения `Message` , чтобы записать его в это средство записи.|  
|Декодирование (с буферизацией)|При декодировании в режиме буферизации, как правило, создается специальный подкласс `Message` , который содержит буферизованные данные. Считываются заголовки сообщения, создается средство чтения XML и устанавливается в теле письма. Это средство чтения, которое будет возвращено с <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.|  
|Декодирование (потоковое)|При декодировании в потоковом режиме, как правило, создается специальный подкласс "Сообщения". Поток перемещается вперед ровно настолько, чтобы прочитать все заголовки и разместить их в теле сообщения. Затем над потоком создается средство чтения XML. Это средство чтения, которое будет возвращено с <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.|  
  
 Кодировщики могут выполнять и другие функции. Например, они могут объединять в пул средства чтения и записи XML. Не рационально создавать новое средство чтения или записи XML всякий раз, когда в них возникает необходимость. Поэтому кодировщики, как правило, поддерживают пул средств чтения и пул средств записи настраиваемого размера. В описаниях операции кодировщика, описанной выше каждый раз, когда фразу «Создание чтения/записи XML» используется, как правило, означают «взять из пула или создайте его, если он не доступен.» Кодировщик (и подклассы `Message` , создаваемые им при декодировании) содержит логику для возвращения средств чтения и записи в пулы, если эти средства более не нужны (например, при закрытии `Message` ).  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] предоставляет три типа кодировщика сообщений, хотя при необходимости возможно создать дополнительные пользовательские типы. Это текстовое и двоичное кодирование и механизм оптимизации передачи сообщений (MTOM). Эти типы подробно описаны в разделе [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md).  
  
### <a name="the-istreamprovider-interface"></a>Интерфейс IStreamProvider  
 При записи исходящего сообщения с потоковым текстом в средство записи XML <xref:System.ServiceModel.Channels.Message> использует в реализации <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> последовательность вызовов, подобную описанной ниже:  
  
-   Запись всех необходимых данных, предшествующих потоку (например, открывающий тег XML).  
  
-   запись потока;  
  
-   Запись данных, следующих за потоком (например, закрывающий тег XML).  
  
 Этот подход хорошо работает с кодировками, подобными текстовой кодировке XML. Однако некоторые кодировки не размещают информацию набора сведений XML (например, теги начальных и конечных XML-элементов) вместе с данными, которые содержатся внутри элементов. Например, при кодировании MTOM сообщение разделяется на несколько частей. Одна часть содержит набор сведений XML, в том числе, возможно, и ссылки на другие части фактического содержимого элемента. Набор сведений XML, как правило, сравнительно мал по сравнению с потоковым содержимым, поэтому имеет смысл его буферизировать, сохранить, а затем записать содержимое потоковым способом. Это означает, что к моменту записи закрывающего тега элемента поток должен быть не сохранен.  
  
 Для этого используется интерфейс <xref:System.Xml.IStreamProvider> . Этот интерфейс содержит метод <xref:System.Xml.IStreamProvider.GetStream> , который возвращает поток, подлежащий записи. Ниже описан правильный способ сохранения потокового тела сообщения в <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> .  
  
1.  Запись всех необходимых данных, предшествующих потоку (например, открывающий тег XML).  
  
2.  Вызов перегрузки `WriteValue` для <xref:System.Xml.XmlDictionaryWriter> , принимающего <xref:System.Xml.IStreamProvider>, с реализацией `IStreamProvider` , возвращающей подлежащий записи поток.  
  
3.  Запись данных, следующих за потоком (например, закрывающий тег XML).  
  
 Используя этот подход, средство записи XML может выбирать, когда вызывать <xref:System.Xml.IStreamProvider.GetStream> и сохранять потоковые данные. Например, средства записи текстовых и двоичных данных XML немедленно вызывают его и записывают потоковое содержимое между открывающим и закрывающим тегами. Средство записи MTOM может вызвать <xref:System.Xml.IStreamProvider.GetStream> позже, когда будет готово к записи соответствующей части сообщения.  
  
## <a name="representing-data-in-the-service-framework"></a>Представление данных в инфраструктуре службы  
 Как отмечается в подразделе "Базовая архитектура" данного раздела, инфраструктура службы - это часть [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] , которая, кроме всего прочего, отвечает за преобразование между удобной для пользователей моделью программирования данных сообщения и фактическими экземплярами `Message` . Как правило, обмен сообщениями представляется в инфраструктуре службы как метод [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] , отмеченный атрибутом <xref:System.ServiceModel.OperationContractAttribute> . Метод может брать несколько параметров и возвращать возвращаемое значение или выходные параметры (или и то, и другое). На стороне службы входные параметры представляют входящее сообщение, а возвращаемое значение и выходные параметры - исходящее сообщение. На стороне клиента происходит обратное представление. Подробные сведения о модели программирования для описания сообщений с помощью параметров и возвращаемого значения см. в разделе [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md). А в этом разделе приводится краткий обзор моделей.  
  
## <a name="programming-models"></a>Модели программирования  
 Инфраструктура службы [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] поддерживает пять разных моделей программирования для описания сообщений.  
  
### <a name="1-the-empty-message"></a>1. Пустое сообщение  
 Это простейший случай. Для описания пустого входящего сообщения не нужно использовать какие-либо входные параметры.  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 Для описания пустого исходящего сообщения нужно использовать возвращаемое значение типа void, выходные параметры при этом не используются.  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 Обратите внимание, что это описание отличается от контракта односторонних операций.  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 В примере `SetDesiredTemperature` описывается шаблон двустороннего обмена сообщениями. Сообщение возвращается от операции, но при этом оно пустое. От операции также можно возвратить ошибку. В примере "Set Lightbulb" описывается шаблон одностороннего обмена сообщениями, поэтому не требуется описание исходящего сообщения. В этом случае служба не может передать обратно клиенту какое-либо состояние.  
  
### <a name="2-using-the-message-class-directly"></a>2. Использование класса сообщений напрямую  
 Класс <xref:System.ServiceModel.Channels.Message> (или один из его подклассов) можно использовать напрямую в контракте операций. В этом случае инфраструктура службы только передает сообщение `Message` от операции стеку каналов и обратно без какой-либо дальнейшей обработки.  
  
 Существует два основных варианта непосредственного использования `Message` . Его можно использовать в продвинутых сценариях, если ни одна из других моделей программирования не является достаточно гибкой для описания данного сообщения. Например, для описания сообщения можно использовать файлы на диске, тогда свойства файла становятся заголовками сообщения, а его содержимое - текстом сообщения. В этом случае можно создать что-нибудь подобное описанному ниже.  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 Второй распространенный вариант использования `Message` в контракте операций применяется в случае, когда для службы не имеет значения содержимое конкретного сообщения, и служба рассматривает сообщение в качестве "черного ящика". Например, имеется служба, которая пересылает сообщения нескольким другим получателям. В этом случае контракт можно записать следующим образом.  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 Действие = "*» строки эффективно отключает функцию перенаправления сообщений и гарантирует, что всех сообщений, отправленных `IForwardingService` контракта сделать их способ `ForwardMessage` операции. (Как правило, диспетчер анализирует заголовка сообщения «Действие», чтобы определить, какую операцию, он предназначен для. Действие =»\*"означает «все возможные значения для заголовка действия».) Сочетание Action =»\*"и с использованием сообщения как параметр называется «универсальный контракт», так как он сможет получать все возможные сообщения. Чтобы иметь возможность отправлять все возможные сообщения, использовать Message как возвращаемое значение и задайте `ReplyAction` для «\*». В этом случае инфраструктура службы не сможет добавить свой собственный заголовок действия, и вы сможете управлять этим заголовком с помощью возвращаемого вами объекта `Message` .  
  
### <a name="3-message-contracts"></a>3. Контракты сообщений  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] предоставляет декларативную модель программирования для описания сообщений, называемую *контракты сообщений*. Эта модель более подробно описана в разделе [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md). По существу, все сообщение представляется одним типом [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] , который использует атрибуты <xref:System.ServiceModel.MessageBodyMemberAttribute> и <xref:System.ServiceModel.MessageHeaderAttribute> для описания того, какие части класса контракта сообщений с какими частями сообщения должны сопоставляться.  
  
 Контракты сообщений обеспечивают значительную степень управления над получаемыми экземплярами `Message` (хотя в данном случае степень управления все равно ниже, чем при непосредственном использовании класса `Message` ). Например, тела сообщений часто состоят из многочисленных элементов данных, каждый из которых представлен собственным XML-элементом. Эти элементы могут встречаться непосредственно в теле сообщения (режим*bare* ) или помещаться в *программу-оболочку* содержащегося в теле XML-элемента. Использование модели программирования контракта сообщений позволяет выбирать способ представления элементов (в режиме "bare" или в программе-оболочке) и управлять именем программы-оболочки и пространством имен.  
  
 В следующем примере кода контракта сообщений проиллюстрированы эти возможности.  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 Элементы, отмеченные для сериализации (с атрибутами <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>или любыми другими связанными атрибутами), должны быть сериализуемыми, иначе они не могут находиться в контракте сообщения. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)] подраздел «Сериализация» далее в этом разделе.  
  
### <a name="4-parameters"></a>4. Параметры  
 Часто для описания операции с несколькими элементами данных разработчику не требуется тот высокий уровень управления, который обеспечивается контрактами сообщений. Например, при создании новых служб, как правило, не приходится принимать решение о способе представления элементов (в режиме "bare" или в программе-оболочке) и выбирать имя программы-оболочки. Зачастую для принятия таких решений необходимы глубокие знания о функционировании веб-служб и протокола SOAP.  
  
 Инфраструктура службы [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] может автоматически выбирать оптимальное представление SOAP с наиболее широкими возможностями взаимодействия для отправки и получения большого числа взаимосвязанных элементов данных, освобождая, таким образом, пользователя от необходимости принимать подобные решения самостоятельно. Это возможно благодаря тому, что данные элементы данных описаны как параметры или возвращаемые значения контракта операций. Например, рассмотрим следующий контракт операций.  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 Инфраструктура службы автоматически принимает решение о размещении всех трех элементов данных (`customerID`, `item`и `quantity`) в теле сообщения и помещении их в программу-оболочку с именем `SubmitOrderRequest`.  
  
 Рекомендуется описывать информацию, которую необходимо отправить или получить, в виде простого списка параметров контракта операций, если, конечно, не имеется особых причин, вынуждающих перейти к использованию более сложного контракта сообщений или моделей программирования на основе `Message`.  
  
### <a name="5-stream"></a>5. Поток  
 Использование потока `Stream` или одного из его подклассов в контракте операций либо в качестве единственной части тела сообщения в контракте сообщений может считаться отдельной моделью программирования, которая отличается от описанных выше моделей. Только использование `Stream` подобным образом гарантирует возможность использования контракта в потоковом режиме; во всех остальных случаях необходимо самостоятельно создавать подкласс `Message` , совместимый с потоковым режимом. [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)][Большие объемы данных и потоковой передачи](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).  
  
 При использовании `Stream` или одного из его подклассов таким образом сериализатор не вызывается. Для исходящих сообщений создается специальный потоковый подкласс `Message` , а поток записывается в интерфейсе <xref:System.Xml.IStreamProvider> описанным в данном разделе способом. Для входящих сообщений инфраструктура службы создает подкласс `Stream` над входящими сообщениями и предоставляет этот подкласс операции.  
  
## <a name="programming-model-restrictions"></a>Ограничения модели программирования  
 Вышеописанные модели программирования нельзя сочетать произвольно. Например, если операция принимает определенный тип контракта сообщений, этот контракт сообщений должен стать единственным входным параметром операции. Более того, после этого операция должна вернуть либо пустое сообщение (возвращаемый тип "void"), либо другой контракт сообщений. Ограничения моделей программирования описаны в разделах, посвященных каждой из этих моделей: [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)и [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).  
  
## <a name="message-formatters"></a>Модули форматирования сообщений  
 Описанные выше модели программирования поддерживаются подключением компонентов под названием *модули форматирования сообщений* в инфраструктуру службы. Модули форматирования сообщений представляют собой типы, которые реализуют интерфейс <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> или <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> (или оба) для использования в клиентах и клиентах службы [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] соответственно.  
  
 Как правило, модули форматирования сообщений подключаются поведениями. Например, поведение <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> подключает модуль форматирования сообщений контракта данных. На стороне службы это достигается благодаря установке <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> на соответствующий модуль форматирования в методе <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> , а на стороне клиента - благодаря установке <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> на соответствующий модуль форматирования в методе <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> .  
  
 В таблице ниже приведены методы, которые могут реализовываться модулем форматирования сообщений.  
  
|Интерфейс|Метод|Действие|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|преобразует входящее сообщение `Message` в параметры операции|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|создает исходящее сообщение `Message` из возвращаемого значения/выходных параметров операции|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|создает исходящее сообщение `Message` из параметров операции|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|преобразует входящее сообщение `Message` в возвращаемое значение/выходные параметры|  
  
## <a name="serialization"></a>Сериализация  
 Всякий раз при использовании контрактов сообщений или параметров для описания содержимого сообщений необходимо использовать сериализацию для преобразования между типами [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] и представлением набора данных XML. Сериализация используется и в других частях [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], например <xref:System.ServiceModel.Channels.Message> содержит универсальный метод <xref:System.ServiceModel.Channels.Message.GetBody%2A> , который можно использовать для прочтения всего тела сообщения, десериализованного в объект.  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] поддерживает две встроенные технологии сериализации для сериализации и десериализации параметров и частей сообщений: <xref:System.Runtime.Serialization.DataContractSerializer> и `XmlSerializer`. Более того, можно создать настраиваемые сериализаторы. Однако в других частях [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] (таких как универсальный метод `GetBody` или сериализация ошибок протокола SOAP) может действовать ограничение на использование каких-либо иных подклассов, кроме <xref:System.Runtime.Serialization.XmlObjectSerializer> (например, разрешается использование подклассов<xref:System.Runtime.Serialization.DataContractSerializer> и <xref:System.Runtime.Serialization.NetDataContractSerializer>, запрещается использование подкласса <xref:System.Xml.Serialization.XmlSerializer>); более того, приложение может быть жестко запрограммировано на использование исключительно подкласса <xref:System.Runtime.Serialization.DataContractSerializer>.  
  
 `XmlSerializer` представляет собой модуль сериализации, используемый в веб-службах [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] . Новый модуль сериализации `DataContractSerializer` , совместимый с новой моделью программирования на основе контрактов данных. `DataContractSerializer` выбирается по умолчанию, однако можно выбрать `XmlSerializer` для отдельных операций с помощью атрибута <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> .  
  
 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> и <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> - это поведения операции, ответственные за подключение модулей форматирования сообщений для `DataContractSerializer` и `XmlSerializer`соответственно. Фактически, поведение <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> может работать с любым сериализатором, наследуемым от <xref:System.Runtime.Serialization.XmlObjectSerializer>, включая <xref:System.Runtime.Serialization.NetDataContractSerializer> (подробное описание см. в разделе "Использование автономной сериализации"). Поведение вызывает одну из перегрузок виртуального метода `CreateSerializer` для получения сериализатора. Для подключения иного сериализатора необходимо создать новый подкласс <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> и переопределить обе перегрузки метода `CreateSerializer` .  
  
## <a name="see-also"></a>См. также  
 [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
