---
title: Объединение сообщений в одну транзакцию
ms.custom: ''
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: ''
ms.suite: ''
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- batching messages [WCF]
ms.assetid: 53305392-e82e-4e89-aedc-3efb6ebcd28c
caps.latest.revision: 19
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 17d9bd3b58e8320bfe1f62ac56aff59ba52f4374
ms.sourcegitcommit: 94d33cadc5ff81d2ac389bf5f26422c227832052
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/30/2018
---
# <a name="batching-messages-in-a-transaction"></a>Объединение сообщений в одну транзакцию
Для обеспечения правильной и надежной доставки сообщений в приложениях с очередью используются транзакции. Однако транзакции являются очень ресурсоемкими операциями и могут очень сильно снизить пропускную способность при передаче сообщений. Одним из способов повышения пропускной способности при передаче сообщений является чтение и обработка приложением нескольких сообщений в одной транзакции. Компромисс заключается в балансе производительности и объема восстановления: так как количество сообщений в пакете возрастает, также возрастает объем работы по восстановлению, которую необходимо выполнить при откате транзакции. Важно отметить разницу между объединением сообщений в пакеты в транзакции и в сеансах. Объект *сеанса* — это группа связанных сообщений, обрабатываемых одним приложением и фиксируются как единый блок. Сеансы обычно используются, если группа связанных сообщений должна обрабатываться совместно. В качестве примера можно привести веб-сайт интернет-магазина. *Пакеты* используются для обработки нескольких, несвязанных сообщений таким образом, сообщения, повышает пропускную способность. Дополнительные сведения о сеансах см. в разделе [группирования в очередь сообщений в сеансе](../../../../docs/framework/wcf/feature-details/grouping-queued-messages-in-a-session.md). Сообщения из пакета также обрабатываются одним приложением и фиксируются как единый блок, однако связь между сообщениями из пакета отсутствует. Объединение сообщений в пакеты внутри транзакции - это способ оптимизации, не влияющий на работу приложения.  
  
## <a name="entering-batching-mode"></a>Вход в пакетный режим  
 Пакетная обработка управляется поведением конечной точки <xref:System.ServiceModel.Description.TransactedBatchingBehavior>. Добавление этого поведения конечной точки в конечную точку службы сообщает [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] о необходимости пакетной обработки сообщений в транзакции. Не все сообщения требуют транзакций, поэтому в пакет помещаются только сообщения, требующие транзакции, и только сообщения, переданные из операций, отмеченные `TransactionScopeRequired`  =  `true` и `TransactionAutoComplete`  =  `true` , считается для пакета. Если все операции в контракте службы, помечаются `TransactionScopeRequired`  =  `false` и `TransactionAutoComplete`  =  `false`, то никогда не вводилось пакетного режима.  
  
## <a name="committing-a-transaction"></a>Фиксация транзакции  
 Пакетная транзакция фиксируется на основе следующих параметров.  
  
-   `MaxBatchSize`. Свойство поведения <xref:System.ServiceModel.Description.TransactedBatchingBehavior>. Это свойство определяет максимальное количество сообщений, помещаемых в пакет. При достижении этого количества производится фиксация пакета. Это значение не является строгим ограничением, возможна фиксация пакета до достижения этого количества сообщений.  
  
-   `Transaction Timeout`. По истечении 80 процентов времени ожидания транзакции пакет фиксируется и создается новый пакет. Это означает, что если от времени, выделенного для завершения транзакции, осталось 20 процентов или менее, пакет фиксируется.  
  
-   `TransactionScopeRequired`. Если при обработке пакета сообщений, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] находит тот, который имеет `TransactionScopeRequired`  =  `false`, он фиксируется и открывается новый пакет при поступлении первого сообщения с `TransactionScopeRequired`  =  `true` и `TransactionAutoComplete` = `true`.  
  
-   Если в очереди больше нет сообщений, текущий пакет фиксируется, даже если еще не достигнуто значение `MaxBatchSize` и 80 процентов времени ожидания транзакции еще не истекли.  
  
## <a name="leaving-batching-mode"></a>Выход из пакетного режима  
 Если сообщение из пакета приводит к прерыванию транзакции, выполняются следующие шаги:  
  
1.  Производится откат всего пакета сообщений.  
  
2.  Сообщения считываются по одному до тех пор, пока количество сообщений не превысит удвоенного максимального размера пакета.  
  
3.  Производится повторный вход в пакетный режим.  
  
## <a name="choosing-the-batch-size"></a>Выбор размера пакета  
 Размер пакета зависит от приложения. Лучше всего определять оптимальный размер пакета для приложения эмпирическим путем. При выборе размера пакета важно выбирать размер в соответствии с фактической моделью развертывания приложения. Например, если при развертывании приложения требуются сервер SQL Server на удаленном компьютере и транзакции, охватывающие очередь и этот сервер SQL Server, то размер пакета лучше всего определять при работе именно в такой конфигурации.  
  
## <a name="concurrency-and-batching"></a>Параллелизм и пакетная обработка  
 Для увеличения пропускной способности возможна также параллельная обработка нескольких пакетов. Задав значение `ConcurrencyMode.Multiple` в атрибуте `ServiceBehaviorAttribute`, можно включить параллельную пакетную обработку.  
  
 *Регулирование службы* поведение службы, которое указывает, сколько максимальное количество одновременных вызовов можно сделать на стороне службы. При использовании с пакетной обработкой это означает количество параллельно обрабатываемых пакетов. Если регулирование службы не задано, по умолчанию в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] максимальное количество параллельных вызовов равно 16. Таким образом, если поведение пакетной обработки было добавлено по умолчанию, одновременно может быть активно не более 16 пакетов. Лучше всего настроить регулирование службы и пакетную обработку на основе реальных объемов. Например, если очередь содержит 100 сообщений и требуются 20 пакетов, задавать значение 16 в качестве максимального количества параллельных вызовов бесполезно, так как, в зависимости от пропускной способности, могут быть активны 16 транзакций, что равносильно просто выключению пакетной обработки. Поэтому при тонкой настройке производительности либо выключите параллельную пакетную обработку, либо включите ее с правильным значением регулирования службы.  
  
## <a name="batching-and-multiple-endpoints"></a>Пакетная обработка и несколько конечных точек  
 Конечная точка состоит из адреса и контракта. Могут существовать несколько конечных точек, совместно использующих одну привязку. Две конечные точки могут совместно использовать одну привязку и ожидать передачи данных по универсальному коду ресурса (URI) или адресу очереди. Если две конечные точки производят чтение из одной очереди и поведение пакетной обработки с транзакциями добавлено в обе конечные точки, возможно возникновение конфликта между заданными размерами пакетов. Этот конфликт устраняется реализацией пакетной обработки с использованием минимального размера пакета из заданных в двух поведениях пакетной обработки с транзакциями. Если в этом сценарии для одной конечной точки не задана пакетная обработка с транзакциями, пакетная обработка не будет использоваться в обеих конечных точках.  
  
## <a name="example"></a>Пример  
 В следующем примере показано, как задать `TransactedBatchingBehavior` в файле конфигурации.  
  
```xml  
<behaviors>
  <endpointBehaviors>
    <behavior name="TransactedBatchingBehavior"
              maxBatchSize="100" />
  </endpointBehaviors>
</behaviors>
```  
  
 В следующем примере показано, как задать <xref:System.ServiceModel.Description.TransactedBatchingBehavior> в коде.  
  
```csharp
using (ServiceHost serviceHost = new ServiceHost(typeof(OrderProcessorService)))
{
     ServiceEndpoint sep = ServiceHost.AddServiceEndpoint(typeof(IOrderProcessor), new NetMsmqBinding(), "net.msmq://localhost/private/ServiceModelSamplesTransacted");
     sep.Behaviors.Add(new TransactedBatchingBehavior(100));
     
     // Open the ServiceHost to create listeners and start listening for messages.
    serviceHost.Open();
  
    // The service can now be accessed.
    Console.WriteLine("The service is ready.");
    Console.WriteLine("Press <ENTER> to terminate service.");
    Console.WriteLine();
    Console.ReadLine();
  
    // Close the ServiceHostB to shut down the service.
    serviceHost.Close();
}  
```  
  
## <a name="see-also"></a>См. также  
 [Общие сведения об очередях](../../../../docs/framework/wcf/feature-details/queues-overview.md)  
 [Очереди в WCF](../../../../docs/framework/wcf/feature-details/queuing-in-wcf.md)
