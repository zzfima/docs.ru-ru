---
title: Использование класса сообщений
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed
ms.openlocfilehash: 0ff65d9173838a8eb8850253e62d822f06942f26
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2018
ms.locfileid: "33508986"
---
# <a name="using-the-message-class"></a><span data-ttu-id="0e686-102">Использование класса сообщений</span><span class="sxs-lookup"><span data-stu-id="0e686-102">Using the Message Class</span></span>
<span data-ttu-id="0e686-103"><xref:System.ServiceModel.Channels.Message> Класс — это основа для Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="0e686-103">The <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="0e686-104">Все взаимодействие между клиентами и службами в конечном итоге приводит к отправке и получению экземпляров класса <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="0e686-104">All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.</span></span>  
  
 <span data-ttu-id="0e686-105">Как правило, с классом <xref:System.ServiceModel.Channels.Message> не приходится взаимодействовать напрямую.</span><span class="sxs-lookup"><span data-stu-id="0e686-105">You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="0e686-106">Вместо этого для описания входящих и исходящих сообщений используются конструкции модели службы WCF, такие как контракты данных, контракты сообщений и контракты операций.</span><span class="sxs-lookup"><span data-stu-id="0e686-106">Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.</span></span> <span data-ttu-id="0e686-107">Однако в некоторых сложных сценариях можно создавать код непосредственно с использованием класса <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="0e686-107">However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="0e686-108">Например, класс <xref:System.ServiceModel.Channels.Message> можно использовать в следующих случаях.</span><span class="sxs-lookup"><span data-stu-id="0e686-108">For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:</span></span>  
  
-   <span data-ttu-id="0e686-109">Если необходим альтернативный способ создания содержимого исходящих сообщений (например, нужно создать сообщение непосредственно из файла на диске), отличный от сериализации объектов [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0e686-109">When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects.</span></span>  
  
-   <span data-ttu-id="0e686-110">Если необходим альтернативный способ использования содержимого входящих сообщений (например, когда нужно применить преобразование XSLT к необработанному содержимому XML), отличный от десериализации в объекты [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0e686-110">When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects.</span></span>  
  
-   <span data-ttu-id="0e686-111">Если необходимо совершить общие операции с сообщениями независимо от их содержимого (например, маршрутизировать или переслать сообщения при создании маршрутизатора, подсистемы балансировки нагрузки или системы публикации-подписки).</span><span class="sxs-lookup"><span data-stu-id="0e686-111">When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).</span></span>  
  
 <span data-ttu-id="0e686-112">Перед использованием <xref:System.ServiceModel.Channels.Message> класса, ознакомьтесь с архитектурой передачи данных WCF в [Обзор архитектуры передачи данных](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).</span><span class="sxs-lookup"><span data-stu-id="0e686-112">Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).</span></span>  
  
 <span data-ttu-id="0e686-113">Класс <xref:System.ServiceModel.Channels.Message> представляет собой контейнер для данных общего назначения, структура которого во многом схожа со структурой сообщения в протоколе SOAP.</span><span class="sxs-lookup"><span data-stu-id="0e686-113">A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.</span></span> <span data-ttu-id="0e686-114">Как и в протоколе SOAP, сообщение имеет тело и заголовки.</span><span class="sxs-lookup"><span data-stu-id="0e686-114">Just like in SOAP, a message has both a message body and headers.</span></span> <span data-ttu-id="0e686-115">Тело сообщения содержит фактическую полезную нагрузку данных, а заголовки - дополнительные именованные контейнеры с данными.</span><span class="sxs-lookup"><span data-stu-id="0e686-115">The message body contains the actual payload data, while the headers contain additional named data containers.</span></span> <span data-ttu-id="0e686-116">Правила чтения и записи тела и заголовков сообщения различаются. Так, заголовки всегда буферизуются в памяти, доступ к ним можно получать в любой очередности неограниченное количество раз, в то время как тело можно прочитать только один раз, и тело может участвовать в потоковой передаче.</span><span class="sxs-lookup"><span data-stu-id="0e686-116">The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.</span></span> <span data-ttu-id="0e686-117">Как правило, при использовании протокола SOAP тело сообщения сопоставляется телу сообщения SOAP, а его заголовки - заголовкам сообщения SOAP.</span><span class="sxs-lookup"><span data-stu-id="0e686-117">Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.</span></span>  
  
## <a name="using-the-message-class-in-operations"></a><span data-ttu-id="0e686-118">Использование класса сообщений в операциях</span><span class="sxs-lookup"><span data-stu-id="0e686-118">Using the Message Class in Operations</span></span>  
 <span data-ttu-id="0e686-119">Класс <xref:System.ServiceModel.Channels.Message> можно использовать в качестве входного параметра или возвращаемого значения операции либо обоих.</span><span class="sxs-lookup"><span data-stu-id="0e686-119">You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both.</span></span> <span data-ttu-id="0e686-120">При использовании класса <xref:System.ServiceModel.Channels.Message> в любом месте операции действуют следующие ограничения.</span><span class="sxs-lookup"><span data-stu-id="0e686-120">If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="0e686-121">Операция не должна иметь параметров `out` или `ref`.</span><span class="sxs-lookup"><span data-stu-id="0e686-121">The operation cannot have any `out` or `ref` parameters.</span></span>  
  
-   <span data-ttu-id="0e686-122">Операция не должна иметь более одного параметра `input`.</span><span class="sxs-lookup"><span data-stu-id="0e686-122">There cannot be more than one `input` parameter.</span></span> <span data-ttu-id="0e686-123">Если параметр присутствует, это должен быть параметр Message или тип контракта сообщений.</span><span class="sxs-lookup"><span data-stu-id="0e686-123">If the parameter is present, it must be either Message or a message contract type.</span></span>  
  
-   <span data-ttu-id="0e686-124">Возвращаемый тип должен представлять собой `void`, `Message` или тип контракта сообщений.</span><span class="sxs-lookup"><span data-stu-id="0e686-124">The return type must be either `void`, `Message`, or a message contract type.</span></span>  
  
 <span data-ttu-id="0e686-125">В следующем примере кода показан действительный контракт операции.</span><span class="sxs-lookup"><span data-stu-id="0e686-125">The following code example contains a valid operation contract.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]
 [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  
  
## <a name="creating-basic-messages"></a><span data-ttu-id="0e686-126">Создание базовых сообщений</span><span class="sxs-lookup"><span data-stu-id="0e686-126">Creating Basic Messages</span></span>  
 <span data-ttu-id="0e686-127">Класс <xref:System.ServiceModel.Channels.Message> предоставляет статические методы фабрики `CreateMessage`, которые можно использовать для создания базовых сообщений.</span><span class="sxs-lookup"><span data-stu-id="0e686-127">The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.</span></span>  
  
 <span data-ttu-id="0e686-128">Все перегрузки `CreateMessage` могут принимать параметр версии типа <xref:System.ServiceModel.Channels.MessageVersion>, который указывает, какие версии протокола SOAP и WS-Addressing использовать для данного сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-128">All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message.</span></span> <span data-ttu-id="0e686-129">При необходимости использовать те же версии протокола, что и входящее сообщение, можно использовать свойство <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> в экземпляре <xref:System.ServiceModel.OperationContext>, полученном из свойства <xref:System.ServiceModel.OperationContext.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-129">If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property.</span></span> <span data-ttu-id="0e686-130">Большинство перегрузок `CreateMessage` также имеют параметр строки, который указывает, какое действие SOAP следует использовать для сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-130">Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message.</span></span> <span data-ttu-id="0e686-131">Чтобы отключить создание конверта SOAP, можно задать версии значение `None`, тогда сообщение будет состоять только из тела.</span><span class="sxs-lookup"><span data-stu-id="0e686-131">Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.</span></span>  
  
## <a name="creating-messages-from-objects"></a><span data-ttu-id="0e686-132">Создание сообщений из объектов</span><span class="sxs-lookup"><span data-stu-id="0e686-132">Creating Messages from Objects</span></span>  
 <span data-ttu-id="0e686-133">Самая обычная перегрузка метода `CreateMessage`, использующая только версию и действие, создает сообщение с пустым телом.</span><span class="sxs-lookup"><span data-stu-id="0e686-133">The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body.</span></span> <span data-ttu-id="0e686-134">Перегрузка, принимающая дополнительный параметр <xref:System.Object>, создает сообщение, тело которого представляет собой сериализуемое представление данного объекта.</span><span class="sxs-lookup"><span data-stu-id="0e686-134">Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object.</span></span> <span data-ttu-id="0e686-135">Для сериализации используйте сериализатор <xref:System.Runtime.Serialization.DataContractSerializer> с параметрами по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0e686-135">Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization.</span></span> <span data-ttu-id="0e686-136">При необходимости использовать другой сериализатор или сериализатор `DataContractSerializer` с другими настройками используйте перегрузку метода `CreateMessage`, которая также принимает параметр `XmlObjectSerializer`.</span><span class="sxs-lookup"><span data-stu-id="0e686-136">If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.</span></span>  
  
 <span data-ttu-id="0e686-137">Например, чтобы вернуть объект в сообщение, следует воспользоваться следующим кодом.</span><span class="sxs-lookup"><span data-stu-id="0e686-137">For example, to return an object in a message, you can use the following code.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]
 [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  
  
## <a name="creating-messages-from-xml-readers"></a><span data-ttu-id="0e686-138">Создание сообщений из средств чтения XML</span><span class="sxs-lookup"><span data-stu-id="0e686-138">Creating Messages from XML Readers</span></span>  
 <span data-ttu-id="0e686-139">Существуют перегрузки метода `CreateMessage`, которые вместо объекта принимают средство чтения <xref:System.Xml.XmlReader> или <xref:System.Xml.XmlDictionaryReader> для тела сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-139">There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object.</span></span> <span data-ttu-id="0e686-140">В этом случае тело сообщения содержит XML-код, создаваемый в результате чтения из переданного средства чтения XML.</span><span class="sxs-lookup"><span data-stu-id="0e686-140">In this case, the body of the message contains the XML that results from reading from the passed XML reader.</span></span> <span data-ttu-id="0e686-141">Например, следующий код возвращает сообщение, содержимое тела которого прочитано из файла XML.</span><span class="sxs-lookup"><span data-stu-id="0e686-141">For example, the following code returns a message with body contents read from an XML file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]
 [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  
  
 <span data-ttu-id="0e686-142">Кроме того, существуют перегрузки метода `CreateMessage`, которые принимают средство чтения <xref:System.Xml.XmlReader> или <xref:System.Xml.XmlDictionaryReader>, представляющее все сообщение, а не только его тело.</span><span class="sxs-lookup"><span data-stu-id="0e686-142">Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body.</span></span> <span data-ttu-id="0e686-143">Эти перегрузки также принимают целочисленный параметр `maxSizeOfHeaders`.</span><span class="sxs-lookup"><span data-stu-id="0e686-143">These overloads also take an integer `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="0e686-144">Заголовки всегда буферизуются в память сразу после создания сообщения, а этот параметр ограничивает объем буферизации.</span><span class="sxs-lookup"><span data-stu-id="0e686-144">Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.</span></span> <span data-ttu-id="0e686-145">Для снижения вероятности атаки типа "отказ в обслуживании" необходимо задать безопасное значение этому параметру, если XML-код поступает из ненадежного источника.</span><span class="sxs-lookup"><span data-stu-id="0e686-145">It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.</span></span> <span data-ttu-id="0e686-146">Версии SOAP и WS-Addressing сообщения, представляемого средством чтения XML, должны соответствовать версиям, указанным с использованием параметра версии.</span><span class="sxs-lookup"><span data-stu-id="0e686-146">The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.</span></span>  
  
## <a name="creating-messages-with-bodywriter"></a><span data-ttu-id="0e686-147">Создание сообщений с помощью конструктора BodyWriter</span><span class="sxs-lookup"><span data-stu-id="0e686-147">Creating Messages with BodyWriter</span></span>  
 <span data-ttu-id="0e686-148">Одна из перегрузок метода `CreateMessage` использует экземпляр `BodyWriter` для описания тела сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-148">One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message.</span></span> <span data-ttu-id="0e686-149">`BodyWriter` - это абстрактный класс, который может наследоваться для настройки способа создания тел сообщений.</span><span class="sxs-lookup"><span data-stu-id="0e686-149">A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created.</span></span> <span data-ttu-id="0e686-150">Можно создать собственный производный класс `BodyWriter` для описания тел сообщений пользовательским способом.</span><span class="sxs-lookup"><span data-stu-id="0e686-150">You can create your own `BodyWriter` derived class to describe message bodies in a custom way.</span></span> <span data-ttu-id="0e686-151">Необходимо переопределить метод `BodyWriter.OnWriteBodyContents`, принимающий <xref:System.Xml.XmlDictionaryWriter>; этот метод используется для записи тела сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-151">You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.</span></span>  
  
 <span data-ttu-id="0e686-152">Некоторые средства записи тела сообщения используют буферизацию, другие (потоковые) - нет.</span><span class="sxs-lookup"><span data-stu-id="0e686-152">Body writers can be buffered or non-buffered (streamed).</span></span> <span data-ttu-id="0e686-153">Средства записи тела с буферизацией могут записывать содержимое неограниченное число раз, а потоковые - только один раз.</span><span class="sxs-lookup"><span data-stu-id="0e686-153">Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.</span></span> <span data-ttu-id="0e686-154">Свойство `IsBuffered` указывает, использует ли средство записи тела сообщения буферизацию или нет.</span><span class="sxs-lookup"><span data-stu-id="0e686-154">The `IsBuffered` property indicates whether a body writer is buffered or not.</span></span> <span data-ttu-id="0e686-155">Настроить это свойство для используемого средства записи тела сообщения можно вызовом защищенного конструктора `BodyWriter`, принимающего логический параметр `isBuffered`.</span><span class="sxs-lookup"><span data-stu-id="0e686-155">You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter.</span></span> <span data-ttu-id="0e686-156">Средства записи тела сообщения позволяют создавать средство записи тела сообщения с буферизацией из средства записи без буферизации.</span><span class="sxs-lookup"><span data-stu-id="0e686-156">Body writers support creating a buffered body writer from a non-buffered body writer.</span></span> <span data-ttu-id="0e686-157">Для настройки этого процесса можно переопределить метод `OnCreateBufferedCopy`.</span><span class="sxs-lookup"><span data-stu-id="0e686-157">You can override the `OnCreateBufferedCopy` method to customize this process.</span></span> <span data-ttu-id="0e686-158">По умолчанию используется буфер в памяти, который содержит XML-код, возвращаемый `OnWriteBodyContents`.</span><span class="sxs-lookup"><span data-stu-id="0e686-158">By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used.</span></span> <span data-ttu-id="0e686-159">`OnCreateBufferedCopy` принимает целочисленный параметр `maxBufferSize`; при переопределении этого метода не следует создавать буферы, размер которых превышает данное максимальное значение.</span><span class="sxs-lookup"><span data-stu-id="0e686-159">`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.</span></span>  
  
 <span data-ttu-id="0e686-160">Класс `BodyWriter` предоставляет методы `WriteBodyContents` и `CreateBufferedCopy`, которые, по сути, являются тонкими программами-оболочками для методов `OnWriteBodyContents` и `OnCreateBufferedCopy` соответственно.</span><span class="sxs-lookup"><span data-stu-id="0e686-160">The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively.</span></span> <span data-ttu-id="0e686-161">Эти методы выполняют проверку состояния, чтобы убедиться, что доступ к средству записи тела сообщения без буферизации не осуществляется более одного раза.</span><span class="sxs-lookup"><span data-stu-id="0e686-161">These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.</span></span> <span data-ttu-id="0e686-162">Эти методы вызываются непосредственно только при создании пользовательских производных классов `Message` на основе `BodyWriters`.</span><span class="sxs-lookup"><span data-stu-id="0e686-162">These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.</span></span>  
  
## <a name="creating-fault-messages"></a><span data-ttu-id="0e686-163">Создание сообщений об ошибках</span><span class="sxs-lookup"><span data-stu-id="0e686-163">Creating Fault Messages</span></span>  
 <span data-ttu-id="0e686-164">Для создания сообщений об ошибке SOAP можно использовать определенные перегрузки `CreateMessage`.</span><span class="sxs-lookup"><span data-stu-id="0e686-164">You can use certain `CreateMessage` overloads to create SOAP fault messages.</span></span> <span data-ttu-id="0e686-165">Основная из них принимает объект <xref:System.ServiceModel.Channels.MessageFault>, который описывает ошибку.</span><span class="sxs-lookup"><span data-stu-id="0e686-165">The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault.</span></span> <span data-ttu-id="0e686-166">Другие перегрузки предоставляются для удобства.</span><span class="sxs-lookup"><span data-stu-id="0e686-166">Other overloads are provided for convenience.</span></span> <span data-ttu-id="0e686-167">Первая такая перегрузка принимает `FaultCode` и строку причины и создает `MessageFault` с помощью `MessageFault.CreateFault`, использующего эти сведения.</span><span class="sxs-lookup"><span data-stu-id="0e686-167">The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information.</span></span> <span data-ttu-id="0e686-168">Другая перегрузка этого метода принимает объект сведений и передает его `CreateFault` вместе с кодом ошибки и причиной.</span><span class="sxs-lookup"><span data-stu-id="0e686-168">The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason.</span></span> <span data-ttu-id="0e686-169">Например, следующая операция возвращает ошибку.</span><span class="sxs-lookup"><span data-stu-id="0e686-169">For example, the following operation returns a fault.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]
 [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  
  
## <a name="extracting-message-body-data"></a><span data-ttu-id="0e686-170">Извлечение данных тела сообщения</span><span class="sxs-lookup"><span data-stu-id="0e686-170">Extracting Message Body Data</span></span>  
 <span data-ttu-id="0e686-171">Класс `Message` позволяет извлекать данные из его тела несколькими способами.</span><span class="sxs-lookup"><span data-stu-id="0e686-171">The `Message` class supports multiple ways of extracting information from its body.</span></span> <span data-ttu-id="0e686-172">Эти способы можно разделить на следующие категории.</span><span class="sxs-lookup"><span data-stu-id="0e686-172">These can be classified into the following categories:</span></span>  
  
-   <span data-ttu-id="0e686-173">Возвращение целого тела сообщения, мгновенно записываемого в средство записи XML.</span><span class="sxs-lookup"><span data-stu-id="0e686-173">Getting the entire message body written out at once to an XML writer.</span></span> <span data-ttu-id="0e686-174">Это называется *записи сообщения*.</span><span class="sxs-lookup"><span data-stu-id="0e686-174">This is referred to as *writing a message*.</span></span>  
  
-   <span data-ttu-id="0e686-175">Размещение средства чтения XML над телом сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-175">Getting an XML reader over the message body.</span></span> <span data-ttu-id="0e686-176">Этот способ позволяет впоследствии при необходимости получать доступ к телу сообщения по частям.</span><span class="sxs-lookup"><span data-stu-id="0e686-176">This enables you to later access the message body piece-by-piece as required.</span></span> <span data-ttu-id="0e686-177">Это называется *прочтение сообщения*.</span><span class="sxs-lookup"><span data-stu-id="0e686-177">This is referred to as *reading a message*.</span></span>  
  
-   <span data-ttu-id="0e686-178">Все сообщение, включая его тело, можно скопировать в буфер памяти типа <xref:System.ServiceModel.Channels.MessageBuffer>.</span><span class="sxs-lookup"><span data-stu-id="0e686-178">The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type.</span></span> <span data-ttu-id="0e686-179">Это называется *копирование сообщения*.</span><span class="sxs-lookup"><span data-stu-id="0e686-179">This is referred to as *copying a message*.</span></span>  
  
 <span data-ttu-id="0e686-180">Доступ к телу `Message` можно получить только один раз независимо от того, каким способом осуществляется доступ.</span><span class="sxs-lookup"><span data-stu-id="0e686-180">You can access the body of a `Message` only once, regardless of how it is accessed.</span></span> <span data-ttu-id="0e686-181">Объект сообщения имеет свойство `State`, которому изначально задано значение Created.</span><span class="sxs-lookup"><span data-stu-id="0e686-181">A message object has a `State` property, which is initially set to Created.</span></span> <span data-ttu-id="0e686-182">Три способа доступа, описанные в вышеприведенном списке, устанавливают состояние Written, Read и Copied соответственно.</span><span class="sxs-lookup"><span data-stu-id="0e686-182">The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.</span></span> <span data-ttu-id="0e686-183">Кроме того, метод `Close` может установить состояние Closed, если содержимое тела сообщения больше не требуется.</span><span class="sxs-lookup"><span data-stu-id="0e686-183">Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required.</span></span> <span data-ttu-id="0e686-184">Доступ к телу сообщения осуществляется только в состоянии Created, вернуться к состоянию Created после изменения состояния невозможно.</span><span class="sxs-lookup"><span data-stu-id="0e686-184">The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.</span></span>  
  
## <a name="writing-messages"></a><span data-ttu-id="0e686-185">Создание сообщений</span><span class="sxs-lookup"><span data-stu-id="0e686-185">Writing Messages</span></span>  
 <span data-ttu-id="0e686-186">Метод <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> записывает содержимое тела заданного экземпляра `Message` в заданное средство записи XML.</span><span class="sxs-lookup"><span data-stu-id="0e686-186">The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer.</span></span> <span data-ttu-id="0e686-187">Метод <xref:System.ServiceModel.Channels.Message.WriteBody%2A> действует практически также, за исключением того, что он помещает содержимое тела в соответствующую программу-оболочку (например, <`soap:body`>).</span><span class="sxs-lookup"><span data-stu-id="0e686-187">The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>).</span></span> <span data-ttu-id="0e686-188">Наконец, метод <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> записывает все сообщение, включая конверт SOAP и заголовки, выполняющие функции оболочки.</span><span class="sxs-lookup"><span data-stu-id="0e686-188">Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers.</span></span> <span data-ttu-id="0e686-189">Если SOAP отключен (версия `MessageVersion.None`), все три метода действуют одинаково: они записывают содержимое тела сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-189">If SOAP is turned off (Version is `MessageVersion.None`), all three methods do the same thing: they write out the message body contents.</span></span>  
  
 <span data-ttu-id="0e686-190">Например, следующий код записывает тело входящего сообщения в файл.</span><span class="sxs-lookup"><span data-stu-id="0e686-190">For example, the following code writes out the body of an incoming message to a file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]
 [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  
  
 <span data-ttu-id="0e686-191">Два дополнительных вспомогательных метода записывают определенные теги начального элемента SOAP.</span><span class="sxs-lookup"><span data-stu-id="0e686-191">Two additional helper methods write out certain SOAP start element tags.</span></span> <span data-ttu-id="0e686-192">Эти методы не осуществляют доступ к телу сообщения, поэтому они не изменяют состояние сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-192">These methods do not access the message body and so they do not change the message state.</span></span> <span data-ttu-id="0e686-193">К ним относятся следующие методы.</span><span class="sxs-lookup"><span data-stu-id="0e686-193">These include:</span></span>  
  
-   <span data-ttu-id="0e686-194"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> записывает начальный элемент тела, например `<soap:Body>`.</span><span class="sxs-lookup"><span data-stu-id="0e686-194"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.</span></span>  
  
-   <span data-ttu-id="0e686-195"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> записывает начальный элемент конверта, например `<soap:Envelope>`.</span><span class="sxs-lookup"><span data-stu-id="0e686-195"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.</span></span>  
  
 <span data-ttu-id="0e686-196">Для записи соответствующих тегов конечных элементов необходимо вызвать метод `WriteEndElement` в соответствующем средстве записи XML.</span><span class="sxs-lookup"><span data-stu-id="0e686-196">To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer.</span></span> <span data-ttu-id="0e686-197">Эти методы редко вызываются напрямую.</span><span class="sxs-lookup"><span data-stu-id="0e686-197">These methods are rarely called directly.</span></span>  
  
## <a name="reading-messages"></a><span data-ttu-id="0e686-198">Чтение сообщений</span><span class="sxs-lookup"><span data-stu-id="0e686-198">Reading Messages</span></span>  
 <span data-ttu-id="0e686-199">Основной способ прочитать тело сообщения - это вызвать метод <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-199">The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span></span> <span data-ttu-id="0e686-200">В результате возвращается средство чтения <xref:System.Xml.XmlDictionaryReader>, которое можно использовать для чтения тела сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-200">You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body.</span></span> <span data-ttu-id="0e686-201">Обратите внимания, что <xref:System.ServiceModel.Channels.Message> переходит в состояние Read сразу после вызова <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>, а не одновременно с использованием возвращенного средства чтения XML.</span><span class="sxs-lookup"><span data-stu-id="0e686-201">Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.</span></span>  
  
 <span data-ttu-id="0e686-202">Метод <xref:System.ServiceModel.Channels.Message.GetBody%2A> также позволяет получать доступ к телу сообщения как типизированному объекту.</span><span class="sxs-lookup"><span data-stu-id="0e686-202">The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object.</span></span> <span data-ttu-id="0e686-203">Изнутри этот метод использует `GetReaderAtBodyContents`, поэтому он также изменяет состояние сообщения на <xref:System.ServiceModel.Channels.MessageState.Read> (см. свойство <xref:System.ServiceModel.Channels.Message.State%2A>).</span><span class="sxs-lookup"><span data-stu-id="0e686-203">Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).</span></span>  
  
 <span data-ttu-id="0e686-204">Рекомендуется всегда проверять свойство <xref:System.ServiceModel.Channels.Message.IsEmpty%2A>; в этом случае тело сообщения пустое, а <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> создает исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="0e686-204">It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="0e686-205">Кроме того, если речь идет о полученном сообщении (например, ответе), целесообразно проверить свойство <xref:System.ServiceModel.Channels.Message.IsFault%2A>, указывающее, содержит ли сообщение ошибку.</span><span class="sxs-lookup"><span data-stu-id="0e686-205">Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.</span></span>  
  
 <span data-ttu-id="0e686-206">Основная перегрузка метода <xref:System.ServiceModel.Channels.Message.GetBody%2A> десериализует тело сообщения в экземпляр типа (определяемый универсальным параметром) с использованием сериализатора <xref:System.Runtime.Serialization.DataContractSerializer> с настроенными по умолчанию параметрами и отключенной квотой <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-206">The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled.</span></span> <span data-ttu-id="0e686-207">При необходимости использовать другой модуль сериализации или изменить настройки `DataContractSerializer` по умолчанию используйте перегрузку метода <xref:System.ServiceModel.Channels.Message.GetBody%2A>, которая принимает параметр <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span><span class="sxs-lookup"><span data-stu-id="0e686-207">If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
 <span data-ttu-id="0e686-208">Например, следующий код извлекает данные из тела сообщения, которое содержит сериализованный объект `Person` и выводит имя пользователя.</span><span class="sxs-lookup"><span data-stu-id="0e686-208">For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]
 [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  
  
## <a name="copying-a-message-into-a-buffer"></a><span data-ttu-id="0e686-209">Копирование сообщения в буфер</span><span class="sxs-lookup"><span data-stu-id="0e686-209">Copying a Message into a Buffer</span></span>  
 <span data-ttu-id="0e686-210">Иногда необходимо получить доступ к телу сообщения более одного раза, например чтобы переслать одно и то же сообщение по нескольким назначениям в рамках системы "издатель-подписчик".</span><span class="sxs-lookup"><span data-stu-id="0e686-210">Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.</span></span> <span data-ttu-id="0e686-211">В этом случае необходимо поместить в буфер памяти все сообщение (включая тело).</span><span class="sxs-lookup"><span data-stu-id="0e686-211">In this case, it is necessary to buffer the entire message (including the body) in memory.</span></span> <span data-ttu-id="0e686-212">Это выполняется вызовом метода <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span><span class="sxs-lookup"><span data-stu-id="0e686-212">You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span></span> <span data-ttu-id="0e686-213">Этот метод принимает целочисленное значение, которое представляет максимальный размер буфера, и создает буфер, размеры которого не превышают это значение.</span><span class="sxs-lookup"><span data-stu-id="0e686-213">This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.</span></span> <span data-ttu-id="0e686-214">Если сообщение поступает из ненадежного источника, важно задать этому параметру безопасное значение.</span><span class="sxs-lookup"><span data-stu-id="0e686-214">It is important to set this to a safe value if the message is coming from an untrusted source.</span></span>  
  
 <span data-ttu-id="0e686-215">Буфер возвращается в виде экземпляра <xref:System.ServiceModel.Channels.MessageBuffer>.</span><span class="sxs-lookup"><span data-stu-id="0e686-215">The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span></span> <span data-ttu-id="0e686-216">Доступ к данным в буфере осуществляется несколькими способами.</span><span class="sxs-lookup"><span data-stu-id="0e686-216">You can access data in the buffer in several ways.</span></span> <span data-ttu-id="0e686-217">Основной способ - это вызов метода <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> для создания экземпляров `Message` из буфера.</span><span class="sxs-lookup"><span data-stu-id="0e686-217">The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.</span></span>  
  
 <span data-ttu-id="0e686-218">Доступ к данным в буфере также можно получить реализацией интерфейса <xref:System.Xml.XPath.IXPathNavigable>, который класс <xref:System.ServiceModel.Channels.MessageBuffer> реализует для осуществления прямого доступа к лежащему в основе XML-коду.</span><span class="sxs-lookup"><span data-stu-id="0e686-218">Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly.</span></span> <span data-ttu-id="0e686-219">Некоторые перегрузки метода <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> позволяют создавать навигаторы <xref:System.Xml.XPath>, защищенные квотой узла, которая ограничивает число узлов XML для посещения.</span><span class="sxs-lookup"><span data-stu-id="0e686-219">Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited.</span></span> <span data-ttu-id="0e686-220">Это позволяет предотвратить атаки типа "отказ в обслуживании", возникающие из-за длительного времени обработки.</span><span class="sxs-lookup"><span data-stu-id="0e686-220">This helps prevent denial of service attacks based on lengthy processing time.</span></span> <span data-ttu-id="0e686-221">По умолчанию эта квота выключена.</span><span class="sxs-lookup"><span data-stu-id="0e686-221">This quote is disabled by default.</span></span> <span data-ttu-id="0e686-222">Некоторые перегрузки метода `CreateNavigator` позволяют задавать, как следует обрабатывать пробелы в XML с использованием перечисления <xref:System.Xml.XmlSpace>, по умолчанию установлено значение `XmlSpace.None`.</span><span class="sxs-lookup"><span data-stu-id="0e686-222">Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.</span></span>  
  
 <span data-ttu-id="0e686-223">Наконец, доступ к содержимому буфера сообщений можно получить записью его содержимого в поток с использованием метода <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-223">A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span></span>  
  
 <span data-ttu-id="0e686-224">В следующем примере продемонстрирована работа с буфером сообщений `MessageBuffer`: входящее сообщение пересылается нескольким получателям, а затем записывается в файл.</span><span class="sxs-lookup"><span data-stu-id="0e686-224">The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file.</span></span> <span data-ttu-id="0e686-225">Это было бы невозможно без использования буфера, потому что в этом случае доступ к телу сообщения можно было бы получить только один раз.</span><span class="sxs-lookup"><span data-stu-id="0e686-225">Without buffering, this is not possible, because the message body can then be accessed only once.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]
 [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  
  
 <span data-ttu-id="0e686-226">Имеет смысл упомянуть и о других членах класса `MessageBuffer`.</span><span class="sxs-lookup"><span data-stu-id="0e686-226">The `MessageBuffer` class has other members worth noting.</span></span> <span data-ttu-id="0e686-227">Метод <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> можно вызвать для освобождения ресурсов, когда содержимое буфера больше не требуется.</span><span class="sxs-lookup"><span data-stu-id="0e686-227">The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required.</span></span> <span data-ttu-id="0e686-228">Свойство <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> возвращает размер выделенного буфера.</span><span class="sxs-lookup"><span data-stu-id="0e686-228">The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer.</span></span> <span data-ttu-id="0e686-229">Свойство <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> возвращает тип содержимого сообщения MIME.</span><span class="sxs-lookup"><span data-stu-id="0e686-229">The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.</span></span>  
  
## <a name="accessing-the-message-body-for-debugging"></a><span data-ttu-id="0e686-230">Доступ к телу сообщения для отладки</span><span class="sxs-lookup"><span data-stu-id="0e686-230">Accessing the Message Body for Debugging</span></span>  
 <span data-ttu-id="0e686-231">При отладке можно вызвать метод <xref:System.ServiceModel.Channels.Message.ToString%2A>, чтобы представить сообщение в качестве строки.</span><span class="sxs-lookup"><span data-stu-id="0e686-231">For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string.</span></span> <span data-ttu-id="0e686-232">Это представление, как правило, соответствует виду кодированного с помощью текстового кодировщика сообщения с той разницей, что XML лучше отформатирован для восприятия человеком.</span><span class="sxs-lookup"><span data-stu-id="0e686-232">This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.</span></span> <span data-ttu-id="0e686-233">Единственным исключением из вышесказанного является тело сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-233">The one exception to this is the message body.</span></span> <span data-ttu-id="0e686-234">Тело сообщения можно прочитать только один раз, и `ToString` не меняет состояние сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-234">The body can be read only once, and `ToString` does not change the message state.</span></span> <span data-ttu-id="0e686-235">Таким образом `ToString` метод может оказаться невозможным доступ к тексту и может потребоваться заменить заполнитель (например, «...» или многоточие) вместо тела сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-235">Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, "…" or three dots) instead of the message body.</span></span> <span data-ttu-id="0e686-236">Следовательно, не рекомендуется использовать `ToString` для записи сообщений в журнал, если важно содержимое тел сообщений.</span><span class="sxs-lookup"><span data-stu-id="0e686-236">Therefore, do not use `ToString` to log messages if the body content of the messages is important.</span></span>  
  
## <a name="accessing-other-message-parts"></a><span data-ttu-id="0e686-237">Осуществление доступа к другим частям сообщения</span><span class="sxs-lookup"><span data-stu-id="0e686-237">Accessing Other Message Parts</span></span>  
 <span data-ttu-id="0e686-238">Для получения доступа к другой информации о сообщении (кроме содержимого его тела) предоставляются различные свойства.</span><span class="sxs-lookup"><span data-stu-id="0e686-238">Various properties are provided to access information about the message other than its body contents.</span></span> <span data-ttu-id="0e686-239">Однако эти свойства невозможно вызвать после того, как сообщение было закрыто.</span><span class="sxs-lookup"><span data-stu-id="0e686-239">However, these cannot be called once the message has been closed:</span></span>  
  
-   <span data-ttu-id="0e686-240">Свойство <xref:System.ServiceModel.Channels.Message.Headers%2A> представляет заголовки сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-240">The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers.</span></span> <span data-ttu-id="0e686-241">См. подраздел «Работа с заголовками» далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="0e686-241">See the section on "Working with Headers" later in this topic.</span></span>  
  
-   <span data-ttu-id="0e686-242">Свойство <xref:System.ServiceModel.Channels.Message.Properties%2A> представляет свойства сообщения, которые являются элементами именованных данных, прикрепленных к сообщению; как правило, они не выдаются при отправке сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-242">The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.</span></span> <span data-ttu-id="0e686-243">См. подраздел "Работа со свойствами" далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="0e686-243">See the section on "Working with Properties" later in this topic.</span></span>  
  
-   <span data-ttu-id="0e686-244">Свойство <xref:System.ServiceModel.Channels.Message.Version%2A> указывает на версию SOAP и WS-Addressing, связанную с сообщением, или имеет значение `None`, если SOAP отключен.</span><span class="sxs-lookup"><span data-stu-id="0e686-244">The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.</span></span>  
  
-   <span data-ttu-id="0e686-245">Свойство <xref:System.ServiceModel.Channels.Message.IsFault%2A> возвращает значение `true`, если сообщение является сообщением об ошибке SOAP.</span><span class="sxs-lookup"><span data-stu-id="0e686-245">The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.</span></span>  
  
-   <span data-ttu-id="0e686-246">Свойство <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> возвращает значение `true`, если сообщение пустое.</span><span class="sxs-lookup"><span data-stu-id="0e686-246">The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.</span></span>  
  
 <span data-ttu-id="0e686-247">Для доступа к определенному атрибуту в программе-оболочке тела (например, <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29>), обозначаемому определенным именем и пространством имен, можно использовать метод `<soap:Body>`.</span><span class="sxs-lookup"><span data-stu-id="0e686-247">You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace.</span></span> <span data-ttu-id="0e686-248">Если такой атрибут не найден, возвращается значение `null`.</span><span class="sxs-lookup"><span data-stu-id="0e686-248">If such an attribute is not found, `null` is returned.</span></span> <span data-ttu-id="0e686-249">Этот метод можно вызвать, только если сообщение `Message` находится в состоянии Created (если доступ к телу сообщения еще не осуществлялся).</span><span class="sxs-lookup"><span data-stu-id="0e686-249">This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).</span></span>  
  
## <a name="working-with-headers"></a><span data-ttu-id="0e686-250">Работа с заголовками</span><span class="sxs-lookup"><span data-stu-id="0e686-250">Working with Headers</span></span>  
 <span data-ttu-id="0e686-251">Объект `Message` может содержать любое число именованных фрагментов XML, которые называются *заголовки*.</span><span class="sxs-lookup"><span data-stu-id="0e686-251">A `Message` can contain any number of named XML fragments, called *headers*.</span></span> <span data-ttu-id="0e686-252">Как правило, каждый фрагмент сопоставляется заголовку SOAP.</span><span class="sxs-lookup"><span data-stu-id="0e686-252">Each fragment normally maps to a SOAP header.</span></span> <span data-ttu-id="0e686-253">Доступ к заголовкам осуществляется через свойство `Headers` типа <xref:System.ServiceModel.Channels.MessageHeaders>.</span><span class="sxs-lookup"><span data-stu-id="0e686-253">Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>.</span></span> <span data-ttu-id="0e686-254"><xref:System.ServiceModel.Channels.MessageHeaders> - это коллекция объектов <xref:System.ServiceModel.Channels.MessageHeaderInfo>. Доступ к отдельным заголовкам осуществляется через его интерфейс <xref:System.Collections.IEnumerable> или индексатор.</span><span class="sxs-lookup"><span data-stu-id="0e686-254"><xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer.</span></span> <span data-ttu-id="0e686-255">Например, в следующем коде перечислены имена всех заголовков в сообщении `Message`.</span><span class="sxs-lookup"><span data-stu-id="0e686-255">For example, the following code lists the names of all the headers in a `Message`.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]
 [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  
  
#### <a name="adding-removing-finding-headers"></a><span data-ttu-id="0e686-256">Добавление, удаление, нахождение заголовков</span><span class="sxs-lookup"><span data-stu-id="0e686-256">Adding, Removing, Finding Headers</span></span>  
 <span data-ttu-id="0e686-257">С помощью метода <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> можно добавлять новый заголовок в конце всех существующих заголовков.</span><span class="sxs-lookup"><span data-stu-id="0e686-257">You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method.</span></span> <span data-ttu-id="0e686-258">Для вставки заголовка в заданном индексе можно использовать метод <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-258">You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index.</span></span> <span data-ttu-id="0e686-259">Существующие заголовки сдвигаются на вставленный элемент.</span><span class="sxs-lookup"><span data-stu-id="0e686-259">Existing headers are shifted for the inserted item.</span></span> <span data-ttu-id="0e686-260">Заголовки упорядочиваются по индексу, первым доступным индексом является 0.</span><span class="sxs-lookup"><span data-stu-id="0e686-260">Headers are ordered according to their index, and the first available index is 0.</span></span> <span data-ttu-id="0e686-261">Можно использовать различные методы перегрузки <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> для добавления заголовков из другого экземпляра `Message` или `MessageHeaders`.</span><span class="sxs-lookup"><span data-stu-id="0e686-261">You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance.</span></span> <span data-ttu-id="0e686-262">Некоторые перегрузки копируют только один заголовок, другие копируют все заголовки.</span><span class="sxs-lookup"><span data-stu-id="0e686-262">Some overloads copy one individual header, while others copy all of them.</span></span> <span data-ttu-id="0e686-263">Метод <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> удаляет все заголовки.</span><span class="sxs-lookup"><span data-stu-id="0e686-263">The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers.</span></span> <span data-ttu-id="0e686-264">Метод <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> удаляет заголовок в определенном индексе (сдвигая все заголовки после него).</span><span class="sxs-lookup"><span data-stu-id="0e686-264">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it).</span></span> <span data-ttu-id="0e686-265">Метод <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> удаляет все заголовки с определенным именем и пространством имен.</span><span class="sxs-lookup"><span data-stu-id="0e686-265">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.</span></span>  
  
 <span data-ttu-id="0e686-266">Метод <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> позволяет извлечь определенный заголовок.</span><span class="sxs-lookup"><span data-stu-id="0e686-266">Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method.</span></span> <span data-ttu-id="0e686-267">Этот метод использует для нахождения заголовка его имя и пространство имен и возвращает его индекс.</span><span class="sxs-lookup"><span data-stu-id="0e686-267">This method takes the name and namespace of the header to find, and returns its index.</span></span> <span data-ttu-id="0e686-268">Если заголовок встречается более одного раза, создается исключение.</span><span class="sxs-lookup"><span data-stu-id="0e686-268">If the header occurs more than once, an exception is thrown.</span></span> <span data-ttu-id="0e686-269">Если заголовок не найден, возвращается -1.</span><span class="sxs-lookup"><span data-stu-id="0e686-269">If the header is not found, it returns -1.</span></span>  
  
 <span data-ttu-id="0e686-270">В модели заголовков SOAP заголовки могут иметь значение `Actor`, которое задает законного получателя заголовка.</span><span class="sxs-lookup"><span data-stu-id="0e686-270">In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header.</span></span> <span data-ttu-id="0e686-271">Основная перегрузка метода `FindHeader` осуществляет только поиск заголовков, предназначенных для конечного получателя сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-271">The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message.</span></span> <span data-ttu-id="0e686-272">Другая перегрузка метода позволяет указать, какие значения `Actor` необходимо включить в поиск.</span><span class="sxs-lookup"><span data-stu-id="0e686-272">However, another overload enables you to specify which `Actor` values are included in the search.</span></span> <span data-ttu-id="0e686-273">Дополнительные сведения см. в спецификации SOAP.</span><span class="sxs-lookup"><span data-stu-id="0e686-273">For more information, see the SOAP specification.</span></span>  
  
 <span data-ttu-id="0e686-274">Метод <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> предоставляется для копирования заголовков из коллекции <xref:System.ServiceModel.Channels.MessageHeaders> в массив объектов <xref:System.ServiceModel.Channels.MessageHeaderInfo>.</span><span class="sxs-lookup"><span data-stu-id="0e686-274">A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.</span></span>  
  
 <span data-ttu-id="0e686-275">Чтобы получить доступ к XML-данным в заголовке, можно вызвать метод <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> и вернуть средство чтения XML для конкретного индекса заголовка.</span><span class="sxs-lookup"><span data-stu-id="0e686-275">To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index.</span></span> <span data-ttu-id="0e686-276">При необходимости десериализовать содержимое заголовка в объект, следует использовать <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> или любую другую перегрузку.</span><span class="sxs-lookup"><span data-stu-id="0e686-276">If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads.</span></span> <span data-ttu-id="0e686-277">Основные перегрузки десериализуют заголовки с помощью сериализатора <xref:System.Runtime.Serialization.DataContractSerializer>, настроенного по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0e686-277">The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way.</span></span> <span data-ttu-id="0e686-278">При необходимости использовать другой сериализатор или сериализатор `DataContractSerializer` с другими настройками используйте одну из перегрузок, принимающих `XmlObjectSerializer`.</span><span class="sxs-lookup"><span data-stu-id="0e686-278">If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`.</span></span> <span data-ttu-id="0e686-279">Существуют перегрузки, принимающие вместо индекса имя заголовка, пространство имен и дополнительно список значений `Actor`; в этом случае получается сочетание `FindHeader` и `GetHeader`.</span><span class="sxs-lookup"><span data-stu-id="0e686-279">There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.</span></span>  
  
## <a name="working-with-properties"></a><span data-ttu-id="0e686-280">Работа со свойствами</span><span class="sxs-lookup"><span data-stu-id="0e686-280">Working with Properties</span></span>  
 <span data-ttu-id="0e686-281">Экземпляр `Message` может содержать произвольное число именованных объектов произвольных типов.</span><span class="sxs-lookup"><span data-stu-id="0e686-281">A `Message` instance can contain an arbitrary number of named objects of arbitrary types.</span></span> <span data-ttu-id="0e686-282">Доступ к этой коллекции осуществляется через свойство `Properties` типа `MessageProperties`.</span><span class="sxs-lookup"><span data-stu-id="0e686-282">This collection is accessed through the `Properties` property of type `MessageProperties`.</span></span> <span data-ttu-id="0e686-283">Коллекция реализует интерфейс <xref:System.Collections.Generic.IDictionary%602> и действует как сопоставление между <xref:System.String> и <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="0e686-283">The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>.</span></span> <span data-ttu-id="0e686-284">Как правило, значения свойств не сопоставляются непосредственно любую часть сообщения в сети, а также предоставляют различные сообщения подсказки об различным каналам в стеке каналов WCF или к обработке <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> инфраструктура службы.</span><span class="sxs-lookup"><span data-stu-id="0e686-284">Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework.</span></span> <span data-ttu-id="0e686-285">Пример см. в разделе [Общие сведения об архитектуре передачи данных](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).</span><span class="sxs-lookup"><span data-stu-id="0e686-285">For an example, see [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).</span></span>  
  
## <a name="inheriting-from-the-message-class"></a><span data-ttu-id="0e686-286">Наследование от класса сообщений</span><span class="sxs-lookup"><span data-stu-id="0e686-286">Inheriting from the Message Class</span></span>  
 <span data-ttu-id="0e686-287">Если встроенные типы сообщений, созданные с использованием `CreateMessage`, не соответствуют предъявляемым требованиям, можно создать класс, который наследуется от класса `Message`.</span><span class="sxs-lookup"><span data-stu-id="0e686-287">If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.</span></span>  
  
### <a name="defining-the-message-body-contents"></a><span data-ttu-id="0e686-288">Определение содержимого тела сообщения</span><span class="sxs-lookup"><span data-stu-id="0e686-288">Defining the Message Body Contents</span></span>  
 <span data-ttu-id="0e686-289">Для осуществления доступа к данным в теле сообщения существует три основных методики: запись, чтение и копирование в буфер.</span><span class="sxs-lookup"><span data-stu-id="0e686-289">Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.</span></span> <span data-ttu-id="0e686-290">Эти операции, по сути, сводятся к вызову для производного класса <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> методов <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> и `Message` соответственно.</span><span class="sxs-lookup"><span data-stu-id="0e686-290">These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`.</span></span> <span data-ttu-id="0e686-291">Базовый класс `Message` гарантирует, что для каждого экземпляра `Message` вызывается только один из этих методов и вызывается однократно.</span><span class="sxs-lookup"><span data-stu-id="0e686-291">The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once.</span></span> <span data-ttu-id="0e686-292">Базовый класс также гарантирует, что эти методы не вызываются для закрытого сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-292">The base class also ensures that the methods are not called on a closed message.</span></span> <span data-ttu-id="0e686-293">Нет необходимости отслеживать состояние сообщения в реализации.</span><span class="sxs-lookup"><span data-stu-id="0e686-293">There is no need to track the message state in your implementation.</span></span>  
  
 <span data-ttu-id="0e686-294">Метод <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> является абстрактным и должен быть реализован.</span><span class="sxs-lookup"><span data-stu-id="0e686-294"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented.</span></span> <span data-ttu-id="0e686-295">Основным способом определения содержимого тела сообщения является его запись с помощью этого метода.</span><span class="sxs-lookup"><span data-stu-id="0e686-295">The most basic way to define the body contents of your message is to write using this method.</span></span> <span data-ttu-id="0e686-296">Например, в следующем сообщении содержится 100 000 случайных чисел от 1 до 20.</span><span class="sxs-lookup"><span data-stu-id="0e686-296">For example, the following message contains 100,000 random numbers from 1 to 20.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]
 [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  
  
 <span data-ttu-id="0e686-297">Методы `OnGetReaderAtBodyContents` и `OnCreateBufferedCopy` имеют реализации по умолчанию, которые срабатывают в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="0e686-297">The `OnGetReaderAtBodyContents` and `OnCreateBufferedCopy` methods have default implementations that work for most cases.</span></span> <span data-ttu-id="0e686-298">Реализации по умолчанию вызывают метод `OnWriteBodyContents`, буферизуют результаты и работают с получившимся буфером.</span><span class="sxs-lookup"><span data-stu-id="0e686-298">The default implementations call `OnWriteBodyContents`, buffer the results, and work with the resulting buffer.</span></span> <span data-ttu-id="0e686-299">Однако в некоторых случаях этого недостаточно.</span><span class="sxs-lookup"><span data-stu-id="0e686-299">However, in some cases this may not be enough.</span></span> <span data-ttu-id="0e686-300">В предыдущем примере чтение сообщения приводит к буферизации 100 000 элементов XML, что может оказаться нежелательным.</span><span class="sxs-lookup"><span data-stu-id="0e686-300">In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.</span></span> <span data-ttu-id="0e686-301">Возможно, для возвращения пользовательского производного класса `OnGetReaderAtBodyContents`, обслуживающего случайные числа, целесообразно переопределить метод `XmlDictionaryReader`.</span><span class="sxs-lookup"><span data-stu-id="0e686-301">You might want to override `OnGetReaderAtBodyContents` to return a custom `XmlDictionaryReader` derived class that serves up random numbers.</span></span> <span data-ttu-id="0e686-302">Затем можно переопределить метод `OnWriteBodyContents` для использования средства чтения, возвращаемого свойством `OnGetReaderAtBodyContents`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="0e686-302">You can then override `OnWriteBodyContents` to use the reader that the `OnGetReaderAtBodyContents` property returns, as shown in the following example.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]
 [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  
  
 <span data-ttu-id="0e686-303">Аналогично, для возвращения собственного производного класса `OnCreateBufferedCopy` имеет смысл переопределить метод `MessageBuffer`.</span><span class="sxs-lookup"><span data-stu-id="0e686-303">Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.</span></span>  
  
 <span data-ttu-id="0e686-304">Производный класс сообщения должен не только предоставлять содержимое тела сообщения, но и переопределять свойства `Version`, `Headers` и `Properties`.</span><span class="sxs-lookup"><span data-stu-id="0e686-304">In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.</span></span>  
  
 <span data-ttu-id="0e686-305">Обратите внимание, что если создать копию сообщения, в ней будут использоваться заголовки из оригинального сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-305">Note that if you create a copy of a message, the copy uses the message headers from the original.</span></span>  
  
### <a name="other-members-that-can-be-overridden"></a><span data-ttu-id="0e686-306">Другие переопределяемые члены</span><span class="sxs-lookup"><span data-stu-id="0e686-306">Other Members that Can Be Overridden</span></span>  
 <span data-ttu-id="0e686-307">Чтобы задать способ записи конверта SOAP, заголовков SOAP и открывающих тегов элементов тела сообщения SOAP, можно переопределить методы <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> и <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A>. Как правило, эти методы соответствуют `<soap:Envelope>`, `<soap:Header>` и `<soap:Body>`.</span><span class="sxs-lookup"><span data-stu-id="0e686-307">You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`.</span></span> <span data-ttu-id="0e686-308">Если свойство `Version` возвращает значение `MessageVersion.None`, как правило, эти методы ничего не записывают.</span><span class="sxs-lookup"><span data-stu-id="0e686-308">These methods should normally not write anything out if the `Version` property returns `MessageVersion.None`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0e686-309">До вызова метода `OnGetReaderAtBodyContents` и буферизации результатов используемая по умолчанию реализация `OnWriteStartEnvelope` вызывает методы `OnWriteStartBody` и `OnWriteBodyContents`.</span><span class="sxs-lookup"><span data-stu-id="0e686-309">The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results.</span></span> <span data-ttu-id="0e686-310">Заголовки не записываются.</span><span class="sxs-lookup"><span data-stu-id="0e686-310">Headers are not written out.</span></span>  
  
 <span data-ttu-id="0e686-311">Чтобы изменить способ создания целого сообщения из различных элементов, необходимо переопределить метод <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-311">Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces.</span></span> <span data-ttu-id="0e686-312">Метод `OnWriteMessage` вызывается из <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> и реализации по умолчанию <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-312">The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation.</span></span> <span data-ttu-id="0e686-313">Обратите внимание, что переопределять <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="0e686-313">Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice.</span></span> <span data-ttu-id="0e686-314">Вместо этого целесообразнее переопределить соответствующие методы `On` (например, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> и <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>).</span><span class="sxs-lookup"><span data-stu-id="0e686-314">It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span></span>  
  
 <span data-ttu-id="0e686-315">Чтобы переопределить способ представления тела сообщения в ходе отладки необходимо переопределить метод <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-315">Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging.</span></span> <span data-ttu-id="0e686-316">По умолчанию для этого необходимо представить его в виде многоточия ("...").</span><span class="sxs-lookup"><span data-stu-id="0e686-316">The default is to represent it as three dots ("…").</span></span> <span data-ttu-id="0e686-317">Обратите внимание, что этот метод можно вызывать несколько раз при любом состоянии сообщения, кроме Closed.</span><span class="sxs-lookup"><span data-stu-id="0e686-317">Note that this method can be called multiple times when the message state is anything other than Closed.</span></span> <span data-ttu-id="0e686-318">Реализация этого метода никогда не должна вызывать действие, которое должно выполняться однократно (например, чтение из потока только в прямом направлении).</span><span class="sxs-lookup"><span data-stu-id="0e686-318">An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).</span></span>  
  
 <span data-ttu-id="0e686-319">Чтобы разрешить доступ к атрибутам в элементе тела сообщения SOAP, нужно переопределить метод <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-319">Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element.</span></span> <span data-ttu-id="0e686-320">Этот метод можно вызывать неограниченное количество раз, но базовый тип сообщения `Message` гарантирует, что этот метод вызывается, только если сообщение находится в состоянии Created.</span><span class="sxs-lookup"><span data-stu-id="0e686-320">This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state.</span></span> <span data-ttu-id="0e686-321">В реализации не требуется проверять состояние сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-321">It is not required to check the state in an implementation.</span></span> <span data-ttu-id="0e686-322">Реализация по умолчанию всегда возвращает значение `null`, что указывает на отсутствие атрибутов в элементе тела сообщения.</span><span class="sxs-lookup"><span data-stu-id="0e686-322">The default implementation always returns `null`, which indicates that there are no attributes on the body element.</span></span>  
  
 <span data-ttu-id="0e686-323">Если объект `Message` должен выполнить какие-либо специальные операции очистки, когда тело сообщения больше не требуется, можно переопределить метод <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="0e686-323">If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span></span> <span data-ttu-id="0e686-324">Реализация по умолчанию не выполняет никаких действий.</span><span class="sxs-lookup"><span data-stu-id="0e686-324">The default implementation does nothing.</span></span>  
  
 <span data-ttu-id="0e686-325">Свойства `IsEmpty` и `IsFault` могут переопределяться.</span><span class="sxs-lookup"><span data-stu-id="0e686-325">The `IsEmpty` and `IsFault` properties can be overridden.</span></span> <span data-ttu-id="0e686-326">По умолчанию оба свойства возвращают `false`.</span><span class="sxs-lookup"><span data-stu-id="0e686-326">By default, both return `false`.</span></span>
