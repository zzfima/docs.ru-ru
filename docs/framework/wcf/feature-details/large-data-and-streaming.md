---
title: Большие наборы данных и потоковая передача
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 91e53f66fb0f2f94a315c318eb0b203d78427bae
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79184682"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="290b2-102">Большие наборы данных и потоковая передача</span><span class="sxs-lookup"><span data-stu-id="290b2-102">Large Data and Streaming</span></span>

<span data-ttu-id="290b2-103">Windows Communication Foundation (WCF) — это инфраструктура связи на основе XML.</span><span class="sxs-lookup"><span data-stu-id="290b2-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="290b2-104">Поскольку данные XML обычно закодированы в стандартном текстовом формате, определенном в [спецификации XML 1.0,](https://www.w3.org/TR/REC-xml/)разработчики и архитекторы подключенных систем, как правило, обеспокоены следом проводов (или размером) сообщений, отправляемых по сети, а кодирование XML на основе текста создает особые проблемы для эффективной передачи двоичных данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="290b2-105">Основные вопросы</span><span class="sxs-lookup"><span data-stu-id="290b2-105">Basic Considerations</span></span>  
 <span data-ttu-id="290b2-106">Чтобы предоставить справочную информацию о следующей информации для WCF, в этом разделе освещаются некоторые общие проблемы и соображения для кодирования, двоичных данных и потоковой передачи, которые обычно применяются к подключенным инфраструктурам систем.</span><span class="sxs-lookup"><span data-stu-id="290b2-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="290b2-107">Кодирование данных: текстовый формат в сравнении с двоичным</span><span class="sxs-lookup"><span data-stu-id="290b2-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="290b2-108">Общие вопросы разработчиков включают в себя понимание того, что для XML характерна значительная нагрузка по сравнению с двоичными форматами из-за повторяющейся сущности открывающих и закрывающих тегов, и кодирование числовых значений требует значительно больших ресурсов, поскольку они выражаются текстовыми значениями, и эффективное выражение двоичных данных невозможно, т.к. они требуют специального кодирования для внедрения в текстовый формат.</span><span class="sxs-lookup"><span data-stu-id="290b2-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="290b2-109">В то время как многие из этих и аналогичных вопросов действительно актуальны, фактическое различие между сообщениями с кодированием в виде текста XML в среде веб-служб XML и сообщениями с двоичным кодированием в предыдущей среде удаленного вызова процедур (RPC) часто намного менее значимо по сравнению с изначальными соображениями.</span><span class="sxs-lookup"><span data-stu-id="290b2-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="290b2-110">Тогда как сообщения с кодированием в виде текста XML прозрачны и имеют удобочитаемый вид, двоичные сообщения часто непонятны в сравнении с ними и сложны для декодирования без специальных средств.</span><span class="sxs-lookup"><span data-stu-id="290b2-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="290b2-111">Такая разница в читаемости становится причиной игнорирования того факта, что двоичные сообщения часто содержат встроенные метаданные в полезной нагрузке, что приводит к увеличению объема служебных данных как и в случае сообщений в виде текста XML.</span><span class="sxs-lookup"><span data-stu-id="290b2-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="290b2-112">Это особенно актуально для двоичных форматов, направленных на обеспечение возможностей слабого соединения и динамического вызова.</span><span class="sxs-lookup"><span data-stu-id="290b2-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="290b2-113">Однако двоичные форматы в основном содержат такие описательные метаданные в "заголовке", что также объявляет макет данных для следующих записей данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="290b2-114">Полезная нагрузка согласуется с таким общим объявлением блока метаданных при минимальном увеличении объема служебных данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="290b2-115">В противоположность этому, XML заключает каждый элемент данных в элемент или атрибут, чтобы заключенные метаданные постоянно указывались для каждого сериализованного объекта полезной нагрузки.</span><span class="sxs-lookup"><span data-stu-id="290b2-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="290b2-116">В результате этого размер одного сериализованного объекта полезной нагрузки аналогичен, если сравнивать текстовое и двоичное представление, поскольку некоторые описательные метаданные должны быть выражены для обоих форматов, но двоичный формат более удобен из-за описания общих метаданных с каждым дополнительным объектом полезной нагрузки, передаваемым благодаря низкой общей нагрузке.</span><span class="sxs-lookup"><span data-stu-id="290b2-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="290b2-117">Однако для некоторых типов данных, например чисел, использование двоичных числовых представлений фиксированного размера (например, 128-разрядного десятичного типа вместо обычного текста) может показать свою неэффективность, поскольку текстовое представление может быть на несколько байт меньше.</span><span class="sxs-lookup"><span data-stu-id="290b2-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="290b2-118">Текстовые данные также могут иметь преимущества в отношении размера благодаря обычно более гибким вариантам кодирования текста XML, тогда как некоторые двоичные форматы могут иметь по умолчанию 16-разрядную или даже 32-разрядную кодировку Юникод, что непригодно для формата двоичных XML-данных .NET.</span><span class="sxs-lookup"><span data-stu-id="290b2-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="290b2-119">В результате этого выбор между текстовым и двоичным форматом не так прост, как если бы принимался во внимание тот факт, что двоичные сообщения всегда меньше сообщений в виде текста XML.</span><span class="sxs-lookup"><span data-stu-id="290b2-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="290b2-120">Явное преимущество текстовых XML-сообщений заключается в том, что они основаны на стандартах и обеспечивают более широкие возможности взаимодействия и поддержки платформ.</span><span class="sxs-lookup"><span data-stu-id="290b2-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="290b2-121">Для получения дополнительной информации, см.</span><span class="sxs-lookup"><span data-stu-id="290b2-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="290b2-122">Двоичное содержимое</span><span class="sxs-lookup"><span data-stu-id="290b2-122">Binary Content</span></span>  
 <span data-ttu-id="290b2-123">Сферами, где двоичное кодирование превосходит кодирование на основе текста в отношении получаемого размера сообщений, являются большие элементы двоичных данных, например изображения, видеоролики, звукозаписи или другие виды непрозрачных, двоичных данных, обмен которыми осуществляется между службами и их пользователями.</span><span class="sxs-lookup"><span data-stu-id="290b2-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="290b2-124">Чтобы преобразовать эти типы данных в текст XML, они, как правило, кодируются с помощью кодирования Base64.</span><span class="sxs-lookup"><span data-stu-id="290b2-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="290b2-125">В строке с кодированием Base64 каждый символ представляет 6-разрядные данные вместо исходных 8-разрядных, в результате чего соотношение кодирование-нагрузка для Base64 равно 4:3, не считая символы дополнительного форматирования (возврат каретки/переход на новую строку), которые обычно добавляются.</span><span class="sxs-lookup"><span data-stu-id="290b2-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="290b2-126">Тогда как значимость различий между кодированием XML и двоичным кодированием обычно зависит от сценария, увеличение размера более чем на 33% при передаче полезной нагрузки 500 МБ, как правило, неприемлемо.</span><span class="sxs-lookup"><span data-stu-id="290b2-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="290b2-127">Чтобы избежать такой чрезмерной нагрузки при кодировании, стандарт подсистемы оптимизации передачи сообщений (MTOM) позволяет внешне выражать большие элементы данных, содержащиеся в сообщении, и передавать их с сообщением в качестве двоичных данных без какого-либо специального кодирования.</span><span class="sxs-lookup"><span data-stu-id="290b2-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="290b2-128">С MTOM сообщения обмениваются аналогичным образом с простыми сообщениями по электронной почте (SMTP) с вложениями или встроенным контентом (картинки и другое встроенное содержимое); Сообщения MTOM упаковываются как многокомпонентные/связанные последовательности MIME, а корневая часть является фактическим сообщением SOAP.</span><span class="sxs-lookup"><span data-stu-id="290b2-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="290b2-129">Сообщение MTOM SOAP изменяется с некодированной версии таким образом, что специальные теги элементов, относящиеся к соответствующим частям MIME, занимают место исходных элементов в сообщении, содержащем двоичные данные.</span><span class="sxs-lookup"><span data-stu-id="290b2-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="290b2-130">В результате этого сообщение SOAP относится к двоичному содержимому, указывая на отправленные с ним части MIME, но передает только текстовые данные XML.</span><span class="sxs-lookup"><span data-stu-id="290b2-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="290b2-131">Поскольку эта модель тесно связана с надежной моделью SMTP, существует широкая поддержка в виде средств для кодирования и декодирования сообщений MTOM на многих платформах, что обеспечивает исключительные возможности взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="290b2-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="290b2-132">Тем не менее, как и в случае с Base64, для MTOM также характерен некоторый объем служебных данных для формата MIME, поэтому преимущества использования MTOM проявляются только, когда размер элемента двоичных данных превышает 1 КБ.</span><span class="sxs-lookup"><span data-stu-id="290b2-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="290b2-133">Из-за служебных данных сообщения, закодированные в MTOM, могут оказаться больше, чем сообщения в кодировке Base64 для двоичных данных, если двоичная полезная нагрузка не превышает это пороговое значение.</span><span class="sxs-lookup"><span data-stu-id="290b2-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="290b2-134">Для получения дополнительной информации, см.</span><span class="sxs-lookup"><span data-stu-id="290b2-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="290b2-135">Содержимое данных большого объема</span><span class="sxs-lookup"><span data-stu-id="290b2-135">Large Data Content</span></span>  
 <span data-ttu-id="290b2-136">Если не учитывать расстояние передачи, ранее упомянутая полезная нагрузка 500 МБ также создает большую проблему в локальной среде на уровне службы и клиента.</span><span class="sxs-lookup"><span data-stu-id="290b2-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="290b2-137">По умолчанию WCF обрабатывает сообщения в *буферизированном режиме.*</span><span class="sxs-lookup"><span data-stu-id="290b2-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="290b2-138">Это означает, что все содержимое сообщения находится в памяти до его отправки или после получения.</span><span class="sxs-lookup"><span data-stu-id="290b2-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="290b2-139">Хотя это и является хорошей стратегией для большинства сценариев и необходимо для таких возможностей обмена сообщениями, как цифровые сигнатуры и надежная доставка, большие сообщения могут исчерпать системные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="290b2-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="290b2-140">Стратегией обработки больших полезных нагрузок является потоковая передача.</span><span class="sxs-lookup"><span data-stu-id="290b2-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="290b2-141">Хотя сообщения, в особенности выраженные в XML, как правило, считаются относительно компактными пакетами данных, сообщение может иметь размер в несколько гигабайт и напоминать непрерывный поток данных, а не пакет данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="290b2-142">Когда данные передаются в потоковом, а не буферизованном режиме, отправитель открывает содержимое тела сообщения для получателя в виде потока, и инфраструктура сообщения непрерывно направляет данные от отправителя получателю по мере их поступления.</span><span class="sxs-lookup"><span data-stu-id="290b2-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="290b2-143">Наиболее распространенным сценарием, при котором осуществляется передача содержания данных такого большого объема, является передача объектов двоичных данных, которые:</span><span class="sxs-lookup"><span data-stu-id="290b2-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="290b2-144">невозможно легко разбить на последовательность сообщений;</span><span class="sxs-lookup"><span data-stu-id="290b2-144">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="290b2-145">должны быть своевременно доставлены;</span><span class="sxs-lookup"><span data-stu-id="290b2-145">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="290b2-146">недоступны полностью при начале передачи.</span><span class="sxs-lookup"><span data-stu-id="290b2-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="290b2-147">Данные, не имеющие этих ограничений, обычно лучше отправлять в виде последовательностей сообщений в рамках одного сеанса, а не одним большим сообщением.</span><span class="sxs-lookup"><span data-stu-id="290b2-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="290b2-148">Для получения дополнительной информации смотрите раздел "Потоковые данные" позже в этой теме.</span><span class="sxs-lookup"><span data-stu-id="290b2-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="290b2-149">При отправке больших объемов данных `maxAllowedContentLength` необходимо установить настройку IIS (для получения дополнительной `maxReceivedMessageSize` информации см. [Настройка лимитов запросов IIS)](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)и параметр привязки (например, [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) или <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span><span class="sxs-lookup"><span data-stu-id="290b2-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="290b2-150">Свойство `maxAllowedContentLength` по умолчанию до 28,6 МБ, а `maxReceivedMessageSize` свойство по умолчанию до 64KB.</span><span class="sxs-lookup"><span data-stu-id="290b2-150">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="290b2-151">Кодирование</span><span class="sxs-lookup"><span data-stu-id="290b2-151">Encodings</span></span>  
 <span data-ttu-id="290b2-152">*Кодирование* определяет набор правил о том, как представлять сообщения на проводе.</span><span class="sxs-lookup"><span data-stu-id="290b2-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="290b2-153">*Кодер* реализует такое кодирование и отвечает, со стороны отправителя, за <xref:System.ServiceModel.Channels.Message> превращение в памяти в поток байта или буфер байта, который может быть отправлен по сети.</span><span class="sxs-lookup"><span data-stu-id="290b2-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="290b2-154">На стороне получателя кодировщик преобразует последовательность байтов в сообщение в памяти.</span><span class="sxs-lookup"><span data-stu-id="290b2-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="290b2-155">WCF включает в себя три кодера и позволяет писать и подключать свои собственные кодеры, если это необходимо.</span><span class="sxs-lookup"><span data-stu-id="290b2-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="290b2-156">Каждая стандартная привязка включает в себя предварительно настроенный кодировщик, в соответствии с чем привязки с префиксом Net\* используют двоичный кодировщик (путем включения класса <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>), тогда как классы <xref:System.ServiceModel.BasicHttpBinding> и <xref:System.ServiceModel.WSHttpBinding> используют кодировщик текстовых сообщений (с помощью класса <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>) по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="290b2-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="290b2-157">Элемент привязки кодировщика</span><span class="sxs-lookup"><span data-stu-id="290b2-157">Encoder binding element</span></span>|<span data-ttu-id="290b2-158">Описание</span><span class="sxs-lookup"><span data-stu-id="290b2-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="290b2-159">Кодировщик текстовых сообщений является кодировщиком по умолчанию для всех привязок на основе HTTP и представляет собой правильный выбор для всех пользовательских привязок, где наибольшее значение имеет взаимодействие.</span><span class="sxs-lookup"><span data-stu-id="290b2-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="290b2-160">Этот кодировщик считывает и записывает текстовые сообщения стандарта SOAP 1.1/SOAP 1.2 без специальной обработки двоичных данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="290b2-161">Если <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> свойство сообщения настроено <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>на, обертка конверта SOAP опущена из вывода и только содержимое тела сообщения сериализуется.</span><span class="sxs-lookup"><span data-stu-id="290b2-161">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="290b2-162">Кодировщик сообщений MTOM представляет собой текстовый кодировщик, реализующий специальную обработку двоичных данных и не используется по умолчанию в любой из стандартных привязок, поскольку он является только программой индивидуальной оптимизации.</span><span class="sxs-lookup"><span data-stu-id="290b2-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="290b2-163">Если сообщение содержит двоичные данные, превышающие предел, при котором кодирование MTOM обладает преимуществом, данные внешне выводятся в часть MIME вслед за конвертом сообщения.</span><span class="sxs-lookup"><span data-stu-id="290b2-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="290b2-164">См. "Реализация MTOM" далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="290b2-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="290b2-165">Двоичный кодеер сообщения является кодером по умолчанию для привязок Net и подходящим выбором всякий раз, когда обе коммуникационные стороны основаны на WCF.</span><span class="sxs-lookup"><span data-stu-id="290b2-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="290b2-166">Кодировщик двоичных сообщений использует формат двоичных XML-данных .NET, двоичное представление для информационных наборов XML (Infosets), относящееся к продуктам Майкрософт, для которого характерно меньшее занимаемое место по сравнению с аналогичным представлением XML 1.0, и этот кодировщик кодирует двоичные данные как поток байтов.</span><span class="sxs-lookup"><span data-stu-id="290b2-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="290b2-167">Текстовое кодирование сообщений обычно идеальный выбор для любого пути передачи, требующего взаимодействия, а двоичное кодирование сообщений отлично подходит для любых других путей передачи.</span><span class="sxs-lookup"><span data-stu-id="290b2-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="290b2-168">Двоичное кодирование, как правило, приводит к уменьшению размеров сообщений по сравнению с текстом применительно к одному сообщению, а на протяжении сеанса связи размеры сообщений неизменно становятся еще меньше.</span><span class="sxs-lookup"><span data-stu-id="290b2-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="290b2-169">В отличие от текстового кодирования для двоичного не требуется специальная обработка двоичных данных, например использование Base64, и оно представляет байты как байты.</span><span class="sxs-lookup"><span data-stu-id="290b2-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="290b2-170">Если в решении не используется взаимодействие, но тем не менее следует использовать транспорт HTTP, можно создать <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> в пользовательской привязке, использующей для транспорта класс <xref:System.ServiceModel.Channels.HttpTransportBindingElement>.</span><span class="sxs-lookup"><span data-stu-id="290b2-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="290b2-171">Если для ряда клиентов службы необходимо обеспечить взаимодействие, рекомендуется открыть параллельные конечные точки, чтобы у каждой из них имелись правильные варианты транспорта и кодирования для соответствующих клиентов.</span><span class="sxs-lookup"><span data-stu-id="290b2-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="290b2-172">Реализация MTOM</span><span class="sxs-lookup"><span data-stu-id="290b2-172">Enabling MTOM</span></span>  
 <span data-ttu-id="290b2-173">Если требуется обеспечить взаимодействие и планируется отправка больших объемов двоичных данных, в качестве альтернативной стратегии можно использовать кодирование сообщений MTOM, которое можно реализовать для стандартных привязок <xref:System.ServiceModel.BasicHttpBinding> или <xref:System.ServiceModel.WSHttpBinding>, задав соответствующее свойство `MessageEncoding` как <xref:System.ServiceModel.WSMessageEncoding.Mtom> или создав <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> в <xref:System.ServiceModel.Channels.CustomBinding>.</span><span class="sxs-lookup"><span data-stu-id="290b2-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="290b2-174">Следующий пример кода, извлеченный из образца [кодирования MTOM,](../../../../docs/framework/wcf/samples/mtom-encoding.md) показывает, как включить MTOM в конфигурации.</span><span class="sxs-lookup"><span data-stu-id="290b2-174">The following example code, extracted from the [MTOM Encoding](../../../../docs/framework/wcf/samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="290b2-175">Как уже упоминалось ранее, решение об использовании кодирования MTOM зависит от объема отправляемых данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="290b2-176">Кроме того, поскольку MTOM реализуется на уровне привязки, MTOM влияет на все операции в указанной конечной точке.</span><span class="sxs-lookup"><span data-stu-id="290b2-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="290b2-177">Поскольку кодировщик MTOM всегда выдает кодированное MTOM MIME/многоэлементное сообщение независимо от того, заканчиваются ли двоичные данные во время внешнего вывода, в обычной ситуации необходимо реализовывать MTOM только для конечных точек, в которых осуществляется обмен сообщениями объемом более 1 КБ двоичных данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="290b2-178">Кроме того, контракты служб, разработанные для использования с конечными точками с MTOM, должны, где возможно, ограничиваться указанием таких операций передачи данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="290b2-179">Связанная функциональность управления должна находиться в отдельном контракте.</span><span class="sxs-lookup"><span data-stu-id="290b2-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="290b2-180">Это правило "только MTOM" применимо только к сообщениям, отправленным через конечную точку с MTOM; кодировщик MTOM также может декодировать и анализировать входящие сообщения, отличные от MTOM.</span><span class="sxs-lookup"><span data-stu-id="290b2-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="290b2-181">Использование кодера MTOM соответствует всем другим функциям WCF.</span><span class="sxs-lookup"><span data-stu-id="290b2-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="290b2-182">Обратите внимание, что это правило может соблюдаться не во всех случаях, например оно неприменимо при необходимости поддержки сеансов.</span><span class="sxs-lookup"><span data-stu-id="290b2-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="290b2-183">Модель программирования</span><span class="sxs-lookup"><span data-stu-id="290b2-183">Programming Model</span></span>  
 <span data-ttu-id="290b2-184">Независимо от того, какой из трех встроенных кодировщиков используется в приложении, программирование аналогично таковому в случае передачи двоичных данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="290b2-185">Разница заключается в том, как WCF обрабатывает данные на основе их типов данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="290b2-186">При использовании MTOM предыдущий контракт данных сериализуется в соответствии со следующими правилами.</span><span class="sxs-lookup"><span data-stu-id="290b2-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="290b2-187">Если `binaryBuffer` не `null` и по отдельности содержит достаточно данных, чтобы подтвердить служебные данные внешнего выделения MTOM (заголовки MIME и т. д.) при сравнении с кодированием Base64, данные внешне выводятся и передаются с сообщением как двоичная часть MIME.</span><span class="sxs-lookup"><span data-stu-id="290b2-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="290b2-188">Если это пороговое значение не превышается, данные кодируются как Base64.</span><span class="sxs-lookup"><span data-stu-id="290b2-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="290b2-189">Строка (и все другие недвоичные типы) всегда представлена как строка внутри тела сообщения, независимо от размера.</span><span class="sxs-lookup"><span data-stu-id="290b2-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="290b2-190">Результат кодирования MTOM точно такой же независимо от того, используется ли явный контракт данных, как показано в предыдущем примере, используется ли список параметров в операции, имеются ли вложенные контракты данных или передается ли объект контракта данных в коллекции.</span><span class="sxs-lookup"><span data-stu-id="290b2-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="290b2-191">Байтовые массивы всегда подлежат оптимизации и оптимизируются, если удовлетворяются пороги оптимизации.</span><span class="sxs-lookup"><span data-stu-id="290b2-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="290b2-192">В контрактах данных не следует использовать унаследованные типы <xref:System.IO.Stream?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="290b2-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="290b2-193">Потоковые данные должны передаваться с помощью модели потоковой передачи, которая рассматривается в разделе "Потоковая передача данных".</span><span class="sxs-lookup"><span data-stu-id="290b2-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="290b2-194">Потоковая передача данных</span><span class="sxs-lookup"><span data-stu-id="290b2-194">Streaming Data</span></span>  
 <span data-ttu-id="290b2-195">Если у вас есть большой объем данных для передачи, режим потоковой передачи в WCF является возможной альтернативой поведению по умолчанию буферизации и обработки сообщений в памяти в полном объеме.</span><span class="sxs-lookup"><span data-stu-id="290b2-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="290b2-196">Как упоминалось ранее, потоковую передачу следует реализовать только для больших сообщений (с текстовым или двоичным содержимым), если данные невозможно сегментировать, если сообщение должно быть своевременно доставлено или если данные еще не полностью доступны на момент начала передачи.</span><span class="sxs-lookup"><span data-stu-id="290b2-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="290b2-197">Ограничения</span><span class="sxs-lookup"><span data-stu-id="290b2-197">Restrictions</span></span>  
 <span data-ttu-id="290b2-198">При включении потоковой передачи не удается использовать значительное количество функций WCF:</span><span class="sxs-lookup"><span data-stu-id="290b2-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="290b2-199">Цифровые сигнатуры для тела сообщения недоступны, поскольку для них требуется вычисление хэша по содержимому всего сообщения.</span><span class="sxs-lookup"><span data-stu-id="290b2-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="290b2-200">При потоковой передаче содержимое не полностью доступно на момент создания и отправки заголовков сообщений, поэтому цифровую сигнатуру вычислить невозможно.</span><span class="sxs-lookup"><span data-stu-id="290b2-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="290b2-201">Шифрование зависит от цифровых сигнатур, по которым проверяется правильность восстановления данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="290b2-202">Во время надежных сеансов отправленные сообщения должны помещаться в буфер клиента для повторной передачи в случае потери сообщения во время передачи, а также сообщения должны сохраняться в службе до их обработки в реализации службы, чтобы сохранить порядок сообщений в случае непоследовательного получения сообщений.</span><span class="sxs-lookup"><span data-stu-id="290b2-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="290b2-203">Из-за этих функциональных ограничений параметры безопасности для потоковой передачи можно использовать только на транспортном уровне, и невозможно реализовать надежные сеансы.</span><span class="sxs-lookup"><span data-stu-id="290b2-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="290b2-204">Потоковая передача доступна только в следующих, определенных системой привязках.</span><span class="sxs-lookup"><span data-stu-id="290b2-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="290b2-205">Поскольку для базового транспорта <xref:System.ServiceModel.NetTcpBinding> и <xref:System.ServiceModel.NetNamedPipeBinding> характерна заведомо надежная доставка и поддержка сеанса на основе подключения, в отличие от HTTP, на практике на эти две привязки оказывается минимальное влияние такими ограничениями.</span><span class="sxs-lookup"><span data-stu-id="290b2-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="290b2-206">Потоковая передача недоступна с транспортом очереди сообщений (MSMQ), и, соответственно, не может быть использована с классом <xref:System.ServiceModel.NetMsmqBinding> или <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="290b2-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="290b2-207">Транспорт очереди сообщений поддерживает только передачу буферизованных данных с ограниченным размером сообщения, тогда как все остальные транспорты не имеют какого-либо реального ограничения размера сообщений для большинства сценариев.</span><span class="sxs-lookup"><span data-stu-id="290b2-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="290b2-208">Потоковая передача также недоступна при использовании транспорта однорангового канала и не может использоваться с <xref:System.ServiceModel.NetPeerTcpBinding>.</span><span class="sxs-lookup"><span data-stu-id="290b2-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="290b2-209">Потоковая передача и сеансы</span><span class="sxs-lookup"><span data-stu-id="290b2-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="290b2-210">При потоковой передаче вызовов с привязкой, основанной на сеансе, может возникнуть непредвиденное поведение.</span><span class="sxs-lookup"><span data-stu-id="290b2-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="290b2-211">Все потоковые вызовы выполняются через один канал (канал датаграммы), который не поддерживает сеансы, даже если используемая привязка настроена так, чтобы она использовала сеансы.</span><span class="sxs-lookup"><span data-stu-id="290b2-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="290b2-212">Если несколько клиентов выполняют потоковые вызовы одного объекта службы через привязку, основанную на сеансе, и задан "одиночный" режим параллелизма объекта службы и режим контекста его экземпляра как PerSession, все вызовы должны проходить через канал датаграммы, а потому может обрабатываться не более одного вызова одновременно.</span><span class="sxs-lookup"><span data-stu-id="290b2-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="290b2-213">Один или несколько клиентов могут затем тайм-аут. Вы можете обойти эту проблему, установив либо режим контекста инстанции объекта службы на PerCall, либо совмещая несколько.</span><span class="sxs-lookup"><span data-stu-id="290b2-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="290b2-214">Свойство MaxConcurrentSessions в данном случае ни на что не влияет, поскольку имеется всего один сеанс.</span><span class="sxs-lookup"><span data-stu-id="290b2-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="290b2-215">Реализация потоковой передачи</span><span class="sxs-lookup"><span data-stu-id="290b2-215">Enabling Streaming</span></span>  
 <span data-ttu-id="290b2-216">Потоковую передачу можно включить следующими способами.</span><span class="sxs-lookup"><span data-stu-id="290b2-216">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="290b2-217">Отправляйте и принимайте запросы в режиме потоковой передачи, принимайте и возвращайте ответы в режиме буферизации (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span><span class="sxs-lookup"><span data-stu-id="290b2-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="290b2-218">Отправляйте и принимайте запросы в режиме буферизации, принимайте и возвращайте ответы в режиме потоковой передачи (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span><span class="sxs-lookup"><span data-stu-id="290b2-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="290b2-219">Отправляйте и получайте запросы и ответы в режиме потоковой передачи в обоих направлениях.</span><span class="sxs-lookup"><span data-stu-id="290b2-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="290b2-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="290b2-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="290b2-221">Потоковую передачу можно отключить, задав режим передачи как <xref:System.ServiceModel.TransferMode.Buffered>, что является параметром по умолчанию для всех привязок.</span><span class="sxs-lookup"><span data-stu-id="290b2-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="290b2-222">В следующем коде показано, как задать режим передачи в конфигурации.</span><span class="sxs-lookup"><span data-stu-id="290b2-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="290b2-223">При инициализации привязки в коде следует задать соответствующее свойство `TransferMode` привязки (или элемент привязки транспорта, если создается пользовательская привязка) как одно из ранее упомянутых значений.</span><span class="sxs-lookup"><span data-stu-id="290b2-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="290b2-224">Потоковую передачу можно включить для запросов и ответов или обоих направлений по отдельности на любой стороне взаимодействующих сторон, не затрагивая функциональность.</span><span class="sxs-lookup"><span data-stu-id="290b2-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="290b2-225">Однако следует всегда принимать во внимание, что размер передаваемых данных настолько важен, что включение потоковой передачи имеет смысл на обеих конечных точках канала связи.</span><span class="sxs-lookup"><span data-stu-id="290b2-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="290b2-226">Для кросс-платформенного общения, где одна из конечных точек не реализована с WCF, возможность использования потоковой передачи зависит от возможностей потоковой передачи платформы.</span><span class="sxs-lookup"><span data-stu-id="290b2-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="290b2-227">Другим редким исключением может быть сценарий с зависимостью от потребления памяти, когда клиент или служба должны свести к минимуму рабочий набор и способны обработать только небольшие объемы данных в буфере.</span><span class="sxs-lookup"><span data-stu-id="290b2-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="290b2-228">Включение асинхронной потоковой передачи</span><span class="sxs-lookup"><span data-stu-id="290b2-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="290b2-229">Чтобы включить поддержку асинхронной потоковой передачи данных, добавьте поведение конечной точки <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> в основное приложение службы и установите свойству <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> значение `true`.</span><span class="sxs-lookup"><span data-stu-id="290b2-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="290b2-230">Также добавлена возможность истинной асинхронной потоковой передачи на стороне отправителя.</span><span class="sxs-lookup"><span data-stu-id="290b2-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="290b2-231">Это повышает масштабируемость службы в сценариях, когда обрабатываются потоковые сообщения для нескольких клиентов. Некоторые из этих сообщений считываются медленно, возможно, из-за перегрузки сети или не считываются совсем.</span><span class="sxs-lookup"><span data-stu-id="290b2-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="290b2-232">В таких сценариях отдельные потоки в службе для каждого клиента больше не блокируются.</span><span class="sxs-lookup"><span data-stu-id="290b2-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="290b2-233">Это гарантирует, что служба может обрабатывать гораздо больше клиентов, повышая таким образом масштабируемость службы.</span><span class="sxs-lookup"><span data-stu-id="290b2-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="290b2-234">Модель программирования для потоковой передачи</span><span class="sxs-lookup"><span data-stu-id="290b2-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="290b2-235">Модель программирования для потоковой передачи является простой.</span><span class="sxs-lookup"><span data-stu-id="290b2-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="290b2-236">Для получения потоковых данных следует указать контракт операции с одним параметром ввода типа <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="290b2-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="290b2-237">Для возвращения потоковых данных следует возвратить ссылку <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="290b2-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="290b2-238">Во время операции `Echo` в предыдущем примере осуществляется получение и возврат потока, поэтому она должна использоваться в привязке с <xref:System.ServiceModel.TransferMode.Streamed>.</span><span class="sxs-lookup"><span data-stu-id="290b2-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="290b2-239">Для операции `RequestInfo` наилучшим образом подходит <xref:System.ServiceModel.TransferMode.StreamedResponse>, поскольку он только возвращает <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="290b2-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="290b2-240">Односторонняя операция наилучшим образом подходит для <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span><span class="sxs-lookup"><span data-stu-id="290b2-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="290b2-241">Обратите внимание, что добавление второго параметра в операции `Echo` или `ProvideInfo` станет причиной возвращения модели службы к стратегии буферизации и использованию представления сериализации в среде выполнения потока.</span><span class="sxs-lookup"><span data-stu-id="290b2-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="290b2-242">Со сквозной потоковой передачей запросов совместимы только операции с одним параметром входного потока.</span><span class="sxs-lookup"><span data-stu-id="290b2-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="290b2-243">Применение этого правила аналогично контрактам сообщений.</span><span class="sxs-lookup"><span data-stu-id="290b2-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="290b2-244">Как показано в следующем контракте сообщения, в нем (являющимся потоком) можно расположить только один элемент тела.</span><span class="sxs-lookup"><span data-stu-id="290b2-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="290b2-245">Если вместе с потоком требуется передать дополнительную информацию, ее следует указать в заголовках сообщений.</span><span class="sxs-lookup"><span data-stu-id="290b2-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="290b2-246">Тело сообщения зарезервировано исключительно для содержимого потока.</span><span class="sxs-lookup"><span data-stu-id="290b2-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="290b2-247">Когда поток достигает конца файла (EOF), потоковая передача прекращается, и сообщение закрывается.</span><span class="sxs-lookup"><span data-stu-id="290b2-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="290b2-248">При отправке сообщения (возвращающ значение или ссылаясь на <xref:System.IO.FileStream> операцию) вы можете пройти и инфраструктура WCF впоследствии вытягивает все данные из этого потока до тех пор, пока поток не будет полностью прочитан и не достиг EOF.</span><span class="sxs-lookup"><span data-stu-id="290b2-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="290b2-249">Чтобы передать потоковые данные для источника, для которого не существует такого предварительно созданного унаследованного класса <xref:System.IO.Stream>, следует создать такой класс, наложить его на источник потока и использовать в качестве аргумента или возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="290b2-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="290b2-250">При получении сообщения WCF строит поток по содержимому тела тела Base64 (или соответствующей части MIME при использовании MTOM), и поток достигает EOF, когда содержимое было прочитано.</span><span class="sxs-lookup"><span data-stu-id="290b2-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="290b2-251">Потоковая передача на транспортном уровне также используется с любым другим типом контракта сообщения (списками параметров, аргументами контракта данных и явным контрактом сообщения), но поскольку для сериализации и десериализации сообщений таких типов требуется буферизация сериализатором, использование таких вариантов контрактов не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="290b2-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="290b2-252">Особые вопросы по безопасности данных большого объема</span><span class="sxs-lookup"><span data-stu-id="290b2-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="290b2-253">Все привязки позволяют ограничивать размер входящих сообщений, чтобы избежать атак типа "отказ в обслуживании".</span><span class="sxs-lookup"><span data-stu-id="290b2-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="290b2-254">Например, <xref:System.ServiceModel.BasicHttpBinding>разоблачает свойство [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize,](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) которое граничит с размером входящего сообщения, а также ограничено максимальное количество памяти, доступ к которым при обработке сообщения.</span><span class="sxs-lookup"><span data-stu-id="290b2-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="290b2-255">Эта единица задается в байтах и имеет значение по умолчанию 65 536 байт.</span><span class="sxs-lookup"><span data-stu-id="290b2-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="290b2-256">Угроза безопасности, относящаяся к сценарию потоковой передачи большого объема данных, вызывает отказ в обслуживании, приводя к буферизации данных, когда получатель ожидает их потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="290b2-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="290b2-257">Например, WCF всегда буферизирует заголовки SOAP сообщения, и поэтому злоумышленник может создать большое вредоносное сообщение, полностью состоящее из заголовков, чтобы заставить данные быть буферизированными.</span><span class="sxs-lookup"><span data-stu-id="290b2-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="290b2-258">Если включена потоковая передача, `MaxReceivedMessageSize` может быть задано как крайне большое значение, поскольку получатель не ожидает одновременной буферизации всего сообщения в память.</span><span class="sxs-lookup"><span data-stu-id="290b2-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="290b2-259">Если WCF вынужден буферизировать сообщение, происходит переполнение памяти.</span><span class="sxs-lookup"><span data-stu-id="290b2-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="290b2-260">Поэтому в данном случае ограничения максимального размера входящего сообщения недостаточно.</span><span class="sxs-lookup"><span data-stu-id="290b2-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="290b2-261">Свойство `MaxBufferSize` требуется для ограничения памяти, которую буферы WCF.</span><span class="sxs-lookup"><span data-stu-id="290b2-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="290b2-262">Для потоковой передачи важно задать безопасное значение (или оставить значение по умолчанию).</span><span class="sxs-lookup"><span data-stu-id="290b2-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="290b2-263">Например, допустим, что служба должна получить файлы размером до 4 ГБ и сохранить их на локальный диск.</span><span class="sxs-lookup"><span data-stu-id="290b2-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="290b2-264">Также предположим, что память ограничена таким образом, что одновременно можно буферизовать только 64 КБ данных.</span><span class="sxs-lookup"><span data-stu-id="290b2-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="290b2-265">В этом случае для `MaxReceivedMessageSize` следует задать 4 ГБ, а для `MaxBufferSize` - 64 КБ.</span><span class="sxs-lookup"><span data-stu-id="290b2-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="290b2-266">Кроме того, в реализации службы следует обеспечить чтение из входящего потока только фрагментов по 64 КБ, и не считывать следующий фрагмент, пока предыдущий не будет записан на диск и удален из памяти.</span><span class="sxs-lookup"><span data-stu-id="290b2-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="290b2-267">Важно также понимать, что эта квота ограничивает только буферизирование, выполненное WCF, и не может защитить вас от любого буферизации, что вы делаете в вашей собственной службе или реализации клиента.</span><span class="sxs-lookup"><span data-stu-id="290b2-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="290b2-268">Для получения дополнительной информации о [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)дополнительных соображениях безопасности см.</span><span class="sxs-lookup"><span data-stu-id="290b2-268">For more information about additional security considerations, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="290b2-269">Решение по использованию буферизованной или потоковой передачи является локальным решением конечной точки.</span><span class="sxs-lookup"><span data-stu-id="290b2-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="290b2-270">Для транспортов HTTP режим передачи не распространяется через подключение или на прокси-серверы и других посредников.</span><span class="sxs-lookup"><span data-stu-id="290b2-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="290b2-271">Выбор режима передачи не отражается в описании интерфейса службы.</span><span class="sxs-lookup"><span data-stu-id="290b2-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="290b2-272">После генерации клиента WCF в службу необходимо отредки файла конфигурации для служб, предназначенных для использования с потоковыми переводами, для настройки режима.</span><span class="sxs-lookup"><span data-stu-id="290b2-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="290b2-273">Для транспортов TCP и именованного канала режим передачи распространяется в виде утверждения политики.</span><span class="sxs-lookup"><span data-stu-id="290b2-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="290b2-274">См. также раздел</span><span class="sxs-lookup"><span data-stu-id="290b2-274">See also</span></span>

- [<span data-ttu-id="290b2-275">Практическое руководство. Включение потоковой передачи</span><span class="sxs-lookup"><span data-stu-id="290b2-275">How to: Enable Streaming</span></span>](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)
