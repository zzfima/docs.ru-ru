---
title: Работа с сертификатами
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- certificates [WCF]
ms.assetid: 6ffb8682-8f07-4a45-afbb-8d2487e9dbc3
ms.openlocfilehash: 0764ca29fc959092e77629ff3888e65f0d68d70c
ms.sourcegitcommit: 7e2128d4a4c45b4274bea3b8e5760d4694569ca1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/14/2020
ms.locfileid: "75938051"
---
# <a name="working-with-certificates"></a>Работа с сертификатами

Для программирования безопасности Windows Communication Foundation (WCF) обычно используются цифровые сертификаты X.509, с помощью которых выполняется проверка подлинности клиентов и серверов, шифрование и создание цифровой подписи для сообщений. В этом разделе содержится краткое описание возможностей для работы с цифровыми сертификатами X.509 и порядка использования этих возможностей в WCF. Кроме того, этот раздел включает ссылки на другие разделы с более подробным объяснением основных понятий и порядка выполнения общих задач с использованием WCF и сертификатов.

Вкратце, цифровой сертификат является частью *инфраструктуры открытых ключей* (PKI), представляющей собой систему цифровых сертификатов, центров сертификации и других центров регистрации, которые используются для проверки подлинности каждой стороны, участвующей в электронной транзакции, посредством использования шифрования с открытым ключом. Сертификаты выдаются центрами сертификации, и каждый сертификат имеет набор полей, в которых содержатся такие данные, как *субъект* (сущность, которой выдается сертификат), срок действия (период времени, в течение которого сертификат является действительным), издатель (лицо, выдавшее сертификат) и открытый ключ. В WCF каждое из этих свойств обрабатывается как утверждение <xref:System.IdentityModel.Claims.Claim>, и каждое утверждение затем подразделяется на два типа: удостоверение и право. Дополнительные сведения о сертификатах X.509 см. в разделе [Сертификаты открытого ключа X.509](/windows/desktop/SecCertEnroll/about-x-509-public-key-certificates). Дополнительные сведения об утверждениях и авторизации в WCF см. в разделе [Управление утверждениями и авторизацией с помощью модели удостоверения](managing-claims-and-authorization-with-the-identity-model.md). Дополнительные сведения о реализации PKI см. в статье [Enterprise PKI с Windows Server 2012 R2 Active Directory Certificate Services](https://docs.microsoft.com/archive/blogs/yungchou/enterprise-pki-with-windows-server-2012-r2-active-directory-certificate-services-part-1-of-2).

Основной функцией сертификата является удостоверение подлинности владельца сертификата для других сторон. В сертификате содержится *открытый ключ* владельца, в то время как закрытый ключ хранится у владельца. Открытый ключ можно использовать для зашифровывания сообщений, передаваемых владельцу сертификата. Доступ к закрытому ключу имеет только владелец сертификата, поэтому только он может расшифровать эти сообщения.

Сертификаты должны выдаваться центром сертификации, который обычно является сторонним издателем сертификатов. Домен Windows содержит центр сертификации, который можно использовать для выдачи сертификатов компьютерам домена.

## <a name="viewing-certificates"></a>Просмотр сертификатов

При работе с сертификатами зачастую необходимо просматривать их и проверять определенные свойства. Это легко выполняется с помощью консоли управления (MMC). (Дополнительные сведения см. в разделе [Практическое руководство. Просмотр сертификатов с помощью оснастки консоли MMC](how-to-view-certificates-with-the-mmc-snap-in.md).)

## <a name="certificate-stores"></a>Хранилища сертификатов

Сертификаты хранятся в хранилищах. Существует два основных хранилища, которые подразделяются на вложенные хранилища. Администратор компьютера может просматривать оба основных хранилища с помощью средства MMC. Пользователи, не являющиеся администраторами, могут просматривать только хранилище текущего пользователя.

- **Хранилище локального компьютера**. Он содержит сертификаты, к которым обращаются машинные процессы, например ASP.NET. Это расположение используется для хранения сертификатов, удостоверяющих подлинность сервера для клиентов.

- **Хранилище текущего пользователя**. Интерактивные приложения обычно помещают сертификаты в это хранилище для текущего пользователя компьютера. В случае клиентского приложения в это хранилище обычно помещаются сертификаты, используемые для проверки подлинности пользователя при подключении к службе.

Эти два хранилища подразделяются на вложенные хранилища. Ниже представлены наиболее важные вложенные хранилища, используемые при программировании с помощью WCF.

- **Доверенные корневые центры сертификации**. Сертификаты из этого хранилища можно использовать для создания цепочки сертификатов, которую можно проследить до сертификата центра сертификации в этом хранилище.

  > [!IMPORTANT]
  > Локальный компьютер полностью доверяет любому сертификату, помещенному в это хранилище, даже если он поступил не из доверенного стороннего центра сертификации. Поэтому в данное хранилище не следует помещать сертификаты, к издателям которых нет полного доверия, или если последствия не до конца ясны.

- **Личное**. Это хранилище используется для хранения сертификатов, связанных с пользователем компьютера. Обычно в этом хранилище хранятся сертификаты, выданные одним из центров сертификации, сертификаты которых находятся в хранилище «Доверенные корневые центры сертификации». С другой стороны, сертификат, находящийся в этом хранилище, может быть самостоятельно выданным, и ему будет доверять приложение.

Дополнительные сведения о хранилищах сертификатов см. в разделе [Хранилища сертификатов](/windows/desktop/secauthn/certificate-stores).

### <a name="selecting-a-store"></a>Выбор хранилища

Выбор расположения для хранения сертификата зависит от режима и места выполнения клиента или службы. Действуют следующие общие правила.

- Если служба WCF размещается в службе Windows, используйте хранилище **локального компьютера**. Обратите внимание, что для установки сертификатов в хранилище локального компьютера требуются привилегии администратора.

- Если служба или клиент является приложением, выполняющимся от имени учетной записи пользователя, используйте хранилище **текущего пользователя**.

### <a name="accessing-stores"></a>Доступ к хранилищам

Хранилища защищаются с помощью списков управления доступом (ACL) аналогично папкам на компьютере. При создании службы, размещенной службы IIS (IIS), процесс ASP.NET выполняется в учетной записи ASP.NET. Эта учетная запись должна иметь доступ к хранилищу, в котором содержатся используемые службой сертификаты. Каждое основное хранилище защищается с помощью списка управления доступом по умолчанию, однако списки можно изменять. При создании отдельной роли для доступа к хранилищу необходимо предоставить ей разрешение на доступ. Сведения о том, как изменить список доступа с помощью средства WinHttpCertConfig.exe, см. в разделе [Практическое руководство. Создание временных сертификатов для использования во время разработки](how-to-create-temporary-certificates-for-use-during-development.md).

## <a name="chain-trust-and-certificate-authorities"></a>Цепочка доверия и центры сертификации

Сертификаты создаются в иерархии, где каждый отдельный сертификат связан с выдавшим его органом сертификации. Эта ссылка указывает на сертификат органа сертификации. Затем сертификат ЦС связывается с центром сертификации, который выдал сертификат исходного ЦС. Процесс повторяется до тех пор, пока не будет достигнут корневой сертификат органа сертификации. Сертификат корневого органа сертификации является изначально доверенным.

Цифровые сертификаты используются для удостоверения подлинности сущности на основе этой иерархии, которая также называется *цепочкой сертификатов*. Вы можете просмотреть цепочку сертификатов с помощью оснастки MMC, дважды щелкнув любой сертификат, а затем перейдя на вкладку **путь к сертификату** . Дополнительные сведения об импорте цепочек сертификатов для центра сертификации см. в разделе [инструкции. Указание цепочки сертификатов центра сертификации, используемой для проверки подписей](specify-the-certificate-authority-chain-verify-signatures-wcf.md).

> [!NOTE]
> Любой издатель может быть сделан доверенным корневым центром; для этого необходимо поместить сертификат издателя в хранилище сертификатов доверенных корневых центров.

### <a name="disabling-chain-trust"></a>Отключение механизма проверки цепочки доверия

При создании новой службы пользователь может использовать сертификат, который был выдан центром сертификации, отличным от доверенного, или сертификат издателя может отсутствовать в хранилище «Доверенные корневые центры сертификации». Предусмотрена возможность временного отключения механизма, проверяющего цепочку сертификатов для заданного сертификата; эта возможность должна использоваться только в процессе разработки. Чтобы отключить данный механизм, задайте для свойства `CertificateValidationMode` значение `PeerTrust` или `PeerOrChainTrust`. Эти режимы определяют, что сертификат может быть либо самостоятельно выданным (доверие одноранговой группы), либо являться частью цепочки доверия. Указанное свойство можно задать для любого из следующих классов.

|Класс|Идентификаторы|
|-----------|--------------|
|<xref:System.ServiceModel.Security.X509ClientCertificateAuthentication>|<xref:System.ServiceModel.Security.X509ClientCertificateAuthentication.CertificateValidationMode%2A?displayProperty=nameWithType>|
|<xref:System.ServiceModel.Security.X509PeerCertificateAuthentication>|<xref:System.ServiceModel.Security.X509PeerCertificateAuthentication.CertificateValidationMode%2A?displayProperty=nameWithType>|
|<xref:System.ServiceModel.Security.X509ServiceCertificateAuthentication>|<xref:System.ServiceModel.Security.X509ServiceCertificateAuthentication.CertificateValidationMode%2A?displayProperty=nameWithType>|
|<xref:System.ServiceModel.Security.IssuedTokenServiceCredential>|<xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A?displayProperty=nameWithType>|

Свойство также можно задать с использованием конфигурации. Для задания режима проверки используются следующие элементы.

- [\<authentication>](../../../../docs/framework/configure-apps/file-schema/wcf/authentication-of-servicecertificate-element.md)

- [\<peerAuthentication>](../../../../docs/framework/configure-apps/file-schema/wcf/peerauthentication-element.md)

- [\<messageSenderAuthentication>](../../../../docs/framework/configure-apps/file-schema/wcf/messagesenderauthentication-element.md)

## <a name="custom-authentication"></a>Пользовательская проверка подлинности

Свойство `CertificateValidationMode` также позволяет настроить способ проверки сертификатов. По умолчанию задано значение `ChainTrust`. Чтобы использовать значение <xref:System.ServiceModel.Security.X509CertificateValidationMode.Custom>, необходимо также установить атрибут `CustomCertificateValidatorType` для сборки и типа, которые используются при проверке сертификата. Для создания пользовательского проверяющего элемента управления необходимо наследование от абстрактного класса <xref:System.IdentityModel.Selectors.X509CertificateValidator>.

При создании пользовательской структуры проверки подлинности наиболее важным методом, который необходимо переопределить, является метод <xref:System.IdentityModel.Selectors.X509CertificateValidator.Validate%2A>. Образец создания пользовательской структуры проверки подлинности см. в разделе [Проверяющий элемент управления для сертификатов X.509](../../../../docs/framework/wcf/samples/x-509-certificate-validator.md). Дополнительные сведения см. в разделе [Пользовательские учетные данные и проверка учетных данных](../../../../docs/framework/wcf/extending/custom-credential-and-credential-validation.md).

## <a name="using-the-powershell-new-selfsignedcertificate-cmdlet-to-build-a-certificate-chain"></a>Использование командлета PowerShell New-SelfSignedCertificate для создания цепочки сертификатов

Командлет PowerShell New-SelfSignedCertificate создает сертификаты X. 509 и пары "закрытый ключ — открытый ключ". Закрытый ключ можно сохранить на диск, а затем использовать его для выдачи и подписи новых сертификатов, что позволяет имитировать иерархию цепочки сертификатов. Командлет предназначен для использования только в качестве вспомогательной службы при разработке служб и никогда не должен использоваться для создания сертификатов для фактического развертывания. При разработке службы WCF выполните следующие действия, чтобы создать цепочку доверия с помощью командлета New-SelfSignedCertificate.

#### <a name="to-build-a-chain-of-trust-with-the-new-selfsignedcertificate-cmdlet"></a>Создание цепочки доверия с помощью командлета New-SelfSignedCertificate

1. Создайте временный сертификат корневого центра сертификации с помощью командлета New-SelfSignedCertificate. Сохраните закрытый ключ на диск.

2. Воспользуйтесь новым сертификатом для выдачи другого сертификата, содержащего открытый ключ.

3. Импортируйте сертификат корневого центра в хранилище «Доверенные корневые центры сертификации».

4. Подробные инструкции см. в разделе [Практическое руководство. Создание временных сертификатов для использования во время разработки](how-to-create-temporary-certificates-for-use-during-development.md).

## <a name="which-certificate-to-use"></a>Выбор сертификата для использования

Наиболее распространенными вопросами о сертификатах являются следующие: какой сертификат использовать и почему? Ответ зависит от того, что программирует пользователь - клиент или службу. Ниже представлены общие рекомендации; следует иметь виду, что они не являются исчерпывающими ответами на поставленные вопросы.

### <a name="service-certificates"></a>Сертификаты служб

Основной задачей сертификатов служб является удостоверение подлинности сервера для клиентов. При проверке подлинности сервера клиентом одной из исходных проверок является сравнение значения поля **Субъект** с универсальным кодом ресурса (URI), используемым для обращения к службе: DNS-имена должны совпадать. Например, если URI службы `http://www.contoso.com/endpoint/`, поле **subject** также должно содержать значение `www.contoso.com`.

Обратите внимание, что в этом поле может содержаться несколько значений с отдельными префиксами. Чаще всего это "CN" для общего имени, например `CN = www.contoso.com`. Кроме того, поле **Субъект** может быть пустым; в этом случае в поле **Альтернативное имя субъекта** может содержаться значение **DNS-имя**.

Также обратите внимание, что поле **Назначения** сертификата должно включать соответствующее значение, например "Проверка подлинности сервера" или "Проверка подлинности клиента".

### <a name="client-certificates"></a>Сертификаты клиентов

Сертификаты клиентов, как правило, выдаются не сторонними центрами сертификации. В хранилище «Личное» текущего пользователя обычно содержатся сертификаты, выданные корневым центром; в поле «Назначения» этих сертификатов задано значение «Проверка подлинности клиента». Клиент может использовать такой сертификат, когда требуется взаимная проверка подлинности.

## <a name="online-revocation-and-offline-revocation"></a>Проверка отзыва сертификатов в режиме подключения к сети и автономном режиме

### <a name="certificate-validity"></a>Срок действия сертификата

Каждый сертификат действителен только в течение заданного периода времени, который называется *сроком действия*. Срок действия определяется значениями полей **Действителен с** и **Действителен по** сертификата X.509. Во время проверки подлинности проверяется, не истек ли срок действия сертификата.

### <a name="certificate-revocation-list"></a>Список отзыва сертификатов

Центр сертификации может отменить действующий сертификат в любой момент. Это может произойти по многим причинам, например при компрометации закрытого ключа сертификата.

В этом случае все цепочки, происходящие от отозванного сертификата, также становятся недействительными и механизмы проверки подлинности перестают им доверять. Для обозначения отозванных сертификатов каждый издатель публикует *список отзыва сертификатов*, имеющий отметку даты и времени. Этот список можно проверить с помощью режима с подключением к сети или автономного режима, задав одно из значений перечисления `RevocationMode` для свойства `DefaultRevocationMode` или <xref:System.Security.Cryptography.X509Certificates.X509RevocationMode> следующих классов: <xref:System.ServiceModel.Security.X509ClientCertificateAuthentication>, <xref:System.ServiceModel.Security.X509PeerCertificateAuthentication>, <xref:System.ServiceModel.Security.X509ServiceCertificateAuthentication> и <xref:System.ServiceModel.Security.IssuedTokenServiceCredential>. Значение по умолчанию для всех свойств - `Online`.

Можно также задать режим в конфигурации с помощью атрибута `revocationMode` для элементов [\<authentication>](../../../../docs/framework/configure-apps/file-schema/wcf/authentication-of-clientcertificate-element.md) ([\<serviceBehaviors>](../../../../docs/framework/configure-apps/file-schema/wcf/servicebehaviors.md)) и [\<authentication>](../../../../docs/framework/configure-apps/file-schema/wcf/authentication-of-clientcertificate-element.md) ([\<endpointBehaviors>](../../../../docs/framework/configure-apps/file-schema/wcf/endpointbehaviors.md)).

## <a name="the-setcertificate-method"></a>Метод SetCertificate

В WCF часто требуется задать сертификат или набор сертификатов, который служба или клиент будут использовать для проверки подлинности, шифрования или подписи сообщения. Это можно сделать программно с помощью метода `SetCertificate` различных классов, представляющих сертификаты X.509. Следующие классы используют метод `SetCertificate` для задания сертификата.

|Класс|Метод|
|-----------|------------|
|<xref:System.ServiceModel.Security.PeerCredential>|<xref:System.ServiceModel.Security.PeerCredential.SetCertificate%2A>|
|<xref:System.ServiceModel.Security.X509CertificateInitiatorClientCredential>|<xref:System.ServiceModel.Security.X509CertificateInitiatorClientCredential.SetCertificate%2A>|
|<xref:System.ServiceModel.Security.X509CertificateRecipientServiceCredential>|<xref:System.ServiceModel.Security.X509CertificateRecipientServiceCredential.SetCertificate%2A>|
|<xref:System.ServiceModel.Security.X509CertificateInitiatorServiceCredential>|
|<xref:System.ServiceModel.Security.X509CertificateInitiatorServiceCredential.SetCertificate%2A>|

Метод `SetCertificate` позволяет задать хранилище и его расположение, тип поиска (параметр `x509FindType`), определяющий поле сертификата, и значение, которое требуется найти в данном поле. Например, следующий код создает экземпляр <xref:System.ServiceModel.ServiceHost> и задает сертификат службы, используемый с целью удостоверения подлинности службы для клиентов, с помощью метода `SetCertificate`.

[!code-csharp[c_WorkingWithCertificates#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_workingwithcertificates/cs/source.cs#1)]
[!code-vb[c_WorkingWithCertificates#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_workingwithcertificates/vb/source.vb#1)]

### <a name="multiple-certificates-with-the-same-value"></a>Несколько сертификатов с одинаковыми значениями полей

В хранилище может содержаться несколько сертификатов с одним и тем же именем субъекта. Поэтому если для параметра `x509FindType` задано значение <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindBySubjectName> или <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindBySubjectDistinguishedName> и существует несколько сертификатов с таким значением, возникает исключение, поскольку в этом случае невозможно определить, какой именно сертификат требуется использовать. Это можно подавить, задав для параметра `x509FindType` значение <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByThumbprint>. В поле отпечатка содержится уникальное значение, которое можно использовать для поиска конкретного сертификата в хранилище. Однако у данного подхода есть свой недостаток: если сертификат был отозван или обновлен, метод `SetCertificate` выполнить не удастся, поскольку исходный отпечаток на будет найден. А если сертификат является недействительным, проверка подлинности не будет пройдена. Это можно подавить, задав для параметра `x590FindType` значение <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByIssuerName> и указав имя издателя. Если указывать издателя не требуется, можно также задать одно из значений перечисления <xref:System.Security.Cryptography.X509Certificates.X509FindType>, например <xref:System.Security.Cryptography.X509Certificates.X509FindType.FindByTimeValid>.

## <a name="certificates-in-configuration"></a>Сертификаты в конфигурации

Сертификаты также можно задать с использованием конфигурации. При создании службы учетные данные, включая сертификаты, указываются в разделе [\<serviceBehaviors>](../../../../docs/framework/configure-apps/file-schema/wcf/servicebehaviors.md). В случае программирования клиента сертификаты указываются в разделе [\<endpointBehaviors>](../../../../docs/framework/configure-apps/file-schema/wcf/endpointbehaviors.md).

## <a name="mapping-a-certificate-to-a-user-account"></a>Сопоставление сертификата с учетной записью пользователя

Службы IIS и Active Directory предусматривают возможность сопоставления сертификата с учетной пользовательской записью Windows. Дополнительные сведения об этой возможности см. в разделе [Сопоставление сертификатов с учетными записями пользователей](https://go.microsoft.com/fwlink/?LinkId=88917).

Дополнительные сведения о сопоставлении Active Directory см. в разделе [Сопоставление сертификатов клиентов с помощью функции сопоставления службы каталогов](https://go.microsoft.com/fwlink/?LinkId=88918).

Если эта функция включена, можно задать для свойства <xref:System.ServiceModel.Security.X509ClientCertificateAuthentication.MapClientCertificateToWindowsAccount%2A> класса <xref:System.ServiceModel.Security.X509ClientCertificateAuthentication> значение `true`. В конфигурации можно задать для атрибута `mapClientCertificateToWindowsAccount` элемента [\<authentication>](../../../../docs/framework/configure-apps/file-schema/wcf/authentication-of-servicecertificate-element.md) значение `true`, как показано в следующем примере кода.

```xml
<serviceBehaviors>
 <behavior name="MappingBehavior">
  <serviceCredentials>
   <clientCertificate>
    <authentication certificateValidationMode="None" mapClientCertificateToWindowsAccount="true" />
   </clientCertificate>
  </serviceCredentials>
 </behavior>
</serviceBehaviors>
```

Сопоставление сертификата X.509 с маркером, представляющим учетную запись пользователя Windows, считается повышением привилегий, поскольку после сопоставления маркер Windows может использоваться для получения доступа к защищенным ресурсам. Поэтому перед сопоставлением необходимо проверить, что сертификат X.509 соответствует политике домена. Проверку этого требования обеспечивает пакет безопасности *SChannel*.

При использовании .NET Framework 3,5 или более поздних версий WCF гарантирует, что сертификат соответствует политике домена, прежде чем он будет сопоставлен с учетной записью Windows.

В первом выпуске WCF сопоставление выполняется без обращения к политике домена. Поэтому более старые приложения, которые работали при использовании первого выпуска, могут не работать, если включено сопоставление и сертификат X.509 не удовлетворяет требованиям политики домена.

## <a name="see-also"></a>См. также:

- <xref:System.ServiceModel.Channels>
- <xref:System.ServiceModel.Security>
- <xref:System.ServiceModel>
- <xref:System.Security.Cryptography.X509Certificates.X509FindType>
- [Securing Services and Clients](../../../../docs/framework/wcf/feature-details/securing-services-and-clients.md)
