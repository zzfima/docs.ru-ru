---
title: Односторонние службы
ms.date: 03/30/2017
helpviewer_keywords:
- Windows Communication Foundation [WCF], one-way service contracts
- WCF [WCF], one-way service contracts
- service contracts [WCF], defining one-way
ms.assetid: 19053a36-4492-45a3-bfe6-0365ee0205a3
ms.openlocfilehash: 011bca07890e706b86f2a0b1dbf11acf77058548
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "61762492"
---
# <a name="one-way-services"></a><span data-ttu-id="0077a-102">Односторонние службы</span><span class="sxs-lookup"><span data-stu-id="0077a-102">One-Way Services</span></span>
<span data-ttu-id="0077a-103">По умолчанию операция службы выполняется по шаблону "запрос-ответ".</span><span class="sxs-lookup"><span data-stu-id="0077a-103">The default behavior of a service operation is the request-reply pattern.</span></span> <span data-ttu-id="0077a-104">В соответствии с шаблоном "запрос-ответ" клиент ждет ответного сообщения, даже если операция службы представлена в коде в виде метода `void`.</span><span class="sxs-lookup"><span data-stu-id="0077a-104">In a request-reply pattern, the client waits for the reply message, even if the service operation is represented in code as a `void` method.</span></span> <span data-ttu-id="0077a-105">В случае односторонних операций передается только одно сообщение.</span><span class="sxs-lookup"><span data-stu-id="0077a-105">With a one-way operation, only one message is transmitted.</span></span> <span data-ttu-id="0077a-106">Получатель не отправляет ответное сообщение, а отправитель не ожидает получения этого сообщения.</span><span class="sxs-lookup"><span data-stu-id="0077a-106">The receiver does not send a reply message, nor does the sender expect one.</span></span>  
  
 <span data-ttu-id="0077a-107">Односторонний шаблон используется в следующих случаях.</span><span class="sxs-lookup"><span data-stu-id="0077a-107">Use the one-way design pattern:</span></span>  
  
- <span data-ttu-id="0077a-108">Если клиент должен вызывать операции и не зависит от результата выполнения этих операций на уровне операций.</span><span class="sxs-lookup"><span data-stu-id="0077a-108">When the client must call operations and is not affected by the result of the operation at the operation level.</span></span>  
  
- <span data-ttu-id="0077a-109">При использовании класса <xref:System.ServiceModel.NetMsmqBinding> или <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span><span class="sxs-lookup"><span data-stu-id="0077a-109">When using the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="0077a-110">(Дополнительные сведения об этом сценарии см. в разделе [очереди в WCF](../../../../docs/framework/wcf/feature-details/queues-in-wcf.md).)</span><span class="sxs-lookup"><span data-stu-id="0077a-110">(For more information about this scenario, see [Queues in WCF](../../../../docs/framework/wcf/feature-details/queues-in-wcf.md).)</span></span>  
  
 <span data-ttu-id="0077a-111">Если операция является односторонней, ответное сообщение, в котором могут передаваться сведения об ошибке, клиенту не отправляется.</span><span class="sxs-lookup"><span data-stu-id="0077a-111">When an operation is one-way, there is no response message to carry error information back to the client.</span></span> <span data-ttu-id="0077a-112">Условия возникновения ошибок можно определять с помощью возможностей соответствующей привязки, например надежных сеансов, или посредством разработки дуплексного контракта службы, который использует две односторонних операции - односторонний контракт от клиента к службе для вызова операции службы и еще один односторонний контракт между службой и клиентом, чтобы служба могла вернуть клиенту ошибки, используя реализуемый в клиенте обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="0077a-112">You can detect error conditions by using features of the underlying binding, such as reliable sessions, or by designing a duplex service contract that uses two one-way operations—a one-way contract from the client to the service to call service operation and another one-way contract between the service and the client so that the service can send back faults to the client using a callback that the client implements.</span></span>  
  
 <span data-ttu-id="0077a-113">Чтобы создать односторонний контракт службы, определите контракт службы, примените класс <xref:System.ServiceModel.OperationContractAttribute> к каждой из операций, и установите свойство <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> равным `true`, как показано в следующем примере кода.</span><span class="sxs-lookup"><span data-stu-id="0077a-113">To create a one-way service contract, define your service contract, apply the <xref:System.ServiceModel.OperationContractAttribute> class to each operation, and set the <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> property to `true`, as shown in the following sample code.</span></span>  
  
```  
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IOneWayCalculator  
{  
    [OperationContract(IsOneWay=true)]  
    void Add(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Subtract(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Multiply(double n1, double n2);  
    [OperationContract(IsOneWay = true)]  
    void Divide(double n1, double n2);  
}  
```  
  
 <span data-ttu-id="0077a-114">Полный пример см. в разделе [односторонней](../../../../docs/framework/wcf/samples/one-way.md) образца.</span><span class="sxs-lookup"><span data-stu-id="0077a-114">For a complete example, see the [One-Way](../../../../docs/framework/wcf/samples/one-way.md) sample.</span></span>  
  
## <a name="clients-blocking-with-one-way-operations"></a><span data-ttu-id="0077a-115">Блокировка клиентов с помощью односторонних операций</span><span class="sxs-lookup"><span data-stu-id="0077a-115">Clients Blocking with One-Way Operations</span></span>  
 <span data-ttu-id="0077a-116">Важно понимать, что, хотя некоторые односторонние приложения возобновляют работу, как только исходящие данные будут переданы по сетевому подключению, в некоторых сценариях реализация привязки или службы может вызывать проблемы клиента WCF для блокировки с помощью односторонних операций.</span><span class="sxs-lookup"><span data-stu-id="0077a-116">It is important to realize that while some one-way applications return as soon as the outbound data is written to the network connection, in several scenarios the implementation of a binding or of a service can cause a WCF client to block using one-way operations.</span></span> <span data-ttu-id="0077a-117">В клиентских приложениях WCF объекта клиента WCF не возвращается до исходящие данные были переданы по сетевому подключению.</span><span class="sxs-lookup"><span data-stu-id="0077a-117">In WCF client applications, the WCF client object does not return until the outbound data has been written to the network connection.</span></span> <span data-ttu-id="0077a-118">Это относится ко всем шаблонам обмена сообщениями, включая односторонние операции; это означает, что любая проблема, связанная с передачей данных через транспортный канал, не позволит клиенту вернуть управление.</span><span class="sxs-lookup"><span data-stu-id="0077a-118">This is true for all message exchange patterns, including one-way operations; this means that any problem writing the data to the transport prevents the client from returning.</span></span> <span data-ttu-id="0077a-119">В зависимости от проблемы ее результатом может быть исключение или задержка при отправке сообщения службе.</span><span class="sxs-lookup"><span data-stu-id="0077a-119">Depending upon the problem, the result could be an exception or a delay in sending messages to the service.</span></span>  
  
 <span data-ttu-id="0077a-120">Например, если транспорту не удается найти конечную точку, исключение <xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType> будет создано без большой задержки.</span><span class="sxs-lookup"><span data-stu-id="0077a-120">For example, if the transport cannot find the endpoint, a <xref:System.ServiceModel.EndpointNotFoundException?displayProperty=nameWithType> exception is thrown without much delay.</span></span> <span data-ttu-id="0077a-121">Однако также возможна ситуация, при которой службе по какой-либо причине не удается считать данные из сети, в результате чего операция отправки на стороне клиента не может быть завешена.</span><span class="sxs-lookup"><span data-stu-id="0077a-121">However, it is also possible that the service is unable to read the data off the wire for some reason, which prevents the client transport send operation from returning.</span></span> <span data-ttu-id="0077a-122">В этих случаях, если превышается время <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType> привязки транспорта клиента, создается исключение <xref:System.TimeoutException?displayProperty=nameWithType> - но не раньше истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="0077a-122">In these cases, if the <xref:System.ServiceModel.Channels.Binding.SendTimeout%2A?displayProperty=nameWithType> period on the client transport binding is exceeded, a <xref:System.TimeoutException?displayProperty=nameWithType> is thrown—but not until the timeout period has been exceeded.</span></span> <span data-ttu-id="0077a-123">Кроме того, службе может быть отправлено так много сообщений, что в какой-то момент служба больше не сможет их обрабатывать.</span><span class="sxs-lookup"><span data-stu-id="0077a-123">It is also possible to fire so many messages at a service that the service cannot process them past a certain point.</span></span> <span data-ttu-id="0077a-124">В этом случае односторонний клиент также блокируется, пока служба не сможет обработать сообщения или пока не будет создано исключение.</span><span class="sxs-lookup"><span data-stu-id="0077a-124">In this case, too, the one-way client blocks until the service can process the messages or until an exception is thrown.</span></span>  
  
 <span data-ttu-id="0077a-125">Подобная блокировка также может происходить в том случае, если свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> службы имеет значение <xref:System.ServiceModel.ConcurrencyMode.Single>, а привязка использует сеансы.</span><span class="sxs-lookup"><span data-stu-id="0077a-125">Another variation is the situation in which the service <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ConcurrencyMode.Single> and the binding uses sessions.</span></span> <span data-ttu-id="0077a-126">В этом случае диспетчер принудительно упорядочивает входящие сообщения (требование сеансов), что не допускает чтения из сети следующего сообщения, пока служба не обработала предыдущее сообщение для этого сеанса.</span><span class="sxs-lookup"><span data-stu-id="0077a-126">In this case, the dispatcher enforces ordering on the incoming messages (a requirement of sessions), which prevents subsequent messages from being read off the network until the service has processed the preceding message for that session.</span></span> <span data-ttu-id="0077a-127">Клиент в этом случае также блокируется, но появление исключения зависит от того, успеет ли служба обработать ожидающие данные, пока не истечет установленное на стороне клиента время ожидания.</span><span class="sxs-lookup"><span data-stu-id="0077a-127">Again, the client blocks, but whether an exception occurs depends upon whether the service is able to process the waiting data prior to the timeout settings on the client.</span></span>  
  
 <span data-ttu-id="0077a-128">Можно частично ограничить эту проблему, поместив буфер между объектом клиента и операцией отправки транспорта клиента.</span><span class="sxs-lookup"><span data-stu-id="0077a-128">You can mitigate some of this problem by inserting a buffer between the client object and the client transport's send operation.</span></span> <span data-ttu-id="0077a-129">Например, при использовании асинхронных вызовов или очереди сообщений в памяти объект клиента может быстро возвращать управление.</span><span class="sxs-lookup"><span data-stu-id="0077a-129">For example, using asynchronous calls or using an in-memory message queue can enable the client object to return quickly.</span></span> <span data-ttu-id="0077a-130">Оба подхода могут расширить функциональность, но размер пула потоков и очереди сообщений по-прежнему накладывает ограничения.</span><span class="sxs-lookup"><span data-stu-id="0077a-130">Both approaches may increase functionality, but the size of the thread pool and the message queue still enforce limits.</span></span>  
  
 <span data-ttu-id="0077a-131">Вместо этого рекомендуется изучить различные элементы управления службы и клиента и испытать различные сценарии работы приложения, чтобы определить наилучшую конфигурацию на каждой из сторон.</span><span class="sxs-lookup"><span data-stu-id="0077a-131">It is recommended, instead, that you examine the various controls on the service as well as on the client, and then test your application scenarios to determine the best configuration on either side.</span></span> <span data-ttu-id="0077a-132">Например, если использование сеансов блокирует обработку сообщений на стороне службы, можно установить для свойства <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> значение <xref:System.ServiceModel.InstanceContextMode.PerCall>, чтобы каждое сообщение обрабатывалось отдельным экземпляром службы, а также установить свойство <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> равным <xref:System.ServiceModel.ConcurrencyMode.Multiple>, чтобы одновременно распределять сообщения могло более одного потока.</span><span class="sxs-lookup"><span data-stu-id="0077a-132">For example, if the use of sessions is blocking the processing of messages on your service, you can set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.PerCall> so that each message can be processed by a different service instance, and set the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> to <xref:System.ServiceModel.ConcurrencyMode.Multiple> in order to allow more than one thread to dispatch messages at a time.</span></span> <span data-ttu-id="0077a-133">Еще одно возможное решение - увеличить квоты чтения привязок службы и клиента.</span><span class="sxs-lookup"><span data-stu-id="0077a-133">Another approach is to increase the read quotas of the service and client bindings.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0077a-134">См. также</span><span class="sxs-lookup"><span data-stu-id="0077a-134">See also</span></span>

- [<span data-ttu-id="0077a-135">Одностороннее взаимодействие</span><span class="sxs-lookup"><span data-stu-id="0077a-135">One-Way</span></span>](../../../../docs/framework/wcf/samples/one-way.md)
