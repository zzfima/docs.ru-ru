---
title: Пользовательские кодировщики
ms.date: 03/30/2017
ms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f
ms.openlocfilehash: 036cbff9046df2d1179c5cc0921dd8d89757558b
ms.sourcegitcommit: 8145ad08288bf141d68e3256cb1f7a3ad842ca33
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/22/2018
ms.locfileid: "50034392"
---
# <a name="custom-encoders"></a>Пользовательские кодировщики
В данном разделе рассматривается процесс создания пользовательских кодировщиков.  
  
 В Windows Communication Foundation (WCF), используйте *привязки* для указания способа передачи данных по сети между конечными точками. Привязка состоит из последовательности *элементов привязки*. В привязку входят необязательные элементы привязки протокола такие как безопасность, обязательный *кодировщик сообщений* элемент привязки и обязательный элемент привязки транспорта. Кодировщик сообщений представлен элементом привязки кодирования сообщений. Три кодировщика сообщений в WCF: двоичный файл, механизм оптимизации передачи сообщений (MTOM) и текст.  
  
 Элемент привязки кодирования сообщений сериализует исходящее сообщение <xref:System.ServiceModel.Channels.Message> и передает его транспорту или получает сериализованную форму сообщения от транспорта и передает ее на уровень протоколов, если он имеется, или в приложение, если он отсутствует.  
  
 Кодировщики сообщений преобразовывают экземпляры <xref:System.ServiceModel.Channels.Message> в представление для передачи и наоборот. Хотя в описании кодировщиков указано, что они находятся над транспортным уровнем в стеке каналов, они располагаются на транспортном уровне. Транспорты (например, HTTP) форматируют сообщение в соответствии с требованиями стандарта транспортов. Кодировщики (например, Text Xml) только кодируют сообщение.  
  
 При подключении к ранее существующему клиенту или серверу не всегда имеется возможность выбрать определенное кодирование сообщений. Тем не менее службы WCF возможен через несколько конечных точек, каждая из которых использует свой кодировщик сообщений. Если один кодировщик не охватывает всю аудиторию для службы, следует рассмотреть возможность представления службы через несколько конечных точек. Это позволит клиентским приложениям выбрать наиболее подходящую конечную точку. Использование нескольких конечных точек позволяет сочетать преимущества разных кодировщиков сообщений с другими элементами привязки.  
  
## <a name="system-provided-encoders"></a>Кодировщики, предоставляемые системой  
 WCF предоставляет несколько предоставляемых системой привязок, которые разработаны для удовлетворения самых распространенных сценариев приложений. Каждая из этих привязок содержит транспорт, кодировщик сообщений и другие параметры (например, безопасность). В этом разделе описывается, как расширить `Text`, `Binary`, и `MTOM` кодировщики, которые были добавлены в WCF, или создать собственный пользовательский кодировщик сообщений. Кодировщик текстовых сообщений поддерживает как кодирование на простом языке XML, так и кодирование SOAP. Режим кодирования на простом языке XML кодировщика текстовых сообщений называется кодировщиком POX ("plain old XML"), что позволяет отличить его от текстового кодирования SOAP.  
  
 Дополнительные сведения о сочетаниях элементов привязки, предоставляемые системой привязки, предоставляемые см. в соответствующем разделе в [выбор транспорта](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md).  
  
## <a name="how-to-work-with-system-provided-encoders"></a>Принцип работы с кодировщиками, предоставляемыми системой  
 Кодирование добавляется в привязку с помощью класса, унаследованного от класса <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.  
  
 WCF предоставляет следующие типы элементов привязки, производный от <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> класса, реализующего текстовое, двоичное кодирование и механизм оптимизации передачи сообщений (MTOM) кодировки:  
  
-   <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>. Кодировщик для сообщений XML с наиболее широкими возможностями взаимодействия, но при этом наименее неэффективный. Веб-служба или клиент веб-службы в общем могут понимать XML в текстовом виде. Однако передача больших блоков двоичных данных в виде текста неэффективна.  
  
-   <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>. Представляет собой элемент привязки, указывающий кодирование символов и управление версиями сообщений для сообщений XML в двоичном формате. Это наиболее эффективный параметры кодировки, но наименее подходящий для взаимодействия, так как он поддерживается только конечными точками WCF.  
  
-   <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>. Представляет собой элемент привязки, указывающий кодирование символов и управление версиями сообщений для сообщений, для которых применяется подсистема оптимизации передачи сообщений MTOM. MTOM - это эффективный способ передачи двоичных данных в сообщениях WCF. Кодировщик MTOM пытается обеспечить баланс между эффективностью и взаимодействием. Кодирование MTOM передает большую часть XML-данных в текстовой форме, но оптимизирует большие блоки двоичных данных путем передачи их в исходном виде, без преобразования в текст.  
  
 Элемент привязки создает двоичную, MTOM или текстовую фабрику <xref:System.ServiceModel.Channels.MessageEncoderFactory>. Фабрика создает двоичный, MTOM или текстовый экземпляр <xref:System.ServiceModel.Channels.MessageEncoderFactory>. Обычно существует только один экземпляр. Однако при использовании сеансов для каждого сеанса могут предоставляться разные кодировщики. Двоичный кодировщик использует это для координации динамических словарей (см. раздел "Инфраструктура XML").  
  
 Методы <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> и <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> являются основой кодировщиков. Методы обеспечивают чтение сообщения из потока или формируют массив <xref:System.Byte>. Байтовые массивы используются, когда транспорт работает в режиме буферизации. Сообщения всегда записываются в потоки. Если транспорт должен поместить сообщение в буфер, он предоставляет поток, который выполняет буферизацию.  
  
 Остальные члены работают с дополнительным содержимым, типами носителей и <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>. Транспорт вызывает эти методы кодировщика, чтобы проверить, можно ли с их помощью декодировать входящее сообщение, или чтобы определить, является ли исходящее сообщение действительным для этого кодировщика.  
  
 Каждая из трех реализаций кодировщика добавляет свойства, относящиеся к определенному кодированию, и является полностью настраиваемой. Кодировщики также предоставляют квоты средства чтения, которые имеют защищенные параметры по умолчанию. Обсуждение квот см. в разделе "Инфраструктура XML".  
  
## <a name="features-of-system-provided-encoders"></a>Функции кодировщиков, предоставляемых системой  
 Кодировщики, предоставляемые системой, имеют несколько функций.  
  
### <a name="pooling"></a>Pooling  
 В каждой реализации выполняется попытка объединения в пул, насколько это возможно. Снижение выделения памяти- это основной способ улучшения производительности управляемого кода. Для облегчения объединения в пул в реализациях используется класс `SynchronizedPool`. Файл C# содержит описание дополнительных оптимизаций, используемых в этом классе.  
  
 Экземпляры `XmlDictionaryReader` и `XmlDictionaryWriter` объединяются в пул и повторно инициализируются, чтобы предотвратить выделение памяти для новых экземпляров для каждого сообщения. В случае средств чтения, обратный вызов `OnClose` закрывает средство чтения при вызове метода `Close()`. Кодировщик также повторно использует некоторые объекты состояния сообщений, используемые при создании сообщений. Размер пулов настраивается с помощью свойств `MaxReadPoolSize` и `MaxWritePoolSize` для каждого из трех классов, унаследованных от класса <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.  
  
### <a name="binary-encoding"></a>Двоичное кодирование  
 Если при двоичном кодировании используются сеансы, получатель сообщения должен иметь возможность взаимодействия со строкой динамического словаря. Это осуществляется путем задания префикса сообщению со строками динамического словаря. Получатель отсекает строки, добавляет их в сеанс и обрабатывает сообщение. Для правильной передачи строк словаря необходимо, чтобы транспорт был помещен в буфер.  
  
 Строки добавляются в сообщение с помощью внутреннего метода `AddSessionInformationToMessage`. Он добавляет строки в виде UTF-8 вначале сообщения с префиксом их длины. Затем во весь заголовок словаря добавляет префикс длины данных. Обратная операция выполняется внутренним методом `ExtractSessionInformationFromMessage`.  
  
 Помимо обработки ключей динамического словаря, буферизированные сообщения, связанные с сеансом, принимаются уникальным способом. Вместо создания средства чтения над документом и его обработки в двоичном кодировании используется внутренний класс `MessagePatterns` для разбора двоичного потока. Идея состоит в том, что большинство сообщений имеют определенный набор заголовков, представляемых в определенном порядке при формировании платформой WCF. Система шаблонов разделяет сообщение на части на основании ожиданий. В случае успешного выполнения она инициализирует объект <xref:System.ServiceModel.Channels.MessageHeaders> без анализа XML. В противном случае она возвращается к стандартному методу.  
  
### <a name="mtom-encoding"></a>Кодирование MTOM  
 Класс <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> имеет дополнительное свойство конфигурации <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement.MaxBufferSize%2A>. Оно задает верхнюю границу объема данных, который можно помещать в буфер во время чтения сообщения. Может возникнуть необходимость в буферизации XML Information Set (Infoset) или других частей MIME, чтобы повторно собрать все части MIME в одно сообщение.  
  
 Для правильной работы с HTTP внутренний класс кодировщика сообщений MTOM предоставляет несколько интерфейсов API для метода `GetContentType` (который также является внутренним) и метода `WriteMessage`, который является открытым и может быть переопределен. Чтобы значения в заголовках HTTP соответствовали значениям в заголовках MIME, необходимо обеспечить более широкие возможности взаимодействия.  
  
 На внутреннем уровне кодировщик сообщений MTOM использует средства чтения текста WCF и похож на текстовый кодировщик. Основное отличие заключается в том, что он оптимизирует большой объем двоичных данных или большие двоичные объекты, не преобразовывая их в кодировку Base-64 до внедрения в байты сообщения. Вместо этого эти объекты остаются извлеченными, и на них существуют ссылки как на вложения MIME.  
  
## <a name="writing-your-own-encoder"></a>Запись собственного кодировщика  
 Чтобы реализовать собственный пользовательский кодировщик сообщений, предоставьте пользовательские реализации следующих абстрактных базовых классов.  
  
-   <xref:System.ServiceModel.Channels.MessageEncoder>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
-   <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
 Преобразование из хранимого в памяти представления сообщения в представление, которое можно записать в поток, инкапсулировано внутри класса <xref:System.ServiceModel.Channels.MessageEncoder>, который используется в качестве фабрики для средств чтения XML и средств записи XML, поддерживающих определенные типы кодирования XML.  
  
-   Ниже представлены основные методы этого класса, которые необходимо переопределить.  
  
-   <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A>, который принимает объект <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> и записывает его в объект <xref:System.IO.Stream>.  
  
-   <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A>, который принимает объект <xref:System.IO.Stream> и максимальный размер заголовка и возвращает объект <xref:System.ServiceModel.Channels.Message>.  
  
 Код, записываемый в этих методах, выполняет преобразование между стандартным транспортным протоколом и настроенным кодированием.  
  
 Затем следует записать в код класс фабрики, создающий пользовательский кодировщик. Переопределите свойство <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A>, чтобы обеспечить возврат экземпляра пользовательского кодировщика <xref:System.ServiceModel.Channels.MessageEncoder>.  
  
 Затем подключите пользовательскую фабрику <xref:System.ServiceModel.Channels.MessageEncoderFactory> к стеку элементов привязки, используемому для настройки службы или клиента, переопределив метод <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A>, чтобы вернуть экземпляр этой фабрики.  
  
 Существует два примера, в состав WCF, демонстрирующие этот процесс с помощью примера кода: [пользовательский кодировщик сообщений: кодировщик пользовательских текстовых](../../../../docs/framework/wcf/samples/custom-message-encoder-custom-text-encoder.md) и [пользовательский кодировщик сообщений: кодировщик сжатия](../../../../docs/framework/wcf/samples/custom-message-encoder-compression-encoder.md).  
  
## <a name="see-also"></a>См. также  
 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
 <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
 <xref:System.ServiceModel.Channels.MessageEncoder>  
 [Общие сведения об архитектуре передачи данных](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)  
 [Выбор кодировщика сообщений](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)  
 [Выбор транспорта](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)
