---
title: "Пользовательские кодировщики"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: fa0e1d7f-af36-4bf4-aac9-cd4eab95bc4f
caps.latest.revision: "15"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: f1c8223ea7900ba0a89ee2c5c48895a1782d18a0
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2017
---
# <a name="custom-encoders"></a><span data-ttu-id="963a0-102">Пользовательские кодировщики</span><span class="sxs-lookup"><span data-stu-id="963a0-102">Custom Encoders</span></span>
<span data-ttu-id="963a0-103">В данном разделе рассматривается процесс создания пользовательских кодировщиков.</span><span class="sxs-lookup"><span data-stu-id="963a0-103">This topic discusses how to create custom encoders.</span></span>  
  
 <span data-ttu-id="963a0-104">В [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)], используется *привязки* для указания способа передачи данных по сети между конечными точками.</span><span class="sxs-lookup"><span data-stu-id="963a0-104">In [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)], you use a *binding* to specify how to transfer data across a network between endpoints.</span></span> <span data-ttu-id="963a0-105">Привязка состоит из последовательности *элементов привязки*.</span><span class="sxs-lookup"><span data-stu-id="963a0-105">A binding is made up of a sequence of *binding elements*.</span></span> <span data-ttu-id="963a0-106">В привязку входят необязательные элементы привязки протокола такие как безопасность, обязательный *кодировщик сообщений* элемент привязки и обязательный элемент привязки транспорта.</span><span class="sxs-lookup"><span data-stu-id="963a0-106">A binding includes optional protocol binding elements such as security, a required *Message Encoder* binding element, and a required transport binding element.</span></span> <span data-ttu-id="963a0-107">Кодировщик сообщений представлен элементом привязки кодирования сообщений.</span><span class="sxs-lookup"><span data-stu-id="963a0-107">A message encoder is represented by a message encoding binding element.</span></span> <span data-ttu-id="963a0-108">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] содержит три кодировщика сообщений: двоичный, подсистему оптимизации передачи сообщений MTOM и текстовый.</span><span class="sxs-lookup"><span data-stu-id="963a0-108">Three message encoders are included in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]: Binary, Message Transmission Optimization Mechanism (MTOM), and Text.</span></span>  
  
 <span data-ttu-id="963a0-109">Элемент привязки кодирования сообщений сериализует исходящее сообщение <xref:System.ServiceModel.Channels.Message> и передает его транспорту или получает сериализованную форму сообщения от транспорта и передает ее на уровень протоколов, если он имеется, или в приложение, если он отсутствует.</span><span class="sxs-lookup"><span data-stu-id="963a0-109">A message encoding binding element serializes an outgoing <xref:System.ServiceModel.Channels.Message> and passes it to the transport, or receives the serialized form of a message from the transport and passes it to the protocol layer if present, or to the application, if not present.</span></span>  
  
 <span data-ttu-id="963a0-110">Кодировщики сообщений преобразовывают экземпляры <xref:System.ServiceModel.Channels.Message> в представление для передачи и наоборот.</span><span class="sxs-lookup"><span data-stu-id="963a0-110">Message encoders transform <xref:System.ServiceModel.Channels.Message> instances to and from a wire representation.</span></span> <span data-ttu-id="963a0-111">Хотя в описании кодировщиков указано, что они находятся над транспортным уровнем в стеке каналов, они располагаются на транспортном уровне.</span><span class="sxs-lookup"><span data-stu-id="963a0-111">Although encoders are described as sitting above the transport layer in the channel stack, they reside inside the transport layer.</span></span> <span data-ttu-id="963a0-112">Транспорты (например, HTTP) форматируют сообщение в соответствии с требованиями стандарта транспортов.</span><span class="sxs-lookup"><span data-stu-id="963a0-112">Transports (for example HTTP) format the message according to the requirements of the transport standard.</span></span> <span data-ttu-id="963a0-113">Кодировщики (например, Text Xml) только кодируют сообщение.</span><span class="sxs-lookup"><span data-stu-id="963a0-113">Encoders (for example Text Xml) just encode the message.</span></span>  
  
 <span data-ttu-id="963a0-114">При подключении к ранее существующему клиенту или серверу не всегда имеется возможность выбрать определенное кодирование сообщений.</span><span class="sxs-lookup"><span data-stu-id="963a0-114">When connecting to a preexisting client or server, you may not have a choice about using a particular message encoding.</span></span> <span data-ttu-id="963a0-115">Однако доступ к службам [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] может осуществляться через несколько конечных точек, каждая из которых использует свой кодировщик сообщений.</span><span class="sxs-lookup"><span data-stu-id="963a0-115">However, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] services can be made accessible through multiple endpoints, each with a different message encoder.</span></span> <span data-ttu-id="963a0-116">Если один кодировщик не охватывает всю аудиторию для службы, следует рассмотреть возможность представления службы через несколько конечных точек.</span><span class="sxs-lookup"><span data-stu-id="963a0-116">When a single encoder does not cover the entire audience for your service, consider exposing your service over multiple endpoints.</span></span> <span data-ttu-id="963a0-117">Это позволит клиентским приложениям выбрать наиболее подходящую конечную точку.</span><span class="sxs-lookup"><span data-stu-id="963a0-117">Client applications can then choose the endpoint that is best for them.</span></span> <span data-ttu-id="963a0-118">Использование нескольких конечных точек позволяет сочетать преимущества разных кодировщиков сообщений с другими элементами привязки.</span><span class="sxs-lookup"><span data-stu-id="963a0-118">Using multiple endpoints allows you to combine the advantages of different message encoders with other binding elements.</span></span>  
  
## <a name="system-provided-encoders"></a><span data-ttu-id="963a0-119">Кодировщики, предоставляемые системой</span><span class="sxs-lookup"><span data-stu-id="963a0-119">System-Provided Encoders</span></span>  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="963a0-120"> предлагает несколько привязок, предоставляемых системой, которые разработаны для использования с самыми общими сценариями приложения.</span><span class="sxs-lookup"><span data-stu-id="963a0-120"> provides several system-provided bindings that are designed to cover the most common application scenarios.</span></span> <span data-ttu-id="963a0-121">Каждая из этих привязок содержит транспорт, кодировщик сообщений и другие параметры (например, безопасность).</span><span class="sxs-lookup"><span data-stu-id="963a0-121">Each of these bindings combine a transport, message encoder, and other options (security, for example).</span></span> <span data-ttu-id="963a0-122">В данном разделе описывается, как расширить кодировщики сообщений `Text`, `Binary` и `MTOM`, содержащиеся в [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], или создать собственный пользовательский кодировщик.</span><span class="sxs-lookup"><span data-stu-id="963a0-122">This topic describes how to extend the `Text`, `Binary`, and `MTOM` message encoders that are included in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], or create your own custom encoder.</span></span> <span data-ttu-id="963a0-123">Кодировщик текстовых сообщений поддерживает как кодирование на простом языке XML, так и кодирование SOAP.</span><span class="sxs-lookup"><span data-stu-id="963a0-123">The text message encoder supports both a plain XML encoding as well as SOAP encodings.</span></span> <span data-ttu-id="963a0-124">Режим кодирования на простом языке XML кодировщика текстовых сообщений называется кодировщиком POX ("plain old XML"), что позволяет отличить его от текстового кодирования SOAP.</span><span class="sxs-lookup"><span data-stu-id="963a0-124">The plain XML encoding mode of the text message encoder is called the POX ("Plain Old XML") encoder to distinguish it from the text-based SOAP encoding.</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="963a0-125">сочетания элементов привязки, предоставляемые привязок, предоставляемых системой, см. в соответствующий подраздел в [выбор транспорта](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md).</span><span class="sxs-lookup"><span data-stu-id="963a0-125"> the combinations of binding elements provided by the system-provided bindings, see the corresponding section in [Choosing a Transport](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md).</span></span>  
  
## <a name="how-to-work-with-system-provided-encoders"></a><span data-ttu-id="963a0-126">Принцип работы с кодировщиками, предоставляемыми системой</span><span class="sxs-lookup"><span data-stu-id="963a0-126">How to Work with System-Provided Encoders</span></span>  
 <span data-ttu-id="963a0-127">Кодирование добавляется в привязку с помощью класса, унаследованного от класса <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span><span class="sxs-lookup"><span data-stu-id="963a0-127">An encoding is added to a binding using a class derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="963a0-128"> предоставляет следующие типы элементов привязки, унаследованные от класса <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>, которые обеспечивают текстовое кодирование, двоичное кодирование и подсистему оптимизации передачи сообщений MTOM.</span><span class="sxs-lookup"><span data-stu-id="963a0-128"> provides the following types of binding elements derived from the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> class that can provide for text, binary and Message Transmission Optimization Mechanism (MTOM) encoding:</span></span>  
  
-   <span data-ttu-id="963a0-129"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>. Кодировщик для сообщений XML с наиболее широкими возможностями взаимодействия, но при этом наименее неэффективный.</span><span class="sxs-lookup"><span data-stu-id="963a0-129"><xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>: The most interoperable, but the least efficient encoder for XML messages.</span></span> <span data-ttu-id="963a0-130">Веб-служба или клиент веб-службы в общем могут понимать XML в текстовом виде.</span><span class="sxs-lookup"><span data-stu-id="963a0-130">A Web service or Web service client can generally understand textual XML.</span></span> <span data-ttu-id="963a0-131">Однако передача больших блоков двоичных данных в виде текста неэффективна.</span><span class="sxs-lookup"><span data-stu-id="963a0-131">However, transmitting large blocks of binary data as text is not efficient.</span></span>  
  
-   <span data-ttu-id="963a0-132"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>. Представляет собой элемент привязки, указывающий кодирование символов и управление версиями сообщений для сообщений XML в двоичном формате.</span><span class="sxs-lookup"><span data-stu-id="963a0-132"><xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>: Represents the binding element that specifies the character encoding and message versioning used for binary-based XML messages.</span></span> <span data-ttu-id="963a0-133">Этот параметр кодирования самый эффективный, но наименее подходящий для взаимодействия, поскольку он поддерживается только конечными точками [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="963a0-133">This is most efficient of the encoding options, but the least interoperable, because it is only supported by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] endpoints.</span></span>  
  
-   <span data-ttu-id="963a0-134"><<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement -->`System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`>: представляет элемент привязки, задающий кодировку и управление версиями сообщений для сообщения с использованием кодировки механизм оптимизации передачи сообщений (MTOM).</span><span class="sxs-lookup"><span data-stu-id="963a0-134"><<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`>: Represents the binding element that specifies the character encoding and message versioning used for a message using a Message Transmission Optimization Mechanism (MTOM) encoding.</span></span> <span data-ttu-id="963a0-135">MTOM - это эффективная технология передачи двоичных данных в сообщениях [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="963a0-135">MTOM is an efficient technology for transmitting binary data in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] messages.</span></span> <span data-ttu-id="963a0-136">Кодировщик MTOM пытается обеспечить баланс между эффективностью и взаимодействием.</span><span class="sxs-lookup"><span data-stu-id="963a0-136">The MTOM encoder attempts to balance between efficiency and interoperability.</span></span> <span data-ttu-id="963a0-137">Кодирование MTOM передает большую часть XML-данных в текстовой форме, но оптимизирует большие блоки двоичных данных путем передачи их в исходном виде, без преобразования в текст.</span><span class="sxs-lookup"><span data-stu-id="963a0-137">The MTOM encoding transmits most XML in textual form, but optimizes large blocks of binary data by transmitting them as-is, without conversion to text.</span></span>  
  
 <span data-ttu-id="963a0-138">Элемент привязки создает двоичную, MTOM или текстовую фабрику <xref:System.ServiceModel.Channels.MessageEncoderFactory>.</span><span class="sxs-lookup"><span data-stu-id="963a0-138">The binding element creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory>.</span></span> <span data-ttu-id="963a0-139">Фабрика создает двоичный, MTOM или текстовый экземпляр <xref:System.ServiceModel.Channels.MessageEncoderFactory>.</span><span class="sxs-lookup"><span data-stu-id="963a0-139">The factory creates a binary, MTOM, or text <xref:System.ServiceModel.Channels.MessageEncoderFactory> instance.</span></span> <span data-ttu-id="963a0-140">Обычно существует только один экземпляр.</span><span class="sxs-lookup"><span data-stu-id="963a0-140">Typically, there is only a single instance.</span></span> <span data-ttu-id="963a0-141">Однако при использовании сеансов для каждого сеанса могут предоставляться разные кодировщики.</span><span class="sxs-lookup"><span data-stu-id="963a0-141">However if sessions are used, a different encoder may be provided to each session.</span></span> <span data-ttu-id="963a0-142">Двоичный кодировщик использует это для координации динамических словарей (см. раздел "Инфраструктура XML").</span><span class="sxs-lookup"><span data-stu-id="963a0-142">The Binary encoder makes use of this to coordinate dynamic dictionaries (see XML Infrastructure).</span></span>  
  
 <span data-ttu-id="963a0-143">Методы <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> и <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> являются основой кодировщиков.</span><span class="sxs-lookup"><span data-stu-id="963a0-143">The <xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> and <xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> methods are the core of the encoders.</span></span> <span data-ttu-id="963a0-144">Методы обеспечивают чтение сообщения из потока или формируют массив <xref:System.Byte>.</span><span class="sxs-lookup"><span data-stu-id="963a0-144">The methods provide for reading a message from a stream or from a <xref:System.Byte> array.</span></span> <span data-ttu-id="963a0-145">Байтовые массивы используются, когда транспорт работает в режиме буферизации.</span><span class="sxs-lookup"><span data-stu-id="963a0-145">Byte arrays are used when the transport is operating in buffered mode.</span></span> <span data-ttu-id="963a0-146">Сообщения всегда записываются в потоки.</span><span class="sxs-lookup"><span data-stu-id="963a0-146">Messages are always written to streams.</span></span> <span data-ttu-id="963a0-147">Если транспорт должен поместить сообщение в буфер, он предоставляет поток, который выполняет буферизацию.</span><span class="sxs-lookup"><span data-stu-id="963a0-147">If the transport must buffer the message, it provides a stream that does the buffering.</span></span>  
  
 <span data-ttu-id="963a0-148">Остальные члены работают с дополнительным содержимым, типами носителей и <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>.</span><span class="sxs-lookup"><span data-stu-id="963a0-148">The rest of the members work with support content, media types, and <xref:System.ServiceModel.Channels.MessageEncoder.MessageVersion%2A>.</span></span> <span data-ttu-id="963a0-149">Транспорт вызывает эти методы кодировщика, чтобы проверить, можно ли с их помощью декодировать входящее сообщение, или чтобы определить, является ли исходящее сообщение действительным для этого кодировщика.</span><span class="sxs-lookup"><span data-stu-id="963a0-149">The transport calls these encoder methods to test whether the incoming message can be decoded by it, or to determine if the outgoing message is valid for this encoder.</span></span>  
  
 <span data-ttu-id="963a0-150">Каждая из трех реализаций кодировщика добавляет свойства, относящиеся к определенному кодированию, и является полностью настраиваемой.</span><span class="sxs-lookup"><span data-stu-id="963a0-150">Each of the three encoder implementations adds properties that are relevant to the specific encodings and is fully configurable.</span></span> <span data-ttu-id="963a0-151">Кодировщики также предоставляют квоты средства чтения, которые имеют защищенные параметры по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="963a0-151">The encoders also expose reader quotas that have secure defaults.</span></span> <span data-ttu-id="963a0-152">Обсуждение квот см. в разделе "Инфраструктура XML".</span><span class="sxs-lookup"><span data-stu-id="963a0-152">See XML Infrastructure for a discussion of the quotas.</span></span>  
  
## <a name="features-of-system-provided-encoders"></a><span data-ttu-id="963a0-153">Функции кодировщиков, предоставляемых системой</span><span class="sxs-lookup"><span data-stu-id="963a0-153">Features of System-Provided Encoders</span></span>  
 <span data-ttu-id="963a0-154">Кодировщики, предоставляемые системой, имеют несколько функций.</span><span class="sxs-lookup"><span data-stu-id="963a0-154">There are a number of features provided by the system-provided encoders.</span></span>  
  
### <a name="pooling"></a><span data-ttu-id="963a0-155">Pooling</span><span class="sxs-lookup"><span data-stu-id="963a0-155">Pooling</span></span>  
 <span data-ttu-id="963a0-156">В каждой реализации выполняется попытка объединения в пул, насколько это возможно.</span><span class="sxs-lookup"><span data-stu-id="963a0-156">Each of the encoder implementations tries to pool as much as possible.</span></span> <span data-ttu-id="963a0-157">Снижение выделения памяти- это основной способ улучшения производительности управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="963a0-157">Reducing allocations is a key way to improve the performance of managed code.</span></span> <span data-ttu-id="963a0-158">Для облегчения объединения в пул в реализациях используется класс `SynchronizedPool`.</span><span class="sxs-lookup"><span data-stu-id="963a0-158">To accomplish this pooling, the implementations use the `SynchronizedPool` class.</span></span> <span data-ttu-id="963a0-159">Файл C# содержит описание дополнительных оптимизаций, используемых в этом классе.</span><span class="sxs-lookup"><span data-stu-id="963a0-159">The C# file contains a description of the additional optimizations used by this class.</span></span>  
  
 <span data-ttu-id="963a0-160">Экземпляры `XmlDictionaryReader` и `XmlDictionaryWriter` объединяются в пул и повторно инициализируются, чтобы предотвратить выделение памяти для новых экземпляров для каждого сообщения.</span><span class="sxs-lookup"><span data-stu-id="963a0-160">`XmlDictionaryReader` and `XmlDictionaryWriter` instances are pooled and reinitialized to prevent allocating new ones for each message.</span></span> <span data-ttu-id="963a0-161">В случае средств чтения, обратный вызов `OnClose` закрывает средство чтения при вызове метода `Close()`.</span><span class="sxs-lookup"><span data-stu-id="963a0-161">For the readers, an `OnClose` callback reclaims the reader when `Close()` is called.</span></span> <span data-ttu-id="963a0-162">Кодировщик также повторно использует некоторые объекты состояния сообщений, используемые при создании сообщений.</span><span class="sxs-lookup"><span data-stu-id="963a0-162">The encoder also recycles some message state objects used when constructing messages.</span></span> <span data-ttu-id="963a0-163">Размер пулов настраивается с помощью свойств `MaxReadPoolSize` и `MaxWritePoolSize` для каждого из трех классов, унаследованных от класса <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span><span class="sxs-lookup"><span data-stu-id="963a0-163">The sizes of these pools are configurable by the `MaxReadPoolSize` and `MaxWritePoolSize` properties on each of the three classes derived from <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>.</span></span>  
  
### <a name="binary-encoding"></a><span data-ttu-id="963a0-164">Двоичное кодирование</span><span class="sxs-lookup"><span data-stu-id="963a0-164">Binary Encoding</span></span>  
 <span data-ttu-id="963a0-165">Если при двоичном кодировании используются сеансы, получатель сообщения должен иметь возможность взаимодействия со строкой динамического словаря.</span><span class="sxs-lookup"><span data-stu-id="963a0-165">When binary encoding uses sessions, the dynamic dictionary string must be communicated to the receiver of the message.</span></span> <span data-ttu-id="963a0-166">Это осуществляется путем задания префикса сообщению со строками динамического словаря.</span><span class="sxs-lookup"><span data-stu-id="963a0-166">This is done by prefixing the message with the dynamic dictionary strings.</span></span> <span data-ttu-id="963a0-167">Получатель отсекает строки, добавляет их в сеанс и обрабатывает сообщение.</span><span class="sxs-lookup"><span data-stu-id="963a0-167">The receiver strips off the strings, adds them to the session, and processes the message.</span></span> <span data-ttu-id="963a0-168">Для правильной передачи строк словаря необходимо, чтобы транспорт был помещен в буфер.</span><span class="sxs-lookup"><span data-stu-id="963a0-168">Correctly passing dictionary strings requires that the transport be buffered.</span></span>  
  
 <span data-ttu-id="963a0-169">Строки добавляются в сообщение с помощью внутреннего метода `AddSessionInformationToMessage`.</span><span class="sxs-lookup"><span data-stu-id="963a0-169">The strings are appended to the message by an internal `AddSessionInformationToMessage` method.</span></span> <span data-ttu-id="963a0-170">Он добавляет строки в виде UTF-8 вначале сообщения с префиксом их длины.</span><span class="sxs-lookup"><span data-stu-id="963a0-170">It adds the strings as UTF-8 to the front of the message prefixed with their length.</span></span> <span data-ttu-id="963a0-171">Затем во весь заголовок словаря добавляет префикс длины данных.</span><span class="sxs-lookup"><span data-stu-id="963a0-171">The entire dictionary header is then prefixed with the length of its data.</span></span> <span data-ttu-id="963a0-172">Обратная операция выполняется внутренним методом `ExtractSessionInformationFromMessage`.</span><span class="sxs-lookup"><span data-stu-id="963a0-172">The reverse operation is performed by an internal `ExtractSessionInformationFromMessage` method.</span></span>  
  
 <span data-ttu-id="963a0-173">Помимо обработки ключей динамического словаря, буферизированные сообщения, связанные с сеансом, принимаются уникальным способом.</span><span class="sxs-lookup"><span data-stu-id="963a0-173">In addition to processing dynamic dictionary keys, buffered sessionful messages are received in a unique way.</span></span> <span data-ttu-id="963a0-174">Вместо создания средства чтения над документом и его обработки в двоичном кодировании используется внутренний класс `MessagePatterns` для разбора двоичного потока.</span><span class="sxs-lookup"><span data-stu-id="963a0-174">Instead of creating a reader over the document and processing it, the binary encoder uses the internal `MessagePatterns` class to deconstruct the binary stream.</span></span> <span data-ttu-id="963a0-175">Идея заключается в том, что большинство сообщений имеют определенный набор заголовков, представляемых в определенном порядке при создании службой [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span><span class="sxs-lookup"><span data-stu-id="963a0-175">The idea is that most messages have a certain set of headers that show up in a certain order when generated by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span> <span data-ttu-id="963a0-176">Система шаблонов разделяет сообщение на части на основании ожиданий.</span><span class="sxs-lookup"><span data-stu-id="963a0-176">The pattern system breaks the message apart based on what it expects.</span></span> <span data-ttu-id="963a0-177">В случае успешного выполнения она инициализирует объект <xref:System.ServiceModel.Channels.MessageHeaders> без анализа XML.</span><span class="sxs-lookup"><span data-stu-id="963a0-177">If it is successful, it initializes a <xref:System.ServiceModel.Channels.MessageHeaders> object without parsing the XML.</span></span> <span data-ttu-id="963a0-178">В противном случае она возвращается к стандартному методу.</span><span class="sxs-lookup"><span data-stu-id="963a0-178">If not, it falls back to the standard method.</span></span>  
  
### <a name="mtom-encoding"></a><span data-ttu-id="963a0-179">Кодирование MTOM</span><span class="sxs-lookup"><span data-stu-id="963a0-179">MTOM Encoding</span></span>  
 <span data-ttu-id="963a0-180"><<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`> Класс имеет дополнительное свойство конфигурации <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`. MaxBufferSize % 2A >.</span><span class="sxs-lookup"><span data-stu-id="963a0-180">The <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`> class has an additional configuration property called <<!--zz xref:System.ServiceModel.Channels.MTOMMessageEncodingBindingElement --> `System.ServiceModel.Channels.MTOMMessageEncodingBindingElement`.MaxBufferSize%2A>.</span></span> <span data-ttu-id="963a0-181">Оно задает верхнюю границу объема данных, который можно помещать в буфер во время чтения сообщения.</span><span class="sxs-lookup"><span data-stu-id="963a0-181">This places an upper bound on how much data it is allowed to buffer during the process of reading a message.</span></span> <span data-ttu-id="963a0-182">Может возникнуть необходимость в буферизации XML Information Set (Infoset) или других частей MIME, чтобы повторно собрать все части MIME в одно сообщение.</span><span class="sxs-lookup"><span data-stu-id="963a0-182">The XML Information Set (Infoset), or other MIME parts, may need to be buffered to reassemble all the MIME parts into a single message.</span></span>  
  
 <span data-ttu-id="963a0-183">Для правильной работы с HTTP внутренний класс кодировщика сообщений MTOM предоставляет несколько интерфейсов API для метода `GetContentType` (который также является внутренним) и метода `WriteMessage`, который является открытым и может быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="963a0-183">To work correctly with HTTP, the internal MTOM message encoder class provides some internal APIs for `GetContentType` (which is also internal) and `WriteMessage`, which is public and can be overridden.</span></span> <span data-ttu-id="963a0-184">Чтобы значения в заголовках HTTP соответствовали значениям в заголовках MIME, необходимо обеспечить более широкие возможности взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="963a0-184">More communication must occur to ensure values in the HTTP headers agree with values in the MIME headers.</span></span>  
  
 <span data-ttu-id="963a0-185">Изнутри кодировщик сообщений MTOM использует средства чтения текста [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] и похож на текстовый кодировщик.</span><span class="sxs-lookup"><span data-stu-id="963a0-185">Internally, the MTOM message encoder uses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]'s text readers, and is similar to the Text encoder.</span></span> <span data-ttu-id="963a0-186">Основное отличие заключается в том, что он оптимизирует большой объем двоичных данных или большие двоичные объекты, не преобразовывая их в кодировку Base-64 до внедрения в байты сообщения.</span><span class="sxs-lookup"><span data-stu-id="963a0-186">The main difference is that it optimizes large chunks of binary, or "Binary Large Objects" (BLOBs), by not converting them to Base-64 encoding prior to being embedded into the message bytes.</span></span> <span data-ttu-id="963a0-187">Вместо этого эти объекты остаются извлеченными, и на них существуют ссылки как на вложения MIME.</span><span class="sxs-lookup"><span data-stu-id="963a0-187">Instead, these BLOBs are kept extracted, and referenced as the MIME attachments.</span></span>  
  
## <a name="writing-your-own-encoder"></a><span data-ttu-id="963a0-188">Запись собственного кодировщика</span><span class="sxs-lookup"><span data-stu-id="963a0-188">Writing your own Encoder</span></span>  
 <span data-ttu-id="963a0-189">Чтобы реализовать собственный пользовательский кодировщик сообщений, предоставьте пользовательские реализации следующих абстрактных базовых классов.</span><span class="sxs-lookup"><span data-stu-id="963a0-189">To implement your own custom message encoder, you must provide custom implementations of the following abstract base classes:</span></span>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoder>  
  
-   <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
  
-   <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
  
 <span data-ttu-id="963a0-190">Преобразование из хранимого в памяти представления сообщения в представление, которое можно записать в поток, инкапсулировано внутри класса <xref:System.ServiceModel.Channels.MessageEncoder>, который используется в качестве фабрики для средств чтения XML и средств записи XML, поддерживающих определенные типы кодирования XML.</span><span class="sxs-lookup"><span data-stu-id="963a0-190">Converting from the in-memory representation of a message to a representation that can be written to a stream is encapsulated within the <xref:System.ServiceModel.Channels.MessageEncoder> class, which serves as a factory for XML readers and XML writers that support specific types of XML encodings.</span></span>  
  
-   <span data-ttu-id="963a0-191">Ниже представлены основные методы этого класса, которые необходимо переопределить.</span><span class="sxs-lookup"><span data-stu-id="963a0-191">The key methods of this class that you must override are:</span></span>  
  
-   <span data-ttu-id="963a0-192"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A>, который принимает объект <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> и записывает его в объект <xref:System.IO.Stream>.</span><span class="sxs-lookup"><span data-stu-id="963a0-192"><xref:System.ServiceModel.Channels.MessageEncoder.WriteMessage%2A> which takes a <xref:System.ServiceModel.Channels.MessageEncodingBindingElement> object and writes it into a <xref:System.IO.Stream> object.</span></span>  
  
-   <span data-ttu-id="963a0-193"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A>, который принимает объект <xref:System.IO.Stream> и максимальный размер заголовка и возвращает объект <xref:System.ServiceModel.Channels.Message>.</span><span class="sxs-lookup"><span data-stu-id="963a0-193"><xref:System.ServiceModel.Channels.MessageEncoder.ReadMessage%2A> which takes a <xref:System.IO.Stream> object and a maximum header size and returns a <xref:System.ServiceModel.Channels.Message> object.</span></span>  
  
 <span data-ttu-id="963a0-194">Код, записываемый в этих методах, выполняет преобразование между стандартным транспортным протоколом и настроенным кодированием.</span><span class="sxs-lookup"><span data-stu-id="963a0-194">It is the code you write in these methods that handles conversion between the standard transport protocol, and your customized encoding.</span></span>  
  
 <span data-ttu-id="963a0-195">Затем следует записать в код класс фабрики, создающий пользовательский кодировщик.</span><span class="sxs-lookup"><span data-stu-id="963a0-195">Next you need to code a factory class that creates your custom encoder.</span></span> <span data-ttu-id="963a0-196">Переопределите свойство <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A>, чтобы обеспечить возврат экземпляра пользовательского кодировщика <xref:System.ServiceModel.Channels.MessageEncoder>.</span><span class="sxs-lookup"><span data-stu-id="963a0-196">Override the <xref:System.ServiceModel.Channels.MessageEncoderFactory.Encoder%2A> to return an instance of your custom <xref:System.ServiceModel.Channels.MessageEncoder>.</span></span>  
  
 <span data-ttu-id="963a0-197">Затем подключите пользовательскую фабрику <xref:System.ServiceModel.Channels.MessageEncoderFactory> к стеку элементов привязки, используемому для настройки службы или клиента, переопределив метод <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A>, чтобы вернуть экземпляр этой фабрики.</span><span class="sxs-lookup"><span data-stu-id="963a0-197">Then connect your custom <xref:System.ServiceModel.Channels.MessageEncoderFactory> to the binding element stack used to configure the service or client by overriding the <xref:System.ServiceModel.Channels.MessageEncodingBindingElement.CreateMessageEncoderFactory%2A> method to return an instance of this factory.</span></span>  
  
 <span data-ttu-id="963a0-198">Существует два образцы, поставляемые с [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] , показывающих, этот процесс с примерами кода: [пользовательский кодировщик сообщений: пользовательский кодировщик текстовых](../../../../docs/framework/wcf/samples/custom-message-encoder-custom-text-encoder.md) и [пользовательский кодировщик сообщений: кодировщик сжатия](../../../../docs/framework/wcf/samples/custom-message-encoder-compression-encoder.md).</span><span class="sxs-lookup"><span data-stu-id="963a0-198">There are two samples provided with [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that illustrate this process with sample code: [Custom Message Encoder: Custom Text Encoder](../../../../docs/framework/wcf/samples/custom-message-encoder-custom-text-encoder.md) and [Custom Message Encoder: Compression Encoder](../../../../docs/framework/wcf/samples/custom-message-encoder-compression-encoder.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="963a0-199">См. также</span><span class="sxs-lookup"><span data-stu-id="963a0-199">See Also</span></span>  
 <xref:System.ServiceModel.Channels.MessageEncodingBindingElement>  
 <xref:System.ServiceModel.Channels.MessageEncoderFactory>  
 <xref:System.ServiceModel.Channels.MessageEncoder>  
 [<span data-ttu-id="963a0-200">Общие сведения об архитектуре передачи данных</span><span class="sxs-lookup"><span data-stu-id="963a0-200">Data Transfer Architectural Overview</span></span>](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)  
 [<span data-ttu-id="963a0-201">Выбор кодировщика сообщений</span><span class="sxs-lookup"><span data-stu-id="963a0-201">Choosing a Message Encoder</span></span>](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)  
 [<span data-ttu-id="963a0-202">Выбор транспорта</span><span class="sxs-lookup"><span data-stu-id="963a0-202">Choosing a Transport</span></span>](../../../../docs/framework/wcf/feature-details/choosing-a-transport.md)
