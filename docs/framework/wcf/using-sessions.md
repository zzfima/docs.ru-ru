---
title: Использование сеансов
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- sessions [WCF]
ms.assetid: 864ba12f-3331-4359-a359-6d6d387f1035
ms.openlocfilehash: 9285f68521770e0dd4fbc8d6f9aa006eccc502c3
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54533146"
---
# <a name="using-sessions"></a>Использование сеансов
В приложениях Windows Communication Foundation (WCF) *сеанса* объединяет группу сообщений в диалоге. Сеансы WCF отличаются от объектов сеансов, имеющихся в [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] приложений, поддерживают другие поведения, а также управляются разными способами. В этом разделе описаны возможности, обеспечиваемые сеансами в WCF, приложений и их использование.  
  
## <a name="sessions-in-windows-communication-foundation-applications"></a>Сеансы в приложениях Windows Communication Foundation  
 Если в контракте службы указано, что для него требуется сеанс, это означает, что все вызовы (т. е. обмен сообщениями, на котором он основан) должны быть частью одного диалога. Если в контракте указано, что сеансы для него разрешены, но не требуются, клиенты могут подключаться, создавая сеанс или не создавая его. Если сеанс завершен и по его каналу отправляется сообщение, выдается исключение.  
  
 WCF сеансы имеют следующие основные особенности:  
  
-   Они явным образом инициируются и завершаются вызвавшим приложением (клиентом WCF).  
  
-   Сообщения, доставленные в ходе сеанса, обрабатываются в порядке их получения.  
  
-   Сеанс коррелирует группу сообщений в диалог. Возможны различные типы корреляций. Например, один основанный на сеансах канал может коррелировать сообщения, основываясь на общем сетевом подключении, а другой - основываясь на общем теге в тексте сообщения. Функции, получаемые в результате сеанса, зависят от характера корреляции.  
  
-   Нет общего хранилища данных, связанного с сеансом WCF.  
  
 Если вы знакомы с <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> в класс [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] приложения и функциональные возможности она предоставляет, можно отметить следующие различия между его сеансами и сеансами WCF:  
  
-   Сеансы[!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] всегда инициируются сервером.  
  
-   Сеансы[!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] явным образом неупорядочены.  
  
-   Сеансы[!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] обеспечивают общий механизм хранения данных для запросов.  
  
 В этом разделе описываются следующие функции и операции:  
  
-   Поведение выполнения по умолчанию при использовании привязок, основанных на сеансе, в уровне модели службы.  
  
-   Типы компонентов, предоставляющих WCF на основе сеансов, предоставляемых системой привязок.  
  
-   Создание контракта, объявляющего требование сеанса.  
  
-   Управление созданием и прекращением сеанса и его связью с экземпляром службы.  
  
## <a name="default-execution-behavior-using-sessions"></a>Поведение выполнения по умолчанию с использованием сеансов  
 Привязка, пытающаяся инициировать сеанс, называется *основанной на сеансе* . Контракты служб указывают о том, что для них требуются, допускаются или не допускаются привязки, основанные на сеансе. Для этого свойству <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> интерфейса (или класса) контракта службы присваивается одно из значений перечисления <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> . По умолчанию значение этого свойства является <xref:System.ServiceModel.SessionMode.Allowed>, т.е. Если клиент использует привязку на основе сеансов с реализацией службы WCF, служба устанавливает и использует предоставленный сеанс.  
  
 Когда служба WCF принимает клиентский сеанс, следующие возможности будут доступны по умолчанию:  
  
1.  Все вызовы между объекта клиента WCF обрабатываются на один и тот же экземпляр службы.  
  
2.  Различные привязки на основе сеанса предоставляют дополнительные возможности.  
  
## <a name="system-provided-session-types"></a>Типы сеансов, предоставляемые системой  
 Привязка, основанная на сеансе, поддерживает ассоциацию по умолчанию экземпляра службы с определенным сеансом. Впрочем, различные привязки, основанные на сеансе, поддерживают и другие различные функции, помимо описанного выше управления созданием экземпляров на основе сеанса.  
  
 WCF предоставляет следующие типы поведения приложений на основе сеансов:  
  
-   Элемент <xref:System.ServiceModel.Channels.SecurityBindingElement?displayProperty=nameWithType> поддерживает основанные на безопасности сеансы, в которых обе стороны, обменивающиеся информацией, согласовали определенный безопасный диалог. Дополнительные сведения см. в разделе [Защита служб](../../../docs/framework/wcf/securing-services.md). Например, привязка <xref:System.ServiceModel.WSHttpBinding?displayProperty=nameWithType> , содержащая поддержку как безопасных, так и надежных сеансов, по умолчанию использует только безопасный сеанс, шифрующий сообщения и защищающий их цифровой подписью.  
  
-   Привязка <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> поддерживает сеансы, основанные на TCP/IP, что обеспечивает корреляцию всех сообщений по подключению на уровне сокетов.  
  
-   Элемент <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> , реализующий спецификацию WS-ReliableMessaging, обеспечивает поддержку надежных сеансов, в которых можно настроить отправку сообщений в определенном порядке и только один раз, что гарантирует получение сообщений, даже когда при диалоге они проходят через несколько узлов. Дополнительные сведения см. в разделе [надежные сеансы](../../../docs/framework/wcf/feature-details/reliable-sessions.md).  
  
-   Привязка <xref:System.ServiceModel.NetMsmqBinding?displayProperty=nameWithType> обеспечивает сеансы датаграммы MSMQ. Дополнительные сведения см. в разделе [очереди в WCF](../../../docs/framework/wcf/feature-details/queues-in-wcf.md).  
  
 Установка свойства <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> указывает о том, что для контракта требуется сеанс, но не задает тип этого сеанса.  
  
## <a name="creating-a-contract-that-requires-a-session"></a>Создание контракта, требующего сеанс  
 Создание контракта, требующего сеанс, означает, что группа операций, объявляемых контрактом службы, должна выполняться в пределах одного сеанса и сообщения должны быть доставлены в определенном порядке. Чтобы назначить уровень поддержки сеансов, требуемый контрактом, задайте в качестве значения свойства <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> класса или интерфейса контракта службы перечисление <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> . При этом указывается одно из следующих условий контракта:  
  
-   Требуется сеанс.  
  
-   Клиенту допускается создавать сеанс.  
  
-   Сеансы запрещены.  
  
 Впрочем, установка свойства <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A> не указывает требуемый контрактом тип поведения, основанного на сеансе. Он указывает WCF проверить во время выполнения, настроенная привязка (создающая коммуникационный канал), для службы, не поддерживает и может установить сеанс при реализации службы. Опять же, привязка может выполнить это требование с любым типом поведения, основанного на сеансе: безопасность, транспорт, надежность или некоторая комбинация этих типов. Конкретное поведение зависит от выбранного значения <xref:System.ServiceModel.SessionMode?displayProperty=nameWithType> . Если настроенная для службы привязка не соответствует значению <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A>, выдается исключение. Привязки и создаваемые ими каналы, поддерживающие сеансы, называются основанными на сеансах.  
  
 Следующий контракт службы указывает, что все операции в `ICalculatorSession` необходимо выполнить в пределах одного сеанса. Ни одна операция не возвращает значение вызвавшему объекту, за исключением метода `Equals` . Впрочем, метод `Equals` не принимает параметры, а потому может возвращать только ненулевое значение в пределах сеанса, в котором данные уже переданы другим операциям. Для правильной работы этого контракта требуется сеанс. При отсутствии сеанса, связанного с определенным клиентом, экземпляр службы не может определить, какие именно данные отправил клиент.  
  
 [!code-csharp[S_Service_Session#1](../../../samples/snippets/csharp/VS_Snippets_CFX/s_service_session/cs/service.cs#1)]
 [!code-vb[S_Service_Session#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/s_service_session/vb/service.vb#1)]  
  
 Если сеанс разрешен службой, он создается и используется, если он инициирован клиентом. В противном случае сеанс не создается.  
  
## <a name="sessions-and-service-instances"></a>Сеансы и экземпляры служб  
 Если вы используете поведения в WCF при создании экземпляров по умолчанию, все вызовы между объекта клиента WCF обрабатываются один и тот же экземпляр службы. Таким образом, на уровне приложения можно считать, что сеанс обеспечивает поведение приложений, аналогичное поведению местных вызовов. Например, при создании локального объекта происходит следующее:  
  
-   Вызывается конструктор.  
  
-   Все последующие вызовы к ссылке объекта клиента WCF обрабатываются тот же экземпляр объекта.  
  
-   Деструктор вызывается при уничтожении ссылки на объект.  
  
 Сеансы обеспечивают аналогичное поведение при взаимодействии между клиентами и службами, если используется поведение создания экземпляров службы по умолчанию. Если контракт службы требует или поддерживает сеансы, можно отметить операцию (или несколько операций) как инициирующую или завершающую сеанс. Для этого необходимо задать свойства <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> и <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> .  
  
 *Инициирующие операции* - это операции, вызываемые в качестве первых операций новых сеансов. Неинициирующие операции могут вызываться только после вызова по крайней мере одной инициирующей операции. Поэтому можно создать некоторое подобие конструктора сеансов для службы, объявив инициирующие операции, которые принимают от клиентов входные данные, как подходящие для создания экземпляра службы. (Впрочем, состояние ассоциируется с сеансом, а не с объектом службы.)  
  
 *Завершающие операции*- это, соответственно, операции, вызываемые как последние сообщения существующих сеансов. В случае по умолчанию WCF повторно использует объект службы и его контекст после закрытия сеанса, с которым была связана эта служба. Поэтому можно создать некоторое подобие деструктора, объявив завершающие операции, которые выполняют функции по завершению действия экземпляра службы.  
  
> [!NOTE]
>  Поведение по умолчанию имеет сходство с локальными конструкторами и деструкторами, но это не более чем сходство. Все операции службы WCF может быть инициирующей или завершающей или оба одновременно. Кроме того, в случае по умолчанию инициирующие операции можно вызывать сколько угодно раз и в любом порядке. После того как сеанс установлен и связан с экземпляром, дополнительные сеансы могут быть созданы только в случае осуществления явным образом управления временем существования экземпляра службы (путем обработки объекта <xref:System.ServiceModel.InstanceContext?displayProperty=nameWithType> ). И наконец, состояние связывается с сеансом, а не с объектом службы.  
  
 Например `ICalculatorSession` контракта, используемого в предыдущем примере требуется, что клиент WCF объект первый вызов `Clear` операцию до выполнения любой другой операции и что сеанс с этим объектом клиента WCF завершался при вызове `Equals` операции. В следующем примере кода приведен контракт, обеспечивающий выполнение этих требований. Для инициации сеанса сначала необходимо вызвать операцию`Clear` , а завершится сеанс при вызове операции `Equals` .  
  
 [!code-csharp[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/csharp/VS_Snippets_CFX/sca.isinitiatingisterminating/cs/service.cs#1)]
 [!code-vb[SCA.IsInitiatingIsTerminating#1](../../../samples/snippets/visualbasic/VS_Snippets_CFX/sca.isinitiatingisterminating/vb/service.vb#1)]  
  
 Службы не начинают сеансы с клиентами. В клиентских приложениях WCF существует прямая связь между временем существования канала на основе сеансов и время существования самого сеанса. Таким образом, клиенты создают новые сеансы путем создания новых каналов, основанных на сеансах, и прерывают существующие сеансы путем правильного закрытия этих каналов. Клиент начинает сеанс с конечной точкой службы путем вызова одной из следующих операций:  
  
-   <xref:System.ServiceModel.ICommunicationObject.Open%2A?displayProperty=nameWithType> для канала, возвращенного при вызове <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.  
  
-   <xref:System.ServiceModel.ClientBase%601.Open%2A?displayProperty=nameWithType> в объекте клиента WCF, создаваемые [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).  
  
-   Инициирующей операции для любого типа объекта клиента WCF (по умолчанию все операции являются инициирующими). При вызове первой операции объекта клиента WCF автоматически открывает канал и инициирует сеанс.  
  
 Обычно клиент завершает сеанс с конечной точкой службы путем вызова одной из следующих операций:  
  
-   <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> для канала, возвращенного при вызове <xref:System.ServiceModel.ChannelFactory%601.CreateChannel%2A?displayProperty=nameWithType>.  
  
-   <xref:System.ServiceModel.ClientBase%601.Close%2A?displayProperty=nameWithType> в объекте клиента WCF, созданный средством Svcutil.exe.  
  
-   Завершающей операции для любого типа объекта клиента WCF (по умолчанию операции не являются завершающими; контракт должен явно указывать завершающую операцию). При вызове первой операции объекта клиента WCF автоматически открывает канал и инициирует сеанс.  
  
 Примеры см. в разделах [Практическое руководство. Создать Service That Requires Sessions](../../../docs/framework/wcf/feature-details/how-to-create-a-service-that-requires-sessions.md) , а также [Default Service Behavior](../../../docs/framework/wcf/samples/default-service-behavior.md) и [Instancing](../../../docs/framework/wcf/samples/instancing.md) примеры.  
  
 Дополнительные сведения о клиентах и сеансах см. в разделе [доступ к службам, с помощью клиента WCF](../../../docs/framework/wcf/feature-details/accessing-services-using-a-client.md).  
  
## <a name="sessions-interact-with-instancecontext-settings"></a>Сеансы взаимодействуют с параметрами InstanceContext  
 Перечисление <xref:System.ServiceModel.SessionMode> контракта взаимодействует со свойством <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> , управляющим связью между каналами и определенными объектами службы. Дополнительные сведения см. в разделе [сеансы, создание экземпляров и параллелизм](../../../docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
### <a name="sharing-instancecontext-objects"></a>Совместное использование объектов InstanceContext  
 Также можно задать для каждого вызова или канала, основанного на сеансе, с каким именно объектом <xref:System.ServiceModel.InstanceContext> он будет ассоциирован, самостоятельно назначив ассоциацию. Полный пример содержится в разделе [InstanceContextSharing](https://msdn.microsoft.com/library/4a6a46d7-b7d7-4bb5-a0dd-03ffa3cbc230).  
  
## <a name="sessions-and-streaming"></a>Сеансы и потоковая передача  
 При наличии большой объем передаваемых данных, режим потоковой передачи в WCF является выгодной альтернативой по умолчанию поведение буферизации и обработка сообщений в памяти целиком. При потоковой передаче вызовов с привязкой, основанной на сеансе, может возникнуть непредвиденное поведение. Все потоковые вызовы выполняются через один канал (канал датаграммы), который не поддерживает сеансы, даже если используемая привязка настроена так, чтобы она использовала сеансы. Если несколько клиентов выполняют потоковые вызовы одного объекта службы через привязку, основанную на сеансе, и задан "одиночный" режим параллелизма объекта службы и задан режим контекста его экземпляра `PerSession`, все вызовы должны проходить через канал датаграммы, а потому может обрабатываться не более одного вызова одновременно. При этом может истечь время ожидания для одного или нескольких клиентов. Эту проблему можно обойти, присвоив значение `InstanceContextMode` свойству `PerCall` или выбрав "множественный" режим параллелизма.  
  
> [!NOTE]
>  Свойство MaxConcurrentSessions в данном случае ни на что не влияет, поскольку имеется всего один сеанс.  
  
## <a name="see-also"></a>См. также
- <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>
- <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A>
