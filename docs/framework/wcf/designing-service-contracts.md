---
title: Создание контрактов служб
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- service contracts [WCF]
ms.assetid: 8e89cbb9-ac84-4f0d-85ef-0eb6be0022fd
ms.openlocfilehash: 37723011d69e8ea2ead3f7a30a30898dede054cb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/12/2020
ms.locfileid: "79176686"
---
# <a name="designing-service-contracts"></a>Создание контрактов служб
Этот раздел описывает, что такое контракты служб, как они определяются, какие операции доступны (также описаны последствия обмена сообщениями, на которых они основаны), какие типы данных используются; кроме того, он содержит ответы на другие вопросы, которые помогут при разработке операций, удовлетворяющих требованиям вашего сценария.  
  
## <a name="creating-a-service-contract"></a>Создание контракта службы  
 Службы предоставляют несколько операций. В приложениях Windows Communication Foundation (WCF) определяютоперации, создавая <xref:System.ServiceModel.OperationContractAttribute> метод и маркировать его атрибутом. Затем, для создания контракта службы, необходимо сгруппировать операции либо объявив их в интерфейсе, отмеченном атрибутом <xref:System.ServiceModel.ServiceContractAttribute>, либо определив их в классе с таким же атрибутом. (Для основного примера [см. Как определить контракт на обслуживание.)](how-to-define-a-wcf-service-contract.md)  
  
 Любые методы, не <xref:System.ServiceModel.OperationContractAttribute> имеюющие атрибутики, не являются операциями службы и не подвергаются воздействию служб WCF.  
  
 Этот раздел рассказывает о принятии решений по следующим вопросам при создании контракта службы:  
  
- использовать ли классы или интерфейсы;  
  
- как задать типы данных, которыми нужно обмениваться;  
  
- какие типы шаблонов обмена можно использовать;  
  
- можно ли сделать явные требования безопасности частью контракта;  
  
- каковы ограничения для входных и выходных данных операций.  
  
## <a name="classes-or-interfaces"></a>Классы или интерфейсы  
 Оба класса и интерфейсы представляют собой группировку функциональных возможностей и, следовательно, оба могут быть использованы для определения контракта на обслуживание WCF. Однако рекомендуется использовать интерфейсы, так как они напрямую моделируют контракты служб. Не имея реализации, интерфейсы всего лишь определяют группу методов с определенными сигнатурами. Внедрите интерфейс сервисного контракта, и вы внедрили службу WCF.  
  
 Все преимущества управляемых интерфейсов относятся также к интерфейсам контрактов служб:  
  
- интерфейсы контрактов служб могут расширять любое число других интерфейсов контрактов служб;  
  
- отдельный класс может реализовывать любое число контрактов служб, реализуя интерфейсы этих контрактов служб;  
  
- можно изменить реализацию контракта службы, изменив реализацию интерфейса и не изменяя сам контракт;  
  
- можно создать несколько версий службы, реализуя старый и новый интерфейсы. Старые клиенты могут подключаться к исходной версии, а более новые клиенты - к более новой версии.  
  
> [!NOTE]
> При наследовании от других интерфейсов контрактов служб нельзя переопределять свойства операций, например имя или пространство имен. Если попытаться сделать это, будет создана новая операция в текущем контракте службы.  
  
 Например, при использовании интерфейса для создания сервисного контракта [см., как: Создать службу с интерфейсом контракта](./feature-details/how-to-create-a-service-with-a-contract-interface.md).  
  
 Однако можно использовать класс для определения контракта службы и одновременной реализации этого контракта. Преимущество создания службы путем применения атрибутов <xref:System.ServiceModel.ServiceContractAttribute> и <xref:System.ServiceModel.OperationContractAttribute> напрямую к классу и методам класса, соответственно, - это скорость и простота. Недостаток состоит в том, что управляемые классы не поддерживают множественное наследование, и в результате могут реализовывать только один контракт службы за раз. Кроме того, любое изменение сигнатуры класса или метода изменяет открытый контракт для этой службы, что может предотвратить использование службы неизмененными клиентами. Для получения дополнительной [информации](implementing-service-contracts.md)см.  
  
 Например, для создания контракта на обслуживание и одновременного его реализации см., [как: Создать службу с классом контракта.](./feature-details/how-to-create-a-wcf-contract-with-a-class.md)  
  
 К этому моменту у вас должно было сложиться представление о том, в чем заключается разница между определением контракта службы через интерфейс и через класс. Следующий шаг - определить, какие данные могут передаваться между службой и клиентами.  
  
## <a name="parameters-and-return-values"></a>Параметры и возвращаемые значения  
 Каждая операция имеет возвращаемое значение и параметр, даже в случае `void`. Однако, в отличие от локального метода, в котором можно передавать ссылки на объекты от одного объекта к другому, операции служб не передают ссылки на объекты. Вместо этого они передают копии объектов.  
  
 Это важно, потому что каждый тип, используемый для параметра или возвращаемого значения, должен быть сериализуем. Это значит, должно быть возможно преобразование объекта этого типа в поток байтов и обратно из потока байтов в объект.  
  
 Примитивные типы сериализуемы по умолчанию, как и многие типы в .NET Framework.  
  
> [!NOTE]
> Значения имен параметров в сигнатуре операции являются частью контракта и чувствительны к регистру. Если требуется использовать одно имя параметра локально, но изменить имя опубликованных метаданных, см. раздел <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType>.  
  
#### <a name="data-contracts"></a>Контракты данных  
 Сервис-ориентированные приложения, такие как приложения Windows Communication Foundation (WCF), предназначены для взаимодействия с максимально широким числом клиентских приложений как на платформах Microsoft, так и на немайконных платформах. Для наиболее широких возможностей взаимодействия рекомендуется помечать типы атрибутами <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute> для создания контракта данных - части контракта службы, описывающей данные, которыми могут обмениваться операции службы.  
  
 Контракты данных - включаемые по требованию контракты стилей: тип или элемент данных не сериализуются, если не применен явным образом атрибут контракта данных. Контракты данных не связаны с областью доступа управляемого кода: закрытые элементы данных могут быть сериализованы и отправлены куда-либо для открытого доступа. (Для базового примера контракта на передачу данных см.: [Как: Создать базовый контракт на передачу данных для класса или структуры.)](./feature-details/how-to-create-a-basic-data-contract-for-a-class-or-structure.md) WCF обрабатывает определение основных сообщений SOAP, которые позволяют функциональность операции, а также сериализации типов данных в и из тела сообщений. Если типы данных сериализуемы, нет необходимости думать об инфраструктуре обмена базовыми сообщениями при создании операций.  
  
 Хотя типичное приложение WCF использует <xref:System.Runtime.Serialization.DataContractAttribute> и <xref:System.Runtime.Serialization.DataMemberAttribute> атрибуты для создания контрактов данных для операций, можно использовать другие механизмы сериализации. Стандартные механизмы <xref:System.Runtime.Serialization.ISerializable>, <xref:System.SerializableAttribute> и <xref:System.Xml.Serialization.IXmlSerializable> все обеспечивают сериализацию типов данных в базовые сообщения SOAP, которые переносят данные от одного приложения к другому. Можно применить дополнительные стратегии сериализации, если типы данных требуют специальной поддержки. Для получения дополнительной информации о выборе сериализации типов данных в приложениях WCF [см.](./feature-details/specifying-data-transfer-in-service-contracts.md)  
  
#### <a name="mapping-parameters-and-return-values-to-message-exchanges"></a>Сопоставление параметров и возвращаемых значений с обменом сообщениями  
 Операции службы поддерживаются при помощи базового обмена сообщениями SOAP, в которых передаются данные приложения в двух направлениях, а также данные, необходимые приложению для поддержки стандартной безопасности, транзакций и возможностей, связанных с сеансами. Поскольку это так, подпись операции службы диктует определенный базовый *шаблон обмена сообщениями* (MEP), который может поддерживать передачу данных и функции, необходимые операции. В модели программирования WCF можно указать три шаблона: шаблоны запроса/ответа, односторонние и дуплексные шаблоны сообщений.  
  
##### <a name="requestreply"></a>Запрос-ответ  
 Шаблон запрос-ответ означает, что отправитель запроса (клиентское приложение) получает ответ, который соответствует запросу. Это шаблон обмена сообщениями по умолчанию, так как он поддерживает операцию, в которую передается один или больше параметров и из которой происходит возврат результирующего значения вызывавшей стороне. Например, следующий пример кода на языке C# показывает основную операцию службы, которая получает и возвращает строку.  
  
```csharp  
[OperationContractAttribute]  
string Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute()>  
Function Hello (ByVal greeting As String) As String  
```  
  
 Сигнатура этой операции диктует вид базового обмена сообщениями. Если корреляции не существовало, WCF не может определить, для какой операции предназначено значение возврата.  
  
 Обратите внимание, что если вы не укажете `void` другой`Nothing` базовый шаблон сообщения, даже операции службы, которые возвращаются (в Visual Basic) являются обменами сообщениями запроса/ответа. Результат для операции такой: если клиент не вызывает операцию асинхронно, клиент приостанавливает обработку до получения возвращаемого сообщения, даже несмотря на то, что в нормальном случае это сообщение пустое. Следующий пример кода на C# показывает операцию, которая не отвечает, пока клиент не получит пустое сообщение в ответ.  
  
```csharp  
[OperationContractAttribute]  
void Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute()>  
Sub Hello (ByVal greeting As String)  
```  
  
 Приведенный пример кода может понизить производительность и скорость ответа клиента, если выполнение операции требует длительного времени, но у операций типа запрос-ответ есть преимущества, даже если они возвращают `void`. Наиболее очевидное состоит в том, что сообщения о неисправностях SOAP могут возвращаться в сообщении ответа, что будет указывать на возникновение какой-либо связанной со службой ошибки либо при подключении, либо при обработке. Неисправности SOAP, заданные в контракте службы, передаются клиентскому приложению в виде объекта <xref:System.ServiceModel.FaultException%601>, где параметр типа - это тип, заданный в контракте службы. Это упрощает уведомляние клиентов об условиях ошибки в сервисах WCF. Для получения дополнительной информации об исключениях, ошибках SOAP и обработке ошибок [см.](specifying-and-handling-faults-in-contracts-and-services.md) Чтобы увидеть пример службы запроса/ответа и клиента, [см.](./feature-details/how-to-create-a-request-reply-contract.md) Для получения дополнительной информации о проблемах с шаблоном запрос-ответ, [см.](./feature-details/request-reply-services.md)  
  
##### <a name="one-way"></a>Односторонний  
 Если клиент приложения службы WCF не должен ждать завершения операции и не обрабатывает ошибки SOAP, операция может указать односторонний шаблон сообщения. Односторонней операцией является операция, в которой клиент вызывает операцию и продолжает обработку после того, как WCF записывает сообщение в сеть. Обычно это означает, что клиент продолжает работу почти без перерыва, если объем данных, передаваемых в исходящем сообщение не очень велик, и если не возникает ошибка при передаче данных. Этот шаблон обмена сообщениями поддерживает событийное взаимодействие между клиентом и приложением службы.  
  
 Обмен сообщениями, при котором одно сообщение отправляется и ни одного не принимается не поддерживает операции службы, для которых задано возвращаемое значение, отличное от `void`; в таком случае возникает исключение <xref:System.InvalidOperationException>.  
  
 Отсутствие обратного сообщения также означает, что не может быть возвращено сообщение о неисправностях SOAP, указывающее на ошибки при обработке или подключении. (Передача сведений об ошибках подключения для односторонних операций требует дуплексного шаблона обмена сообщениями.)  
  
 Чтобы задать односторонний обмен сообщениями для операции, возвращающей `void`, присвойте свойству <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> значение `true`, как в следующем примере кода C#.  
  
```csharp  
[OperationContractAttribute(IsOneWay=true)]  
void Hello(string greeting);  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<OperationContractAttribute(IsOneWay := True)>  
Sub Hello (ByVal greeting As String)  
```  
  
 Метод тот же, что и в предшествующем примере типа запрос-ответ, но значение <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> свойства `true` означает, что несмотря на то, что метод тот же, операция службы не посылает ответное сообщение и клиенты продолжают работу немедленно после передачи исходящего сообщения на уровень канала. Например, [см. Как: Создать односторонний контракт.](./feature-details/how-to-create-a-one-way-contract.md) Для получения дополнительной информации о односторонней модели [см.](./feature-details/one-way-services.md)  
  
##### <a name="duplex"></a>Дуплекс  
 Дуплексный шаблон характеризуется способностью и службы, и клиента отправлять сообщения друг другу, независимо от того, используется ли односторонний обмен сообщениями или запрос-ответ. Такая форма двустороннего общения полезна для служб, которым требуется напрямую обращаться к клиенту, или для асинхронного взаимодействия обеих сторон обмена сообщениями, в том числе для событийного поведения.  
  
 Дуплексный шаблон несколько более сложен, чем односторонний шаблон и шаблон запрос-ответ, так как имеет дополнительный механизм для взаимодействия с клиентом.  
  
 Для создания дуплексного контракта необходимо также создать контракт обратного вызова и присвоить тип этого контракта обратного вызова свойству <xref:System.ServiceModel.ServiceContractAttribute.CallbackContract%2A> атрибута <xref:System.ServiceModel.ServiceContractAttribute> контракта службы.  
  
 Для реализации дуплексного шаблона необходимо создать второй интерфейс, содержащий объявления методов, вызываемых на клиенте.  
  
 Например, создание службы и клиента, который получает доступ к этой службе, [см., как: Создать Duplex Contract](./feature-details/how-to-create-a-duplex-contract.md) и [Как: Услуги доступа с Duplex Contract](./feature-details/how-to-access-services-with-a-duplex-contract.md). Для рабочего образца [см.](./samples/duplex.md) Для получения дополнительной информации о проблемах с использованием дуплексных контрактов [см.](./feature-details/duplex-services.md)  
  
> [!CAUTION]
> Когда служба получает дуплексное сообщение, она проверяет элемент `ReplyTo` входящего сообщения, чтобы определить, куда отправлять ответ. Если сообщение принимается по небезопасному каналу, ненадежный клиент может послать вредоносное сообщение с указанием компьютера для атаки в элементе `ReplyTo`, что приведет к отказу в обслуживании (DOS) этого компьютера.  
  
##### <a name="out-and-ref-parameters"></a>Параметры Out и Ref  
 В большинстве случаев `in` можно`ByVal` использовать параметры (в `ref` Visual`ByRef` Basic) и `out` параметры (в Visual Basic). Так как параметры `out` и `ref` оба указывают на то, что операция возвращает данные, сигнатура операции, такая, как показана далее, задает необходимость операции запрос-ответ, несмотря на то что сигнатура операции возвращает `void`.  
  
```csharp  
[ServiceContractAttribute]  
public interface IMyContract  
{  
  [OperationContractAttribute]  
  public void PopulateData(ref CustomDataType data);  
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface IMyContract  
  <OperationContractAttribute()> _  
  Public Sub PopulateData(ByRef data As CustomDataType)  
End Interface  
```  
  
 Исключение составляют только те случаи, когда сигнатура имеет определенную структуру. Например, можно использовать привязку <xref:System.ServiceModel.NetMsmqBinding> для взаимодействия с клиентами, только если метод, использованный для объявления операции, возвращает `void`; может не быть выходного значения, является ли оно возвращаемым значением, параметром `ref` или `out`.  
  
 Помимо этого, использование параметров `out` или `ref` требует, чтобы у операции было базовое ответное сообщение для передачи обратно измененного объекта. Если операция является односторонней, во время выполнения создается исключение <xref:System.InvalidOperationException>.  
  
### <a name="specify-message-protection-level-on-the-contract"></a>Определение уровня защиты сообщений для контракта  
 При создании контракта необходимо также определить уровень защиты сообщений служб, реализующих этот контракт. Это необходимо, только если к привязке применена безопасность сообщений в конечной точке контракта. Если для привязки безопасность отключена (то есть, если привязка, предоставляемая системой, присваивает объекту <xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> значение <xref:System.ServiceModel.SecurityMode.None?displayProperty=nameWithType>), то не нужно определять уровень безопасности сообщений для контракта. В большинстве случаев привязки, предоставляемые системой, с безопасностью на уровне сообщений предоставляют достаточный уровень защиты и нет необходимости рассматривать уровень защиты для каждой операции или для каждого сообщения.  
  
 Уровень защиты - это значение, которое определяет для сообщений (или частей сообщений), поддерживающих службу, подписываются ли они, подписываются и шифруются или отправляются без подписи и шифровки. Уровень защиты может быть задан в различных областях: на уровне службы, для конкретной операции, для сообщения операции или для части сообщения. Значения, заданные для более широкой области, становятся значениями по умолчанию для более узких областей, если не переопределить их явным образом. Если конфигурация привязки не может обеспечить минимальный необходимый уровень защиты для контракта, создается исключение. Если для контракта явно не задано значений уровня защиты, и если привязка имеет безопасность сообщений, уровнем защиты всех сообщений управляет конфигурация привязки. Это поведение по умолчанию.  
  
> [!IMPORTANT]
> Решение явно задать для различных областей контракта уровень защиты меньше максимального <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> обычно является компромиссом между степенью защиты и улучшением производительности. В таких случаях решения должны опираться на вид операций и ценность передаваемых данных. Для получения дополнительной [информации см.](securing-services.md)  
  
 Например, в следующем примере кода не задается ни свойство<xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A>, ни свойство <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> контракта.  
  
```csharp  
[ServiceContract]  
public interface ISampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute]  
  public int GetInt();
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContractAttribute()> _  
Public Interface ISampleService  
  
  <OperationContractAttribute()> _  
  Public Function GetString()As String  
  
  <OperationContractAttribute()> _  
  Public Function GetData() As Integer  
  
End Interface  
```  
  
 При взаимодействии с реализацией `ISampleService` в конечной точке с привязкой <xref:System.ServiceModel.WSHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.Message>), все сообщения зашифровываются и подписываются, так как это является уровнем защиты по умолчанию. Однако при использовании службы `ISampleService` с привязкой <xref:System.ServiceModel.BasicHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.None>), все сообщения отправляются в текстовом виде, так как эта привязка не имеет безопасности и, следовательно, уровень защиты игнорируется (то есть сообщения не шифруются и не подписываются). Если изменить значение свойства <xref:System.ServiceModel.SecurityMode> на <xref:System.ServiceModel.SecurityMode.Message>, то сообщения будут зашифровываться и подписываться, так как теперь таков будет уровень защиты по умолчанию для привязки.  
  
 Если требуется явным образом задать или настроить требования по безопасности для контракта, задайте для свойства <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A> (или для любого из свойств `ProtectionLevel` более узкой области) уровень, требуемый для контракта службы. В данном случае явная настройка требует, чтобы привязка поддерживала эту настройку по крайней мере для указанной области. Например, в следующем примере кода явно задается одно значение <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> для операции `GetGuid`.  
  
```csharp  
[ServiceContract]  
public interface IExplicitProtectionLevelSampleService  
{  
  [OperationContractAttribute]  
  public string GetString();  
  
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.None)]  
  public int GetInt();
  [OperationContractAttribute(ProtectionLevel=ProtectionLevel.EncryptAndSign)]  
  public int GetGuid();
}  
```  
  
 Ниже приведен эквивалентный код Visual Basic.  
  
```vb  
<ServiceContract()> _
Public Interface IExplicitProtectionLevelSampleService
    <OperationContract()> _
    Public Function GetString() As String
    End Function
  
    <OperationContract(ProtectionLevel := ProtectionLevel.None)> _
    Public Function GetInt() As Integer
    End Function
  
    <OperationContractAttribute(ProtectionLevel := ProtectionLevel.EncryptAndSign)> _
    Public Function GetGuid() As Integer
    End Function
  
End Interface  
```  
  
 Служба, реализующая этот контракт `IExplicitProtectionLevelSampleService` и имеющая конечную точку, где используется привязка <xref:System.ServiceModel.WSHttpBinding> по умолчанию (<xref:System.ServiceModel.SecurityMode?displayProperty=nameWithType> по умолчанию, то есть значение <xref:System.ServiceModel.SecurityMode.Message>) ведет себя следующим образом:  
  
- Для операции `GetString` сообщения шифруются и подписываются.  
  
- Для операции `GetInt` сообщения не шифруются и не подписываются, то есть отправляются как простой текст.  
  
- `GetGuid` операции <xref:System.Guid?displayProperty=nameWithType> возвращается в зашифрованном подписанном сообщении.  
  
 Для получения дополнительной информации об уровнях [Understanding Protection Level](understanding-protection-level.md)защиты и о том, как их использовать, см. Для получения дополнительной информации о [безопасности](securing-services.md)см.  
  
##### <a name="other-operation-signature-requirements"></a>Другие требования к сигнатуре операции  
 Некоторые возможности приложения требуют определенного вида сигнатуры операции. Например, привязка <xref:System.ServiceModel.NetMsmqBinding> поддерживает устойчивые службы и клиенты, позволяющие перезапуск приложения при установленном подключении, при этом приложение продолжит работу с того места, где остановилось, и ни одно сообщение не будет потеряно. (Для получения дополнительной [информации, см. Очереди в WCF](./feature-details/queues-in-wcf.md).) Однако прочные операции `in` должны принимать только один параметр и не иметь значения возврата.  
  
 Другой пример - использование типов <xref:System.IO.Stream> в операциях. Так как параметр <xref:System.IO.Stream> включает в себя тело сообщения целиком, если входные или выходные данные (то есть параметр `ref`, параметр `out` или возвращаемое значение) принадлежат типу <xref:System.IO.Stream>, это должны быть единственные входные и выходные данные, заданные для операции. Кроме того, параметр или тип возвращаемого значения должны являться объектами <xref:System.IO.Stream>, <xref:System.ServiceModel.Channels.Message?displayProperty=nameWithType> или <xref:System.Xml.Serialization.IXmlSerializable?displayProperty=nameWithType>. Для получения дополнительной информации о потоках [см.](./feature-details/large-data-and-streaming.md)  
  
##### <a name="names-namespaces-and-obfuscation"></a>Имена, пространства имен и запутывание  
 Имена и пространства имен типов .NET в определениях контрактов и операций важны при преобразовании контрактов в WSDL и при создании и отправке сообщений контрактов. Поэтому рекомендуется явно задавать имена и пространства имен контракта службы с помощью свойств `Name` и `Namespace` всех поддерживающих атрибутов контракта, например <xref:System.ServiceModel.ServiceContractAttribute>, <xref:System.ServiceModel.OperationContractAttribute>, <xref:System.Runtime.Serialization.DataContractAttribute>, <xref:System.Runtime.Serialization.DataMemberAttribute> и других атрибутов контракта.  
  
 Одним из следствий этого является то, что если имена и пространства имен не заданы явно, применение обфускации IL для сборки изменяет имена типов и пространства имен контракта, что приводит к измененному коду WSDL и обмену сообщениями, который обычно завершается ошибкой. Если вы не задаете явно имена и пространства имен контракта, но планируете использовать обфускацию, используйте атрибуты <xref:System.Reflection.ObfuscationAttribute> и <xref:System.Reflection.ObfuscateAssemblyAttribute>, чтобы предотвратить изменение имен и пространств имен контракта.  
  
## <a name="see-also"></a>См. также раздел

- [Практическое руководство. Создание контракта типа "запрос-ответ"](./feature-details/how-to-create-a-request-reply-contract.md)
- [Практическое руководство. Создание одностороннего контракта](./feature-details/how-to-create-a-one-way-contract.md)
- [Практическое руководство. Создание дуплексного контракта](./feature-details/how-to-create-a-duplex-contract.md)
- [Specifying Data Transfer in Service Contracts](./feature-details/specifying-data-transfer-in-service-contracts.md)
- [Указание и обработка сбоев в контрактах и службах](specifying-and-handling-faults-in-contracts-and-services.md)
- [Использование сеансов](using-sessions.md)
- [Синхронные и асинхронные операции](synchronous-and-asynchronous-operations.md)
- [Надежные услуги](reliable-services.md)
- [Службы и транзакции](services-and-transactions.md)
